Commit:
a44445510a8e8babb8452f162ceba6bfa661ef1c
Paul King
paulk@asert.com.au
2018-05-27 12:49:06 +1000
typo
diff --git a/src/spec/doc/core-metaprogramming.adoc b/src/spec/doc/core-metaprogramming.adoc
index 21cb942ae9..32ac7595b4 100644
--- a/src/spec/doc/core-metaprogramming.adoc
+++ b/src/spec/doc/core-metaprogramming.adoc
@@ -3272,7 +3272,7 @@ public class ExampleMacroMethods {
 Now you would register this as an extension module using a `org.codehaus.groovy.runtime.ExtensionModule`
 file within the `META-INF/groovy` directory.
 
-Now, assuming that the class and meta info file are on your claspath, you can use the
+Now, assuming that the class and meta info file are on your classpath, you can use the
 macro method in the following way:
 
 [source,groovy]

Commit:
b4d6129a0d361b665e3cfe9d509bc99683f6c772
Paul King
paulk@asert.com.au
2018-05-27 12:44:52 +1000
first cut doco for @Macro
diff --git a/src/spec/doc/core-metaprogramming.adoc b/src/spec/doc/core-metaprogramming.adoc
index 0247589c84..21cb942ae9 100644
--- a/src/spec/doc/core-metaprogramming.adoc
+++ b/src/spec/doc/core-metaprogramming.adoc
@@ -3238,6 +3238,49 @@ IMPORTANT: Notice that we're using `@CompileDynamic`. That's because the way we
 were actually implementing it. So if you were using `@CompileStatic` it will complain because an implementation of
 an abstract class can't be another different class.
 
+===== @Macro methods
+
+You have seen that by using `macro` you can save yourself a lot of work but you might wonder where
+that method came from. You didn't declare it or static import it. You can think of it as a special
+global method (or if you prefer, a method on every `Object`). This is much like how the `println`
+extension method is defined. But unlike `println` which becomes a method selected for execution
+later in the compilation process, `macro` expansion is done early in the compilation process.
+The declaration of `macro` as one of the available methods for this early expansion is done
+by annotating a `macro` method definition with the `@Macro` annotation and making that method
+available using a similar mechanism for extension modules. Such methods are known as _macro_ methods
+and the good news is you can define your own.
+
+To define your own macro method, create a class in a similar way to an extension module and
+add a method such as:
+
+[source,groovy]
+----
+public class ExampleMacroMethods {
+
+    @Macro
+    public static Expression safe(MacroContext macroContext, MethodCallExpression callExpression) {
+        return ternaryX(
+                notNullX(callExpression.getObjectExpression()),
+                callExpression,
+                constX(null)
+        );
+    }
+    ...
+}
+----
+
+Now you would register this as an extension module using a `org.codehaus.groovy.runtime.ExtensionModule`
+file within the `META-INF/groovy` directory.
+
+Now, assuming that the class and meta info file are on your claspath, you can use the
+macro method in the following way:
+
+[source,groovy]
+----
+def nullObject = null
+assert null == safe(safe(nullObject.hashcode()).toString())
+----
+
 ==== Testing AST transformations
 ===== Separating source trees
 

Commit:
b329ed221100e2e54f812ccab9ee9852aaf12cd9
Paul King
paulk@asert.com.au
2018-05-27 09:33:34 +1000
trivial refactor
diff --git a/subprojects/parser-antlr4/build.gradle b/subprojects/parser-antlr4/build.gradle
index 5097e3f18f..33de21ad63 100644
--- a/subprojects/parser-antlr4/build.gradle
+++ b/subprojects/parser-antlr4/build.gradle
@@ -65,14 +65,13 @@ dependencies {
     testCompile project(':groovy-test')
 }
 
-sourceSets.main.java.srcDirs += file("$srcMain/java");
-sourceSets.main.groovy.srcDirs += file("$srcMain/groovy");
-sourceSets.main.resources.srcDirs += file("$srcMain/resources");
-sourceSets.test.java.srcDirs += file("$srcTest/java");
-sourceSets.test.groovy.srcDirs += file("$srcTest/groovy");
-sourceSets.test.resources.srcDirs += file("$srcTest/resources");
-
+sourceSets.main.java.srcDirs += file("$srcMain/java")
+sourceSets.main.groovy.srcDirs += file("$srcMain/groovy")
+sourceSets.main.resources.srcDirs += file("$srcMain/resources")
+sourceSets.test.java.srcDirs += file("$srcTest/java")
+sourceSets.test.groovy.srcDirs += file("$srcTest/groovy")
+sourceSets.test.resources.srcDirs += file("$srcTest/resources")
 
 tasks.withType(Test) {
     jvmArgs "-Dgroovy.attach.groovydoc=true", "-Dgroovy.antlr4.cache.threshold=100"
-}
\ No newline at end of file
+}

Commit:
8dcbefbe893b23bbe17e329ec5fd16408d17f74e
Paul King
paulk@asert.com.au
2018-05-27 09:15:38 +1000
add missing license header
diff --git a/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc b/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc
index b1d915fbf1..922e431cd3 100644
--- a/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc
+++ b/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc
@@ -1,3 +1,24 @@
+//////////////////////////////////////////
+
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied.  See the License for the
+  specific language governing permissions and limitations
+  under the License.
+
+//////////////////////////////////////////
+
 == JUnit 5
 
 Much of the approach and helper classes described under JUnit4 apply when using JUnit5 however JUnit5
diff --git a/subprojects/groovy-test-junit5/src/test/groovy/MyTestJunit5.groovy b/subprojects/groovy-test-junit5/src/test/groovy/MyTestJunit5.groovy
index 69317b3da1..ad88257337 100644
--- a/subprojects/groovy-test-junit5/src/test/groovy/MyTestJunit5.groovy
+++ b/subprojects/groovy-test-junit5/src/test/groovy/MyTestJunit5.groovy
@@ -1,3 +1,21 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 //@Grab('org.junit.jupiter:junit-jupiter-params:5.2.0')
 import org.junit.jupiter.api.*
 import org.junit.jupiter.params.ParameterizedTest

Commit:
2c40b0266df30285bac73dfb1cb88d703777fd55
Paul King
paulk@asert.com.au
2018-05-27 00:20:45 +1000
GROOVY-8608: Bump picocli version to 3.0.2 from 3.0.1
diff --git a/build.gradle b/build.gradle
index b1f95ee98f..ef73861be4 100644
--- a/build.gradle
+++ b/build.gradle
@@ -163,7 +163,7 @@ ext {
     luceneVersion = '4.7.2'
     openbeansVersion = '1.0'
     openejbVersion = '1.0'
-    picocliVersion = '3.0.1'
+    picocliVersion = '3.0.2'
     qdoxVersion = '1.12.1'
     slf4jVersion = '1.7.21'
     xmlunitVersion = '1.6'

Commit:
34d6369199ee28cbb3a972f3831da359215c0ad4
Paul King
paulk@asert.com.au
2018-05-27 00:18:00 +1000
GROOVY-8605 Autocompletion for Groovy command line tools
diff --git a/src/bin/grape_completion b/src/bin/grape_completion
new file mode 100644
index 0000000000..1c59b0c143
--- /dev/null
+++ b/src/bin/grape_completion
@@ -0,0 +1,181 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+#
+# grape Bash Completion
+# =======================
+#
+# Bash completion support for the `grape` command,
+# generated by [picocli](http://picocli.info/) version 3.0.2.
+#
+# Installation
+# ------------
+#
+# 1. Source all completion scripts in your .bash_profile
+#
+#   cd $GROOVY_HOME/bin
+#   for f in $(find . -name "*_completion"); do line=". $(pwd)/$f"; grep "$line" ~/.bash_profile || echo "$line" >> ~/.bash_profile; done
+#
+# 2. Open a new bash console, and type `grape [TAB][TAB]`
+#
+# Documentation
+# -------------
+# The script is called by bash whenever [TAB] or [TAB][TAB] is pressed after
+# 'grape (..)'. By reading entered command line parameters,
+# it determines possible bash completions and writes them to the COMPREPLY variable.
+# Bash then completes the user input if only one entry is listed in the variable or
+# shows the options if more than one is listed in COMPREPLY.
+#
+# References
+# ----------
+# [1] http://stackoverflow.com/a/12495480/1440785
+# [2] http://tiswww.case.edu/php/chet/bash/FAQ
+# [3] https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
+# [4] https://stackoverflow.com/questions/17042057/bash-check-element-in-array-for-elements-in-another-array/17042655#17042655
+# [5] https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html#Programmable-Completion
+#
+
+# Enable programmable completion facilities (see [3])
+shopt -s progcomp
+
+# ArrContains takes two arguments, both of which are the name of arrays.
+# It creates a temporary hash from lArr1 and then checks if all elements of lArr2
+# are in the hashtable.
+#
+# Returns zero (no error) if all elements of the 2nd array are in the 1st array,
+# otherwise returns 1 (error).
+#
+# Modified from [4]
+function ArrContains() {
+  local lArr1 lArr2
+  declare -A tmp
+  eval lArr1=("\"\${$1[@]}\"")
+  eval lArr2=("\"\${$2[@]}\"")
+  for i in "${lArr1[@]}";{ [ -n "$i" ] && ((++tmp[$i]));}
+  for i in "${lArr2[@]}";{ [ -n "$i" ] && [ -z "${tmp[$i]}" ] && return 1;}
+  return 0
+}
+
+# Bash completion entry point function.
+# _complete_grape finds which commands and subcommands have been specified
+# on the command line and delegates to the appropriate function
+# to generate possible options and subcommands for the last specified subcommand.
+function _complete_grape() {
+  CMDS0=(install)
+  CMDS1=(uninstall)
+  CMDS2=(list)
+  CMDS3=(resolve)
+  CMDS4=(help)
+
+  ArrContains COMP_WORDS CMDS4 && { _picocli_grape_help; return $?; }
+  ArrContains COMP_WORDS CMDS3 && { _picocli_grape_resolve; return $?; }
+  ArrContains COMP_WORDS CMDS2 && { _picocli_grape_list; return $?; }
+  ArrContains COMP_WORDS CMDS1 && { _picocli_grape_uninstall; return $?; }
+  ArrContains COMP_WORDS CMDS0 && { _picocli_grape_install; return $?; }
+
+  # No subcommands were specified; generate completions for the top-level command.
+  _picocli_grape; return $?;
+}
+
+# Generates completions for the options and subcommands of the `grape` command.
+function _picocli_grape() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS="install uninstall list resolve help"
+  FLAG_OPTS="-q --quiet -w --warn -i --info -V --verbose -d --debug -h --help -v --version"
+  ARG_OPTS="-D --define -r --resolver"
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Generates completions for the options and subcommands of the `install` subcommand.
+function _picocli_grape_install() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-h --help -v --version"
+  ARG_OPTS=""
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Generates completions for the options and subcommands of the `uninstall` subcommand.
+function _picocli_grape_uninstall() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-h --help -v --version"
+  ARG_OPTS=""
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Generates completions for the options and subcommands of the `list` subcommand.
+function _picocli_grape_list() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-h --help -v --version"
+  ARG_OPTS=""
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Generates completions for the options and subcommands of the `resolve` subcommand.
+function _picocli_grape_resolve() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-a --ant -d --dos -s --shell -i --ivy -h --help -v --version"
+  ARG_OPTS=""
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Generates completions for the options and subcommands of the `help` subcommand.
+function _picocli_grape_help() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-h --help"
+  ARG_OPTS=""
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Define a completion specification (a compspec) for the
+# `grape`, `grape.sh`, and `grape.bash` commands.
+# Uses the bash `complete` builtin (see [5]) to specify that shell function
+# `_complete_grape` is responsible for generating possible completions for the
+# current word on the command line.
+# The `-o default` option means that if the function generated no matches, the
+# default Bash completions and the Readline default filename completions are performed.
+complete -F _complete_grape -o default grape grape.sh grape.bash
diff --git a/src/bin/groovyConsole_completion b/src/bin/groovyConsole_completion
new file mode 100644
index 0000000000..10c777c2bc
--- /dev/null
+++ b/src/bin/groovyConsole_completion
@@ -0,0 +1,106 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+#
+# groovyConsole Bash Completion
+# =======================
+#
+# Bash completion support for the `groovyConsole` command,
+# generated by [picocli](http://picocli.info/) version 3.0.2.
+#
+# Installation
+# ------------
+#
+# 1. Source all completion scripts in your .bash_profile
+#
+#   cd $GROOVY_HOME/bin
+#   for f in $(find . -name "*_completion"); do line=". $(pwd)/$f"; grep "$line" ~/.bash_profile || echo "$line" >> ~/.bash_profile; done
+#
+# 2. Open a new bash console, and type `groovyConsole [TAB][TAB]`
+#
+# Documentation
+# -------------
+# The script is called by bash whenever [TAB] or [TAB][TAB] is pressed after
+# 'groovyConsole (..)'. By reading entered command line parameters,
+# it determines possible bash completions and writes them to the COMPREPLY variable.
+# Bash then completes the user input if only one entry is listed in the variable or
+# shows the options if more than one is listed in COMPREPLY.
+#
+# References
+# ----------
+# [1] http://stackoverflow.com/a/12495480/1440785
+# [2] http://tiswww.case.edu/php/chet/bash/FAQ
+# [3] https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
+# [4] https://stackoverflow.com/questions/17042057/bash-check-element-in-array-for-elements-in-another-array/17042655#17042655
+# [5] https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html#Programmable-Completion
+#
+
+# Enable programmable completion facilities (see [3])
+shopt -s progcomp
+
+# ArrContains takes two arguments, both of which are the name of arrays.
+# It creates a temporary hash from lArr1 and then checks if all elements of lArr2
+# are in the hashtable.
+#
+# Returns zero (no error) if all elements of the 2nd array are in the 1st array,
+# otherwise returns 1 (error).
+#
+# Modified from [4]
+function ArrContains() {
+  local lArr1 lArr2
+  declare -A tmp
+  eval lArr1=("\"\${$1[@]}\"")
+  eval lArr2=("\"\${$2[@]}\"")
+  for i in "${lArr1[@]}";{ [ -n "$i" ] && ((++tmp[$i]));}
+  for i in "${lArr2[@]}";{ [ -n "$i" ] && [ -z "${tmp[$i]}" ] && return 1;}
+  return 0
+}
+
+# Bash completion entry point function.
+# _complete_groovyConsole finds which commands and subcommands have been specified
+# on the command line and delegates to the appropriate function
+# to generate possible options and subcommands for the last specified subcommand.
+function _complete_groovyConsole() {
+
+
+  # No subcommands were specified; generate completions for the top-level command.
+  _picocli_groovyConsole; return $?;
+}
+
+# Generates completions for the options and subcommands of the `groovyConsole` command.
+function _picocli_groovyConsole() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-cp -classpath --classpath -h --help -V --version -pa --parameters -i --indy"
+  ARG_OPTS="-D --define --configscript"
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Define a completion specification (a compspec) for the
+# `groovyConsole`, `groovyConsole.sh`, and `groovyConsole.bash` commands.
+# Uses the bash `complete` builtin (see [5]) to specify that shell function
+# `_complete_groovyConsole` is responsible for generating possible completions for the
+# current word on the command line.
+# The `-o default` option means that if the function generated no matches, the
+# default Bash completions and the Readline default filename completions are performed.
+complete -F _complete_groovyConsole -o default groovyConsole groovyConsole.sh groovyConsole.bash
diff --git a/src/bin/groovy_completion b/src/bin/groovy_completion
new file mode 100644
index 0000000000..13cd7128c1
--- /dev/null
+++ b/src/bin/groovy_completion
@@ -0,0 +1,106 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+#
+# groovy Bash Completion
+# =======================
+#
+# Bash completion support for the `groovy` command,
+# generated by [picocli](http://picocli.info/) version 3.0.2.
+#
+# Installation
+# ------------
+#
+# 1. Source all completion scripts in your .bash_profile
+#
+#   cd $GROOVY_HOME/bin
+#   for f in $(find . -name "*_completion"); do line=". $(pwd)/$f"; grep "$line" ~/.bash_profile || echo "$line" >> ~/.bash_profile; done
+#
+# 2. Open a new bash console, and type `groovy [TAB][TAB]`
+#
+# Documentation
+# -------------
+# The script is called by bash whenever [TAB] or [TAB][TAB] is pressed after
+# 'groovy (..)'. By reading entered command line parameters,
+# it determines possible bash completions and writes them to the COMPREPLY variable.
+# Bash then completes the user input if only one entry is listed in the variable or
+# shows the options if more than one is listed in COMPREPLY.
+#
+# References
+# ----------
+# [1] http://stackoverflow.com/a/12495480/1440785
+# [2] http://tiswww.case.edu/php/chet/bash/FAQ
+# [3] https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
+# [4] https://stackoverflow.com/questions/17042057/bash-check-element-in-array-for-elements-in-another-array/17042655#17042655
+# [5] https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html#Programmable-Completion
+#
+
+# Enable programmable completion facilities (see [3])
+shopt -s progcomp
+
+# ArrContains takes two arguments, both of which are the name of arrays.
+# It creates a temporary hash from lArr1 and then checks if all elements of lArr2
+# are in the hashtable.
+#
+# Returns zero (no error) if all elements of the 2nd array are in the 1st array,
+# otherwise returns 1 (error).
+#
+# Modified from [4]
+function ArrContains() {
+  local lArr1 lArr2
+  declare -A tmp
+  eval lArr1=("\"\${$1[@]}\"")
+  eval lArr2=("\"\${$2[@]}\"")
+  for i in "${lArr1[@]}";{ [ -n "$i" ] && ((++tmp[$i]));}
+  for i in "${lArr2[@]}";{ [ -n "$i" ] && [ -z "${tmp[$i]}" ] && return 1;}
+  return 0
+}
+
+# Bash completion entry point function.
+# _complete_groovy finds which commands and subcommands have been specified
+# on the command line and delegates to the appropriate function
+# to generate possible options and subcommands for the last specified subcommand.
+function _complete_groovy() {
+
+
+  # No subcommands were specified; generate completions for the top-level command.
+  _picocli_groovy; return $?;
+}
+
+# Generates completions for the options and subcommands of the `groovy` command.
+function _picocli_groovy() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-d --debug -n -p -pa --parameters --indy -h --help -v --version"
+  ARG_OPTS="-cp -classpath --classpath -D --define --disableopt -c --encoding -e -i -l -a --autosplit --configscript -b --basescript"
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Define a completion specification (a compspec) for the
+# `groovy`, `groovy.sh`, and `groovy.bash` commands.
+# Uses the bash `complete` builtin (see [5]) to specify that shell function
+# `_complete_groovy` is responsible for generating possible completions for the
+# current word on the command line.
+# The `-o default` option means that if the function generated no matches, the
+# default Bash completions and the Readline default filename completions are performed.
+complete -F _complete_groovy -o default groovy groovy.sh groovy.bash
diff --git a/src/bin/groovyc_completion b/src/bin/groovyc_completion
new file mode 100644
index 0000000000..ebb2a2a809
--- /dev/null
+++ b/src/bin/groovyc_completion
@@ -0,0 +1,142 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+#
+# groovyc Bash Completion
+# =======================
+#
+# Bash completion support for the `groovyc` command,
+# generated by [picocli](http://picocli.info/) version 3.0.2.
+#
+# Installation
+# ------------
+#
+# 1. Source all completion scripts in your .bash_profile
+#
+#   cd $GROOVY_HOME/bin
+#   for f in $(find . -name "*_completion"); do line=". $(pwd)/$f"; grep "$line" ~/.bash_profile || echo "$line" >> ~/.bash_profile; done
+#
+# 2. Open a new bash console, and type `groovyc [TAB][TAB]`
+#
+# Documentation
+# -------------
+# The script is called by bash whenever [TAB] or [TAB][TAB] is pressed after
+# 'groovyc (..)'. By reading entered command line parameters,
+# it determines possible bash completions and writes them to the COMPREPLY variable.
+# Bash then completes the user input if only one entry is listed in the variable or
+# shows the options if more than one is listed in COMPREPLY.
+#
+# References
+# ----------
+# [1] http://stackoverflow.com/a/12495480/1440785
+# [2] http://tiswww.case.edu/php/chet/bash/FAQ
+# [3] https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
+# [4] https://stackoverflow.com/questions/17042057/bash-check-element-in-array-for-elements-in-another-array/17042655#17042655
+# [5] https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html#Programmable-Completion
+#
+
+# Enable programmable completion facilities (see [3])
+shopt -s progcomp
+
+# ArrContains takes two arguments, both of which are the name of arrays.
+# It creates a temporary hash from lArr1 and then checks if all elements of lArr2
+# are in the hashtable.
+#
+# Returns zero (no error) if all elements of the 2nd array are in the 1st array,
+# otherwise returns 1 (error).
+#
+# Modified from [4]
+function ArrContains() {
+  local lArr1 lArr2
+  declare -A tmp
+  eval lArr1=("\"\${$1[@]}\"")
+  eval lArr2=("\"\${$2[@]}\"")
+  for i in "${lArr1[@]}";{ [ -n "$i" ] && ((++tmp[$i]));}
+  for i in "${lArr2[@]}";{ [ -n "$i" ] && [ -z "${tmp[$i]}" ] && return 1;}
+  return 0
+}
+
+# Bash completion entry point function.
+# _complete_groovyc finds which commands and subcommands have been specified
+# on the command line and delegates to the appropriate function
+# to generate possible options and subcommands for the last specified subcommand.
+function _complete_groovyc() {
+
+
+  # No subcommands were specified; generate completions for the top-level command.
+  _picocli_groovyc; return $?;
+}
+
+# Generates completions for the options and subcommands of the `groovyc` command.
+function _picocli_groovyc() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-e --exception -pa --parameters -j --jointCompilation --indy -h --help -v --version"
+  ARG_OPTS="-cp -classpath --classpath -sourcepath --sourcepath --temp --encoding -d -b --basescript -J -F --configscript"
+
+  case ${CURR_WORD} in
+    -sourcepath|--sourcepath)
+      compopt -o filenames
+      COMPREPLY=( $( compgen -f -- "" ) ) # files
+      return $?
+      ;;
+    --temp)
+      compopt -o filenames
+      COMPREPLY=( $( compgen -f -- "" ) ) # files
+      return $?
+      ;;
+    -d)
+      compopt -o filenames
+      COMPREPLY=( $( compgen -f -- "" ) ) # files
+      return $?
+      ;;
+    *)
+      case ${PREV_WORD} in
+        -sourcepath|--sourcepath)
+          compopt -o filenames
+          COMPREPLY=( $( compgen -f -- $CURR_WORD ) ) # files
+          return $?
+          ;;
+        --temp)
+          compopt -o filenames
+          COMPREPLY=( $( compgen -f -- $CURR_WORD ) ) # files
+          return $?
+          ;;
+        -d)
+          compopt -o filenames
+          COMPREPLY=( $( compgen -f -- $CURR_WORD ) ) # files
+          return $?
+          ;;
+      esac
+  esac
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Define a completion specification (a compspec) for the
+# `groovyc`, `groovyc.sh`, and `groovyc.bash` commands.
+# Uses the bash `complete` builtin (see [5]) to specify that shell function
+# `_complete_groovyc` is responsible for generating possible completions for the
+# current word on the command line.
+# The `-o default` option means that if the function generated no matches, the
+# default Bash completions and the Readline default filename completions are performed.
+complete -F _complete_groovyc -o default groovyc groovyc.sh groovyc.bash
diff --git a/src/bin/groovydoc_completion b/src/bin/groovydoc_completion
new file mode 100644
index 0000000000..afcdfc3e3d
--- /dev/null
+++ b/src/bin/groovydoc_completion
@@ -0,0 +1,106 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+#
+# groovydoc Bash Completion
+# =======================
+#
+# Bash completion support for the `groovydoc` command,
+# generated by [picocli](http://picocli.info/) version 3.0.2.
+#
+# Installation
+# ------------
+#
+# 1. Source all completion scripts in your .bash_profile
+#
+#   cd $GROOVY_HOME/bin
+#   for f in $(find . -name "*_completion"); do line=". $(pwd)/$f"; grep "$line" ~/.bash_profile || echo "$line" >> ~/.bash_profile; done
+#
+# 2. Open a new bash console, and type `groovydoc [TAB][TAB]`
+#
+# Documentation
+# -------------
+# The script is called by bash whenever [TAB] or [TAB][TAB] is pressed after
+# 'groovydoc (..)'. By reading entered command line parameters,
+# it determines possible bash completions and writes them to the COMPREPLY variable.
+# Bash then completes the user input if only one entry is listed in the variable or
+# shows the options if more than one is listed in COMPREPLY.
+#
+# References
+# ----------
+# [1] http://stackoverflow.com/a/12495480/1440785
+# [2] http://tiswww.case.edu/php/chet/bash/FAQ
+# [3] https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
+# [4] https://stackoverflow.com/questions/17042057/bash-check-element-in-array-for-elements-in-another-array/17042655#17042655
+# [5] https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html#Programmable-Completion
+#
+
+# Enable programmable completion facilities (see [3])
+shopt -s progcomp
+
+# ArrContains takes two arguments, both of which are the name of arrays.
+# It creates a temporary hash from lArr1 and then checks if all elements of lArr2
+# are in the hashtable.
+#
+# Returns zero (no error) if all elements of the 2nd array are in the 1st array,
+# otherwise returns 1 (error).
+#
+# Modified from [4]
+function ArrContains() {
+  local lArr1 lArr2
+  declare -A tmp
+  eval lArr1=("\"\${$1[@]}\"")
+  eval lArr2=("\"\${$2[@]}\"")
+  for i in "${lArr1[@]}";{ [ -n "$i" ] && ((++tmp[$i]));}
+  for i in "${lArr2[@]}";{ [ -n "$i" ] && [ -z "${tmp[$i]}" ] && return 1;}
+  return 0
+}
+
+# Bash completion entry point function.
+# _complete_groovydoc finds which commands and subcommands have been specified
+# on the command line and delegates to the appropriate function
+# to generate possible options and subcommands for the last specified subcommand.
+function _complete_groovydoc() {
+
+
+  # No subcommands were specified; generate completions for the top-level command.
+  _picocli_groovydoc; return $?;
+}
+
+# Generates completions for the options and subcommands of the `groovydoc` command.
+function _picocli_groovydoc() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-h -help --help --version -verbose -quiet --debug -classpath -cp --classpath -author -noscripts -nomainforscripts -notimestamp -noversionstamp -public -protected -package -private"
+  ARG_OPTS="-d --destdir -overview -charset -fileEncoding -windowtitle -doctitle -header -footer -exclude -stylesheetfile -sourcepath"
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Define a completion specification (a compspec) for the
+# `groovydoc`, `groovydoc.sh`, and `groovydoc.bash` commands.
+# Uses the bash `complete` builtin (see [5]) to specify that shell function
+# `_complete_groovydoc` is responsible for generating possible completions for the
+# current word on the command line.
+# The `-o default` option means that if the function generated no matches, the
+# default Bash completions and the Readline default filename completions are performed.
+complete -F _complete_groovydoc -o default groovydoc groovydoc.sh groovydoc.bash
diff --git a/src/bin/groovysh_completion b/src/bin/groovysh_completion
new file mode 100644
index 0000000000..5b8869c38d
--- /dev/null
+++ b/src/bin/groovysh_completion
@@ -0,0 +1,103 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------------------------
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+# ----------------------------------------------------------------------------
+#
+# groovysh Bash Completion
+# =======================
+#
+# Bash completion support for the `groovysh` command,
+# generated by [picocli](http://picocli.info/) version 3.0.2.
+#
+# 1. Source all completion scripts in your .bash_profile
+#
+#   cd $GROOVY_HOME/bin
+#   for f in $(find . -name "*_completion"); do line=". $(pwd)/$f"; grep "$line" ~/.bash_profile || echo "$line" >> ~/.bash_profile; done
+#
+# 2. Open a new bash console, and type `groovysh [TAB][TAB]`
+#
+# Documentation
+# -------------
+# The script is called by bash whenever [TAB] or [TAB][TAB] is pressed after
+# 'groovysh (..)'. By reading entered command line parameters,
+# it determines possible bash completions and writes them to the COMPREPLY variable.
+# Bash then completes the user input if only one entry is listed in the variable or
+# shows the options if more than one is listed in COMPREPLY.
+#
+# References
+# ----------
+# [1] http://stackoverflow.com/a/12495480/1440785
+# [2] http://tiswww.case.edu/php/chet/bash/FAQ
+# [3] https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
+# [4] https://stackoverflow.com/questions/17042057/bash-check-element-in-array-for-elements-in-another-array/17042655#17042655
+# [5] https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html#Programmable-Completion
+#
+
+# Enable programmable completion facilities (see [3])
+shopt -s progcomp
+
+# ArrContains takes two arguments, both of which are the name of arrays.
+# It creates a temporary hash from lArr1 and then checks if all elements of lArr2
+# are in the hashtable.
+#
+# Returns zero (no error) if all elements of the 2nd array are in the 1st array,
+# otherwise returns 1 (error).
+#
+# Modified from [4]
+function ArrContains() {
+  local lArr1 lArr2
+  declare -A tmp
+  eval lArr1=("\"\${$1[@]}\"")
+  eval lArr2=("\"\${$2[@]}\"")
+  for i in "${lArr1[@]}";{ [ -n "$i" ] && ((++tmp[$i]));}
+  for i in "${lArr2[@]}";{ [ -n "$i" ] && [ -z "${tmp[$i]}" ] && return 1;}
+  return 0
+}
+
+# Bash completion entry point function.
+# _complete_groovysh finds which commands and subcommands have been specified
+# on the command line and delegates to the appropriate function
+# to generate possible options and subcommands for the last specified subcommand.
+function _complete_groovysh() {
+
+
+  # No subcommands were specified; generate completions for the top-level command.
+  _picocli_groovysh; return $?;
+}
+
+# Generates completions for the options and subcommands of the `groovysh` command.
+function _picocli_groovysh() {
+  # Get completion data
+  CURR_WORD=${COMP_WORDS[COMP_CWORD]}
+  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}
+
+  COMMANDS=""
+  FLAG_OPTS="-cp -classpath --classpath -h --help -V --version -v --verbose -q --quiet -d --debug -pa --parameters"
+  ARG_OPTS="-e --evaluate -C --color -D --define -T --terminal"
+
+  COMPREPLY=( $(compgen -W "${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}" -- ${CURR_WORD}) )
+}
+
+# Define a completion specification (a compspec) for the
+# `groovysh`, `groovysh.sh`, and `groovysh.bash` commands.
+# Uses the bash `complete` builtin (see [5]) to specify that shell function
+# `_complete_groovysh` is responsible for generating possible completions for the
+# current word on the command line.
+# The `-o default` option means that if the function generated no matches, the
+# default Bash completions and the Readline default filename completions are performed.
+complete -F _complete_groovysh -o default groovysh groovysh.sh groovysh.bash

Commit:
95dfb2f2f74ca470bd779e17cbd59c47e5677e11
Paul King
paulk@asert.com.au
2018-05-26 20:10:03 +1000
GROOVY-8601: Groovy should have a runner for JUnit5 tests (closes #723)
diff --git a/gradle/assemble.gradle b/gradle/assemble.gradle
index 2f83048f34..9d677689c9 100644
--- a/gradle/assemble.gradle
+++ b/gradle/assemble.gradle
@@ -409,7 +409,8 @@ ext.distSpec = copySpec {
         include 'jline2-license.txt'
         include 'jsr166y-license.txt'
         include 'jsr223-license.txt'
-        include 'junit-license.txt'
+        include 'junit4-license.txt'
+        include 'junit5-license.txt'
         include 'xstream-license.txt'
     }
 }
diff --git a/gradle/binarycompatibility.gradle b/gradle/binarycompatibility.gradle
index 274838b459..184a2e094c 100644
--- a/gradle/binarycompatibility.gradle
+++ b/gradle/binarycompatibility.gradle
@@ -35,7 +35,7 @@ task checkBinaryCompatibility {
 check.dependsOn(checkBinaryCompatibility)
 
 // for comparing between versions with different modules, set excludeModules to differing modules, e.g.
-def excludeModules = ['groovy-cli-picocli', 'groovy-cli-commons', 'groovy-dateutil', 'groovy-datetime', 'performance', 'groovy-macro', 'tests-vm8', 'groovy-json-direct']
+def excludeModules = ['groovy-cli-picocli', 'groovy-cli-commons', 'groovy-dateutil', 'groovy-datetime', 'performance', 'groovy-macro', 'tests-vm8', 'groovy-json-direct', 'groovy-test-junit5']
 //def excludeModules = []
 
 Set projectsToCheck = allprojects.findAll{ !(it.name in excludeModules) }
diff --git a/licenses/LICENSE-BINZIP b/licenses/LICENSE-BINZIP
index e610786175..065d20c19a 100644
--- a/licenses/LICENSE-BINZIP
+++ b/licenses/LICENSE-BINZIP
@@ -259,10 +259,13 @@ has a BSD-style license. Details can be found in: licenses/jsr223-license.txt
 
 ------------------------------------------------------------------------
 
-JUnit License (optional dependency when using Groovy for testing)
+JUnit Licenses (optional dependencies when using Groovy for testing)
 
-This product bundles the JUnit jar, which is available under the
-Eclipse Public License v1.0.  For details, see licenses/junit-license.
+This product bundles the JUnit 4 jar, which is available under the
+Eclipse Public License v1.0.  For details, see licenses/junit4-license.
+
+This product bundles several JUnit 5 jars, which are available under the
+Eclipse Public License v2.0.  For details, see licenses/junit5-license.
 
 ------------------------------------------------------------------------
 
diff --git a/licenses/LICENSE-SDK b/licenses/LICENSE-SDK
index 6198f15446..2ba84ff962 100644
--- a/licenses/LICENSE-SDK
+++ b/licenses/LICENSE-SDK
@@ -259,10 +259,13 @@ has a BSD-style license. Details can be found in: licenses/jsr223-license.txt
 
 ------------------------------------------------------------------------
 
-JUnit License (optional dependency when using Groovy for testing)
+JUnit Licenses (optional dependencies when using Groovy for testing)
 
-This product bundles the JUnit jar, which is available under the
-Eclipse Public License v1.0.  For details, see licenses/junit-license.
+This product bundles the JUnit 4 jar, which is available under the
+Eclipse Public License v1.0.  For details, see licenses/junit4-license.
+
+This product bundles several JUnit 5 jars, which are available under the
+Eclipse Public License v2.0.  For details, see licenses/junit5-license.
 
 ------------------------------------------------------------------------
 
diff --git a/licenses/junit-BINZIP.txt b/licenses/junit-BINZIP.txt
index 78c3fec17b..87a82c6da4 100644
--- a/licenses/junit-BINZIP.txt
+++ b/licenses/junit-BINZIP.txt
@@ -1,4 +1,7 @@
-JUnit License (optional dependency when using Groovy for testing)
+JUnit Licenses (optional dependencies when using Groovy for testing)
 
-This product bundles the JUnit jar, which is available under the
-Eclipse Public License v1.0.  For details, see licenses/junit-license.
+This product bundles the JUnit 4 jar, which is available under the
+Eclipse Public License v1.0.  For details, see licenses/junit4-license.
+
+This product bundles several JUnit 5 jars, which are available under the
+Eclipse Public License v2.0.  For details, see licenses/junit5-license.
diff --git a/licenses/junit-license.txt b/licenses/junit4-license.txt
similarity index 100%
rename from licenses/junit-license.txt
rename to licenses/junit4-license.txt
diff --git a/licenses/junit5-license.txt b/licenses/junit5-license.txt
new file mode 100644
index 0000000000..76bdbaa8f0
--- /dev/null
+++ b/licenses/junit5-license.txt
@@ -0,0 +1,87 @@
+Eclipse Public License - v 2.0
+
+THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC LICENSE (“AGREEMENT”). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
+
+1. Definitions
+“Contribution” means:
+
+a) in the case of the initial Contributor, the initial content Distributed under this Agreement, and
+b) in the case of each subsequent Contributor:
+i) changes to the Program, and
+ii) additions to the Program; where such changes and/or additions to the Program originate from and are Distributed by that particular Contributor. A Contribution “originates” from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf. Contributions do not include changes or additions to the Program that are not Modified Works.
+“Contributor” means any person or entity that Distributes the Program.
+
+“Licensed Patents” mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone or when combined with the Program.
+
+“Program” means the Contributions Distributed in accordance with this Agreement.
+
+“Recipient” means anyone who receives the Program under this Agreement or any Secondary License (as applicable), including Contributors.
+
+“Derivative Works” shall mean any work, whether in Source Code or other form, that is based on (or derived from) the Program and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship.
+
+“Modified Works” shall mean any work in Source Code or other form that results from an addition to, deletion from, or modification of the contents of the Program, including, for purposes of clarity any new file in Source Code form that contains any contents of the Program. Modified Works shall not include works that contain only declarations, interfaces, types, classes, structures, or files of the Program solely in each case in order to link to, bind by name, or subclass the Program or Modified Works thereof.
+
+“Distribute” means the acts of a) distributing or b) making available in any manner that enables the transfer of a copy.
+
+“Source Code” means the form of a Program preferred for making modifications, including but not limited to software source code, documentation source, and configuration files.
+
+“Secondary License” means either the GNU General Public License, Version 2.0, or any later versions of that license, including any exceptions or additional permissions as identified by the initial Contributor.
+
+2. Grant of Rights
+a) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, Distribute and sublicense the Contribution of such Contributor, if any, and such Derivative Works.
+
+b) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in Source Code or other form. This patent license shall apply to the combination of the Contribution and the Program if, at the time the Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents. The patent license shall not apply to any other combinations which include the Contribution. No hardware per se is licensed hereunder.
+
+c) Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity. Each Contributor disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise. As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other intellectual property rights needed, if any. For example, if a third party patent license is required to allow Recipient to Distribute the Program, it is Recipient's responsibility to acquire that license before distributing the Program.
+
+d) Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright license set forth in this Agreement.
+
+e) Notwithstanding the terms of any Secondary License, no Contributor makes additional grants to any Recipient (other than those set forth in this Agreement) as a result of such Recipient's receipt of the Program under the terms of a Secondary License (if permitted under the terms of Section 3).
+
+3. Requirements
+3.1 If a Contributor Distributes the Program in any form, then:
+
+a) the Program must also be made available as Source Code, in accordance with section 3.2, and the Contributor must accompany the Program with a statement that the Source Code for the Program is available under this Agreement, and informs Recipients how to obtain it in a reasonable manner on or through a medium customarily used for software exchange; and
+
+b) the Contributor may Distribute the Program under a license different than this Agreement, provided that such license:
+
+i) effectively disclaims on behalf of all other Contributors all warranties and conditions, express and implied, including warranties or conditions of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose;
+ii) effectively excludes on behalf of all other Contributors all liability for damages, including direct, indirect, special, incidental and consequential damages, such as lost profits;
+iii) does not attempt to limit or alter the recipients' rights in the Source Code under section 3.2; and
+iv) requires any subsequent distribution of the Program by any party to be under a license that satisfies the requirements of this section 3.
+3.2 When the Program is Distributed as Source Code:
+
+a) it must be made available under this Agreement, or if the Program (i) is combined with other material in a separate file or files made available under a Secondary License, and (ii) the initial Contributor attached to the Source Code the notice described in Exhibit A of this Agreement, then the Program may be made available under the terms of such Secondary Licenses, and
+b) a copy of this Agreement must be included with each copy of the Program.
+3.3 Contributors may not remove or alter any copyright, patent, trademark, attribution notices, disclaimers of warranty, or limitations of liability (“notices”) contained within the Program from any copy of the Program which they Distribute, provided that Contributors may add their own appropriate notices.
+
+4. Commercial Distribution
+Commercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like. While this license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering should do so in a manner which does not create potential liability for other Contributors. Therefore, if a Contributor includes the Program in a commercial product offering, such Contributor (“Commercial Contributor”) hereby agrees to defend and indemnify every other Contributor (“Indemnified Contributor”) against any losses, damages and costs (collectively “Losses”) arising from claims, lawsuits and other legal actions brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in connection with its distribution of the Program in a commercial product offering. The obligations in this section do not apply to any claims or Losses relating to any actual or alleged intellectual property infringement. In order to qualify, an Indemnified Contributor must: a) promptly notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the Commercial Contributor in, the defense and any related settlement negotiations. The Indemnified Contributor may participate in any such claim at its own expense.
+
+For example, a Contributor might include the Program in a commercial product offering, Product X. That Contributor is then a Commercial Contributor. If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims and warranties are such Commercial Contributor's responsibility alone. Under this section, the Commercial Contributor would have to defend claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay any damages as a result, the Commercial Contributor must pay those damages.
+
+5. No Warranty
+EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely responsible for determining the appropriateness of using and distributing the Program and assumes all risks associated with its exercise of rights under this Agreement, including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations.
+
+6. Disclaimer of Liability
+EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT PERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+7. General
+If any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.
+
+If Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's rights granted under Section 2(b) shall terminate as of the date such litigation is filed.
+
+All Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance. If all Recipient's rights under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable. However, Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.
+
+Everyone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted and may only be modified in the following manner. The Agreement Steward reserves the right to publish new versions (including revisions) of this Agreement from time to time. No one other than the Agreement Steward has the right to modify this Agreement. The Eclipse Foundation is the initial Agreement Steward. The Eclipse Foundation may assign the responsibility to serve as the Agreement Steward to a suitable separate entity. Each new version of the Agreement will be given a distinguishing version number. The Program (including Contributions) may always be Distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is published, Contributor may elect to Distribute the Program (including its Contributions) under the new version.
+
+Except as expressly stated in Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement, whether expressly, by implication, estoppel or otherwise. All rights in the Program not expressly granted under this Agreement are reserved. Nothing in this Agreement is intended to be enforceable by any entity that is not a Contributor or Recipient. No third-party beneficiary rights are created under this Agreement.
+
+Exhibit A - Form of Secondary Licenses Notice
+“This Source Code may also be made available under the following Secondary Licenses when the conditions for such availability set forth in the Eclipse Public License, v. 2.0 are satisfied: {name license(s), version(s), and exceptions or additional permissions here}.”
+
+Simply including a copy of this Agreement, including this Exhibit A is not sufficient to license the Source Code under Secondary Licenses.
+
+If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.
+
+You may add additional accurate notices of copyright ownership.
diff --git a/notices/NOTICE-BINZIP b/notices/NOTICE-BINZIP
index bf71a557b4..4d69a76342 100644
--- a/notices/NOTICE-BINZIP
+++ b/notices/NOTICE-BINZIP
@@ -10,9 +10,12 @@ developed by Terence Parr 1989-2006
 This product includes/uses ANTLR4 (https://github.com/antlr/antlr4)
 Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 
-This product bundles the JUnit jar (junit.org)
+This product bundles the JUnit4 jar (junit.org)
 which is available under the terms of the Eclipse Public License v1.0
 
+This product bundles several of the JUnit5 jars (junit.org)
+which are available under the terms of the Eclipse Public License v2.0
+
 This product embeds the OpenBeans jar within its grooid jar artifacts
 OpenBeans includes/uses files from Apache Harmony and the following notice applies
 Copyright 2006, 2010 The Apache Software Foundation.
diff --git a/notices/NOTICE-SDK b/notices/NOTICE-SDK
index e15b4262a6..ed5cf1dc87 100644
--- a/notices/NOTICE-SDK
+++ b/notices/NOTICE-SDK
@@ -10,9 +10,12 @@ developed by Terence Parr 1989-2006
 This product includes/uses ANTLR4 (https://github.com/antlr/antlr4)
 Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 
-This product bundles the JUnit jar (junit.org)
+This product bundles the JUnit4 jar (junit.org)
 which is available under the terms of the Eclipse Public License v1.0
 
+This product bundles several of the JUnit5 jars (junit.org)
+which are available under the terms of the Eclipse Public License v2.0
+
 This product embeds the OpenBeans jar within its grooid jar artifacts
 OpenBeans includes/uses files from Apache Harmony and the following notice applies
 Copyright 2006, 2010 The Apache Software Foundation.
diff --git a/notices/junit-BINZIP.txt b/notices/junit-BINZIP.txt
index 7dd10502ff..7932bddeca 100644
--- a/notices/junit-BINZIP.txt
+++ b/notices/junit-BINZIP.txt
@@ -1,2 +1,5 @@
-This product bundles the JUnit jar (junit.org)
+This product bundles the JUnit4 jar (junit.org)
 which is available under the terms of the Eclipse Public License v1.0
+
+This product bundles several of the JUnit5 jars (junit.org)
+which are available under the terms of the Eclipse Public License v2.0
diff --git a/settings.gradle b/settings.gradle
index 0405148218..f726532ebc 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -36,6 +36,7 @@ def subprojects = ['groovy-ant',
         'groovy-swing',
         'groovy-templates',
         'groovy-test',
+        'groovy-test-junit5',
         'groovy-testng',
         'groovy-xml',
         'groovy-macro',
diff --git a/src/spec/doc/core-testing-guide.adoc b/src/spec/doc/core-testing-guide.adoc
index 5867a29db5..b7e4679677 100644
--- a/src/spec/doc/core-testing-guide.adoc
+++ b/src/spec/doc/core-testing-guide.adoc
@@ -358,10 +358,21 @@ cobertura {
 Several output formats can be chosen for Cobertura coverage reports and test code coverage reports can be added to
 continuous integration build tasks.
 
-== Unit Tests with JUnit 3 and 4
+== Testing with JUnit
 
-Groovy simplifies JUnit testing, making it more Groovy. In the following sections we will have a closer look at
-JUnit 3/4 Groovy integration.
+Groovy simplifies JUnit testing in the following ways:
+
+* You use the same overall practices as you would when testing with Java but you
+can adopt much of Groovy's concise syntax in your tests making them succinct. You can even use
+the capabilities for writing testing domain specific languages (DSLs) if you feel so inclined.
+* There are numerous helper classes that simplify many testing activities. The details differ
+in some cases depending on the version of JUnit you are using. We'll cover those details shortly.
+* Groovy's PowerAssert mechanism is wonderful to use in your tests
+* Groovy deems that tests are so important you should be able to run them as easily as scripts or classes.
+This is why Groovy includes an automatic test runner when using the `groovy` command or the GroovyConsole.
+This gives you some additional options over and above running your tests
+
+In the following sections we will have a closer look at JUnit 3, 4 and 5 Groovy integration.
 
 === JUnit 3
 
@@ -481,6 +492,8 @@ exception:
 include::{projectdir}/src/spec/test/testingguide/JUnit4ExampleTests.groovy[tags=should_fail_return,indent=0]
 ----
 
+include::{rootProjectDir}/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc[leveloffset=+1]
+
 == Testing with Spock
 
 Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the
diff --git a/subprojects/groovy-test-junit5/build.gradle b/subprojects/groovy-test-junit5/build.gradle
new file mode 100644
index 0000000000..1accebcdc6
--- /dev/null
+++ b/subprojects/groovy-test-junit5/build.gradle
@@ -0,0 +1,36 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+dependencies {
+    compile rootProject
+    compile 'org.junit.platform:junit-platform-launcher:1.2.0'
+    runtime 'org.junit.jupiter:junit-jupiter-engine:5.2.0'
+    testCompile 'org.junit.jupiter:junit-jupiter-params:5.2.0'
+    testRuntime 'org.junit.platform:junit-platform-runner:1.2.0'
+    testRuntime 'org.junit.vintage:junit-vintage-engine:5.2.0'
+    testCompile project(':groovy-test')
+}
+
+tasks.withType(JavaCompile) {
+    sourceCompatibility = 1.8
+    targetCompatibility = 1.8
+}
+
+test {
+    useJUnitPlatform()
+}
diff --git a/subprojects/groovy-test-junit5/src/main/groovy/groovy/junit5/plugin/GroovyJUnitRunnerHelper.groovy b/subprojects/groovy-test-junit5/src/main/groovy/groovy/junit5/plugin/GroovyJUnitRunnerHelper.groovy
new file mode 100644
index 0000000000..1c1a1d34e1
--- /dev/null
+++ b/subprojects/groovy-test-junit5/src/main/groovy/groovy/junit5/plugin/GroovyJUnitRunnerHelper.groovy
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.junit5.plugin
+
+import org.junit.platform.launcher.Launcher
+import org.junit.platform.launcher.LauncherDiscoveryRequest
+import org.junit.platform.launcher.TestExecutionListener
+import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder
+import org.junit.platform.launcher.core.LauncherFactory
+import org.junit.platform.launcher.listeners.LoggingListener
+import org.junit.platform.launcher.listeners.SummaryGeneratingListener
+
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass
+
+class GroovyJUnitRunnerHelper {
+    static Throwable execute(Class testClass) {
+        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
+                .selectors(selectClass(testClass)).build()
+        Launcher launcher = LauncherFactory.create()
+
+        TestExecutionListener listener = new SummaryGeneratingListener()
+        launcher.registerTestExecutionListeners(listener)
+        launcher.registerTestExecutionListeners(LoggingListener.forJavaUtilLogging())
+        launcher.execute(request)
+        println listener.summary.with{ "JUnit5 launcher: passed=$testsSucceededCount, failed=$testsFailedCount, skipped=$testsSkippedCount, time=${timeFinished-timeStarted}ms" }
+        if (listener.summary.failures) {
+            listener.summary.printFailuresTo(new PrintWriter(System.out, true))
+            return listener.summary.failures[0].exception
+        }
+        return null
+    }
+}
diff --git a/subprojects/groovy-test-junit5/src/main/java/groovy/junit5/plugin/JUnit5Runner.java b/subprojects/groovy-test-junit5/src/main/java/groovy/junit5/plugin/JUnit5Runner.java
new file mode 100644
index 0000000000..8cd13f653f
--- /dev/null
+++ b/subprojects/groovy-test-junit5/src/main/java/groovy/junit5/plugin/JUnit5Runner.java
@@ -0,0 +1,104 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.junit5.plugin;
+
+import groovy.lang.GroovyClassLoader;
+import groovy.lang.GroovyRuntimeException;
+import org.apache.groovy.plugin.GroovyRunner;
+import org.codehaus.groovy.runtime.InvokerHelper;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+
+/**
+ * Integration code for running JUnit5 tests in Groovy.
+ */
+public class JUnit5Runner implements GroovyRunner {
+
+    /**
+     * Utility method to check via reflection if the parsed class appears to be a JUnit5
+     * test, i.e. checks whether it appears to be using the relevant annotations.
+     *
+     * @param scriptClass the class we want to check
+     * @param loader the GroovyClassLoader to use to find classes
+     * @return true if the class appears to be a compatible test
+     */
+    @Override
+    public boolean canRun(Class<?> scriptClass, GroovyClassLoader loader) {
+        if (isJUnit5AnnotationPresent(scriptClass.getAnnotations(), loader)) {
+            return true;
+        } else {
+            Method[] methods = scriptClass.getMethods();
+            for (Method method : methods) {
+                if (isJUnit5AnnotationPresent(method.getAnnotations(), loader)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private boolean isJUnit5AnnotationPresent(Annotation[] annotations, GroovyClassLoader loader) {
+        for (Annotation annotation : annotations) {
+            String name = annotation.annotationType().getName();
+            if (name.startsWith("org.junit.jupiter.api.") && tryLoadClass(name, loader)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean tryLoadClass(String name, GroovyClassLoader loader) {
+        try {
+            loader.loadClass("org.junit.jupiter.api.Test");
+            return true;
+        } catch (ClassNotFoundException ignore) {
+            // fall through
+        }
+        return false;
+    }
+
+    /**
+     * Utility method to run a JUnit 5 test.
+     *
+     * @param scriptClass the class we want to run as a test
+     * @param loader the class loader to use
+     * @return the result of running the test
+     */
+    @Override
+    public Object run(Class<?> scriptClass, GroovyClassLoader loader) {
+        try {
+            try {
+                loader.loadClass("org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder");
+            } catch (ClassNotFoundException ignored) {
+                // subsequent steps will bomb out but try to give some more friendly information first
+                System.err.println("WARNING: Required dependency: org.junit.platform:junit-platform-launcher doesn't appear to be on the classpath");
+            }
+            Class<?> helper = loader.loadClass("groovy.junit5.plugin.GroovyJUnitRunnerHelper");
+            Throwable ifFailed = (Throwable) InvokerHelper.invokeStaticMethod(helper, "execute", new Object[]{scriptClass});
+            if (ifFailed != null) {
+                throw new GroovyRuntimeException(ifFailed);
+            }
+            return null;
+        } catch (ClassNotFoundException e) {
+            throw new GroovyRuntimeException("Error running JUnit 5 test.", e);
+        }
+    }
+
+}
diff --git a/subprojects/groovy-test-junit5/src/main/resources/META-INF/services/org.apache.groovy.plugin.GroovyRunner b/subprojects/groovy-test-junit5/src/main/resources/META-INF/services/org.apache.groovy.plugin.GroovyRunner
new file mode 100644
index 0000000000..a0a7e3d60c
--- /dev/null
+++ b/subprojects/groovy-test-junit5/src/main/resources/META-INF/services/org.apache.groovy.plugin.GroovyRunner
@@ -0,0 +1,20 @@
+#
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  "License"); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing,
+#  software distributed under the License is distributed on an
+#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+#  KIND, either express or implied.  See the License for the
+#  specific language governing permissions and limitations
+#  under the License.
+#
+
+groovy.junit5.plugin.JUnit5Runner
diff --git a/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc b/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc
new file mode 100644
index 0000000000..b1d915fbf1
--- /dev/null
+++ b/subprojects/groovy-test-junit5/src/spec/doc/testing-with-junit5.adoc
@@ -0,0 +1,30 @@
+== JUnit 5
+
+Much of the approach and helper classes described under JUnit4 apply when using JUnit5 however JUnit5
+uses some slightly different class annotations when writing your tests. See the http://junit.org[JUnit5] documentation
+for more details.
+
+Create your test classes as per normal JUnit5 guidelines as shown in this example:
+
+[source,groovy]
+----
+include::{rootprojectdir}/subprojects/groovy-test-junit5/src/spec/test/MyTestViaRun.groovy[tags=junit5_test_part1,indent=0]
+include::{rootprojectdir}/subprojects/groovy-test-junit5/src/spec/test/MyTestViaRun.groovy[tags=junit5_test_part2,indent=0]
+----
+<1> This test requires the additional `org.junit.jupiter:junit-jupiter-params` dependency if not already in your project.
+
+You can run the tests in your IDE or build tool if it supports and is configured for JUnit5.
+If you run the above test in the GroovyConsole or via the `groovy` command, you will see a short text summary of the
+result of running the test:
+
+----
+include::{rootprojectdir}/subprojects/groovy-test-junit5/src/spec/test/MyTestViaRun.groovy[tags=junit5_test_output,indent=0]
+----
+
+More detailed information is available at the `FINE` logging level. You can configure your logging to display such
+information or do it programmatically as follows:
+
+[source,groovy]
+----
+include::{rootprojectdir}/subprojects/groovy-test-junit5/src/spec/test/MyTestViaRun.groovy[tags=junit5_test_part3,indent=0]
+----
diff --git a/subprojects/groovy-test-junit5/src/spec/test/MyTestViaRun.groovy b/subprojects/groovy-test-junit5/src/spec/test/MyTestViaRun.groovy
new file mode 100644
index 0000000000..17b4b32fbc
--- /dev/null
+++ b/subprojects/groovy-test-junit5/src/spec/test/MyTestViaRun.groovy
@@ -0,0 +1,81 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+class MyTestViaRun extends GroovyTestCase {
+  void testJunit5ViaRun() {
+    new GroovyShell().run '''
+//@Grab('org.junit.jupiter:junit-jupiter-params:5.2.0')
+import org.junit.jupiter.api.*
+import org.junit.jupiter.params.ParameterizedTest
+import org.junit.jupiter.params.provider.ValueSource
+import java.util.stream.Stream
+import static org.junit.jupiter.api.Assertions.assertTrue
+import static org.junit.jupiter.api.DynamicTest.dynamicTest
+import java.util.logging.ConsoleHandler
+import java.util.logging.Level
+import java.util.logging.Logger
+import org.junit.platform.launcher.listeners.LoggingListener
+
+// tag::junit5_test_part1[]
+class MyTest {
+// end::junit5_test_part1[]
+  // tag::junit5_test_part3[]
+  @BeforeAll
+  static void init() {
+    def logger = Logger.getLogger(LoggingListener.name)
+    logger.level = Level.FINE
+    logger.addHandler(new ConsoleHandler(level: Level.FINE))
+  }
+  // end::junit5_test_part3[]
+
+// tag::junit5_test_part2[]
+  @Test
+  void streamSum() {
+    assertTrue(Stream.of(1, 2, 3)
+      .mapToInt(i -> i)
+      .sum() > 5, () -> "Sum should be greater than 5")
+  }
+
+  @RepeatedTest(value=2, name = "{displayName} {currentRepetition}/{totalRepetitions}")
+  void streamSumRepeated() {
+    assert Stream.of(1, 2, 3).mapToInt(i -> i).sum() == 6
+  }
+
+  private boolean isPalindrome(s) { s == s.reverse()  }
+
+  @ParameterizedTest                                                              // <1>
+  @ValueSource(strings = [ "racecar", "radar", "able was I ere I saw elba" ])
+  void palindromes(String candidate) {
+    assert isPalindrome(candidate)
+  }
+
+  @TestFactory
+  def dynamicTestCollection() {[
+    dynamicTest("Add test") { -> assert 1 + 1 == 2 },
+    dynamicTest("Multiply Test", () -> { assert 2 * 3 == 6 })
+  ]}
+}
+// end::junit5_test_part2[]
+''', "MyTest", []
+  }
+/*
+// tag::junit5_test_output[]
+JUnit5 launcher: passed=8, failed=0, skipped=0, time=246ms
+// end::junit5_test_output[]
+*/
+}
diff --git a/subprojects/groovy-test-junit5/src/test/groovy/MyTestJunit5.groovy b/subprojects/groovy-test-junit5/src/test/groovy/MyTestJunit5.groovy
new file mode 100644
index 0000000000..69317b3da1
--- /dev/null
+++ b/subprojects/groovy-test-junit5/src/test/groovy/MyTestJunit5.groovy
@@ -0,0 +1,36 @@
+//@Grab('org.junit.jupiter:junit-jupiter-params:5.2.0')
+import org.junit.jupiter.api.*
+import org.junit.jupiter.params.ParameterizedTest
+import org.junit.jupiter.params.provider.ValueSource
+import java.util.stream.Stream
+import static org.junit.jupiter.api.Assertions.assertTrue
+import static org.junit.jupiter.api.DynamicTest.dynamicTest
+
+class MyTestJUnit5 {
+
+  @Test
+  void streamSum() {
+    assertTrue(Stream.of(1, 2, 3)
+      .mapToInt(i -> i)
+      .sum() > 5, () -> "Sum should be greater than 5")
+  }
+
+  @RepeatedTest(value=2, name = "{displayName} {currentRepetition}/{totalRepetitions}")
+  void streamSumRepeated() {
+    assert Stream.of(1, 2, 3).mapToInt(i -> i).sum() == 6
+  }
+
+  private boolean isPalindrome(s) { s == s.reverse()  }
+
+  @ParameterizedTest
+  @ValueSource(strings = [ "racecar", "radar", "able was I ere I saw elba" ])
+  void palindromes(String candidate) {
+    assert isPalindrome(candidate)
+  }
+
+  @TestFactory
+  def dynamicTestCollection() {[
+    dynamicTest("Add test") { -> assert 1 + 1 == 2 },
+    dynamicTest("Multiply Test", () -> { assert 2 * 3 == 6 })
+  ]}
+}

Commit:
bf21d102762d94035055e177bf82b4bfa17058b4
Paul King
paulk@asert.com.au
2018-05-26 19:56:25 +1000
GROOVY-8592: changes for groovysh and tidy up (closes #727)
diff --git a/build.gradle b/build.gradle
index 107036ebe3..b1f95ee98f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -181,7 +181,6 @@ dependencies {
     compile "org.ow2.asm:asm-tree:$asmVersion"
     compile "org.ow2.asm:asm-util:$asmVersion"
 
-    compile "commons-cli:commons-cli:$commonsCliVersion"
     compile "info.picocli:picocli:$picocliVersion"
     compile "org.apache.ant:ant:$antVersion"
     compile("com.thoughtworks.xstream:xstream:$xstreamVersion") {
diff --git a/gradle/assemble.gradle b/gradle/assemble.gradle
index bd67e480d0..2f83048f34 100644
--- a/gradle/assemble.gradle
+++ b/gradle/assemble.gradle
@@ -198,8 +198,7 @@ allprojects {
                         if (component instanceof ModuleComponentIdentifier) {
                             return component.module in [
                                     'antlr', 'antlr-runtime', 'antlr4', 'antlr4-runtime', 'antlr4-annotations',
-                                    'asm', 'asm-commons', 'asm-tree', 'asm-util',
-                                    'commons-cli', 'picocli']
+                                    'asm', 'asm-commons', 'asm-tree', 'asm-util', 'picocli']
                         }
                         return false
                     }
@@ -209,12 +208,6 @@ allprojects {
             }
             jarjarToolClasspath = rootProject.configurations.tools
             untouchedFiles = [
-                    'org/codehaus/groovy/cli/GroovyPosixParser*.class',
-                    'groovy/util/CliBuilder*.class',
-                    'groovy/util/OptionAccessor*.class',
-                    'org/codehaus/groovy/tools/shell/util/HelpFormatter*.class',
-                    'groovy/cli/commons/CliBuilder*.class',
-                    'groovy/cli/commons/OptionAccessor*.class',
                     'groovy/cli/picocli/CliBuilder*.class',
                     'groovy/cli/picocli/OptionAccessor*.class'
             ]
@@ -222,8 +215,7 @@ allprojects {
                     'antlr.**'                 : 'groovyjarjarantlr.@1', // antlr2
                     'org.antlr.**'             : 'groovyjarjarantlr4.@1', // antlr4
                     'org.objectweb.**'         : 'groovyjarjarasm.@1',
-                    'org.apache.commons.cli.**': 'groovyjarjarcommonscli.@1',
-                    'picocli.**': 'groovyjarjarpicocli.@1'
+                    'picocli.**'               : 'groovyjarjarpicocli.@1'
             ]
             excludesPerLibrary = [
                     '*': ['META-INF/maven/**', 'META-INF/*', 'META-INF/services/javax.annotation.processing.Processor', 'module-info.class']
diff --git a/gradle/docs.gradle b/gradle/docs.gradle
index 7b64132cbd..0809388c41 100644
--- a/gradle/docs.gradle
+++ b/gradle/docs.gradle
@@ -59,8 +59,11 @@ def groovydocBaseSpec = {
     link 'http://docs.oracle.com/javase/8/docs/api/', 'java.', 'org.xml.', 'javax.', 'org.w3c.'
     link 'http://docs.groovy-lang.org/docs/ant/api/', 'org.apache.ant.', 'org.apache.tools.ant.'
     link 'http://junit.org/junit4/javadoc/latest/', 'org.junit.', 'junit.'
+    link 'http://junit.org/junit5/docs/current/api/', 'org.junit.jupiter.', 'org.junit.platform.'
     link 'http://www.antlr2.org/javadoc/', 'antlr.'
+    link 'http://www.antlr.org/api/Java/', 'org.antlr.v4.'
     link 'http://commons.apache.org/proper/commons-cli/javadocs/api-release/', 'org.apache.commons.cli.'
+    link 'http://picocli.info/apidocs/', 'picocli.'
 }
 
 def groovydocSpec = groovydocBaseSpec >> {
diff --git a/src/main/java/org/codehaus/groovy/cli/GroovyPosixParser.java b/src/main/java/org/codehaus/groovy/cli/GroovyPosixParser.java
deleted file mode 100644
index 4168fa6809..0000000000
--- a/src/main/java/org/codehaus/groovy/cli/GroovyPosixParser.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.cli;
-
-import org.apache.commons.cli.Option;
-import org.apache.commons.cli.Options;
-import org.apache.commons.cli.Parser;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * This is a hacked version of Commons CLI 1.2 PosixParser with some bug fixes added.
- * We aren't aware of any use cases where it isn't now preferable to use the
- * Commons CLI 1.3 DefaultParser but this class is retained for the time being for
- * backwards compatibility if someone is relying on this class's exact functionality.
- *
- * @author John Keyes (john at integralsource.com)
- * @author Paul King (Groovy hacks/fixes)
- * @deprecated use the DefaultParser from Commons CLI
- */
-@Deprecated
-public class GroovyPosixParser extends Parser
-{
-    /** holder for flattened tokens */
-    private List tokens = new ArrayList();
-
-    /** specifies if bursting should continue */
-    private boolean eatTheRest;
-
-    /** holder for the current option */
-    private Option currentOption;
-
-    /** the command line Options */
-    private Options options;
-
-    /**
-     * Resets the members to their original state i.e. remove
-     * all of <code>tokens</code> entries and set <code>eatTheRest</code>
-     * to false.
-     */
-    private void init()
-    {
-        eatTheRest = false;
-        tokens.clear();
-    }
-
-    /**
-     * An implementation of {@link Parser}'s abstract
-     * {@link Parser#flatten(Options,String[],boolean) flatten} method.
-     * <p>
-     * The following are the rules used by this flatten method.
-     * <ol>
-     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
-     *  burst anymore of <code>arguments</code> entries, just add each
-     *  successive entry without further processing.  Otherwise, ignore
-     *  <code>stopAtNonOption</code>.</li>
-     *  <li>if the current <code>arguments</code> entry is "<b>--</b>"
-     *  just add the entry to the list of processed tokens</li>
-     *  <li>if the current <code>arguments</code> entry is "<b>-</b>"
-     *  just add the entry to the list of processed tokens</li>
-     *  <li>if the current <code>arguments</code> entry is two characters
-     *  in length and the first character is "<b>-</b>" then check if this
-     *  is a valid {@link Option} id.  If it is a valid id, then add the
-     *  entry to the list of processed tokens and set the current {@link Option}
-     *  member.  If it is not a valid id and <code>stopAtNonOption</code>
-     *  is true, then the remaining entries are copied to the list of
-     *  processed tokens.  Otherwise, the current entry is ignored.</li>
-     *  <li>if the current <code>arguments</code> entry is more than two
-     *  characters in length and the first character is "<b>-</b>" then
-     *  we need to burst the entry to determine its constituents.  For more
-     *  information on the bursting algorithm see
-     *  {@link GroovyPosixParser#burstToken(String, boolean) burstToken}.</li>
-     *  <li>if the current <code>arguments</code> entry is not handled
-     *  by any of the previous rules, then the entry is added to the list
-     *  of processed tokens.</li>
-     * </ol>
-     *
-     * @param options The command line {@link Options}
-     * @param arguments The command line arguments to be parsed
-     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.
-     * @return The flattened <code>arguments</code> String array.
-     */
-    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
-        init();
-        this.options = options;
-
-        // an iterator for the command line tokens
-        Iterator iter = Arrays.asList(arguments).iterator();
-
-        // process each command line token
-        while (iter.hasNext())
-        {
-            // get the next command line token
-            String token = (String) iter.next();
-
-            // handle long option --foo or --foo=bar
-            if (token.startsWith("--"))
-            {
-                int pos = token.indexOf('=');
-                String opt = pos == -1 ? token : token.substring(0, pos); // --foo
-
-                if (!options.hasOption(opt))
-                {
-                    processNonOptionToken(token, stopAtNonOption);
-                }
-                else
-                {
-                    tokens.add(opt);
-                    if (pos != -1)
-                    {
-                        tokens.add(token.substring(pos + 1));
-                    } else {
-                        currentOption = options.getOption(opt);
-                    }
-                }
-            }
-
-            // single hyphen
-            else if ("-".equals(token))
-            {
-                tokens.add(token);
-            }
-            else if (token.startsWith("-"))
-            {
-                if (token.length() == 2 || options.hasOption(token))
-                {
-                    processOptionToken(token, stopAtNonOption);
-                }
-                // requires bursting
-                else
-                {
-                    burstToken(token, stopAtNonOption);
-                }
-            }
-            else
-            {
-                processNonOptionToken(token, stopAtNonOption);
-            }
-
-            gobble(iter);
-        }
-
-        return (String[]) tokens.toArray(new String[0]);
-    }
-
-    /**
-     * Adds the remaining tokens to the processed tokens list.
-     *
-     * @param iter An iterator over the remaining tokens
-     */
-    private void gobble(Iterator iter)
-    {
-        if (eatTheRest)
-        {
-            while (iter.hasNext())
-            {
-                tokens.add(iter.next());
-            }
-        }
-    }
-
-    /**
-     * Add the special token "<b>--</b>" and the current <code>value</code>
-     * to the processed tokens list. Then add all the remaining
-     * <code>argument</code> values to the processed tokens list.
-     *
-     * @param value The current token
-     */
-    private void processNonOptionToken(String value, boolean stopAtNonOption)
-    {
-        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))
-        {
-            eatTheRest = true;
-            tokens.add("--");
-        }
-
-        tokens.add(value);
-        currentOption = null;
-    }
-
-    /**
-     * If an {@link Option} exists for <code>token</code> then
-     * add the token to the processed list.
-     * <p>
-     * If an {@link Option} does not exist and <code>stopAtNonOption</code>
-     * is set then add the remaining tokens to the processed tokens list
-     * directly.
-     *
-     * @param token The current option token
-     * @param stopAtNonOption Specifies whether flattening should halt at the first non option.
-     */
-    private void processOptionToken(String token, boolean stopAtNonOption) {
-        if (stopAtNonOption && !options.hasOption(token))
-        {
-            eatTheRest = true;
-        }
-
-        if (options.hasOption(token)) {
-            currentOption = options.getOption(token);
-        } else {
-            currentOption = null;
-        }
-
-        tokens.add(token);
-    }
-
-    /**
-     * Breaks <code>token</code> into its constituent parts
-     * using the following algorithm.
-     *
-     * <ul>
-     *  <li>ignore the first character ("<b>-</b>")</li>
-     *  <li>foreach remaining character check if an {@link Option}
-     *  exists with that id.</li>
-     *  <li>if an {@link Option} does exist then add that character
-     *  prepended with "<b>-</b>" to the list of processed tokens.</li>
-     *  <li>if the {@link Option} can have an argument value and there
-     *  are remaining characters in the token then add the remaining
-     *  characters as a token to the list of processed tokens.</li>
-     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
-     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token
-     *  "<b>--</b>" followed by the remaining characters and also
-     *  the remaining tokens directly to the processed tokens list.</li>
-     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
-     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that
-     *  character prepended with "<b>-</b>".</li>
-     * </ul>
-     *
-     * @param token The current token to be <b>burst</b>
-     * @param stopAtNonOption Specifies whether to stop processing
-     * at the first non-Option encountered.
-     */
-    protected void burstToken(String token, boolean stopAtNonOption)
-    {
-        for (int i = 1; i < token.length(); i++)
-        {
-            String ch = String.valueOf(token.charAt(i));
-
-            if (options.hasOption(ch))
-            {
-                tokens.add("-" + ch);
-                currentOption = options.getOption(ch);
-
-                if (currentOption.hasArg() && (token.length() != (i + 1)))
-                {
-                    tokens.add(token.substring(i + 1));
-                    break;
-                }
-            }
-            else if (stopAtNonOption)
-            {
-                processNonOptionToken(token.substring(i), true);
-                break;
-            }
-            else
-            {
-                tokens.add(token);
-                break;
-            }
-        }
-    }
-}
diff --git a/src/test/org/codehaus/groovy/classgen/JO.java b/src/test/org/codehaus/groovy/classgen/JO.java
index ae5414c39d..206c9262b3 100644
--- a/src/test/org/codehaus/groovy/classgen/JO.java
+++ b/src/test/org/codehaus/groovy/classgen/JO.java
@@ -38,7 +38,6 @@ public class JO {
 
     public static void main(String[] args) throws Exception {
         ASMifier.main(new String[]{"target/classes/groovy/swing/SwingBuilder.class"});
-//        ASMifierClassVisitor.main(new String[]{"target/classes/org/codehaus/groovy/tools/shell/util/HelpFormatter.class"});
 //        ASMifierClassVisitor.main(new String[]{"target/classes/org/codehaus/groovy/runtime/callsite/PogoMetaMethodSite.class"});
 //        ASMifierClassVisitor.main(new String[]{"target/test-classes/spectralnorm.class"});
 //        ASMifierClassVisitor.main(new String[]{"target/test-classes/groovy/bugs/CustomMetaClassTest.class"});
diff --git a/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy b/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
index e9ff5a0b4b..fd8928a191 100644
--- a/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
@@ -25,7 +25,6 @@ import groovy.transform.TypeChecked
 import org.apache.commons.cli.BasicParser
 import org.apache.commons.cli.DefaultParser
 import org.apache.commons.cli.GnuParser
-import org.codehaus.groovy.cli.GroovyPosixParser
 
 import java.math.RoundingMode
 
@@ -100,19 +99,19 @@ class CliBuilderTest extends GroovyTestCase {
     }
 
     void testSampleShort() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser(), new BasicParser()].each { parser ->
+        [new DefaultParser(), new GnuParser(), new BasicParser()].each { parser ->
             runSample(parser, ['-h', '-c', expectedParameter])
         }
     }
 
     void testSampleLong() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser(), new BasicParser()].each { parser ->
+        [new DefaultParser(), new GnuParser(), new BasicParser()].each { parser ->
             runSample(parser, ['--help', '--encoding', expectedParameter])
         }
     }
 
     void testSimpleArg() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser(), new BasicParser()].each { parser ->
+        [new DefaultParser(), new GnuParser(), new BasicParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             cli.a([:], '')
             def options = cli.parse(['-a', '1', '2'])
@@ -121,7 +120,7 @@ class CliBuilderTest extends GroovyTestCase {
     }
 
     void testMultipleArgs() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser(), new BasicParser()].each { parser ->
+        [new DefaultParser(), new GnuParser(), new BasicParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             cli.a(longOpt: 'arg', args: 2, valueSeparator: ',' as char, 'arguments')
             def options = cli.parse(['-a', '1,2'])
@@ -144,7 +143,7 @@ usage: groovy
     }
 
     void testLongOptsOnly_nonOptionShouldStopArgProcessing() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser()].each { parser ->
+        [new DefaultParser(), new GnuParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             def anOption = builder().longOpt('anOption').hasArg().desc('An option.')
                     .build()
@@ -160,7 +159,7 @@ usage: groovy
     }
 
     void testLongAndShortOpts_allOptionsValid() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser(), new BasicParser()].each { parser ->
+        [new DefaultParser(), new GnuParser(), new BasicParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             def anOption = builder().longOpt('anOption').hasArg().desc('An option.').build()
             cli.options.addOption(anOption)
@@ -174,7 +173,7 @@ usage: groovy
     }
 
     void testUnrecognizedOptions() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser(), new BasicParser()].each { parser ->
+        [new DefaultParser(), new GnuParser(), new BasicParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             cli.v(longOpt: 'verbose', 'verbose mode')
             def options = cli.parse(['-x', '-yyy', '--zzz', 'something'])
@@ -183,7 +182,7 @@ usage: groovy
     }
 
     void testMultipleOccurrencesSeparateSeparate() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser(), new BasicParser()].each { parser ->
+        [new DefaultParser(), new GnuParser(), new BasicParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             cli.a(longOpt: 'arg', args: UNLIMITED_VALUES, 'arguments')
             def options = cli.parse(['-a', '1', '-a', '2', '-a', '3'])
@@ -196,7 +195,7 @@ usage: groovy
     }
 
     void testMultipleOccurrencesSeparateJuxtaposed() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser()].each { parser ->
+        [new DefaultParser(), new GnuParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             //cli.a ( longOpt : 'arg' , args : UNLIMITED_VALUES , 'arguments' )
             cli.a(longOpt: 'arg', args: 1, 'arguments')
@@ -210,7 +209,7 @@ usage: groovy
     }
 
     void testMultipleOccurrencesTogetherSeparate() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser()].each { parser ->
+        [new DefaultParser(), new GnuParser()].each { parser ->
             def cli = new CliBuilder(parser: parser)
             cli.a(longOpt: 'arg', args: UNLIMITED_VALUES, valueSeparator: ',' as char, 'arguments')
             def options = cli.parse(['-a 1,2,3'])
@@ -223,7 +222,7 @@ usage: groovy
     }
 
     void testMultipleOccurrencesTogetherJuxtaposed() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser()].each { parser ->
+        [new DefaultParser(), new GnuParser()].each { parser ->
             def cli1 = new CliBuilder(parser: parser)
             cli1.a(longOpt: 'arg', args: UNLIMITED_VALUES, valueSeparator: ',' as char, 'arguments')
             def options = cli1.parse(['-a1,2,3'])
@@ -279,7 +278,7 @@ usage: groovy
     }
 
     void testMultiCharShortOpt() {
-        [new DefaultParser(), new GroovyPosixParser(), new GnuParser()].each { parser ->
+        [new DefaultParser(), new GnuParser()].each { parser ->
             def cli = new CliBuilder(writer: printWriter, parser: parser)
             cli.abc('abc option')
             cli.def(longOpt: 'defdef', 'def option')
diff --git a/subprojects/groovy-groovysh/build.gradle b/subprojects/groovy-groovysh/build.gradle
index e234781560..6e5e1a0e95 100644
--- a/subprojects/groovy-groovysh/build.gradle
+++ b/subprojects/groovy-groovysh/build.gradle
@@ -18,7 +18,7 @@
  */
 dependencies {
     compile rootProject
-    compile project(':groovy-cli-commons')
+    compile project(':groovy-cli-picocli')
     compile project(':groovy-console')
     testCompile project(':groovy-test')
     compile("jline:jline:$jlineVersion") {
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
index 1b7a9a5c8d..462dd35819 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
@@ -18,14 +18,13 @@
  */
 package org.codehaus.groovy.tools.shell
 
-import groovy.cli.commons.CliBuilder
-import groovy.cli.commons.OptionAccessor
+import groovy.cli.picocli.CliBuilder
+import groovy.cli.picocli.OptionAccessor
 import jline.TerminalFactory
 import jline.UnixTerminal
 import jline.UnsupportedTerminal
 import jline.WindowsTerminal
 import org.codehaus.groovy.control.CompilerConfiguration
-import org.codehaus.groovy.tools.shell.util.HelpFormatter
 import org.codehaus.groovy.tools.shell.util.Logger
 import org.codehaus.groovy.tools.shell.util.MessageSource
 import org.codehaus.groovy.tools.shell.util.NoExitSecurityManager
@@ -76,11 +75,10 @@ class Main {
      */
     static void main(final String[] args) {
         MessageSource messages = new MessageSource(Main)
-        CliBuilder cli = new CliBuilder(usage: 'groovysh [options] [...]', formatter: new HelpFormatter(), stopAtNonOption: false,
+        CliBuilder cli = new CliBuilder(usage: 'groovysh [options] [...]', stopAtNonOption: false,
                 header: messages['cli.option.header'])
         cli.with {
-            classpath(messages['cli.option.classpath.description'])
-            cp(longOpt: 'classpath', messages['cli.option.cp.description'])
+            _(names: ['-cp', '-classpath', '--classpath'], messages['cli.option.classpath.description'])
             h(longOpt: 'help', messages['cli.option.help.description'])
             V(longOpt: 'version', messages['cli.option.version.description'])
             v(longOpt: 'verbose', messages['cli.option.verbose.description'])
@@ -88,7 +86,7 @@ class Main {
             d(longOpt: 'debug', messages['cli.option.debug.description'])
             e(longOpt: 'evaluate', args: 1, argName: 'CODE', optionalArg: false, messages['cli.option.evaluate.description'])
             C(longOpt: 'color', args: 1, argName: 'FLAG', optionalArg: true, messages['cli.option.color.description'])
-            D(longOpt: 'define', args: 2, argName: 'name=value', valueSeparator: '=', messages['cli.option.define.description'])
+            D(longOpt: 'define', type: Map, argName: 'name=value', messages['cli.option.define.description'])
             T(longOpt: 'terminal', args: 1, argName: 'TYPE', messages['cli.option.terminal.description'])
             pa(longOpt: 'parameters', messages['cli.option.parameters.description'])
         }
@@ -134,9 +132,7 @@ class Main {
         IO io = new IO()
 
         if (options.hasOption('D')) {
-            options.getOptionProperties('D')?.each { k, v ->
-                System.setProperty(k, v)
-            }
+            options.Ds.each { k, v -> System.setProperty(k, v) }
         }
 
         if (options.v) {
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/HelpFormatter.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/HelpFormatter.groovy
deleted file mode 100644
index d4e14b9795..0000000000
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/HelpFormatter.groovy
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.tools.shell.util
-
-import jline.Terminal
-import org.apache.commons.cli.Option
-import org.apache.commons.cli.Options
-
-//
-// NOTE: Some code duplicated and augmented from commons-cli (1.0) sources to
-//       properly render options w/arguments.
-//
-
-
-/**
- * Custom CLI help formatter to render things correctly.
- *
- * @author <a href="mailto:jason@planet57.com">Jason Dillon</a>
- */
-class HelpFormatter
-    extends org.apache.commons.cli.HelpFormatter
-{
-    HelpFormatter() {
-        leftPadding = 2
-        descPadding = 4
-    }
-
-    // Detect the terminal width late
-    int getDefaultWidth() {
-        return Terminal.terminal.terminalWidth - 1
-    }
-
-    @Override
-    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {
-        assert sb != null
-        assert options
-
-        List<StringBuffer> prefixes = []
-        String lpad = ' ' * leftPad
-
-        List<Option> opts = options.shortOpts.values().sort {Option a, Option b ->
-            return (a.opt == ' ' ? a.longOpt : a.opt) <=> (b.opt == ' ' ? b.longOpt : b.opt)
-        }
-
-        // Render the prefixes (-X,--xxxx muck)
-        opts.each {Option option ->
-            StringBuffer buff = new StringBuffer(8)
-
-            if (option.opt == ' ') {
-                buff << "${lpad}    ${longOptPrefix}${option.longOpt}"
-            }
-            else {
-                buff << "${lpad}${optPrefix}${option.opt}"
-
-                if (option.hasLongOpt()) {
-                    buff << ", ${longOptPrefix}${option.longOpt}"
-                }
-            }
-
-            if (option.hasArg()) {
-                if (option.hasArgName()) {
-                    if (option.hasOptionalArg()) {
-                        buff << "[=${option.argName}]"
-                    }
-                    else {
-                        buff << "=${option.argName}"
-                    }
-                }
-                else {
-                    buff << ' '
-                }
-            }
-
-            prefixes << buff
-        }
-
-        // Figure out how long the biggest prefix is
-        int maxPrefix = prefixes.max {StringBuffer a, StringBuffer b -> a.size() <=> b.size() }.size()
-
-        String dpad = ' ' * descPad
-
-        // And then render each option's prefix with its description
-        opts.eachWithIndex {Option option, int i ->
-            def buff = new StringBuffer(prefixes[i].toString())
-
-            if (buff.size() < maxPrefix) {
-                buff << ' ' * (maxPrefix - buff.size())
-            }
-            buff << dpad
-
-            int nextLineTabStop = maxPrefix + descPad
-            String text = buff << option.description
-
-            renderWrappedText(sb, width, nextLineTabStop, text)
-
-            if (i < opts.size() - 1) {
-                sb << newLine
-            }
-        }
-
-        return sb
-    }
-}

Commit:
ea462f1e97fa9a607b3e659e89c89f447d24664c
sunlan
sunlan@apache.org
2018-05-26 14:56:28 +0800
Minor refactoring: use another extracting placeholder logic(closes #726)
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GeneralUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GeneralUtils.java
index b45952e1d2..c0082bf75e 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GeneralUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GeneralUtils.java
@@ -24,6 +24,7 @@ import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.PackageNode;
 import org.codehaus.groovy.ast.Parameter;
@@ -68,6 +69,7 @@ import org.codehaus.groovy.transform.AbstractASTTransformation;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -876,4 +878,54 @@ public class GeneralUtils {
         return ((firstPackage == null && secondPackage == null) ||
                         firstPackage != null && secondPackage != null && firstPackage.getName().equals(secondPackage.getName()));
     }
+
+    /**
+     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
+     * declaring generics types:      T,      S extends Serializable
+     * actual generics types   : String,      Long
+     *
+     * the result map is [
+     *  T: String,
+     *  S: Long
+     * ]
+     *
+     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
+     * so we need actual types:  T: String, S: Long
+     */
+    public static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
+        ClassNode parameterizedType = GenericsUtils.findParameterizedTypeFromCache(declaringClass, actualReceiver);
+
+        if (null == parameterizedType) {
+            return Collections.emptyMap();
+        }
+
+        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
+        GenericsType[] actualGenericsTypes = parameterizedType.getGenericsTypes();
+
+        Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
+        for (int i = 0, n = declaringGenericsTypes.length; i < n; i++) {
+            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
+        }
+
+        return result;
+    }
+
+    /**
+     * Get the actual type according to the placeholder name
+     *
+     * @param placeholderName the placeholder name, e.g. T, E
+     * @param genericsPlaceholderAndTypeMap the result of {@link #makeDeclaringAndActualGenericsTypeMap(ClassNode, ClassNode}
+     * @return the actual type
+     */
+    public static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
+        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
+            GenericsType declaringGenericsType = entry.getKey();
+
+            if (placeholderName.equals(declaringGenericsType.getName())) {
+                return entry.getValue().getType().redirect();
+            }
+        }
+
+        return null;
+    }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 6a5245bb2a..c5ee2fe28d 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -36,6 +36,7 @@ import org.codehaus.groovy.ast.expr.ListExpression;
 import org.codehaus.groovy.ast.expr.MapExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
+import org.codehaus.groovy.ast.tools.GeneralUtils;
 import org.codehaus.groovy.ast.tools.GenericsUtils;
 import org.codehaus.groovy.ast.tools.ParameterUtils;
 import org.codehaus.groovy.ast.tools.WideningCategories;
@@ -62,7 +63,6 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -1100,7 +1100,7 @@ public abstract class StaticTypeCheckingSupport {
                 Person p = foo(b)
              */
 
-            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
+            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = GeneralUtils.makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
             Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringAndActualGenericsTypeMap);
             int dist = measureParametersAndArgumentsDistance(params, safeArgs);
             if (dist >= 0) {
@@ -1191,62 +1191,13 @@ public abstract class StaticTypeCheckingSupport {
         return isExtensionMethodNode ? 0 : 1;
     }
 
-    private static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
-        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
-            GenericsType declaringGenericsType = entry.getKey();
-
-            if (placeholderName.equals(declaringGenericsType.getName())) {
-                return entry.getValue().getType();
-            }
-        }
-
-        return null;
-    }
-
-    public static ClassNode findActualTypeByPlaceholderName(String placeholderName, Map<String, GenericsType> placeholderInfo) {
-        GenericsType gt = placeholderInfo.get(placeholderName);
-
-        return null == gt ? null : gt.getType().redirect();
-    }
-
-    /**
-     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
-     * declaring generics types:      T,      S extends Serializable
-     * actual generics types   : String,      Long
-     *
-     * the result map is [
-     *  T: String,
-     *  S: Long
-     * ]
-     *
-     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
-     * so we need actual types:  T: String, S: Long
-     */
-    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
-        ClassNode parameterizedType = GenericsUtils.findParameterizedType(declaringClass, actualReceiver);
-
-        if (null == parameterizedType) {
-            return Collections.emptyMap();
-        }
-
-        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
-        GenericsType[] actualGenericsTypes = parameterizedType.getGenericsTypes();
-
-        Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
-        for (int i = 0, n = declaringGenericsTypes.length; i < n; i++) {
-            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
-        }
-
-        return result;
-    }
-
     private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
 
         Parameter[] newParam = new Parameter[params.length];
         for (int i = 0; i < params.length; i++) {
             Parameter oldP = params[i];
 
-            ClassNode actualType = findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
+            ClassNode actualType = GeneralUtils.findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
             Parameter newP = new Parameter(makeRawType(null == actualType ? oldP.getType() : actualType), oldP.getName());
             newParam[i] = newP;
         }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 96faeb9ca9..6300deb380 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -169,6 +169,8 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.binX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.castX;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.findActualTypeByGenericsPlaceholderName;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.makeDeclaringAndActualGenericsTypeMap;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.toGenericTypesString;
 import static org.codehaus.groovy.ast.tools.WideningCategories.LowestUpperBoundClassNode;
@@ -221,7 +223,6 @@ import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.choose
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.evaluateExpression;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsParameterMapOfThis;
-import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findActualTypeByPlaceholderName;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findSetters;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findTargetVariable;
@@ -623,15 +624,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
 
-            ClassNode parameterizedType = GenericsUtils.findParameterizedTypeFromCache(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
-            if (null != parameterizedType) {
-                ClassNode originalType = fieldNode.getOriginType();
-                ClassNode actualType = findActualTypeByPlaceholderName(originalType.getUnresolvedName(), GenericsUtils.extractPlaceholders(parameterizedType));
+            ClassNode actualType =
+                    findActualTypeByGenericsPlaceholderName(
+                        fieldNode.getOriginType().getUnresolvedName(),
+                        makeDeclaringAndActualGenericsTypeMap(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode())
+                    );
 
-                if (null != actualType) {
-                    storeType(vexp, actualType);
-                    return;
-                }
+            if (null != actualType) {
+                storeType(vexp, actualType);
+                return;
             }
         }
 
diff --git a/src/test/groovy/bugs/Groovy7204Bug.groovy b/src/test/groovy/bugs/Groovy7204Bug.groovy
index 09375ac772..b297112183 100644
--- a/src/test/groovy/bugs/Groovy7204Bug.groovy
+++ b/src/test/groovy/bugs/Groovy7204Bug.groovy
@@ -1,22 +1,3 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one
  *  or more contributor license agreements.  See the NOTICE file
@@ -543,4 +524,54 @@ class Groovy7204Bug extends GroovyTestCase {
         test()
         '''
     }
+
+    void testCompileStatic7() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class Trie<T> {}
+        
+        @groovy.transform.CompileStatic
+        class Base<T> {
+            protected List<Trie<T>> list
+            
+            Base() {
+                list = new ArrayList<Trie<T>>()
+                list.add(new Trie<String>())
+            }
+        }
+        
+        @groovy.transform.CompileStatic
+        class Derived extends Base<String> {
+            Trie<String> getFirstElement() {
+                list.get(0)
+            }
+        }
+        
+        assert new Derived().getFirstElement() instanceof Trie
+        '''
+    }
+
+    void testCompileStatic8() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class Trie<T> {}
+        
+        @groovy.transform.CompileStatic
+        class Base<T> extends ArrayList<Trie<T>> {
+            
+            Base() {
+                this.add(new Trie<String>())
+            }
+        }
+        
+        @groovy.transform.CompileStatic
+        class Derived extends Base<String> {
+            Trie<String> getFirstElement() {
+                this.get(0)
+            }
+        }
+        
+        assert new Derived().getFirstElement() instanceof Trie
+        '''
+    }
 }

Commit:
3460faf0f3354a924d78fe885bf8dd429ace01e3
Paul King
paulk@asert.com.au
2018-05-26 15:07:56 +1000
GROOVY-8607: CliBuilder should ignore 'opt' property if provided within a Map of arguments (closes #725)
diff --git a/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
index 237b631c27..88c64aeb44 100644
--- a/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
+++ b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
@@ -605,7 +605,9 @@ class CliBuilder {
             option = new CliOption(shortname, info)
         }
         adjustDetails(details).each { key, value ->
-            option[key] = value
+            if (key != 'opt') { // GROOVY-8607 ignore opt since we already have that
+                option[key] = value
+            }
         }
         return option
     }
diff --git a/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy b/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
index f5dd3e8ec6..e9ff5a0b4b 100644
--- a/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
@@ -652,6 +652,16 @@ usage: groovy
         @Unparsed List remaining()
     }
 
+    // GROOVY-8607
+    void testOptIgnoredWhenSupplyingMapOfArgs() {
+        def builder = new CliBuilder()
+        def helpOpt = [opt:'h', longOpt: 'help']
+        builder."$helpOpt.opt"(helpOpt, 'help option').with {
+            assert opt == 'h'
+            assert longOpt == 'help'
+        }
+    }
+
     void testParseFromInstanceFlagEdgeCases() {
         def cli = new CliBuilder()
         def options = cli.parseFromSpec(FlagEdgeCasesI, '-abc -efg true --ijk foo --lmn bar baz'.split())
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
index d18a8bd22d..b4c9d9c05b 100644
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
@@ -910,7 +910,7 @@ class CliBuilder {
         commons2picocli(shortname, details).each { key, value ->
             if (builder.hasProperty(key)) {
                 builder[key] = value
-            } else {
+            } else if (key != 'opt') {    // GROOVY-8607 ignore opt since we already have that
                 builder.invokeMethod(key, value)
             }
         }
diff --git a/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy b/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
index be8b5f9310..a39944e5ba 100644
--- a/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
@@ -73,23 +73,23 @@ class CliBuilderTest extends GroovyTestCase {
   -h, --help                 usage information
   -i= [<extension>]          modify files in place, create backup if extension is
                                specified (e.g. '.bak')"""
-        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+        assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
         resetPrintWriter()
         cli.writer = printWriter
         if (options.help) { cli.usage() }
-        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+        assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
         assert options.hasOption('c')
         assert options.c
         assert options.hasOption('encoding')
         assert options.encoding
-        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.getOptionValue('c'))
-        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.c)
-        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.getOptionValue('encoding'))
-        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.encoding)
-        groovy.util.GroovyTestCase.assertEquals(false, options.noSuchOptionGiven)
-        junit.framework.TestCase.assertEquals(false, options.hasOption('noSuchOptionGiven'))
-        groovy.util.GroovyTestCase.assertEquals(false, options.x)
-        junit.framework.TestCase.assertEquals(false, options.hasOption('x'))
+        assertEquals(expectedParameter, options.getOptionValue('c'))
+        assertEquals(expectedParameter, options.c)
+        assertEquals(expectedParameter, options.getOptionValue('encoding'))
+        assertEquals(expectedParameter, options.encoding)
+        assertEquals(false, options.noSuchOptionGiven)
+        assertEquals(false, options.hasOption('noSuchOptionGiven'))
+        assertEquals(false, options.x)
+        assertEquals(false, options.hasOption('x'))
     }
 
     private void resetPrintWriter() {
@@ -109,17 +109,17 @@ class CliBuilderTest extends GroovyTestCase {
         def cli = new CliBuilder()
         cli.a([:], '')
         def options = cli.parse(['-a', '1', '2'])
-        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.arguments())
+        assertEquals(['1', '2'], options.arguments())
     }
 
     void testMultipleArgs() {
         def cli = new CliBuilder()
         cli.a(longOpt: 'arg', args: 2, valueSeparator: ',' as char, 'arguments')
         def options = cli.parse(['-a', '1,2'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.as)
-        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.args)
+        assertEquals('1', options.a)
+        assertEquals(['1', '2'], options.as)
+        assertEquals('1', options.arg)
+        assertEquals(['1', '2'], options.args)
     }
 
     void testPosixNullValueHandledCorrectly_inConstructor() {
@@ -195,18 +195,18 @@ class CliBuilderTest extends GroovyTestCase {
         def cli = new CliBuilder()
         cli.v(longOpt: 'verbose', 'verbose mode')
         def options = cli.parse(['-x', '-yyy', '--zzz', 'something'])
-        groovy.util.GroovyTestCase.assertEquals(['-x', '-yyy', '--zzz', 'something'], options.arguments())
+        assertEquals(['-x', '-yyy', '--zzz', 'something'], options.arguments())
     }
 
     void testMultipleOccurrencesSeparateSeparate() {
         def cli = new CliBuilder()
         cli.a(longOpt: 'arg', args: COMMONS_CLI_UNLIMITED_VALUES, 'arguments')
         def options = cli.parse(['-a', '1', '-a', '2', '-a', '3'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
-        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.args)
-        groovy.util.GroovyTestCase.assertEquals([], options.arguments())
+        assertEquals('1', options.a)
+        assertEquals(['1', '2', '3'], options.as)
+        assertEquals('1', options.arg)
+        assertEquals(['1', '2', '3'], options.args)
+        assertEquals([], options.arguments())
     }
 
     void testMandatoryParametersDoNotConsumeOtherOptions() {
@@ -216,10 +216,10 @@ class CliBuilderTest extends GroovyTestCase {
         cli.c(args: '+', valueSeparator: ',', 'arguments')
 
         def options = cli.parse(['-a', '1', '-a', '2'])
-        junit.framework.TestCase.assertNull(options)
+        assertNull(options)
 
         options = cli.parse(['-a', '1', '-a', '2', '-a', '3'])
-        junit.framework.TestCase.assertNull(options)
+        assertNull(options)
     }
 
     void testMultipleOccurrencesSeparateSeparate3() {
@@ -230,49 +230,49 @@ class CliBuilderTest extends GroovyTestCase {
         cli.c(args: '+', valueSeparator: ',', 'arguments')
 
         def options = cli.parse(['-a', '1'])
-        junit.framework.TestCase.assertNull(options)
+        assertNull(options)
 
         options = cli.parse(['-a1'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1'], options.as)
+        assertEquals('1', options.a)
+        assertEquals(['1'], options.as)
 
 //        options = cli.parse(['-a', '1', '-a', '2']) // TODO
 //        assertNull(options)
 
         options = cli.parse(['-a1', '-a2'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.as)
+        assertEquals('1', options.a)
+        assertEquals(['1', '2'], options.as)
 
         options = cli.parse(['-a1', '-a2', '-a3'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
+        assertEquals('1', options.a)
+        assertEquals(['1', '2', '3'], options.as)
 
 //        options = cli.parse(['-a', '1', '-a', '2', '-a', '3'])
 //        assertNull(options)
 
         options = cli.parse(['-a', '1', '2'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.as)
+        assertEquals('1', options.a)
+        assertEquals(['1', '2'], options.as)
 
         options = cli.parse(['-a1', '2'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        assertEquals('1', options.a)
         assert options.arguments() == ['2']
-        groovy.util.GroovyTestCase.assertEquals(['1'], options.as)
+        assertEquals(['1'], options.as)
 
         options = cli.parse(['-a', '1', '2', '-a', '3', '4'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3', '4'], options.as)
+        assertEquals('1', options.a)
+        assertEquals(['1', '2', '3', '4'], options.as)
 
         options = cli.parse(['-a', '1', '2', '-a3', '-a4', '-a5'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3', '4', '5'], options.as)
+        assertEquals('1', options.a)
+        assertEquals(['1', '2', '3', '4', '5'], options.as)
 
         options = cli.parse(['-a', '1', '2', '-a3', '-a', '4', '5' ])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3', '4', '5'], options.as)
+        assertEquals('1', options.a)
+        assertEquals(['1', '2', '3', '4', '5'], options.as)
 
         options = cli.parse(['-a1', '2', '-a3', '4'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        assertEquals('1', options.a)
         assert options.arguments() == ['2', '-a3', '4']
         //assertEquals(['1', '2', '3', '4'], options.as)
 
@@ -299,33 +299,33 @@ class CliBuilderTest extends GroovyTestCase {
 //        cli.a ( longOpt : 'arg' , args : COMMONS_CLI_UNLIMITED_VALUES , 'arguments' )
         cli.a(longOpt: 'arg', args: 1, 'arguments')
         def options = cli.parse(['-a1', '-a2', '-a3'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
-        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.args)
-        groovy.util.GroovyTestCase.assertEquals([], options.arguments())
+        assertEquals('1', options.a)
+        assertEquals(['1', '2', '3'], options.as)
+        assertEquals('1', options.arg)
+        assertEquals(['1', '2', '3'], options.args)
+        assertEquals([], options.arguments())
     }
 
     void testMultipleOccurrencesTogetherSeparate() {
         def cli = new CliBuilder()
         cli.a(longOpt: 'arg', args: COMMONS_CLI_UNLIMITED_VALUES, valueSeparator: ',' as char, 'arguments')
         def options = cli.parse(['-a 1,2,3'])
-        groovy.util.GroovyTestCase.assertEquals(' 1', options.a)
-        groovy.util.GroovyTestCase.assertEquals([' 1', '2', '3'], options.as)
-        groovy.util.GroovyTestCase.assertEquals(' 1', options.arg)
-        groovy.util.GroovyTestCase.assertEquals([' 1', '2', '3'], options.args)
-        groovy.util.GroovyTestCase.assertEquals([], options.arguments())
+        assertEquals(' 1', options.a)
+        assertEquals([' 1', '2', '3'], options.as)
+        assertEquals(' 1', options.arg)
+        assertEquals([' 1', '2', '3'], options.args)
+        assertEquals([], options.arguments())
     }
 
     void testMultipleOccurrencesTogetherJuxtaposed() {
         def cli1 = new CliBuilder()
         cli1.a(longOpt: 'arg', args: COMMONS_CLI_UNLIMITED_VALUES, valueSeparator: ',' as char, 'arguments')
         def options = cli1.parse(['-a1,2,3'])
-        groovy.util.GroovyTestCase.assertEquals('1', options.a)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
-        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
-        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.args)
-        groovy.util.GroovyTestCase.assertEquals([], options.arguments()) }
+        assertEquals('1', options.a)
+        assertEquals(['1', '2', '3'], options.as)
+        assertEquals('1', options.arg)
+        assertEquals(['1', '2', '3'], options.args)
+        assertEquals([], options.arguments()) }
 
     /*
      *  Behaviour with unrecognized options.
@@ -334,7 +334,7 @@ class CliBuilderTest extends GroovyTestCase {
     void testUnrecognizedOptionSilentlyIgnored_GnuParser() {
         def cli = new CliBuilder(usage: usageString, writer: printWriter)
         def options = cli.parse(['-v'])
-        groovy.util.GroovyTestCase.assertEquals('''''', stringWriter.toString().tokenize('\r\n').join('\n'))
+        assertEquals('''''', stringWriter.toString().tokenize('\r\n').join('\n'))
         assert !options.v
     }
 
@@ -356,7 +356,7 @@ class CliBuilderTest extends GroovyTestCase {
         checkNoOutput()
         assert !options.v
         assert !options.h
-        groovy.util.GroovyTestCase.assertEquals(['-v', '-h'], options.arguments())
+        assertEquals(['-v', '-h'], options.arguments())
     }
 
     void testUnrecognizedOptionTerminatesParse_DefaultParser() {
@@ -366,7 +366,7 @@ class CliBuilderTest extends GroovyTestCase {
         checkNoOutput()
         assert !options.v
         assert !options.h
-        groovy.util.GroovyTestCase.assertEquals(['-v', '-h'], options.arguments())
+        assertEquals(['-v', '-h'], options.arguments())
     }
 
     void testMultiCharShortOpt() {
@@ -859,7 +859,7 @@ class CliBuilderTest extends GroovyTestCase {
         ''', 'CliBuilderTestScript.groovy', argz)
     }
 
-    public void testOptionProperties() {
+    void testOptionProperties() {
         CliBuilder cli = new CliBuilder(usage: 'groovyConsole [options] [filename]', stopAtNonOption: false)
         cli.with {
             D(longOpt: 'define', args: 2, argName: 'name=value', valueSeparator: '=', 'description')
@@ -871,11 +871,11 @@ class CliBuilderTest extends GroovyTestCase {
         assert 'v2' == props.getProperty('k2')
     }
 
-    public void testAcceptLongOptionsWithSingleHyphen_defaultFalse() {
+    void testAcceptLongOptionsWithSingleHyphen_defaultFalse() {
         assert !new CliBuilder().acceptLongOptionsWithSingleHyphen
     }
 
-    public void testAcceptLongOptionsWithSingleHyphen_DuplicateOptionAnnotationsException() {
+    void testAcceptLongOptionsWithSingleHyphen_DuplicateOptionAnnotationsException() {
         CliBuilder cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
         try {
             cli.with {
@@ -887,7 +887,7 @@ class CliBuilderTest extends GroovyTestCase {
         }
     }
 
-    public void testLongOptionsRequireDoubleHyphenByDefault() {
+    void testLongOptionsRequireDoubleHyphenByDefault() {
         CliBuilder cli = new CliBuilder()
         cli.with {
             classpath('description')
@@ -941,7 +941,7 @@ class CliBuilderTest extends GroovyTestCase {
         assert options.arguments() == ['-configscript', 'abc']
     }
 
-    public void testAcceptLongOptionsWithSingleHyphen_registersLongOptionsTwice() {
+    void testAcceptLongOptionsWithSingleHyphen_registersLongOptionsTwice() {
         CliBuilder cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
         cli.with {
             cp(longOpt: 'classpath', 'cli.option.cp.description')
@@ -977,7 +977,17 @@ class CliBuilderTest extends GroovyTestCase {
         assert cli.parse( '-configscript abc'.split()).configscript == 'abc'
     }
 
-    public void testAcceptLongOptionsWithSingleHyphen_usage() {
+    // GROOVY-8607
+    void testOptIgnoredWhenSupplyingMapOfArgs() {
+        def builder = new CliBuilder()
+        def helpOpt = [opt:'h', longOpt: 'help']
+        builder."$helpOpt.opt"(helpOpt, 'help option').with {
+            assert opt == 'h'
+            assert longOpt == 'help'
+        }
+    }
+
+    void testAcceptLongOptionsWithSingleHyphen_usage() {
         resetPrintWriter()
         CliBuilder cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true, writer: printWriter)
         cli.with {
@@ -1003,7 +1013,7 @@ Usage: groovy [-hiV] [-cp] [-pa] [-configscript=PARAM] [-D=<String>=<String>]...
       -pa, -parameters, --parameters
                             cli.option.parameters.description
   -V, -version, --version   cli.option.version.description"""
-        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+        assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
 
         resetPrintWriter()
         cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: false, writer: printWriter)
@@ -1028,6 +1038,6 @@ Usage: groovy [-hiV] [-cp] [-pa] [--configscript=PARAM]
   -i, --indy                 cli.option.indy.description
       -pa, --parameters      cli.option.parameters.description
   -V, --version              cli.option.version.description"""
-        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+        assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
     }
 }

Commit:
c49640e76a7ae80bca8d0ed80ce6f4811b989f1f
John Wagenleitner
jwagenleitner@apache.org
2018-05-25 20:38:17 -0700
Fix NPE if accessed property not a member of the owning class (closes #724)
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 9a13abe2b8..96faeb9ca9 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -611,10 +611,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     if (vexp.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER) == null) {
                         ClassNode owner = (ClassNode) vexp.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);
                         if (owner != null) {
-                            boolean lhsOfEnclosingAssignment = isLHSOfEnclosingAssignment(vexp);
-                            fieldNode = owner.getField(vexp.getName());
-                            vexp.setAccessedVariable(fieldNode);
-                            checkOrMarkPrivateAccess(vexp, fieldNode, lhsOfEnclosingAssignment);
+                            FieldNode veFieldNode = owner.getField(vexp.getName());
+                            if (veFieldNode != null) {
+                                fieldNode = veFieldNode;
+                                boolean lhsOfEnclosingAssignment = isLHSOfEnclosingAssignment(vexp);
+                                vexp.setAccessedVariable(fieldNode);
+                                checkOrMarkPrivateAccess(vexp, fieldNode, lhsOfEnclosingAssignment);
+                            }
                         }
                     }
                 }
diff --git a/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy b/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy
index e6b310e69e..cb1e4fa2d7 100644
--- a/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy
+++ b/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy
@@ -587,6 +587,25 @@ new DelegateTest().delegate()
 '''
     }
 
+    void testDelegateVariableFromDifferentOwningClass() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class A {
+            static private int MAX_LINES = 2
+            static class B {
+                @Delegate
+                private Map<String, Object> delegate = [:]
+                void m(int c) {
+                    if (c > MAX_LINES) {
+                        return
+                    }
+                }
+            }
+        }
+        null
+        '''
+    }
+
     private static class SpecSupport {
         static int getLongueur(String self) { self.length() }
         static int longueur(String self) { self.length() }

Commit:
16b98fb059ee642da7062452798bc90f5e30fb26
John Wagenleitner
jwagenleitner@apache.org
2018-05-25 20:37:55 -0700
Fix parameter matching for parameterized types
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index cf92a6e050..6a5245bb2a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -62,6 +62,7 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -1099,7 +1100,8 @@ public abstract class StaticTypeCheckingSupport {
                 Person p = foo(b)
              */
 
-            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringClassForDistance, actualReceiverForDistance);
+            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
+            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringAndActualGenericsTypeMap);
             int dist = measureParametersAndArgumentsDistance(params, safeArgs);
             if (dist >= 0) {
                 dist += getClassDistance(declaringClassForDistance, actualReceiverForDistance);
@@ -1189,20 +1191,62 @@ public abstract class StaticTypeCheckingSupport {
         return isExtensionMethodNode ? 0 : 1;
     }
 
+    private static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
+        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
+            GenericsType declaringGenericsType = entry.getKey();
+
+            if (placeholderName.equals(declaringGenericsType.getName())) {
+                return entry.getValue().getType();
+            }
+        }
+
+        return null;
+    }
+
     public static ClassNode findActualTypeByPlaceholderName(String placeholderName, Map<String, GenericsType> placeholderInfo) {
         GenericsType gt = placeholderInfo.get(placeholderName);
 
         return null == gt ? null : gt.getType().redirect();
     }
 
-    private static Parameter[] makeRawTypes(Parameter[] params, ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
-        Map<String, GenericsType> placeholderInfo = GenericsUtils.extractPlaceholders(GenericsUtils.findParameterizedTypeFromCache(declaringClassForDistance, actualReceiverForDistance));
+    /**
+     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
+     * declaring generics types:      T,      S extends Serializable
+     * actual generics types   : String,      Long
+     *
+     * the result map is [
+     *  T: String,
+     *  S: Long
+     * ]
+     *
+     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
+     * so we need actual types:  T: String, S: Long
+     */
+    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
+        ClassNode parameterizedType = GenericsUtils.findParameterizedType(declaringClass, actualReceiver);
+
+        if (null == parameterizedType) {
+            return Collections.emptyMap();
+        }
+
+        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
+        GenericsType[] actualGenericsTypes = parameterizedType.getGenericsTypes();
+
+        Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
+        for (int i = 0, n = declaringGenericsTypes.length; i < n; i++) {
+            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
+        }
+
+        return result;
+    }
+
+    private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
 
         Parameter[] newParam = new Parameter[params.length];
         for (int i = 0; i < params.length; i++) {
             Parameter oldP = params[i];
 
-            ClassNode actualType = findActualTypeByPlaceholderName(oldP.getType().getUnresolvedName(), placeholderInfo);
+            ClassNode actualType = findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
             Parameter newP = new Parameter(makeRawType(null == actualType ? oldP.getType() : actualType), oldP.getName());
             newParam[i] = newP;
         }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 4b1055b793..69a43a77f1 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -76,7 +76,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<String> list = []
             list << 1
-        ''', '[Static type checking] - Cannot call <T> java.util.List <String>#leftShift(T) with arguments [int] '
+        ''', '[Static type checking] - Cannot find matching method java.util.List#leftShift(int)'
     }
 
     void testAddOnList2UsingLeftShift() {
@@ -91,6 +91,14 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testAddOnListWithParameterizedTypeLeftShift() {
+        assertScript '''
+            class Trie<T> {}
+            List<Trie<String>> list = []
+            list << new Trie<String>()
+        '''
+    }
+
     void testAddOnListWithDiamondUsingLeftShift() {
         assertScript '''
             List<String> list = new LinkedList<>()

Commit:
603e5f63d91488082581b5d1f508d555c143470b
Paul King
paulk@asert.com.au
2018-05-25 23:26:01 +1000
GROOVY-8592: Migrate command line tools to picocli version of CliBuilder
diff --git a/gradle/assemble.gradle b/gradle/assemble.gradle
index d4844bdf51..bd67e480d0 100644
--- a/gradle/assemble.gradle
+++ b/gradle/assemble.gradle
@@ -215,7 +215,8 @@ allprojects {
                     'org/codehaus/groovy/tools/shell/util/HelpFormatter*.class',
                     'groovy/cli/commons/CliBuilder*.class',
                     'groovy/cli/commons/OptionAccessor*.class',
-                    'groovy/cli/picocli/CliBuilder*.class'
+                    'groovy/cli/picocli/CliBuilder*.class',
+                    'groovy/cli/picocli/OptionAccessor*.class'
             ]
             patterns = [
                     'antlr.**'                 : 'groovyjarjarantlr.@1', // antlr2
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
index e0377b3139..d18a8bd22d 100644
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
@@ -608,7 +608,7 @@ class CliBuilder {
      * Make options accessible from command line args with parser.
      * Returns null on bad command lines after displaying usage message.
      */
-    groovy.cli.picocli.OptionAccessor parse(args) {
+    OptionAccessor parse(args) {
         CommandLine commandLine = createCommandLine()
         try {
             def accessor = new OptionAccessor(commandLine.parseArgs(args as String[]))
diff --git a/subprojects/groovy-console/build.gradle b/subprojects/groovy-console/build.gradle
index dc488bb56b..c55970d936 100644
--- a/subprojects/groovy-console/build.gradle
+++ b/subprojects/groovy-console/build.gradle
@@ -20,7 +20,7 @@ evaluationDependsOn(':groovy-swing')
 
 dependencies {
     compile rootProject
-    compile project(':groovy-cli-commons')
+    compile project(':groovy-cli-picocli')
     compile project(':groovy-swing')
     compile project(':groovy-templates')
     testCompile project(':groovy-test')
diff --git a/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy b/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy
index cee5943689..a7ff3561c1 100644
--- a/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy
+++ b/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy
@@ -18,6 +18,8 @@
  */
 package groovy.ui
 
+import groovy.cli.picocli.CliBuilder
+import groovy.cli.picocli.OptionAccessor
 import groovy.inspect.swingui.AstBrowser
 import groovy.inspect.swingui.ObjectBrowser
 import groovy.swing.SwingBuilder
@@ -191,16 +193,16 @@ class Console implements CaretListener, HyperlinkListener, ComponentListener, Fo
     ConsolePreferences consolePreferences
 
     static void main(args) {
-        CliBuilder cli = new CliBuilder(usage: 'groovyConsole [options] [filename]', stopAtNonOption: false)
         MessageSource messages = new MessageSource(Console)
+        CliBuilder cli = new CliBuilder(usage: 'groovyConsole [options] [filename]', stopAtNonOption: false,
+                header: messages['cli.option.header'])
         cli.with {
-            classpath(messages['cli.option.classpath.description'])
-            cp(longOpt: 'classpath', messages['cli.option.cp.description'])
+            _(names: ['-cp', '-classpath', '--classpath'], messages['cli.option.classpath.description'])
             h(longOpt: 'help', messages['cli.option.help.description'])
             V(longOpt: 'version', messages['cli.option.version.description'])
             pa(longOpt: 'parameters', messages['cli.option.parameters.description'])
             i(longOpt: 'indy', messages['cli.option.indy.description'])
-            D(longOpt: 'define', args: 2, argName: 'name=value', valueSeparator: '=', messages['cli.option.define.description'])
+            D(longOpt: 'define', type: Map, argName: 'name=value', messages['cli.option.define.description'])
             _(longOpt: 'configscript', args: 1, messages['cli.option.configscript.description'])
         }
         OptionAccessor options = cli.parse(args)
@@ -221,9 +223,7 @@ class Console implements CaretListener, HyperlinkListener, ComponentListener, Fo
         }
 
         if (options.hasOption('D')) {
-            options.getOptionProperties('D')?.each { k, v ->
-                System.setProperty(k, v)
-            }
+            options.Ds.each { k, v -> System.setProperty(k, v) }
         }
 
         // full stack trace should not be logged to the output window - GROOVY-4663
diff --git a/subprojects/groovy-console/src/main/resources/groovy/ui/Console.properties b/subprojects/groovy-console/src/main/resources/groovy/ui/Console.properties
index f98f2375f5..4574a518d3 100644
--- a/subprojects/groovy-console/src/main/resources/groovy/ui/Console.properties
+++ b/subprojects/groovy-console/src/main/resources/groovy/ui/Console.properties
@@ -16,6 +16,8 @@
 #  specific language governing permissions and limitations
 #  under the License.
 #
+cli.option.header=The Groovy Swing Console allows a user to enter and run Groovy scripts.
+
 cli.option.help.description=Display this help message
 
 cli.option.version.description=Display the version
diff --git a/subprojects/groovy-groovydoc/build.gradle b/subprojects/groovy-groovydoc/build.gradle
index ef3e292824..0f20879137 100644
--- a/subprojects/groovy-groovydoc/build.gradle
+++ b/subprojects/groovy-groovydoc/build.gradle
@@ -19,7 +19,7 @@
 dependencies {
     compile rootProject
     testCompile rootProject.sourceSets.test.runtimeClasspath
-    compile project(':groovy-cli-commons')
+    compile project(':groovy-cli-picocli')
     compile project(':groovy-templates')
     runtime project(':groovy-dateutil')
     testCompile project(':groovy-test')
diff --git a/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy b/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
index b3041784c1..4646dec28c 100644
--- a/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
+++ b/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
@@ -18,7 +18,7 @@
  */
 package org.codehaus.groovy.tools.groovydoc
 
-import groovy.cli.commons.CliBuilder
+import groovy.cli.picocli.CliBuilder
 import groovy.io.FileType
 import org.codehaus.groovy.tools.groovydoc.gstringTemplates.GroovyDocTemplateInfo
 import org.codehaus.groovy.tools.shell.IO
@@ -58,9 +58,10 @@ class Main {
         IO io = new IO()
         Logger.io = io
 
-        def cli = new CliBuilder(usage : 'groovydoc [options] [packagenames] [sourcefiles]', writer: io.out, posix:false)
+        def cli = new CliBuilder(usage: 'groovydoc [options] [packagenames] [sourcefiles]', writer: io.out, posix: false,
+                header: messages['cli.option.header'])
 
-        cli.help(longOpt: 'help', messages['cli.option.help.description'])
+        cli._(names: ['-h', '-help', '--help'], messages['cli.option.help.description'])
         cli._(longOpt: 'version', messages['cli.option.version.description'])
         cli.verbose(messages['cli.option.verbose.description'])
         cli.quiet(messages['cli.option.quiet.description'])
diff --git a/subprojects/groovy-groovydoc/src/main/resources/org/codehaus/groovy/tools/groovydoc/Main.properties b/subprojects/groovy-groovydoc/src/main/resources/org/codehaus/groovy/tools/groovydoc/Main.properties
index 6c72823196..e3dcdc8053 100644
--- a/subprojects/groovy-groovydoc/src/main/resources/org/codehaus/groovy/tools/groovydoc/Main.properties
+++ b/subprojects/groovy-groovydoc/src/main/resources/org/codehaus/groovy/tools/groovydoc/Main.properties
@@ -20,6 +20,7 @@
 #
 # CLI messages
 #
+cli.option.header=GroovyDoc is a tool responsible for generating documentation from your code. It acts like the Javadoc tool in the Java world but is capable of handling both groovy and java files.
 
 cli.option.help.description=Display this help message
 
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
index acdc258f56..1b7a9a5c8d 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
@@ -47,8 +47,7 @@ import static org.apache.groovy.util.SystemUtil.setSystemPropertyFrom
  *
  * Main CLI entry-point for <tt>groovysh</tt>.
  */
-class Main
-{
+class Main {
     final Groovysh groovysh
 
     /**
@@ -76,8 +75,9 @@ class Main
      * @param main must have a Groovysh member that has an IO member.
      */
     static void main(final String[] args) {
-        CliBuilder cli = new CliBuilder(usage: 'groovysh [options] [...]', formatter: new HelpFormatter(), stopAtNonOption: false)
         MessageSource messages = new MessageSource(Main)
+        CliBuilder cli = new CliBuilder(usage: 'groovysh [options] [...]', formatter: new HelpFormatter(), stopAtNonOption: false,
+                header: messages['cli.option.header'])
         cli.with {
             classpath(messages['cli.option.classpath.description'])
             cp(longOpt: 'classpath', messages['cli.option.cp.description'])
diff --git a/subprojects/groovy-groovysh/src/main/resources/org/codehaus/groovy/tools/shell/Main.properties b/subprojects/groovy-groovysh/src/main/resources/org/codehaus/groovy/tools/shell/Main.properties
index e40ae967ab..fac864ddbe 100644
--- a/subprojects/groovy-groovysh/src/main/resources/org/codehaus/groovy/tools/shell/Main.properties
+++ b/subprojects/groovy-groovysh/src/main/resources/org/codehaus/groovy/tools/shell/Main.properties
@@ -20,6 +20,7 @@
 #
 # CLI messages
 #
+cli.option.header=The Groovy Shell, aka groovysh, is a command-line application which allows easy access to evaluate Groovy expressions, define classes and run simple experiments.
 
 cli.option.help.description=Display this help message
 

Commit:
3d50ca0e513e69e988097d47cb200a642cedccab
sunlan
sunlan@apache.org
2018-05-25 19:11:58 +0800
Revert "GROOVY-8606: Provide friendly error message for invalid lambda body"
diff --git a/src/antlr/GroovyParser.g4 b/src/antlr/GroovyParser.g4
index dbc946c88f..77867dab2f 100644
--- a/src/antlr/GroovyParser.g4
+++ b/src/antlr/GroovyParser.g4
@@ -501,7 +501,6 @@ standardLambdaParameters
 lambdaBody
 	:	block
 	|	statementExpression
-	|   statement // !!! Error Alternative !!!
 	;
 
 
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 22e35ca1c1..031680f0f5 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -3720,16 +3720,12 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
 
     @Override
     public Statement visitLambdaBody(LambdaBodyContext ctx) {
-        if (asBoolean(ctx.block())) {
-            return configureAST(this.visitBlock(ctx.block()), ctx);
-        }
-
         if (asBoolean(ctx.statementExpression())) {
             return configureAST((ExpressionStatement) this.visit(ctx.statementExpression()), ctx);
         }
 
-        if (asBoolean(ctx.statement())) {
-            throw createParsingFailedException("Statements should be wrapped in a block, e.g. () -> { some statements here }", ctx);
+        if (asBoolean(ctx.block())) {
+            return configureAST(this.visitBlock(ctx.block()), ctx);
         }
 
         throw createParsingFailedException("Unsupported lambda body: " + ctx.getText(), ctx);
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
index 1669b3239c..868269f7fe 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
@@ -231,10 +231,6 @@ class SyntaxErrorTest extends GroovyTestCase {
         TestUtils.doRunAndShouldFail('fail/Import_02x.groovy');
     }
 
-    void "test groovy core - Lambda"() {
-        TestUtils.doRunAndShouldFail('fail/Lambda_01x.groovy');
-    }
-
     /**************************************/
     static unzipScriptAndShouldFail(String entryName, List ignoreClazzList, Map<String, String> replacementsMap=[:], boolean toCheckNewParserOnly = false) {
         ignoreClazzList.addAll(TestUtils.COMMON_IGNORE_CLASS_LIST)
diff --git a/subprojects/parser-antlr4/src/test/resources/fail/Lambda_01x.groovy b/subprojects/parser-antlr4/src/test/resources/fail/Lambda_01x.groovy
deleted file mode 100644
index edc0ab1a6e..0000000000
--- a/subprojects/parser-antlr4/src/test/resources/fail/Lambda_01x.groovy
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-def a = () -> assert 1 == 1

Commit:
1bd642488104ca8204bd45c1c1cf4d304d7d564f
sunlan
sunlan@apache.org
2018-05-25 18:39:40 +0800
GROOVY-8606: Provide friendly error message for invalid lambda body
diff --git a/src/antlr/GroovyParser.g4 b/src/antlr/GroovyParser.g4
index 77867dab2f..dbc946c88f 100644
--- a/src/antlr/GroovyParser.g4
+++ b/src/antlr/GroovyParser.g4
@@ -501,6 +501,7 @@ standardLambdaParameters
 lambdaBody
 	:	block
 	|	statementExpression
+	|   statement // !!! Error Alternative !!!
 	;
 
 
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 031680f0f5..22e35ca1c1 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -3720,12 +3720,16 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
 
     @Override
     public Statement visitLambdaBody(LambdaBodyContext ctx) {
+        if (asBoolean(ctx.block())) {
+            return configureAST(this.visitBlock(ctx.block()), ctx);
+        }
+
         if (asBoolean(ctx.statementExpression())) {
             return configureAST((ExpressionStatement) this.visit(ctx.statementExpression()), ctx);
         }
 
-        if (asBoolean(ctx.block())) {
-            return configureAST(this.visitBlock(ctx.block()), ctx);
+        if (asBoolean(ctx.statement())) {
+            throw createParsingFailedException("Statements should be wrapped in a block, e.g. () -> { some statements here }", ctx);
         }
 
         throw createParsingFailedException("Unsupported lambda body: " + ctx.getText(), ctx);
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
index 868269f7fe..1669b3239c 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
@@ -231,6 +231,10 @@ class SyntaxErrorTest extends GroovyTestCase {
         TestUtils.doRunAndShouldFail('fail/Import_02x.groovy');
     }
 
+    void "test groovy core - Lambda"() {
+        TestUtils.doRunAndShouldFail('fail/Lambda_01x.groovy');
+    }
+
     /**************************************/
     static unzipScriptAndShouldFail(String entryName, List ignoreClazzList, Map<String, String> replacementsMap=[:], boolean toCheckNewParserOnly = false) {
         ignoreClazzList.addAll(TestUtils.COMMON_IGNORE_CLASS_LIST)
diff --git a/subprojects/parser-antlr4/src/test/resources/fail/Lambda_01x.groovy b/subprojects/parser-antlr4/src/test/resources/fail/Lambda_01x.groovy
new file mode 100644
index 0000000000..edc0ab1a6e
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/fail/Lambda_01x.groovy
@@ -0,0 +1,20 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+def a = () -> assert 1 == 1

Commit:
22d872a3c0af0e75070ecdcca7ccf3dbaa5eb448
sunlan
sunlan@apache.org
2018-05-25 16:45:40 +0800
Request YourKit Java Profiler Open Source License(closes #722)
diff --git a/README.adoc b/README.adoc
index cad2c51201..fb9191cb2b 100644
--- a/README.adoc
+++ b/README.adoc
@@ -179,6 +179,10 @@ Please note that the following Gradle tasks generate both indy and non indy vari
 
 The official CI server runs {groovy-ci}[here] and is sponsored by http://www.jetbrains.com[JetBrains].
 
+== Java Profiler
+
+Groovy core team tunes performance through YourKit Java Profiler, which is sponsored by https://www.yourkit.com[YourKit].
+
 == License
 
 Groovy is licensed under the terms of the http://www.apache.org/licenses/LICENSE-2.0.html[Apache License, Version 2.0]

Commit:
84f3351a86f70a199769ca6efd661ef6d79c16fa
sunlan
sunlan@apache.org
2018-05-25 16:32:26 +0800
Remove unused import
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index b65797b246..90dc1254fd 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -77,7 +77,6 @@ import java.util.Set;
 
 import static org.codehaus.groovy.ast.tools.GeneralUtils.inSamePackage;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.isDefaultVisibility;
-import static org.codehaus.groovy.runtime.DefaultGroovyMethods.asBoolean;
 
 /**
  * Visitor to resolve Types and convert VariableExpression to

Commit:
0f18789a10140fd33db44f35e4fae1aaf4444c71
sunlan
sunlan@apache.org
2018-05-25 14:19:54 +0800
Remove unnecessary `asBoolean`
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 2f7bcd70c4..b65797b246 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -1484,7 +1484,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                         upperBoundsToResolve.add(new Tuple2<>(upperBound, classNode));
                     }
 
-                    if (asBoolean(upperBound.isUsingGenerics())) {
+                    if (upperBound.isUsingGenerics()) {
                         upperBoundsWithGenerics.add(new Tuple2<>(upperBound, type));
                     }
                 }

Commit:
9fec034e5e81a5411502665872861ba2128e0a4a
sunlan
sunlan@apache.org
2018-05-25 14:14:33 +0800
 Avoid inefficient use of keySet iterator instead of entrySet iterator
diff --git a/src/main/groovy/groovy/ui/GroovyMain.java b/src/main/groovy/groovy/ui/GroovyMain.java
index 58c6635f6a..8490e150ed 100644
--- a/src/main/groovy/groovy/ui/GroovyMain.java
+++ b/src/main/groovy/groovy/ui/GroovyMain.java
@@ -230,8 +230,8 @@ public class GroovyMain {
          * @throws ParameterException if the user input was invalid
          */
         boolean process(CommandLine parser) throws ParameterException, IOException {
-            for (String key : systemProperties.keySet()) {
-                System.setProperty(key, systemProperties.get(key));
+            for (Map.Entry<String, String> entry : systemProperties.entrySet()) {
+                System.setProperty(entry.getKey(), entry.getValue());
             }
             GroovyMain main = new GroovyMain();
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 86e2085f3a..1429102eb5 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -10293,8 +10293,11 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             return createSimilarMap(self);
         }
         Map<K, V> ret = createSimilarMap(self);
-        for (K key : self.keySet()) {
-            ret.put(key, self.get(key));
+        for (Map.Entry<K, V> entry : self.entrySet()) {
+            K key = entry.getKey();
+            V value = entry.getValue();
+
+            ret.put(key, value);
             if (--num <= 0) {
                 break;
             }
@@ -10588,9 +10591,12 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             return cloneSimilarMap(self);
         }
         Map<K, V> ret = createSimilarMap(self);
-        for (K key : self.keySet()) {
+        for (Map.Entry<K, V> entry : self.entrySet()) {
+            K key = entry.getKey();
+            V value = entry.getValue();
+
             if (num-- <= 0) {
-                ret.put(key, self.get(key));
+                ret.put(key, value);
             }
         }
         return ret;
@@ -12744,8 +12750,12 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         if (!self.keySet().equals(other.keySet())) {
             return false;
         }
-        for (Object key : self.keySet()) {
-            if (!coercedEquals(self.get(key), other.get(key))) {
+        for (Object o : self.entrySet()) {
+            Map.Entry entry = (Map.Entry) o;
+            Object key = entry.getKey();
+            Object value = entry.getValue();
+
+            if (!coercedEquals(value, other.get(key))) {
                 return false;
             }
         }

Commit:
ed71b35e755090b1ae841e0e9888c0f61386d050
sunlan
sunlan@apache.org
2018-05-25 09:15:21 +0800
GROOVY-8604: Cache the parameterized type for better performance(closes #721)
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 2e8a103770..3d99e53b5c 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -36,6 +36,8 @@ import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.ResolveVisitor;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.runtime.memoize.EvictableCache;
+import org.codehaus.groovy.runtime.memoize.StampedCommonCache;
 import org.codehaus.groovy.syntax.ParserException;
 import org.codehaus.groovy.syntax.Reduction;
 
@@ -46,6 +48,7 @@ import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.getCorrectedClassNode;
@@ -658,13 +661,22 @@ public class GenericsUtils {
     }
 
     /**
-     * Get the parameterized type by search the whole class hierarchy according to generics class and actual receiver
+     * Try to get the parameterized type from the cache.
+     * If no cached item found, cache and return the result of {@link #findParameterizedType(ClassNode, ClassNode)}
+     */
+    public static ClassNode findParameterizedTypeFromCache(final ClassNode genericsClass, final ClassNode actualType) {
+        return PARAMETERIZED_TYPE_CACHE.getAndPut(new ParameterizedTypeCacheKey(genericsClass, actualType), key -> findParameterizedType(key.getGenericsClass(), key.getActualType()));
+    }
+
+    /**
+     * Get the parameterized type by search the whole class hierarchy according to generics class and actual receiver.
+     * {@link #findParameterizedTypeFromCache(ClassNode, ClassNode)} is strongly recommended for better performance.
      *
      * @param genericsClass the generics class
-     * @param actualReceiver the actual receiver
+     * @param actualType the actual type
      * @return the parameterized type
      */
-    public static ClassNode findParameterizedType(ClassNode genericsClass, ClassNode actualReceiver) {
+    public static ClassNode findParameterizedType(ClassNode genericsClass, ClassNode actualType) {
         ClassNode parameterizedType = null;
 
         if (null == genericsClass.getGenericsTypes()) {
@@ -673,8 +685,8 @@ public class GenericsUtils {
 
         GenericsType[] declaringGenericsTypes = genericsClass.getGenericsTypes();
 
-        List<ClassNode> classNodeList = new LinkedList<>(getAllSuperClassesAndInterfaces(actualReceiver));
-        classNodeList.add(0, actualReceiver);
+        List<ClassNode> classNodeList = new LinkedList<>(getAllSuperClassesAndInterfaces(actualType));
+        classNodeList.add(0, actualType);
 
         for (ClassNode cn : classNodeList) {
             if (cn == genericsClass) {
@@ -720,4 +732,47 @@ public class GenericsUtils {
 
         return superClassNodeList;
     }
+
+    private static final EvictableCache<ParameterizedTypeCacheKey, ClassNode> PARAMETERIZED_TYPE_CACHE = new StampedCommonCache<>(128);
+    private static class ParameterizedTypeCacheKey {
+        private ClassNode genericsClass;
+        private ClassNode actualType;
+
+        public ParameterizedTypeCacheKey(ClassNode genericsClass, ClassNode actualType) {
+            this.genericsClass = genericsClass;
+            this.actualType = actualType;
+        }
+
+        public ClassNode getGenericsClass() {
+            return genericsClass;
+        }
+
+        public void setGenericsClass(ClassNode genericsClass) {
+            this.genericsClass = genericsClass;
+        }
+
+        public ClassNode getActualType() {
+            return actualType;
+        }
+
+        public void setActualType(ClassNode actualType) {
+            this.actualType = actualType;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            ParameterizedTypeCacheKey cacheKey = (ParameterizedTypeCacheKey) o;
+
+            return genericsClass == cacheKey.genericsClass &&
+                    actualType == cacheKey.actualType;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(genericsClass, actualType);
+        }
+    }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 316953becd..cf92a6e050 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1196,7 +1196,7 @@ public abstract class StaticTypeCheckingSupport {
     }
 
     private static Parameter[] makeRawTypes(Parameter[] params, ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
-        Map<String, GenericsType> placeholderInfo = GenericsUtils.extractPlaceholders(GenericsUtils.findParameterizedType(declaringClassForDistance, actualReceiverForDistance));
+        Map<String, GenericsType> placeholderInfo = GenericsUtils.extractPlaceholders(GenericsUtils.findParameterizedTypeFromCache(declaringClassForDistance, actualReceiverForDistance));
 
         Parameter[] newParam = new Parameter[params.length];
         for (int i = 0; i < params.length; i++) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index efa7c26b7b..9a13abe2b8 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -620,7 +620,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
 
-            ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
+            ClassNode parameterizedType = GenericsUtils.findParameterizedTypeFromCache(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
             if (null != parameterizedType) {
                 ClassNode originalType = fieldNode.getOriginType();
                 ClassNode actualType = findActualTypeByPlaceholderName(originalType.getUnresolvedName(), GenericsUtils.extractPlaceholders(parameterizedType));

Commit:
90486ae1075d14a62d14452abfea0c27485a67b5
Paul King
paulk@asert.com.au
2018-05-24 22:43:12 +1000
GROOVY-8562: Wrong closure delegation for property access when using @CompileStatic and DELEGATE_FIRST/DELEGATE_ONLY (closes #717)
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
index d055fc6045..548d9b2a53 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
@@ -34,11 +34,11 @@ import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 public class VariableExpressionTransformer {
 
     public Expression transformVariableExpression(VariableExpression expr) {
-        Expression trn = tryTransformPrivateFieldAccess(expr);
+        Expression trn = tryTransformDelegateToProperty(expr);
         if (trn != null) {
             return trn;
         }
-        trn = tryTransformDelegateToProperty(expr);
+        trn = tryTransformPrivateFieldAccess(expr);
         if (trn != null) {
             return trn;
         }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 27b9d09ee1..efa7c26b7b 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -100,6 +100,7 @@ import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.TokenUtil;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.StaticTypesTransformation;
+import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
 import org.codehaus.groovy.transform.trait.Traits;
 import org.codehaus.groovy.util.ListHashMap;
 import org.objectweb.asm.Opcodes;
@@ -599,6 +600,26 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         } else if (accessedVariable instanceof FieldNode) {
             FieldNode fieldNode = (FieldNode) accessedVariable;
 
+            TypeCheckingContext.EnclosingClosure enclosingClosure = typeCheckingContext.getEnclosingClosure();
+            if (enclosingClosure != null) {
+                // GROOVY-8562
+                // when vexp has the same name as a property of the owner,
+                // the IMPLICIT_RECEIVER must be set in case it's the delegate
+                if (tryVariableExpressionAsProperty(vexp, vexp.getName())) {
+                    // IMPLICIT_RECEIVER is handled elsewhere
+                    // however other access needs to be fixed for private access
+                    if (vexp.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER) == null) {
+                        ClassNode owner = (ClassNode) vexp.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);
+                        if (owner != null) {
+                            boolean lhsOfEnclosingAssignment = isLHSOfEnclosingAssignment(vexp);
+                            fieldNode = owner.getField(vexp.getName());
+                            vexp.setAccessedVariable(fieldNode);
+                            checkOrMarkPrivateAccess(vexp, fieldNode, lhsOfEnclosingAssignment);
+                        }
+                    }
+                }
+            }
+
             ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
             if (null != parameterizedType) {
                 ClassNode originalType = fieldNode.getOriginType();
diff --git a/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy b/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy
index 7d7baa9919..e6b310e69e 100644
--- a/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy
+++ b/src/spec/test/typing/TypeCheckingExtensionSpecTest.groovy
@@ -448,6 +448,144 @@ runner.run()
 '''
     }
 
+    void doDelegateResolutionForPropertyReadTest(String strategy, String expected) {
+        assertScript """import groovy.transform.CompileStatic
+class ADelegate {
+    def x = "delegate"
+}
+
+@CompileStatic
+class AClass {
+    public <T> T closureExecuter(
+            ADelegate d,
+            @DelegatesTo(value = ADelegate, strategy = $strategy) Closure<T> c) {
+        c.resolveStrategy = $strategy
+        c.delegate = d
+        return c()
+    }
+
+    def x = "owner"
+    
+    def test() {
+        def theDelegate = new ADelegate()
+        def res = closureExecuter(theDelegate) {
+            return x
+        }
+        
+        return res
+    }
+}
+assert new AClass().test() == "$expected"
+"""
+    }
+
+
+    void doDelegateResolutionForPropertyWriteTest(String strategy, String expected) {
+        assertScript """import groovy.transform.CompileStatic
+class ADelegate {
+    def x = "delegate"
+}
+
+@CompileStatic
+class AClass {
+    public <T> T closureExecuter(
+            ADelegate d,
+            @DelegatesTo(value = ADelegate, strategy = $strategy) Closure<T> c) {
+        c.resolveStrategy = $strategy
+        c.delegate = d
+        return c()
+    }
+
+    def x = "owner"
+    
+    def test() {
+        def theDelegate = new ADelegate()
+        def res = closureExecuter(theDelegate) {
+            x = "changed"
+        }
+        
+        return [theDelegate.x, this.x].toSet()
+    }
+}
+def result = new AClass().test()
+def expected = (["owner", "delegate", "changed"] - ["$expected"]).toSet()
+assert expected == result
+"""
+    }
+
+    void testDelegateResolutionToPropertyWhenReadingUsingDelegateOnly() {
+        doDelegateResolutionForPropertyReadTest("Closure.DELEGATE_ONLY", "delegate")
+    }
+
+    void testDelegateResolutionToPropertyWhenReadingUsingDelegateFirst() {
+        doDelegateResolutionForPropertyReadTest("Closure.DELEGATE_FIRST", "delegate")
+    }
+
+    void testDelegateResolutionToPropertyWhenReadingUsingOwnerOnly() {
+        doDelegateResolutionForPropertyReadTest("Closure.OWNER_ONLY", "owner")
+    }
+
+    void testDelegateResolutionToPropertyWhenReadingUsingOwnerFirst() {
+        doDelegateResolutionForPropertyReadTest("Closure.OWNER_FIRST", "owner")
+    }
+
+    void testDelegateResolutionToPropertyWhenWritingUsingDelegateOnly() {
+        doDelegateResolutionForPropertyWriteTest("Closure.DELEGATE_ONLY", "delegate")
+    }
+
+    void testDelegateResolutionToPropertyWhenWritingUsingDelegateFirst() {
+        doDelegateResolutionForPropertyWriteTest("Closure.DELEGATE_FIRST", "delegate")
+    }
+
+    void testDelegateResolutionToPropertyWhenWritingUsingOwnerOnly() {
+        doDelegateResolutionForPropertyWriteTest("Closure.OWNER_ONLY", "owner")
+    }
+
+    void testDelegateResolutionToPropertyWhenWritingUsingOwnerFirst() {
+        doDelegateResolutionForPropertyWriteTest("Closure.OWNER_FIRST", "owner")
+    }
+
+    void testDelegateResolutionToPropertyWhenWritingInsideWith() {
+        // Failing example provided by Jan Hackel (@jhunovis) in groovy slack
+        // https://groovy-community.slack.com/files/U9CM8G6AJ/FAR1PJT1U/behavior_of__with__and___compilestatic.groovy
+
+        assertScript '''import groovy.transform.CompileStatic
+class DelegateTest {
+
+  @CompileStatic
+  private static class Person {
+    String name
+    int age
+
+    Person copyWithName(String newName) {
+      return new Person().with {
+        name = newName
+        age = this.age
+        it
+      }
+    }
+  }
+
+  void delegate() {
+    def oldTim = new Person().with {
+      name = 'Tim Old'
+      age = 20
+      it
+    }
+    def newTim = new Person().with {
+      name = 'Tim New'
+      age = 20
+      it
+    }
+    def copiedTim = oldTim.copyWithName('Tim New')
+    assert oldTim.name == 'Tim Old'
+    assert copiedTim.name == newTim.name
+    assert copiedTim.age == newTim.age
+  }
+}
+new DelegateTest().delegate()
+'''
+    }
 
     private static class SpecSupport {
         static int getLongueur(String self) { self.length() }

Commit:
7ff08accdf2739f5f2c183dbfc7c77dfbbc1c9fd
danielsun1106
realbluesun@hotmail.com
2018-05-24 19:13:17 +0800
Add license header(closes #714)
diff --git a/subprojects/parser-antlr4/src/test/resources/core/TryWithResources_02x.groovy b/subprojects/parser-antlr4/src/test/resources/core/TryWithResources_02x.groovy
index e0a304ba99..db8c4206bc 100644
--- a/subprojects/parser-antlr4/src/test/resources/core/TryWithResources_02x.groovy
+++ b/subprojects/parser-antlr4/src/test/resources/core/TryWithResources_02x.groovy
@@ -1,3 +1,21 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 import groovy.transform.CompileStatic
 
 import java.io.*

Commit:
50f6057a379b35ec57b0ec3a1ffceafe7cd2ecd2
danielsun1106
realbluesun@hotmail.com
2018-05-24 19:12:50 +0800
GROOVY-8586: Support Java 9 ARM blocks
diff --git a/src/main/java/org/codehaus/groovy/ast/stmt/TryCatchStatement.java b/src/main/java/org/codehaus/groovy/ast/stmt/TryCatchStatement.java
index f05460fc3e..aee71763d6 100644
--- a/src/main/java/org/codehaus/groovy/ast/stmt/TryCatchStatement.java
+++ b/src/main/java/org/codehaus/groovy/ast/stmt/TryCatchStatement.java
@@ -20,6 +20,7 @@ package org.codehaus.groovy.ast.stmt;
 
 import org.codehaus.groovy.ast.GroovyCodeVisitor;
 import org.codehaus.groovy.ast.expr.DeclarationExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -63,8 +64,8 @@ public class TryCatchStatement extends Statement {
     }
 
     public void addResource(ExpressionStatement resourceStatement) {
-        if (!(resourceStatement.getExpression() instanceof DeclarationExpression)) {
-            throw new IllegalArgumentException("resourceStatement should be a variable declaration statement");
+        if (!(resourceStatement.getExpression() instanceof DeclarationExpression || resourceStatement.getExpression() instanceof VariableExpression)) {
+            throw new IllegalArgumentException("resourceStatement should be a variable declaration statement or a variable");
         }
 
         resourceStatements.add(resourceStatement);
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 37f951d3f6..031680f0f5 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -790,7 +790,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
                 new TryCatchStatement((Statement) this.visit(ctx.block()),
                         this.visitFinallyBlock(ctx.finallyBlock()));
 
-        if (asBoolean(ctx.resources())) {
+        if (resourcesExists) {
             this.visitResources(ctx.resources()).forEach(tryCatchStatement::addResource);
         }
 
@@ -830,14 +830,40 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
             return declarationStatements.get(0);
         } else if (asBoolean(ctx.expression())) {
             Expression expression = (Expression) this.visit(ctx.expression());
-            if (!(expression instanceof BinaryExpression
+            boolean isVariableDeclaration = expression instanceof BinaryExpression
                     && Types.ASSIGN == ((BinaryExpression) expression).getOperation().getType()
-                    && ((BinaryExpression) expression).getLeftExpression() instanceof VariableExpression)) {
+                    && ((BinaryExpression) expression).getLeftExpression() instanceof VariableExpression;
+            boolean isVariableAccess = expression instanceof VariableExpression;
 
-                throw createParsingFailedException("Only variable declarations are allowed to declare resource", ctx);
+            if (!(isVariableDeclaration || isVariableAccess)) {
+                throw createParsingFailedException("Only variable declarations or variable access are allowed to declare resource", ctx);
+            }
+            BinaryExpression assignmentExpression;
+
+            if (isVariableDeclaration) {
+                assignmentExpression = (BinaryExpression) expression;
+            } else if (isVariableAccess) {
+                /* See https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html
+                 * 14.20.3.1. Basic try-with-resources
+                 *
+                 * If a basic try-with-resource statement is of the form:
+                 * try (VariableAccess ...)
+                 *      Block
+                 *
+                 * then the resource is first converted to a local variable declaration by the following translation:
+                 * try (T #r = VariableAccess ...) {
+                 *      Block
+                 * }
+                 */
+                assignmentExpression =
+                        new BinaryExpression(
+                                new VariableExpression(genResourceName()),
+                                org.codehaus.groovy.syntax.Token.newSymbol(Types.ASSIGN, -1, -1),
+                                expression
+                        );
+            } else {
+                throw createParsingFailedException("Unsupported resource declaration", ctx);
             }
-
-            BinaryExpression assignmentExpression = (BinaryExpression) expression;
 
             return configureAST(
                     new ExpressionStatement(
@@ -856,6 +882,11 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         throw createParsingFailedException("Unsupported resource declaration: " + ctx.getText(), ctx);
     }
 
+    private int resourceCnt = 0;
+    private String genResourceName() {
+        return "__$$resource" + resourceCnt++;
+    }
+
     /**
      * Multi-catch(1..*) clause will be unpacked to several normal catch clauses, so the return type is List
      *
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
index fe74a08fb9..196b3718bb 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
@@ -266,6 +266,7 @@ class GroovyParserTest extends GroovyTestCase {
 
     void "test groovy core - TryWithResources"() {
         doRunAndTestAntlr4('core/TryWithResources_01x.groovy')
+        doRunAndTestAntlr4('core/TryWithResources_02x.groovy')
     }
 
     void "test groovy core - SafeIndex"() {
diff --git a/subprojects/parser-antlr4/src/test/resources/core/TryWithResources_02x.groovy b/subprojects/parser-antlr4/src/test/resources/core/TryWithResources_02x.groovy
new file mode 100644
index 0000000000..e0a304ba99
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/core/TryWithResources_02x.groovy
@@ -0,0 +1,292 @@
+import groovy.transform.CompileStatic
+
+import java.io.*
+
+
+class Resource implements Closeable {
+    int resourceId;
+    static closedResourceIds = [];
+    static exMsg = "failed to close";
+
+    public Resource(int resourceId) {
+        this.resourceId = resourceId;
+    }
+
+    public void close() {
+        if (3 == resourceId) throw new IOException(exMsg);
+
+        closedResourceIds << resourceId
+    }
+}
+
+// test case 1
+def a = 1;
+Resource resource1 = new Resource(1)
+try (resource1) {
+    a = 2;
+}
+assert Resource.closedResourceIds == [1]
+assert 2 == a
+
+// test case 2
+Resource.closedResourceIds = []
+final exMsg = "resource not found";
+try {
+    // try { ... } should throw the IOException, while the resource should be closed
+    Resource r1 = new Resource(2)
+    try (r1) {
+        throw new FileNotFoundException(exMsg)
+    }
+} catch(FileNotFoundException e) {
+    assert exMsg == e.getMessage()
+}
+assert Resource.closedResourceIds == [2]
+
+// test case 3
+Resource.closedResourceIds = []
+a = 1;
+try {
+    Resource r1 = new Resource(3)
+    try (r1) {
+        a = 2;
+    }
+} catch (IOException e) {
+    assert Resource.exMsg == e.getMessage()
+}
+assert 2 == a;
+assert Resource.closedResourceIds == []
+
+// test case 4
+Resource.closedResourceIds = []
+try {
+    // try { ... } should throw the IOException, while the resource should be closed
+    Resource r1 = new Resource(3)
+    try (r1) {
+        throw new FileNotFoundException(exMsg)
+    }
+} catch(FileNotFoundException e) {
+    assert exMsg == e.getMessage()
+
+    def suppressedExceptions = e.getSuppressed();
+    assert suppressedExceptions.length == 1
+    assert suppressedExceptions[0] instanceof IOException
+    assert suppressedExceptions[0].getMessage() == Resource.exMsg
+}
+assert Resource.closedResourceIds == []
+
+
+// test case 5
+Resource.closedResourceIds = []
+a = 1;
+Resource rr1 = new Resource(5)
+try (rr1;
+Resource r2 = new Resource(6);) {
+    a = 2;
+}
+assert Resource.closedResourceIds == [6, 5]
+assert 2 == a
+
+// test case 6
+Resource.closedResourceIds = []
+a = 1;
+Resource rr2 = new Resource(6)
+try (Resource r1 = new Resource(5);
+rr2;
+Resource r3 = new Resource(7);) {
+    a = 2;
+}
+assert Resource.closedResourceIds == [7, 6, 5]
+assert 2 == a
+
+
+// test case 7
+Resource.closedResourceIds = []
+Resource rrr1 = new Resource(7)
+try (rrr1) {
+    throw new FileNotFoundException(exMsg)
+} catch(FileNotFoundException e) {
+    assert exMsg == e.getMessage()
+}
+assert Resource.closedResourceIds == [7]
+
+// test case 8
+Resource rrr2 = new Resource(8)
+Resource.closedResourceIds = []
+try (Resource r1 = new Resource(7);
+rrr2) {
+    throw new FileNotFoundException(exMsg)
+} catch(FileNotFoundException e) {
+    assert exMsg == e.getMessage()
+}
+assert Resource.closedResourceIds == [8, 7]
+
+
+// test case 9
+Resource.closedResourceIds = []
+a = 1;
+Resource rrrr1 = new Resource(3)
+try (rrrr1) {
+    a = 2;
+} catch (IOException e) {
+    assert Resource.exMsg == e.getMessage()
+}
+assert 2 == a;
+assert Resource.closedResourceIds == []
+
+
+// test case 10
+Resource.closedResourceIds = []
+a = 1;
+Resource rrrrr1 = new Resource(3);
+Resource rrrrr2 = new Resource(4);
+try (rrrrr1; rrrrr2) {
+    a = 2;
+} catch (IOException e) {
+    assert Resource.exMsg == e.getMessage()
+}
+assert 2 == a;
+assert Resource.closedResourceIds == [4]
+
+// test case 11
+Resource.closedResourceIds = []
+a = 1;
+Resource rrrrrr0 = new Resource(2);
+Resource rrrrrr2 = new Resource(4)
+try (rrrrrr0;
+Resource rrrrrr1 = new Resource(3); rrrrrr2) {
+    a = 2;
+} catch (IOException e) {
+    assert Resource.exMsg == e.getMessage()
+}
+assert 2 == a;
+assert Resource.closedResourceIds == [4, 2]
+
+
+// test case 12
+Resource.closedResourceIds = []
+Resource rrrrrrr1 = new Resource(3);
+Resource rrrrrrr2 = new Resource(4)
+try (rrrrrrr1;
+rrrrrrr2) {
+    throw new FileNotFoundException(exMsg)
+} catch(FileNotFoundException e) {
+    assert exMsg == e.getMessage()
+
+    def suppressedExceptions = e.getSuppressed();
+    assert suppressedExceptions.length == 1
+    assert suppressedExceptions[0] instanceof IOException
+    assert suppressedExceptions[0].getMessage() == Resource.exMsg
+}
+assert Resource.closedResourceIds == [4]
+
+// test case 13
+Resource.closedResourceIds = []
+Resource rrrrrrrr2 = new Resource(4)
+try (Resource r0 = new Resource(2);
+Resource r1 = new Resource(3);
+rrrrrrrr2) {
+    throw new FileNotFoundException(exMsg)
+} catch(FileNotFoundException e) {
+    assert exMsg == e.getMessage()
+
+    def suppressedExceptions = e.getSuppressed();
+    assert suppressedExceptions.length == 1
+    assert suppressedExceptions[0] instanceof IOException
+    assert suppressedExceptions[0].getMessage() == Resource.exMsg
+}
+assert Resource.closedResourceIds == [4, 2]
+
+// test case 14
+Resource.closedResourceIds = []
+a = 1;
+Resource rrrrrrrrr1 = new Resource(1)
+try (rrrrrrrrr1) {
+    a += 2;
+    Resource rrrrrrrrr2 = new Resource(2);
+    Resource rrrrrrrrr4 = new Resource(4)
+    try (rrrrrrrrr2; rrrrrrrrr4) {
+        a += 3;
+        Resource rrrrrrrrr6 = new Resource(6)
+        try (Resource r5 = new Resource(5); rrrrrrrrr6; Resource r7 = new Resource(7)) {
+            a += 4;
+            try {
+                Resource rrrrrrrrr3 = new Resource(3)
+                try (rrrrrrrrr3) {
+                    a += 5;
+                }
+            } catch (IOException e) {
+                assert Resource.exMsg == e.getMessage()
+            }
+        }
+    } catch(Exception e) {
+        // ignored
+    } finally {
+        a += 10
+    }
+}
+assert Resource.closedResourceIds == [7, 6, 5, 4, 2, 1]
+assert 25 == a
+
+// test case 15
+@CompileStatic
+void tryWithResources() {
+    Resource.closedResourceIds = []
+    int cs = 1;
+    Resource r1 = new Resource(1)
+    try (r1) {
+        cs += 2;
+        Resource r2 = new Resource(2);
+        Resource r4 = new Resource(4)
+        try (r2; r4) {
+            cs += 3;
+            Resource r6 = new Resource(6);
+            try (Resource r5 = new Resource(5); r6; Resource r7 = new Resource(7)) {
+                cs += 4;
+                try {
+                    Resource r3 = new Resource(3)
+                    try (r3) {
+                        cs += 5;
+                    }
+                } catch (IOException e) {
+                    assert Resource.exMsg == e.getMessage()
+                }
+            }
+        } catch(Exception e) {
+            // ignored
+        } finally {
+            cs += 10
+        }
+    }
+    assert Resource.closedResourceIds == [7, 6, 5, 4, 2, 1]
+    assert 25 == cs
+}
+
+tryWithResources()
+
+
+// test case 16
+Resource.closedResourceIds = []
+a = 1;
+Resource rrrrrrrrrr1 = new Resource(
+        1
+)
+try (
+        rrrrrrrrrr1
+        Resource r2 = new Resource(2)
+) {
+    a = 2;
+}
+assert Resource.closedResourceIds == [2, 1]
+assert 2 == a
+
+// test case 17
+Resource.closedResourceIds = []
+a = 1;
+rrrrrrrrrrr2 = new Resource(2)
+try (r1 = new Resource(1)
+rrrrrrrrrrr2) {
+    a = 2;
+}
+assert Resource.closedResourceIds == [2, 1]
+assert 2 == a
+

Commit:
622b1487a0583c3017078090b0684987918999cd
Paul King
paulk@asert.com.au
2018-05-24 14:21:58 +1000
move a strangely placed test
diff --git a/subprojects/groovy-test/src/test/groovy/groovy/lang/SpreadMapTest.java b/src/test/groovy/lang/SpreadMapTest.java
similarity index 100%
rename from subprojects/groovy-test/src/test/groovy/groovy/lang/SpreadMapTest.java
rename to src/test/groovy/lang/SpreadMapTest.java

Commit:
01ac72f35207ddb3cd8fb5ca534c1a0af74d366e
Paul King
paulk@asert.com.au
2018-05-24 12:39:39 +1000
GROOVY-8597: SqlGroovyMethods could be moved to avoid split packages - part (2)
diff --git a/subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java b/subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java
deleted file mode 100644
index b69c993002..0000000000
--- a/subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.runtime;
-
-import groovy.sql.GroovyResultSet;
-import groovy.sql.GroovyRowResult;
-import groovy.sql.ResultSetMetaDataWrapper;
-import org.apache.groovy.sql.extensions.SqlExtensions;
-
-import java.sql.ResultSet;
-import java.sql.ResultSetMetaData;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.util.Date;
-import java.util.Iterator;
-
-/**
- * @deprecated use org.apache.groovy.sql.extensions.SqlExtensions
- */
-@Deprecated
-public class SqlGroovyMethods {
-
-    @Deprecated
-    public static GroovyRowResult toRowResult(ResultSet rs) throws SQLException {
-        return SqlExtensions.toRowResult(rs);
-    }
-
-    @Deprecated
-    public static Timestamp toTimestamp(Date d) {
-        return SqlExtensions.toTimestamp(d);
-    }
-
-    @Deprecated
-    public static boolean asBoolean(GroovyResultSet grs) {
-        return true;
-    }
-
-    @Deprecated
-    public static Iterator<ResultSetMetaDataWrapper> iterator(ResultSetMetaData resultSetMetaData) {
-        return SqlExtensions.iterator(resultSetMetaData);
-    }
-
-}

Commit:
f8801bdaf3d33474b98e56d170198a1c227a030d
Paul King
paulk@asert.com.au
2018-05-24 12:35:59 +1000
GROOVY-8594: DocGenerator could be moved to avoid split packages - part (2)
diff --git a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy b/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
deleted file mode 100644
index 79b33cba09..0000000000
--- a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.tools
-
-@Deprecated
-class DocGenerator {
-    @Delegate
-    org.apache.groovy.docgenerator.DocGenerator delegate
-
-    DocGenerator(List<File> sourceFiles, File outputFolder) {
-        delegate = new org.apache.groovy.docgenerator.DocGenerator(sourceFiles, outputFolder)
-    }
-
-    static void main(String... args) {
-        org.apache.groovy.docgenerator.DocGenerator.main(args)
-    }
-}

Commit:
6ed8e6e8134ce3b22be0fdb2a4d0ef1b17da52cf
Paul King
paulk@asert.com.au
2018-05-24 12:24:44 +1000
trivial refactor
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
index 39a5e71591..64a96c9927 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
@@ -46,8 +46,7 @@ public class PluginDefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static Object next(Enum self) {
         final Method[] methods = self.getClass().getMethods();
-        for (int i = 0; i < methods.length; i++) {
-            Method method = methods[i];
+        for (Method method : methods) {
             if (method.getName().equals("next") && method.getParameterTypes().length == 0) {
                 return InvokerHelper.invokeMethod(self, "next", NO_ARGS);
             }
@@ -67,8 +66,7 @@ public class PluginDefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static Object previous(Enum self) {
         final Method[] methods = self.getClass().getMethods();
-        for (int i = 0; i < methods.length; i++) {
-            Method method = methods[i];
+        for (Method method : methods) {
             if (method.getName().equals("previous") && method.getParameterTypes().length == 0) {
                 return InvokerHelper.invokeMethod(self, "previous", NO_ARGS);
             }
@@ -102,11 +100,11 @@ public class PluginDefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             // is going to be extremely expensive, due to calls to GString#charAt,
             // which is going to re-evaluate the GString for each character!
             return self.append(value.toString());
-        } else if (value instanceof CharSequence) {
+        }
+        if (value instanceof CharSequence) {
             return self.append((CharSequence)value);
-        } else {
-            return self.append(value);
         }
+        return self.append(value);
     }
 
     /**

Commit:
37287ae36d968a1d82c2ee6a090668dea9b13b22
Cedric Champeau
cchampeau@apache.org
2018-05-23 21:21:03 +0200
Merge branch 'cc/faster-groovydoc'
Commit:
06b6126f01482bc201f0ebb5ae31a02156eacd47
Paul King
paulk@asert.com.au
2018-05-24 00:39:29 +1000
GROOVY-8596: SqlGroovyMethods could be moved to avoid split packages - part (1) (closes #716)
diff --git a/gradle/docs.gradle b/gradle/docs.gradle
index a7643d068d..7b64132cbd 100644
--- a/gradle/docs.gradle
+++ b/gradle/docs.gradle
@@ -155,7 +155,7 @@ task docGDK {
                     arg(value: 'subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilExtensions.java')
                     arg(value: 'subprojects/groovy-datetime/src/main/java/org/apache/groovy/dateutil/extensions/DateTimeExtensions.java')
                     arg(value: 'subprojects/groovy-datetime/src/main/java/org/apache/groovy/dateutil/extensions/DateTimeStaticExtensions.java')
-                    arg(value: 'subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java')
+                    arg(value: 'subprojects/groovy-sql/src/main/java/org/apache/groovy/sql/extensions/SqlExtensions.java')
                     arg(value: 'subprojects/groovy-swing/src/main/java/org/codehaus/groovy/runtime/SwingGroovyMethods.java')
                     arg(value: 'subprojects/groovy-xml/src/main/java/org/codehaus/groovy/runtime/XmlGroovyMethods.java')
                     arg(value: 'subprojects/groovy-nio/src/main/java/org/codehaus/groovy/runtime/NioGroovyMethods.java')
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 57e0a8c08a..86e2085f3a 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -206,7 +206,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
 //            DateUtilExtensions.class,
 //            DateTimeStaticExtensions.class,
 //            DateTimeExtensions.class,
-//            SqlGroovyMethods.class,
+//            SqlExtensions.class,
 //            SwingGroovyMethods.class,
 //            XmlGroovyMethods.class,
 //            NioGroovyMethods.class
diff --git a/subprojects/groovy-sql/build.gradle b/subprojects/groovy-sql/build.gradle
index b872f66a2d..eb70ce4522 100644
--- a/subprojects/groovy-sql/build.gradle
+++ b/subprojects/groovy-sql/build.gradle
@@ -33,7 +33,7 @@ tasks.withType(Test) {
 }
 
 task moduleDescriptor(type: org.codehaus.groovy.gradle.WriteExtensionDescriptorTask) {
-    extensionClasses = 'org.codehaus.groovy.runtime.SqlGroovyMethods'
+    extensionClasses = 'org.apache.groovy.sql.extensions.SqlExtensions'
 }
 
 compileJava.dependsOn moduleDescriptor
diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/ResultSetMetaDataWrapper.java b/subprojects/groovy-sql/src/main/java/groovy/sql/ResultSetMetaDataWrapper.java
index 05ccdb3b60..025d171706 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/ResultSetMetaDataWrapper.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/ResultSetMetaDataWrapper.java
@@ -38,8 +38,7 @@ import java.sql.ResultSetMetaData;
  * <p>
  * This wrapper is created by an iterator invoked for <code>ResultSetMetaData</code>.
  *
- * @author John Hurst
- * @see org.codehaus.groovy.runtime.SqlGroovyMethods
+ * @see org.apache.groovy.sql.extensions.SqlExtensions
  */
 public class ResultSetMetaDataWrapper extends GroovyObjectSupport {
 
diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
index da61e9f3d7..a78c755dc4 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
@@ -52,7 +52,7 @@ import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static org.codehaus.groovy.runtime.SqlGroovyMethods.toRowResult;
+import static org.apache.groovy.sql.extensions.SqlExtensions.toRowResult;
 
 /**
  * A facade over Java's normal JDBC APIs providing greatly simplified
diff --git a/subprojects/groovy-sql/src/main/java/org/apache/groovy/sql/extensions/SqlExtensions.java b/subprojects/groovy-sql/src/main/java/org/apache/groovy/sql/extensions/SqlExtensions.java
new file mode 100644
index 0000000000..3540df9755
--- /dev/null
+++ b/subprojects/groovy-sql/src/main/java/org/apache/groovy/sql/extensions/SqlExtensions.java
@@ -0,0 +1,123 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.groovy.sql.extensions;
+
+import groovy.lang.GroovyRuntimeException;
+import groovy.sql.GroovyResultSet;
+import groovy.sql.GroovyRowResult;
+import groovy.sql.ResultSetMetaDataWrapper;
+
+import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
+import java.sql.SQLException;
+import java.sql.Timestamp;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * This class defines all the new SQL-related groovy methods which enhance
+ * the normal JDK SQL classes when inside the Groovy environment.
+ * Static methods are used with the first parameter the destination class.
+ */
+public class SqlExtensions {
+
+    /**
+     * Returns a GroovyRowResult given a ResultSet.
+     *
+     * @param rs a ResultSet
+     * @return the resulting GroovyRowResult
+     * @throws java.sql.SQLException if a database error occurs
+     * @since 1.6.0
+     */
+    public static GroovyRowResult toRowResult(ResultSet rs) throws SQLException {
+        ResultSetMetaData metadata = rs.getMetaData();
+        Map<String, Object> lhm = new LinkedHashMap<String, Object>(metadata.getColumnCount(), 1);
+        for (int i = 1; i <= metadata.getColumnCount(); i++) {
+            lhm.put(metadata.getColumnLabel(i), rs.getObject(i));
+        }
+        return new GroovyRowResult(lhm);
+    }
+
+    /**
+     * Return a java.sql.Timestamp given a java.util.Date.
+     *
+     * @param d a date
+     * @return the date wrapped as a Timestamp
+     * @since 1.6.6
+     */
+    public static Timestamp toTimestamp(Date d) {
+        return new Timestamp(d.getTime());
+    }
+
+    /**
+     * Coerce a GroovyResultSet to a boolean value.
+     * A GroovyResultSet is coerced to false if there are no more rows to iterate over,
+     * and to true otherwise.
+     *
+     * @param grs the GroovyResultSet
+     * @return the boolean value
+     * @since 1.7.0
+     */
+    public static boolean asBoolean(GroovyResultSet grs) {
+        //TODO: check why this asBoolean() method is needed for SqlTest to pass with custom boolean coercion in place
+        return true;
+    }
+
+    /**
+     * Return an Iterator given a ResultSetMetaData.
+     *
+     * Enables Groovy collection method syntactic sugar on ResultSetMetaData.
+     *
+     * @param resultSetMetaData the ResultSetMetaData to iterate over
+     * @return an iterator for the ResultSetMetaData
+     * @since 1.7
+     */
+    public static Iterator<ResultSetMetaDataWrapper> iterator(ResultSetMetaData resultSetMetaData) {
+        return new ResultSetMetaDataIterator(resultSetMetaData);
+    }
+
+    private static class ResultSetMetaDataIterator implements Iterator<ResultSetMetaDataWrapper> {
+        private final ResultSetMetaData target;
+        private int index = 1;
+
+        public ResultSetMetaDataIterator(ResultSetMetaData target) {
+            this.target = target;
+        }
+
+        public boolean hasNext() {
+            try {
+                return index <= target.getColumnCount();
+            }
+            catch (SQLException ex) {
+                throw new GroovyRuntimeException("Unable to obtain column count from ResultSetMetaData", ex);
+            }
+        }
+
+        public ResultSetMetaDataWrapper next() {
+            return new ResultSetMetaDataWrapper(target, index++);
+        }
+
+        public void remove() {
+            throw new UnsupportedOperationException("Cannot remove from ResultSetMetaData");
+        }
+    }
+
+}
diff --git a/subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java b/subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java
index af426c7040..b69c993002 100644
--- a/subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java
+++ b/subprojects/groovy-sql/src/main/java/org/codehaus/groovy/runtime/SqlGroovyMethods.java
@@ -18,10 +18,10 @@
  */
 package org.codehaus.groovy.runtime;
 
-import groovy.lang.GroovyRuntimeException;
 import groovy.sql.GroovyResultSet;
 import groovy.sql.GroovyRowResult;
 import groovy.sql.ResultSetMetaDataWrapper;
+import org.apache.groovy.sql.extensions.SqlExtensions;
 
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
@@ -29,98 +29,31 @@ import java.sql.SQLException;
 import java.sql.Timestamp;
 import java.util.Date;
 import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.Map;
 
 /**
- * This class defines all the new SQL-related groovy methods which enhance
- * the normal JDK SQL classes when inside the Groovy environment.
- * Static methods are used with the first parameter the destination class.
- *
- * @author Paul King
- * @author John Hurst
+ * @deprecated use org.apache.groovy.sql.extensions.SqlExtensions
  */
+@Deprecated
 public class SqlGroovyMethods {
 
-    /**
-     * Returns a GroovyRowResult given a ResultSet.
-     *
-     * @param rs a ResultSet
-     * @return the resulting GroovyRowResult
-     * @throws java.sql.SQLException if a database error occurs
-     * @since 1.6.0
-     */
+    @Deprecated
     public static GroovyRowResult toRowResult(ResultSet rs) throws SQLException {
-        ResultSetMetaData metadata = rs.getMetaData();
-        Map<String, Object> lhm = new LinkedHashMap<String, Object>(metadata.getColumnCount(), 1);
-        for (int i = 1; i <= metadata.getColumnCount(); i++) {
-            lhm.put(metadata.getColumnLabel(i), rs.getObject(i));
-        }
-        return new GroovyRowResult(lhm);
+        return SqlExtensions.toRowResult(rs);
     }
 
-    /**
-     * Return a java.sql.Timestamp given a java.util.Date.
-     *
-     * @param d a date
-     * @return the date wrapped as a Timestamp
-     * @since 1.6.6
-     */
+    @Deprecated
     public static Timestamp toTimestamp(Date d) {
-        return new Timestamp(d.getTime());
+        return SqlExtensions.toTimestamp(d);
     }
 
-    /**
-     * Coerce a GroovyResultSet to a boolean value.
-     * A GroovyResultSet is coerced to false if there are no more rows to iterate over,
-     * and to true otherwise.
-     *
-     * @param grs the GroovyResultSet
-     * @return the boolean value
-     * @since 1.7.0
-     */
+    @Deprecated
     public static boolean asBoolean(GroovyResultSet grs) {
-        //TODO: check why this asBoolean() method is needed for SqlTest to pass with custom boolean coercion in place
         return true;
     }
 
-    /**
-     * Return an Iterator given a ResultSetMetaData.
-     *
-     * Enables Groovy collection method syntactic sugar on ResultSetMetaData.
-     *
-     * @param resultSetMetaData the ResultSetMetaData to iterate over
-     * @return an iterator for the ResultSetMetaData
-     * @since 1.7
-     */
+    @Deprecated
     public static Iterator<ResultSetMetaDataWrapper> iterator(ResultSetMetaData resultSetMetaData) {
-        return new ResultSetMetaDataIterator(resultSetMetaData);
-    }
-
-    private static class ResultSetMetaDataIterator implements Iterator<ResultSetMetaDataWrapper> {
-        private final ResultSetMetaData target;
-        private int index = 1;
-
-        public ResultSetMetaDataIterator(ResultSetMetaData target) {
-            this.target = target;
-        }
-
-        public boolean hasNext() {
-            try {
-                return index <= target.getColumnCount();
-            }
-            catch (SQLException ex) {
-                throw new GroovyRuntimeException("Unable to obtain column count from ResultSetMetaData", ex);
-            }
-        }
-
-        public ResultSetMetaDataWrapper next() {
-            return new ResultSetMetaDataWrapper(target, index++);
-        }
-
-        public void remove() {
-            throw new UnsupportedOperationException("Cannot remove from ResultSetMetaData");
-        }
+        return SqlExtensions.iterator(resultSetMetaData);
     }
 
 }

Commit:
c8e8c7b67069a91a0e80e8be45140d42737c91c9
Paul King
paulk@asert.com.au
2018-05-24 00:36:13 +1000
GROOVY-8593: DocGenerator could be moved to avoid split packages (closes #715)
diff --git a/gradle/docs.gradle b/gradle/docs.gradle
index de9c66b8ae..a7643d068d 100644
--- a/gradle/docs.gradle
+++ b/gradle/docs.gradle
@@ -128,7 +128,7 @@ task docGDK {
     doLast { task ->
         try {
             ant {
-                java(classname: 'org.codehaus.groovy.tools.DocGenerator',
+                java(classname: 'org.apache.groovy.docgenerator.DocGenerator',
                      fork: 'true',
                      failonerror: 'true',
                      classpath: (sourceSets.main.runtimeClasspath + rootProject.files(docProjectVersionInfo.destinationDir) + configurations.tools + groovydocAll.groovyClasspath + docGeneratorPath).asPath,
diff --git a/src/test/org/codehaus/groovy/tools/DocGeneratorMain.java b/src/test/org/codehaus/groovy/tools/DocGeneratorMain.java
deleted file mode 100644
index b07685ed7a..0000000000
--- a/src/test/org/codehaus/groovy/tools/DocGeneratorMain.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.tools;
-
-import groovy.lang.GroovyShell;
-
-import java.io.File;
-
-public class DocGeneratorMain {
-
-    public static void main(String[] args) {
-        try {
-            GroovyShell shell = new GroovyShell();
-            //shell.run("src/main/org/codehaus/groovy/tools/DocGenerator.groovy", "org.codehaus.groovy.tools.DocGenerator.groovy", args);
-            shell.run(new File("src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy"), args);
-        }
-        catch (Exception e) {
-            System.out.println("Failed: " + e);
-            e.printStackTrace();
-        }
-    }
-}
diff --git a/subprojects/groovy-docgenerator/src/main/groovy/org/apache/groovy/docgenerator/DocGenerator.groovy b/subprojects/groovy-docgenerator/src/main/groovy/org/apache/groovy/docgenerator/DocGenerator.groovy
new file mode 100644
index 0000000000..da325d7c7d
--- /dev/null
+++ b/subprojects/groovy-docgenerator/src/main/groovy/org/apache/groovy/docgenerator/DocGenerator.groovy
@@ -0,0 +1,546 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.groovy.docgenerator
+
+import com.thoughtworks.qdox.JavaDocBuilder
+import com.thoughtworks.qdox.model.JavaClass
+import com.thoughtworks.qdox.model.JavaMethod
+import com.thoughtworks.qdox.model.JavaParameter
+import com.thoughtworks.qdox.model.Type
+import groovy.cli.picocli.CliBuilder
+import groovy.text.SimpleTemplateEngine
+import groovy.text.Template
+import groovy.text.TemplateEngine
+import org.codehaus.groovy.runtime.DefaultGroovyMethods
+import org.codehaus.groovy.tools.shell.util.Logger
+import org.codehaus.groovy.tools.shell.util.MessageSource
+
+import java.text.BreakIterator
+import java.util.concurrent.ConcurrentHashMap
+
+/**
+ * Generate documentation about the methods provided by the Groovy Development Kit
+ * that enhance the standard JDK classes.
+ */
+class DocGenerator {
+    private static final MessageSource messages = new MessageSource(DocGenerator)
+    private static final Logger log = Logger.create(DocGenerator)
+    private static final Comparator SORT_KEY_COMPARATOR = [compare: { a, b -> return a.sortKey.compareTo(b.sortKey) }] as Comparator
+    private static final Map<String, Object> CONFIG = new ConcurrentHashMap<String, Object>();
+
+    List<File> sourceFiles
+    File outputDir
+    DocSource docSource
+
+    DocGenerator(List<File> sourceFiles, File outputFolder) {
+        this.sourceFiles = sourceFiles
+        this.outputDir = outputFolder
+        this.docSource = parseSource(sourceFiles)
+    }
+
+    /**
+     * Parse the *GroovyMethods (DGM) classes to build a graph representing the structure of the class,
+     * with its methods, javadoc comments and tags.
+     */
+    private static DocSource parseSource(List<File> sourceFiles) {
+        JavaDocBuilder builder = new JavaDocBuilder()
+        sourceFiles.each {
+            if (it.exists()) {
+                builder.addSource(it.newReader())
+                log.debug "adding reader for $it"
+            } else {
+                log.debug "not found, skipping: $it.path"
+            }
+        }
+
+        def methods = builder.sources.collectMany { source ->
+            source.classes.collectMany { aClass ->
+                aClass.methods.findAll { !it.annotations.any { it.type.fullyQualifiedName == 'java.lang.Deprecated' } }
+            }
+        }
+
+        def docSource = new DocSource()
+        methods.each { JavaMethod method ->
+            if (!method.isPublic() || !method.isStatic()) {
+                return // skip it
+            }
+
+            def firstParam = method.parameters[0]
+            def firstParamType = firstParam.resolvedValue.isEmpty() ? firstParam.type : new Type(firstParam.resolvedValue, 0, firstParam.parentClass)
+            docSource.add(firstParamType, method)
+        }
+        docSource.populateInheritedMethods()
+        return docSource
+    }
+
+    /**
+     * Builds an HTML page from the structure of DefaultGroovyMethods.
+     */
+    void generateAll() {
+        def engine = new SimpleTemplateEngine()
+
+        // the index.html
+        def indexTemplate = createTemplate(engine, 'index.html')
+        new File(outputDir, 'index.html').withWriter {
+            it << indexTemplate.make(title: CONFIG.title)
+        }
+
+        // the overview-summary.html
+        def overviewTemplate = createTemplate(engine, 'overview-summary.html')
+        new File(outputDir, 'overview-summary.html').withWriter {
+            it << overviewTemplate.make(title: CONFIG.title)
+        }
+
+        // the overview-frame.html
+        def overviewFrameTemplate = createTemplate(engine, 'template.overview-frame.html')
+        new File(outputDir, 'overview-frame.html').withWriter {
+            def docPackagesExceptPrimitiveType = docSource.packages.findAll { !it.primitive }
+            it << overviewFrameTemplate.make(packages: docPackagesExceptPrimitiveType, title: CONFIG.title)
+        }
+
+        // the package-list
+        new File(outputDir, 'package-list').withWriter { writer ->
+            docSource.packages*.name.each { writer.println it }
+        }
+
+        // the allclasses-frame.html
+        def allClassesTemplate = createTemplate(engine, 'template.allclasses-frame.html')
+        new File(outputDir, 'allclasses-frame.html').withWriter {
+            it << allClassesTemplate.make(docTypes: docSource.allDocTypes, title: CONFIG.title)
+        }
+
+        // the package-frame.html and package-summary.html for each package
+        def packageFrameTemplate = createTemplate(engine, 'template.package-frame.html')
+        def packageSummaryTemplate = createTemplate(engine, 'template.package-summary.html')
+        docSource.packages.each { DocPackage docPackage ->
+            def dir = DocUtil.createPackageDirectory(outputDir, docPackage.name)
+            new File(dir, 'package-frame.html').withWriter {
+                it << packageFrameTemplate.make(docPackage: docPackage, title: CONFIG.title)
+            }
+            new File(dir, 'package-summary.html').withWriter {
+                it << packageSummaryTemplate.make(docPackage: docPackage, title: CONFIG.title)
+            }
+        }
+
+        // the class.html for each class
+        def classTemplate = createTemplate(engine, 'template.class.html')
+        docSource.allDocTypes.each { DocType docType ->
+            def dir = DocUtil.createPackageDirectory(outputDir, docType.packageName)
+            new File(dir, docType.simpleClassName + '.html').withWriter {
+                it << classTemplate.make(docType: docType, title: CONFIG.title)
+            }
+        }
+
+        // the index-all.html
+        def indexAllTemplate = createTemplate(engine, 'template.index-all.html')
+        new File(outputDir, 'index-all.html').withWriter {
+            it << indexAllTemplate.make('indexMap': generateIndexMap(), title: CONFIG.title)
+        }
+
+        // copy resources
+        ['groovy.ico', 'stylesheet.css'].each { String resource ->
+            new File(outputDir, resource) << getClass().getResource(resource).bytes
+        }
+    }
+
+    private Template createTemplate(TemplateEngine templateEngine, String resourceFile) {
+        def resourceUrl = getClass().getResource(resourceFile)
+        return templateEngine.createTemplate(resourceUrl.text)
+    }
+
+    /**
+     * Generate an index map for index-all.html.
+     * <p>
+     * This method creates a index map indexed by the first letter of the
+     * method in upper case, the map value is a list of methods.
+     * <p>
+     * e.g.: 'A' : [ m1, m2, m3 .. ]
+     * The values m1, m2, m3 are sorted by the method name, and the parameter signature.
+     * The method names of m1, m2, m3 start either with 'a', or 'A'.
+     *
+     * @return indexMap
+     */
+    private Map generateIndexMap() {
+        def indexItems = []
+        docSource.allDocTypes.each { DocType docType ->
+            // the class
+            indexItems << [
+                index: docType.simpleClassName.capitalize()[0],
+                docType: docType,
+                sortKey: docType.sortKey,
+            ]
+
+            // the methods
+            docType.docMethods.each { DocMethod docMethod ->
+                indexItems << [
+                    index: docMethod.javaMethod.name.capitalize()[0],
+                    docType: docType,
+                    docMethod: docMethod,
+                    sortKey: docMethod.sortKey
+                ]
+            }
+        }
+        def indexMap = new TreeMap().withDefault { new TreeSet(SORT_KEY_COMPARATOR) }
+        for (indexItem in indexItems) {
+            indexMap[indexItem['index']] << indexItem
+        }
+        return indexMap
+    }
+
+    /**
+     * Main entry point.
+     */
+    static void main(String... args) {
+        def cli = new CliBuilder(usage : 'DocGenerator [options] [sourcefiles]', posix:false)
+        cli.help(longOpt: 'help', messages['cli.option.help.description'])
+        cli._(longOpt: 'version', messages['cli.option.version.description'])
+        cli.o(longOpt: 'outputDir', args:1, argName: 'path', messages['cli.option.output.dir.description'])
+        cli.title(longOpt: 'title', args:1, argName: 'text', messages['cli.option.title.description'])
+        cli.link(args:2, valueSeparator:'=', argName:'comma-separated-package-prefixes=url',
+                messages['cli.option.link.patterns.description'])
+        def options = cli.parse(args)
+
+        if (options.help) {
+            cli.usage()
+            return
+        }
+
+        if (options.links && options.links.size() % 2 == 1) {
+            throw new IllegalArgumentException("Links should be specified in pattern=url pairs")
+        }
+
+        if (options.version) {
+            println messages.format('cli.info.version', GroovySystem.version)
+            return
+        }
+
+        def start = System.currentTimeMillis()
+
+        def outputDir = new File(options.outputDir ?: "target/html/groovy-jdk")
+        outputDir.mkdirs()
+        CONFIG.title = options.title ?: "Groovy JDK"
+        if (options.links) {
+            CONFIG.links = options.links.collate(2).collectMany{ prefixes, url -> prefixes.tokenize(',').collect{[it, url]} }.collectEntries()
+        }
+        CONFIG.locale = Locale.default  // TODO allow locale to be passed in
+
+        def srcFiles = options.arguments().collect { DocUtil.sourceFileOf(it) }
+        try {
+            DefaultGroovyMethods.ADDITIONAL_CLASSES.each { aClass ->
+                def className = aClass.name.replaceAll(/\$.*/, '')
+                def additionalFile = DocUtil.sourceFileOf(className)
+                if (srcFiles.every { it.canonicalPath != additionalFile.canonicalPath }) {
+                    srcFiles << additionalFile
+                }
+            }
+        } catch (MissingPropertyException e) { // TODO is it still needed?
+            // no call site change available, so ignore it
+            log.error e.message, e
+        }
+
+        def docGen = new DocGenerator(srcFiles, outputDir)
+        docGen.generateAll()
+
+        def end = System.currentTimeMillis()
+        log.debug "Done. Took ${end - start} milliseconds."
+    }
+
+    private static class DocSource {
+        SortedSet<DocPackage> packages = new TreeSet<DocPackage>(SORT_KEY_COMPARATOR)
+
+        void add(Type type, JavaMethod javaMethod) {
+            DocType tempDocType = new DocType(type: type)
+
+            DocPackage aPackage = packages.find { it.name == tempDocType.packageName }
+            if (!aPackage) {
+                aPackage = new DocPackage(name: tempDocType.packageName)
+                packages << aPackage
+            }
+
+            DocType docType = aPackage.docTypes.find { it.fullyQualifiedClassName == tempDocType.fullyQualifiedClassName }
+            if (!docType) {
+                docType = tempDocType
+                aPackage.docTypes << docType
+            }
+
+            def docMethod = new DocMethod(declaringDocType: docType, javaMethod: javaMethod)
+            docType.docMethods << docMethod
+        }
+
+        void populateInheritedMethods() {
+            def allTypes = allDocTypes.collectEntries{ [it.fullyQualifiedClassName, it] }
+            allTypes.each { name, docType ->
+                if (name.endsWith('[]') || name.startsWith('primitive-types')) return
+                Type next = docType.javaClass.superClass
+                while (next != null) {
+                    if (allTypes.keySet().contains(next.value)) {
+                        docType.inheritedMethods[allTypes[next.value]] = allTypes[next.value].docMethods
+                    }
+                    next = next.javaClass.superClass
+                }
+                def remaining = docType.javaClass.implementedInterfaces.toList()
+                while (!remaining.isEmpty()) {
+                    def nextInt = remaining.remove(0)
+                    if (allTypes.keySet().contains(nextInt.fullyQualifiedName)) {
+                        docType.inheritedMethods[allTypes[nextInt.fullyQualifiedName]] = allTypes[nextInt.fullyQualifiedName].docMethods
+                    }
+                    remaining.addAll(nextInt.implementedInterfaces.toList())
+                }
+            }
+        }
+
+        SortedSet<DocType> getAllDocTypes() {
+            def allSet = new TreeSet(SORT_KEY_COMPARATOR)
+            allSet.addAll(packages.collectMany { it.docTypes })
+            return allSet
+        }
+    }
+
+    private static class DocPackage {
+        static final String PRIMITIVE_TYPE_PSEUDO_PACKAGE = 'primitive-types'
+        String name
+        SortedSet<DocType> docTypes = new TreeSet<DocType>(SORT_KEY_COMPARATOR)
+
+        boolean isPrimitive() {
+            name == PRIMITIVE_TYPE_PSEUDO_PACKAGE
+        }
+
+        String getSortKey() {
+            name
+        }
+    }
+
+    private static class DocType {
+        private Type type
+        final String shortComment = "" // empty because cannot get a comment of JDK
+        SortedSet<DocMethod> docMethods = new TreeSet<DocMethod>(SORT_KEY_COMPARATOR)
+        Map<String, List<DocMethod>> inheritedMethods = new LinkedHashMap<String, List<DocMethod>>()
+
+        JavaClass getJavaClass() {
+            type.javaClass
+        }
+
+        String getPackageName() {
+            if (type.primitive) {
+                return DocPackage.PRIMITIVE_TYPE_PSEUDO_PACKAGE
+            }
+            def fqcn = fullyQualifiedClassName
+            if (fqcn.indexOf(".") < 0) {
+                return ""
+            }
+            fqcn.replaceAll(/\.[^.]*$/, '')
+        }
+
+        String getSimpleClassName() {
+            fullyQualifiedClassName.replaceAll(/^.*\./, '')
+        }
+
+        String getFullyQualifiedClassName() {
+            if (type.primitive) {
+                return DocPackage.PRIMITIVE_TYPE_PSEUDO_PACKAGE + '.' + type.toString()
+            }
+            DocUtil.resolveJdkClassName(type.toString())
+        }
+
+        boolean isInterface() {
+            type.javaClass.isInterface()
+        }
+
+        String getSortKey() {
+            simpleClassName + ' ' + fullyQualifiedClassName
+        }
+
+        String linkAnchor(DocType otherDocType) {
+            DocUtil.getLinkAnchor(otherDocType.fullyQualifiedClassName, packageName)
+        }
+    }
+
+    private static class DocMethod {
+        DocType declaringDocType
+        JavaMethod javaMethod
+
+        String getName() {
+            javaMethod.name
+        }
+
+        /**
+         * Retrieve the parameters of the method.
+         *
+         * @param method a method
+         * @return a list of parameters without the first one
+         */
+        List<JavaParameter> getParameters() {
+            if (javaMethod.getParameters().size() > 1) {
+                return javaMethod.getParameters().toList()[1..-1]
+            }
+            return []
+        }
+
+        String getParametersSignature() {
+            parameters.collect { DocUtil.resolveJdkClassName(it.type.toString()) }.join(", ")
+        }
+
+        String getParametersDocUrl() {
+            parameters.collect { "${DocUtil.getLinkAnchor(it.type.toString(), declaringDocType.packageName)} $it.name" }.join(", ")
+        }
+
+        String getReturnTypeDocUrl() {
+            def returnType = javaMethod.returnType
+            def resolvedReturnType = (returnType) ? DocUtil.resolveJdkClassName(returnType.toString()) : ""
+            DocUtil.getLinkAnchor(resolvedReturnType, declaringDocType.packageName)
+        }
+
+        String getComment() {
+            DocUtil.formatJavadocText(javaMethod.comment ?: '', declaringDocType.packageName)
+        }
+
+        String getShortComment() {
+            DocUtil.formatJavadocText(DocUtil.getFirstSentence(javaMethod.comment ?: ''), declaringDocType.packageName)
+        }
+
+        String getReturnComment() {
+            DocUtil.formatJavadocText(javaMethod.getTagByName("return")?.value ?: '', declaringDocType.packageName)
+        }
+
+        Map getParameterComments() {
+            javaMethod.getTagsByName("param").drop(1).collectEntries { // first arg is the "real this"
+                def name = it.value.replaceAll(/ .*/, '')
+                def comment = DocUtil.formatJavadocText(it.value.replaceAll(/^\w*/, ''), declaringDocType.packageName)
+                [name, comment]
+            }
+        }
+
+        List<String> getSeeComments() {
+            javaMethod.getTagsByName("see").collect { DocUtil.getLinkAnchor(it.value, declaringDocType.packageName) }
+        }
+
+        String getSinceComment() {
+            javaMethod.getTagByName("since")?.value
+        }
+
+        boolean isStatic() {
+            javaMethod.parentClass.name == 'DefaultGroovyStaticMethods'
+        }
+
+        String getSortKey() {
+            name + ' ' + parametersSignature + ' ' + declaringDocType.fullyQualifiedClassName
+        }
+    }
+
+    private static class DocUtil {
+        static String resolveJdkClassName(String className) {
+            if (className in 'A'..'Z') {
+                return 'java.lang.Object'
+            }
+            if (className in ('A'..'Z').collect{ it + '[]' }) {
+                return 'java.lang.Object[]'
+            }
+            return className
+        }
+
+        static String formatJavadocText(String text, String packageName) {
+            linkify(codify(text), packageName)
+        }
+
+        private static String linkify(String text, String packageName) {
+            text.replaceAll(/\{@link\s+([^}]*)\s*\}/) { String all, String destination ->
+                // A class name cannot be omitted: https://issues.apache.org/jira/browse/GROOVY-6740 TODO: remove DocUtil once fixed?
+                DocUtil.getLinkAnchor(destination, packageName)
+            }
+        }
+
+        private static String codify(String text) {
+            text.replaceAll(/\{@code\s+([^}]*)\s*\}/) { String all, String code -> """<code>${code}</code>""" }
+        }
+
+        static String getFirstSentence(String text) {
+            def boundary = BreakIterator.getSentenceInstance(CONFIG.locale)
+            boundary.setText(text)
+            int start = boundary.first()
+            int end = boundary.next()
+            if (start > -1 && end > -1) {
+                return text.substring(start, end)
+            }
+            return text
+        }
+
+        static String getLinkAnchor(String destination, String originPackageName) {
+            // resolving a destination if it's in GDK.
+            def inGdk = destination.startsWith('#')
+            if (inGdk) {
+                (destination =~ /#([^(]*)\(([^)]+)\)/).each { String all, String name, String argsText ->
+                    def args = argsText.split(/,\s?/).toList()
+                    def first = args.remove(0)
+                    destination = "$first#$name(${args.join(', ')})".toString()
+                }
+            }
+
+            def fullyQualifiedClassName = resolveJdkClassName(destination.replaceFirst(/#.*$/, ''))
+            def methodSignatureHash = destination.replaceFirst(/^[^#]*/, '')
+            def simpleClassName = fullyQualifiedClassName.replaceFirst(/.*\./, "")
+            def packageName = fullyQualifiedClassName.replaceFirst(/.?[^.]+$/, '')
+
+            // If a package is empty, a destination text should be just returned
+            // because a link to the right documentation location cannot be made.
+            if (packageName.empty) {
+                return destination
+            }
+
+            def apiBaseUrl, title
+            if (inGdk) {
+                apiBaseUrl = '../' * (originPackageName.count('.') + 1)
+                title = "GDK enhancement for ${fullyQualifiedClassName}"
+            } else {
+                title = "Class in $packageName"
+                apiBaseUrl = './'
+                String key = CONFIG.links.keySet().find{ packageName.startsWith(it) }
+                if (key) {
+                    apiBaseUrl = CONFIG.links[key]
+                    if (apiBaseUrl.startsWith('..')) apiBaseUrl = '../' * (originPackageName.count('.') + 1) + apiBaseUrl
+
+                }
+            }
+
+            def url = "${apiBaseUrl}${packageName.replace('.', '/')}/${simpleClassName}.html${methodSignatureHash}"
+            return """<a href="$url" title="$title">${simpleClassName}${methodSignatureHash}</a>"""
+        }
+
+        static File createPackageDirectory(File outputDir, String packageName) {
+            def packagePath = filePathOf(packageName)
+            def dir = new File(outputDir, packagePath)
+            dir.mkdirs()
+            return dir
+        }
+
+        private static String filePathOf(String packageName) {
+            def fileSep = File.separator
+            // need to escape separator on windows for regex's sake
+            if (fileSep == '\\') fileSep *= 2
+            return packageName.replaceAll(/\./, fileSep)
+        }
+
+        static File sourceFileOf(String pathOrClassName) {
+            // TODO don't hardcode like this
+            if (pathOrClassName.contains("/")) {
+                return new File(pathOrClassName)
+            }
+            new File("src/main/java/" + pathOrClassName.replace('.', '/') + ".java")
+        }
+    }
+}
diff --git a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy b/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
index 3822935f4d..79b33cba09 100644
--- a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
+++ b/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
@@ -18,529 +18,16 @@
  */
 package org.codehaus.groovy.tools
 
-import com.thoughtworks.qdox.JavaDocBuilder
-import com.thoughtworks.qdox.model.JavaClass
-import com.thoughtworks.qdox.model.JavaMethod
-import com.thoughtworks.qdox.model.JavaParameter
-import com.thoughtworks.qdox.model.Type
-import groovy.cli.picocli.CliBuilder
-import groovy.text.SimpleTemplateEngine
-import groovy.text.Template
-import groovy.text.TemplateEngine
-import org.codehaus.groovy.runtime.DefaultGroovyMethods
-import org.codehaus.groovy.tools.shell.util.Logger
-import org.codehaus.groovy.tools.shell.util.MessageSource
-
-import java.text.BreakIterator
-import java.util.concurrent.ConcurrentHashMap
-
-/**
- * Generate documentation about the methods provided by the Groovy Development Kit
- * that enhance the standard JDK classes.
- */
+@Deprecated
 class DocGenerator {
-    private static final MessageSource messages = new MessageSource(DocGenerator)
-    private static final Logger log = Logger.create(DocGenerator)
-    private static final Comparator SORT_KEY_COMPARATOR = [compare: { a, b -> return a.sortKey.compareTo(b.sortKey) }] as Comparator
-    private static final Map<String, Object> CONFIG = new ConcurrentHashMap<String, Object>();
-
-    List<File> sourceFiles
-    File outputDir
-    DocSource docSource
+    @Delegate
+    org.apache.groovy.docgenerator.DocGenerator delegate
 
     DocGenerator(List<File> sourceFiles, File outputFolder) {
-        this.sourceFiles = sourceFiles
-        this.outputDir = outputFolder
-        this.docSource = parseSource(sourceFiles)
-    }
-
-    /**
-     * Parse the *GroovyMethods (DGM) classes to build a graph representing the structure of the class,
-     * with its methods, javadoc comments and tags.
-     */
-    private static DocSource parseSource(List<File> sourceFiles) {
-        JavaDocBuilder builder = new JavaDocBuilder()
-        sourceFiles.each {
-            if (it.exists()) {
-                builder.addSource(it.newReader())
-                log.debug "adding reader for $it"
-            } else {
-                log.debug "not found, skipping: $it.path"
-            }
-        }
-
-        def methods = builder.sources.collectMany { source ->
-            source.classes.collectMany { aClass ->
-                aClass.methods.findAll { !it.annotations.any { it.type.fullyQualifiedName == 'java.lang.Deprecated' } }
-            }
-        }
-
-        def docSource = new DocSource()
-        methods.each { JavaMethod method ->
-            if (!method.isPublic() || !method.isStatic()) {
-                return // skip it
-            }
-
-            def firstParam = method.parameters[0]
-            def firstParamType = firstParam.resolvedValue.isEmpty() ? firstParam.type : new Type(firstParam.resolvedValue, 0, firstParam.parentClass)
-            docSource.add(firstParamType, method)
-        }
-        docSource.populateInheritedMethods()
-        return docSource
-    }
-
-    /**
-     * Builds an HTML page from the structure of DefaultGroovyMethods.
-     */
-    void generateAll() {
-        def engine = new SimpleTemplateEngine()
-
-        // the index.html
-        def indexTemplate = createTemplate(engine, 'index.html')
-        new File(outputDir, 'index.html').withWriter {
-            it << indexTemplate.make(title: CONFIG.title)
-        }
-
-        // the overview-summary.html
-        def overviewTemplate = createTemplate(engine, 'overview-summary.html')
-        new File(outputDir, 'overview-summary.html').withWriter {
-            it << overviewTemplate.make(title: CONFIG.title)
-        }
-
-        // the overview-frame.html
-        def overviewFrameTemplate = createTemplate(engine, 'template.overview-frame.html')
-        new File(outputDir, 'overview-frame.html').withWriter {
-            def docPackagesExceptPrimitiveType = docSource.packages.findAll { !it.primitive }
-            it << overviewFrameTemplate.make(packages: docPackagesExceptPrimitiveType, title: CONFIG.title)
-        }
-
-        // the package-list
-        new File(outputDir, 'package-list').withWriter { writer ->
-            docSource.packages*.name.each { writer.println it }
-        }
-
-        // the allclasses-frame.html
-        def allClassesTemplate = createTemplate(engine, 'template.allclasses-frame.html')
-        new File(outputDir, 'allclasses-frame.html').withWriter {
-            it << allClassesTemplate.make(docTypes: docSource.allDocTypes, title: CONFIG.title)
-        }
-
-        // the package-frame.html and package-summary.html for each package
-        def packageFrameTemplate = createTemplate(engine, 'template.package-frame.html')
-        def packageSummaryTemplate = createTemplate(engine, 'template.package-summary.html')
-        docSource.packages.each { DocPackage docPackage ->
-            def dir = DocUtil.createPackageDirectory(outputDir, docPackage.name)
-            new File(dir, 'package-frame.html').withWriter {
-                it << packageFrameTemplate.make(docPackage: docPackage, title: CONFIG.title)
-            }
-            new File(dir, 'package-summary.html').withWriter {
-                it << packageSummaryTemplate.make(docPackage: docPackage, title: CONFIG.title)
-            }
-        }
-
-        // the class.html for each class
-        def classTemplate = createTemplate(engine, 'template.class.html')
-        docSource.allDocTypes.each { DocType docType ->
-            def dir = DocUtil.createPackageDirectory(outputDir, docType.packageName)
-            new File(dir, docType.simpleClassName + '.html').withWriter {
-                it << classTemplate.make(docType: docType, title: CONFIG.title)
-            }
-        }
-
-        // the index-all.html
-        def indexAllTemplate = createTemplate(engine, 'template.index-all.html')
-        new File(outputDir, 'index-all.html').withWriter {
-            it << indexAllTemplate.make('indexMap': generateIndexMap(), title: CONFIG.title)
-        }
-
-        // copy resources
-        ['groovy.ico', 'stylesheet.css'].each { String resource ->
-            new File(outputDir, resource) << getClass().getResource(resource).bytes
-        }
-    }
-
-    private Template createTemplate(TemplateEngine templateEngine, String resourceFile) {
-        def resourceUrl = getClass().getResource(resourceFile)
-        return templateEngine.createTemplate(resourceUrl.text)
-    }
-
-    /**
-     * Generate an index map for index-all.html.
-     * <p>
-     * This method creates a index map indexed by the first letter of the
-     * method in upper case, the map value is a list of methods.
-     * <p>
-     * e.g.: 'A' : [ m1, m2, m3 .. ]
-     * The values m1, m2, m3 are sorted by the method name, and the parameter signature.
-     * The method names of m1, m2, m3 start either with 'a', or 'A'.
-     *
-     * @return indexMap
-     */
-    private Map generateIndexMap() {
-        def indexItems = []
-        docSource.allDocTypes.each { DocType docType ->
-            // the class
-            indexItems << [
-                index: docType.simpleClassName.capitalize()[0],
-                docType: docType,
-                sortKey: docType.sortKey,
-            ]
-
-            // the methods
-            docType.docMethods.each { DocMethod docMethod ->
-                indexItems << [
-                    index: docMethod.javaMethod.name.capitalize()[0],
-                    docType: docType,
-                    docMethod: docMethod,
-                    sortKey: docMethod.sortKey
-                ]
-            }
-        }
-        def indexMap = new TreeMap().withDefault { new TreeSet(SORT_KEY_COMPARATOR) }
-        for (indexItem in indexItems) {
-            indexMap[indexItem['index']] << indexItem
-        }
-        return indexMap
+        delegate = new org.apache.groovy.docgenerator.DocGenerator(sourceFiles, outputFolder)
     }
 
-    /**
-     * Main entry point.
-     */
     static void main(String... args) {
-        def cli = new CliBuilder(usage : 'DocGenerator [options] [sourcefiles]', posix:false)
-        cli.help(longOpt: 'help', messages['cli.option.help.description'])
-        cli._(longOpt: 'version', messages['cli.option.version.description'])
-        cli.o(longOpt: 'outputDir', args:1, argName: 'path', messages['cli.option.output.dir.description'])
-        cli.title(longOpt: 'title', args:1, argName: 'text', messages['cli.option.title.description'])
-        cli.link(args:2, valueSeparator:'=', argName:'comma-separated-package-prefixes=url',
-                messages['cli.option.link.patterns.description'])
-        def options = cli.parse(args)
-
-        if (options.help) {
-            cli.usage()
-            return
-        }
-
-        if (options.links && options.links.size() % 2 == 1) {
-            throw new IllegalArgumentException("Links should be specified in pattern=url pairs")
-        }
-
-        if (options.version) {
-            println messages.format('cli.info.version', GroovySystem.version)
-            return
-        }
-
-        def start = System.currentTimeMillis()
-
-        def outputDir = new File(options.outputDir ?: "target/html/groovy-jdk")
-        outputDir.mkdirs()
-        CONFIG.title = options.title ?: "Groovy JDK"
-        if (options.links) {
-            CONFIG.links = options.links.collate(2).collectMany{ prefixes, url -> prefixes.tokenize(',').collect{[it, url]} }.collectEntries()
-        }
-        CONFIG.locale = Locale.default  // TODO allow locale to be passed in
-
-        def srcFiles = options.arguments().collect { DocUtil.sourceFileOf(it) }
-        try {
-            DefaultGroovyMethods.ADDITIONAL_CLASSES.each { aClass ->
-                def className = aClass.name.replaceAll(/\$.*/, '')
-                def additionalFile = DocUtil.sourceFileOf(className)
-                if (srcFiles.every { it.canonicalPath != additionalFile.canonicalPath }) {
-                    srcFiles << additionalFile
-                }
-            }
-        } catch (MissingPropertyException e) { // TODO is it still needed?
-            // no call site change available, so ignore it
-            log.error e.message, e
-        }
-
-        def docGen = new DocGenerator(srcFiles, outputDir)
-        docGen.generateAll()
-
-        def end = System.currentTimeMillis()
-        log.debug "Done. Took ${end - start} milliseconds."
-    }
-
-    private static class DocSource {
-        SortedSet<DocPackage> packages = new TreeSet<DocPackage>(SORT_KEY_COMPARATOR)
-
-        void add(Type type, JavaMethod javaMethod) {
-            DocType tempDocType = new DocType(type: type)
-
-            DocPackage aPackage = packages.find { it.name == tempDocType.packageName }
-            if (!aPackage) {
-                aPackage = new DocPackage(name: tempDocType.packageName)
-                packages << aPackage
-            }
-
-            DocType docType = aPackage.docTypes.find { it.fullyQualifiedClassName == tempDocType.fullyQualifiedClassName }
-            if (!docType) {
-                docType = tempDocType
-                aPackage.docTypes << docType
-            }
-
-            def docMethod = new DocMethod(declaringDocType: docType, javaMethod: javaMethod)
-            docType.docMethods << docMethod
-        }
-
-        void populateInheritedMethods() {
-            def allTypes = allDocTypes.collectEntries{ [it.fullyQualifiedClassName, it] }
-            allTypes.each { name, docType ->
-                if (name.endsWith('[]') || name.startsWith('primitive-types')) return
-                Type next = docType.javaClass.superClass
-                while (next != null) {
-                    if (allTypes.keySet().contains(next.value)) {
-                        docType.inheritedMethods[allTypes[next.value]] = allTypes[next.value].docMethods
-                    }
-                    next = next.javaClass.superClass
-                }
-                def remaining = docType.javaClass.implementedInterfaces.toList()
-                while (!remaining.isEmpty()) {
-                    def nextInt = remaining.remove(0)
-                    if (allTypes.keySet().contains(nextInt.fullyQualifiedName)) {
-                        docType.inheritedMethods[allTypes[nextInt.fullyQualifiedName]] = allTypes[nextInt.fullyQualifiedName].docMethods
-                    }
-                    remaining.addAll(nextInt.implementedInterfaces.toList())
-                }
-            }
-        }
-
-        SortedSet<DocType> getAllDocTypes() {
-            def allSet = new TreeSet(SORT_KEY_COMPARATOR)
-            allSet.addAll(packages.collectMany { it.docTypes })
-            return allSet
-        }
-    }
-
-    private static class DocPackage {
-        static final String PRIMITIVE_TYPE_PSEUDO_PACKAGE = 'primitive-types'
-        String name
-        SortedSet<DocType> docTypes = new TreeSet<DocType>(SORT_KEY_COMPARATOR)
-
-        boolean isPrimitive() {
-            name == PRIMITIVE_TYPE_PSEUDO_PACKAGE
-        }
-
-        String getSortKey() {
-            name
-        }
-    }
-
-    private static class DocType {
-        private Type type
-        final String shortComment = "" // empty because cannot get a comment of JDK
-        SortedSet<DocMethod> docMethods = new TreeSet<DocMethod>(SORT_KEY_COMPARATOR)
-        Map<String, List<DocMethod>> inheritedMethods = new LinkedHashMap<String, List<DocMethod>>()
-
-        JavaClass getJavaClass() {
-            type.javaClass
-        }
-
-        String getPackageName() {
-            if (type.primitive) {
-                return DocPackage.PRIMITIVE_TYPE_PSEUDO_PACKAGE
-            }
-            def fqcn = fullyQualifiedClassName
-            if (fqcn.indexOf(".") < 0) {
-                return ""
-            }
-            fqcn.replaceAll(/\.[^.]*$/, '')
-        }
-
-        String getSimpleClassName() {
-            fullyQualifiedClassName.replaceAll(/^.*\./, '')
-        }
-
-        String getFullyQualifiedClassName() {
-            if (type.primitive) {
-                return DocPackage.PRIMITIVE_TYPE_PSEUDO_PACKAGE + '.' + type.toString()
-            }
-            DocUtil.resolveJdkClassName(type.toString())
-        }
-
-        boolean isInterface() {
-            type.javaClass.isInterface()
-        }
-
-        String getSortKey() {
-            simpleClassName + ' ' + fullyQualifiedClassName
-        }
-
-        String linkAnchor(DocType otherDocType) {
-            DocUtil.getLinkAnchor(otherDocType.fullyQualifiedClassName, packageName)
-        }
-    }
-
-    private static class DocMethod {
-        DocType declaringDocType
-        JavaMethod javaMethod
-
-        String getName() {
-            javaMethod.name
-        }
-
-        /**
-         * Retrieve the parameters of the method.
-         *
-         * @param method a method
-         * @return a list of parameters without the first one
-         */
-        List<JavaParameter> getParameters() {
-            if (javaMethod.getParameters().size() > 1) {
-                return javaMethod.getParameters().toList()[1..-1]
-            }
-            return []
-        }
-
-        String getParametersSignature() {
-            parameters.collect { DocUtil.resolveJdkClassName(it.type.toString()) }.join(", ")
-        }
-
-        String getParametersDocUrl() {
-            parameters.collect { "${DocUtil.getLinkAnchor(it.type.toString(), declaringDocType.packageName)} $it.name" }.join(", ")
-        }
-
-        String getReturnTypeDocUrl() {
-            def returnType = javaMethod.returnType
-            def resolvedReturnType = (returnType) ? DocUtil.resolveJdkClassName(returnType.toString()) : ""
-            DocUtil.getLinkAnchor(resolvedReturnType, declaringDocType.packageName)
-        }
-
-        String getComment() {
-            DocUtil.formatJavadocText(javaMethod.comment ?: '', declaringDocType.packageName)
-        }
-
-        String getShortComment() {
-            DocUtil.formatJavadocText(DocUtil.getFirstSentence(javaMethod.comment ?: ''), declaringDocType.packageName)
-        }
-
-        String getReturnComment() {
-            DocUtil.formatJavadocText(javaMethod.getTagByName("return")?.value ?: '', declaringDocType.packageName)
-        }
-
-        Map getParameterComments() {
-            javaMethod.getTagsByName("param").drop(1).collectEntries { // first arg is the "real this"
-                def name = it.value.replaceAll(/ .*/, '')
-                def comment = DocUtil.formatJavadocText(it.value.replaceAll(/^\w*/, ''), declaringDocType.packageName)
-                [name, comment]
-            }
-        }
-
-        List<String> getSeeComments() {
-            javaMethod.getTagsByName("see").collect { DocUtil.getLinkAnchor(it.value, declaringDocType.packageName) }
-        }
-
-        String getSinceComment() {
-            javaMethod.getTagByName("since")?.value
-        }
-
-        boolean isStatic() {
-            javaMethod.parentClass.name == 'DefaultGroovyStaticMethods'
-        }
-
-        String getSortKey() {
-            name + ' ' + parametersSignature + ' ' + declaringDocType.fullyQualifiedClassName
-        }
-    }
-
-    private static class DocUtil {
-        static String resolveJdkClassName(String className) {
-            if (className in 'A'..'Z') {
-                return 'java.lang.Object'
-            }
-            if (className in ('A'..'Z').collect{ it + '[]' }) {
-                return 'java.lang.Object[]'
-            }
-            return className
-        }
-
-        static String formatJavadocText(String text, String packageName) {
-            linkify(codify(text), packageName)
-        }
-
-        private static String linkify(String text, String packageName) {
-            text.replaceAll(/\{@link\s+([^}]*)\s*\}/) { String all, String destination ->
-                // A class name cannot be omitted: https://issues.apache.org/jira/browse/GROOVY-6740 TODO: remove DocUtil once fixed?
-                DocUtil.getLinkAnchor(destination, packageName)
-            }
-        }
-
-        private static String codify(String text) {
-            text.replaceAll(/\{@code\s+([^}]*)\s*\}/) { String all, String code -> """<code>${code}</code>""" }
-        }
-
-        static String getFirstSentence(String text) {
-            def boundary = BreakIterator.getSentenceInstance(CONFIG.locale)
-            boundary.setText(text)
-            int start = boundary.first()
-            int end = boundary.next()
-            if (start > -1 && end > -1) {
-                return text.substring(start, end)
-            }
-            return text
-        }
-
-        static String getLinkAnchor(String destination, String originPackageName) {
-            // resolving a destination if it's in GDK.
-            def inGdk = destination.startsWith('#')
-            if (inGdk) {
-                (destination =~ /#([^(]*)\(([^)]+)\)/).each { String all, String name, String argsText ->
-                    def args = argsText.split(/,\s?/).toList()
-                    def first = args.remove(0)
-                    destination = "$first#$name(${args.join(', ')})".toString()
-                }
-            }
-
-            def fullyQualifiedClassName = resolveJdkClassName(destination.replaceFirst(/#.*$/, ''))
-            def methodSignatureHash = destination.replaceFirst(/^[^#]*/, '')
-            def simpleClassName = fullyQualifiedClassName.replaceFirst(/.*\./, "")
-            def packageName = fullyQualifiedClassName.replaceFirst(/.?[^.]+$/, '')
-
-            // If a package is empty, a destination text should be just returned
-            // because a link to the right documentation location cannot be made.
-            if (packageName.empty) {
-                return destination
-            }
-
-            def apiBaseUrl, title
-            if (inGdk) {
-                apiBaseUrl = '../' * (originPackageName.count('.') + 1)
-                title = "GDK enhancement for ${fullyQualifiedClassName}"
-            } else {
-                title = "Class in $packageName"
-                apiBaseUrl = './'
-                String key = CONFIG.links.keySet().find{ packageName.startsWith(it) }
-                if (key) {
-                    apiBaseUrl = CONFIG.links[key]
-                    if (apiBaseUrl.startsWith('..')) apiBaseUrl = '../' * (originPackageName.count('.') + 1) + apiBaseUrl
-
-                }
-            }
-
-            def url = "${apiBaseUrl}${packageName.replace('.', '/')}/${simpleClassName}.html${methodSignatureHash}"
-            return """<a href="$url" title="$title">${simpleClassName}${methodSignatureHash}</a>"""
-        }
-
-        static File createPackageDirectory(File outputDir, String packageName) {
-            def packagePath = filePathOf(packageName)
-            def dir = new File(outputDir, packagePath)
-            dir.mkdirs()
-            return dir
-        }
-
-        private static String filePathOf(String packageName) {
-            def fileSep = File.separator
-            // need to escape separator on windows for regex's sake
-            if (fileSep == '\\') fileSep *= 2
-            return packageName.replaceAll(/\./, fileSep)
-        }
-
-        static File sourceFileOf(String pathOrClassName) {
-            // TODO don't hardcode like this
-            if (pathOrClassName.contains("/")) {
-                return new File(pathOrClassName)
-            }
-            new File("src/main/java/" + pathOrClassName.replace('.', '/') + ".java")
-        }
+        org.apache.groovy.docgenerator.DocGenerator.main(args)
     }
 }
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/DocGenerator.properties b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/DocGenerator.properties
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/DocGenerator.properties
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/DocGenerator.properties
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/groovy.ico b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/groovy.ico
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/groovy.ico
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/groovy.ico
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/index.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/index.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/index.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/index.html
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/overview-summary.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/overview-summary.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/overview-summary.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/overview-summary.html
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/stylesheet.css b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/stylesheet.css
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/stylesheet.css
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/stylesheet.css
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.allclasses-frame.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.allclasses-frame.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.allclasses-frame.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.allclasses-frame.html
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.class.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.class.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.class.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.class.html
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.index-all.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.index-all.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.index-all.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.index-all.html
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.overview-frame.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.overview-frame.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.overview-frame.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.overview-frame.html
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.package-frame.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.package-frame.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.package-frame.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.package-frame.html
diff --git a/subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.package-summary.html b/subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.package-summary.html
similarity index 100%
rename from subprojects/groovy-docgenerator/src/main/resources/org/codehaus/groovy/tools/template.package-summary.html
rename to subprojects/groovy-docgenerator/src/main/resources/org/apache/groovy/docgenerator/template.package-summary.html

Commit:
711d82a8476ecabecc6101f676d32c2d9ad9e0cc
Paul King
paulk@asert.com.au
2018-05-24 00:08:24 +1000
GROOVY-8600: BUG! exception in phase 'instruction selection'
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
index c93db9e799..5dd83ad2bc 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
@@ -61,7 +61,7 @@ public class MethodCallExpressionTransformer {
         }
         Expression objectExpression = expr.getObjectExpression();
         ClassNode type = staticCompilationTransformer.getTypeChooser().resolveType(objectExpression, staticCompilationTransformer.getClassNode());
-        if (isCallOnClosure(expr)) {
+        if (isCallOnClosure(expr) && staticCompilationTransformer.getClassNode() != null) {
             FieldNode field = staticCompilationTransformer.getClassNode().getField(expr.getMethodAsString());
             if (field != null) {
                 VariableExpression vexp = new VariableExpression(field);
diff --git a/src/test/groovy/bugs/Groovy8600Bug.groovy b/src/test/groovy/bugs/Groovy8600Bug.groovy
new file mode 100644
index 0000000000..43d4093b8b
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8600Bug.groovy
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy8600Bug extends GroovyTestCase {
+    void testClosureFieldUseWithinMethod() {
+        assertScript '''
+            import groovy.transform.CompileStatic
+
+            class TestCompileStatic {
+                private Closure<String> func = { it.toUpperCase() }
+                @CompileStatic
+                def testCallFunc () {
+                    func('foo') + func.call('bar')
+                }
+            }
+
+            assert new TestCompileStatic().testCallFunc() == 'FOOBAR'
+        '''
+    }
+}

Commit:
1936f1844e952a08eb8eacdb6eebb0233f4eed44
Paul King
paulk@asert.com.au
2018-05-24 00:08:24 +1000
fix typo
diff --git a/src/spec/doc/core-semantics.adoc b/src/spec/doc/core-semantics.adoc
index 37f5b42f6b..5fe3f5dee9 100644
--- a/src/spec/doc/core-semantics.adoc
+++ b/src/spec/doc/core-semantics.adoc
@@ -1591,8 +1591,8 @@ The type checker will now fail at compile time, because it knows that `o` is a `
 so it's a type error.
 
 It is important to understand that it is not the fact of declaring a variable with `def` that triggers type inference.
-Flow typing works for *any* variable of any type. Declaring a variable with an explicit type only constraints what you
-can assign to a variable:
+Flow typing works for *any* variable of any type. Declaring a variable with an explicit type only constrains what you
+can assign to the variable:
 
 [source,groovy]
 ----

Commit:
5eab4a5ffbc2e28c442f3e1467f4112b892e6072
sunlan
sunlan@apache.org
2018-05-23 18:35:36 +0800
GROOVY-8599: Bump ivy to 2.5.0-rc1(closes #718)
diff --git a/build.gradle b/build.gradle
index fdcb7fda52..107036ebe3 100644
--- a/build.gradle
+++ b/build.gradle
@@ -152,7 +152,7 @@ ext {
     commonsHttpClientVersion = '3.1'
     eclipseOsgiVersion = '3.9.1-v20140110-1610'
     gparsVersion = '1.2.1'
-    ivyVersion = '2.4.0'
+    ivyVersion = '2.5.0-rc1'
     jansiVersion = '1.17.1'
     jarjarVersion = '1.6.5'
     jlineVersion = '2.14.6'

Commit:
31c93d6755814953e6eb0e92875ffafb8d33b060
Cedric Champeau
cchampeau@apache.org
2018-05-23 12:12:21 +0200
Cache external class lookup
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
index 3522fa1a0c..d9f40a5944 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
@@ -32,6 +32,7 @@ import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
@@ -80,6 +81,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
     private final List<GroovyClassDoc> interfaceClasses;
     private final List<GroovyClassDoc> nested;
     private final List<LinkArgument> links;
+    private final Map<String, Class<?>> resolvedExternalClassesCache;
     private GroovyClassDoc superClass;
     private GroovyClassDoc outer;
     private String superClassName;
@@ -101,6 +103,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
         interfaceNames = new ArrayList<String>();
         interfaceClasses = new ArrayList<GroovyClassDoc>();
         nested = new ArrayList<GroovyClassDoc>();
+        resolvedExternalClassesCache = new HashMap<String, Class<?>>();
     }
 
     public SimpleGroovyClassDoc(List<String> importedClassesAndPackages, Map<String, String> aliases, String name) {
@@ -667,6 +670,18 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
 
     private Class resolveExternalClassFromImport(String name) {
         if (isPrimitiveType(name)) return null;
+        Class<?> clazz = resolvedExternalClassesCache.get(name);
+        if (clazz == null) {
+            if (resolvedExternalClassesCache.containsKey(name)) {
+                return null;
+            }
+            clazz = doResolveExternalClassFromImport(name);
+            resolvedExternalClassesCache.put(name, clazz);
+        }
+        return clazz;
+    }
+
+    private Class doResolveExternalClassFromImport(final String name) {
         for (String importName : importedClassesAndPackages) {
             String candidate = null;
             if (importName.endsWith("/" + name)) {

Commit:
45e3225485ef44385ff7aa3759c2c63932e088f2
Cedric Champeau
cchampeau@apache.org
2018-05-23 12:03:18 +0200
Precompile some regular expressions
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java
index 8dd1d9cb74..cb394020ac 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java
@@ -32,6 +32,8 @@ import java.util.regex.Pattern;
 public class SimpleGroovyDoc implements GroovyDoc, GroovyTokenTypes {
     private static final Pattern TAG2_PATTERN = Pattern.compile("(?s)([a-z]+)\\s+(.*)");
     private static final Pattern TAG3_PATTERN = Pattern.compile("(?s)([a-z]+)\\s+(\\S*)\\s+(.*)");
+    private static final Pattern RAW_COMMENT_PATTERN = Pattern.compile("\"(?s).*?\\\\*\\\\s*@\"");
+    private static final Pattern TRIMMED_COMMENT_PATTERN = Pattern.compile("(?m)^\\s*\\*\\s*([^*]*)$");
     private final String name;
     private String commentText = null;
     private String rawCommentText = "";
@@ -84,9 +86,9 @@ public class SimpleGroovyDoc implements GroovyDoc, GroovyTokenTypes {
     }
 
     private void calculateTags(String rawCommentText) {
-        String trimmed = rawCommentText.replaceFirst("(?s).*?\\*\\s*@", "@");
+        String trimmed = RAW_COMMENT_PATTERN.matcher(rawCommentText).replaceFirst("@");
         if (trimmed.equals(rawCommentText)) return;
-        String cleaned = trimmed.replaceAll("(?m)^\\s*\\*\\s*([^*]*)$", "$1").trim();
+        String cleaned = TRIMMED_COMMENT_PATTERN.matcher(trimmed).replaceAll("$1").trim();
         String[] split = cleaned.split("(?m)^@");
         List<GroovyTag> result = new ArrayList<GroovyTag>();
         for (String s : split) {

Commit:
12d375852d0c83b5e5924a12d09af6035496aaa2
Cedric Champeau
cchampeau@apache.org
2018-05-23 11:58:11 +0200
Cache classNamed lookups
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
index 3748907a50..d88fca3b7b 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
@@ -39,6 +39,7 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
     private final Map<String, String> equivalentPackageImports;
     private List<GroovyClassDoc> classDocValues = null;
     private final Map<String, GroovyClassDoc> cachedResolvedClasses = new HashMap<String, GroovyClassDoc>();
+    private final ClassNamedCache classNamedCache;
 
     private String description = "";
 
@@ -47,6 +48,7 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
         packageDocs = new LinkedHashMap<String, GroovyPackageDoc>();
         classDocs = new LinkedHashMap<String, GroovyClassDoc>();
         equivalentPackageImports = new HashMap<String, String>();
+        classNamedCache = new ClassNamedCache(classDocs);
     }
 
     public GroovyClassDoc classNamed(GroovyClassDoc groovyClassDoc, String name) {
@@ -54,24 +56,7 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
         if (doc != null) {
             return doc;
         }
-        // look for full match or match excluding package
-        String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;
-        boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);
-        if (hasPackage) {
-            fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));
-        }
-
-        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {
-            String key = entry.getKey();
-            int lastSlashIdx = key.lastIndexOf('/');
-            if (lastSlashIdx > 0) {
-                String shortKey = key.substring(lastSlashIdx + 1);
-                if (shortKey.equals(name) && (!hasPackage || key.startsWith(fullPathName))) {
-                    return entry.getValue();
-                }
-            }
-        }
-        return null;
+        return classNamedCache.search(groovyClassDoc, name);
     }
 
     public GroovyClassDoc classNamedExact(String name) {
@@ -175,4 +160,83 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
 
     }
 
+    private static class ClassNamedCache {
+        private final Map<String, GroovyClassDoc> classDocs;
+        private final Map<Entry, GroovyClassDoc> store = new HashMap<>();
+
+        private ClassNamedCache(final Map<String, GroovyClassDoc> classDocs) {
+            this.classDocs = classDocs;
+        }
+
+        public GroovyClassDoc search(GroovyClassDoc groovyClassDoc, String name) {
+            Entry entry = new Entry(groovyClassDoc, name);
+            GroovyClassDoc result = store.get(entry);
+            if (result == null) {
+                if (store.containsKey(entry)) {
+                    return null;
+                }
+                result = performLookup(groovyClassDoc, name);
+                store.put(entry, result);
+            }
+            return result;
+        }
+
+        private GroovyClassDoc performLookup(GroovyClassDoc groovyClassDoc, String name) {
+            // look for full match or match excluding package
+            String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;
+            boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);
+            if (hasPackage) {
+                fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));
+            }
+
+            for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {
+                String key = entry.getKey();
+                int lastSlashIdx = key.lastIndexOf('/');
+                if (lastSlashIdx > 0) {
+                    String shortKey = key.substring(lastSlashIdx + 1);
+                    if (shortKey.equals(name) && (!hasPackage || key.startsWith(fullPathName))) {
+                        GroovyClassDoc value = entry.getValue();
+                        return value;
+                    }
+                }
+            }
+            return null;
+        }
+
+        private static class Entry {
+            private final GroovyClassDoc groovyClass;
+            private final String name;
+            private final int hashCode;
+
+            private Entry(final GroovyClassDoc groovyClass, final String name) {
+                this.groovyClass = groovyClass;
+                this.name = name;
+                this.hashCode = computeHash();
+            }
+
+            @Override
+            public boolean equals(final Object o) {
+                if (this == o) return true;
+                if (o == null || getClass() != o.getClass()) return false;
+
+                final Entry entry = (Entry) o;
+
+                if (groovyClass != null ? !groovyClass.equals(entry.groovyClass) : entry.groovyClass != null)
+                    return false;
+                return name.equals(entry.name);
+            }
+
+            private int computeHash() {
+                int result = groovyClass != null ? groovyClass.hashCode() : 0;
+                result = 31 * result + name.hashCode();
+                return result;
+            }
+
+            @Override
+            public int hashCode() {
+                return hashCode;
+            }
+        }
+    }
+
 }

Commit:
a5c49a01678fe13145c8e32b415f68361544d06b
Cedric Champeau
cchampeau@apache.org
2018-05-23 11:47:19 +0200
Don't use exception for control flow
diff --git a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
index 80da2414cf..1f0d8b5897 100644
--- a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
+++ b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
@@ -62,7 +62,7 @@ public class GroovySourceAST extends CommonAST implements Comparable, SourceInfo
         if (t instanceof SourceInfo) {
             SourceInfo info = (SourceInfo) t;
             lineLast = info.getLineLast();
-            colLast  = info.getColumnLast(); 
+            colLast  = info.getColumnLast();
         }
     }
 
@@ -140,17 +140,16 @@ public class GroovySourceAST extends CommonAST implements Comparable, SourceInfo
     }
 
     public GroovySourceAST childAt(int position) {
-        List list = new ArrayList();
+        int cur = 0;
         AST child = this.getFirstChild();
-        while (child != null) {
-            list.add(child);
+        while (child != null && cur <= position) {
+            if (cur == position) {
+                return (GroovySourceAST) child;
+            }
+            cur++;
             child = child.getNextSibling();
         }
-        try {
-            return (GroovySourceAST)list.get(position);
-        } catch (IndexOutOfBoundsException e) {
-            return null;
-        }
+        return null;
     }
 
     public GroovySourceAST childOfType(int type) {

Commit:
f810c805922155988395ee1f996530987b0b71f6
Cedric Champeau
cchampeau@apache.org
2018-05-23 11:03:47 +0200
Optimize StringBuilder#leftShift for GString case
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
index 208e815c9c..39a5e71591 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy.vmplugin.v5;
 
 import groovy.lang.EmptyRange;
+import groovy.lang.GString;
 import groovy.lang.IntRange;
 import org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport;
 import org.codehaus.groovy.runtime.InvokerHelper;
@@ -96,10 +97,16 @@ public class PluginDefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return the StringBuilder on which this operation was invoked
      */
     public static StringBuilder leftShift(StringBuilder self, Object value) {
-        if (value instanceof CharSequence)
+        if (value instanceof GString) {
+            // Force the conversion of the GString to string now, or appending
+            // is going to be extremely expensive, due to calls to GString#charAt,
+            // which is going to re-evaluate the GString for each character!
+            return self.append(value.toString());
+        } else if (value instanceof CharSequence) {
             return self.append((CharSequence)value);
-        else
+        } else {
             return self.append(value);
+        }
     }
 
     /**

Commit:
af7605f5ff84cb7a381696fb0d3da8c4902ff658
Cedric Champeau
cchampeau@apache.org
2018-05-23 09:59:59 +0200
Implement a bit smarter lookup
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
index 661ff92a2a..3748907a50 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
@@ -55,16 +55,17 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
             return doc;
         }
         // look for full match or match excluding package
+        String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;
+        boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);
+        if (hasPackage) {
+            fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));
+        }
+
         for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {
             String key = entry.getKey();
             int lastSlashIdx = key.lastIndexOf('/');
             if (lastSlashIdx > 0) {
                 String shortKey = key.substring(lastSlashIdx + 1);
-                String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;
-
-                boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);
-                if (hasPackage) fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));
-
                 if (shortKey.equals(name) && (!hasPackage || key.startsWith(fullPathName))) {
                     return entry.getValue();
                 }

Commit:
c5832093ff9992537db1856b7f0dae58e9fe0081
Cedric Champeau
cchampeau@apache.org
2018-05-23 09:49:38 +0200
Perform direct lookup in maps
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
index 6bb49401ac..661ff92a2a 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
@@ -50,10 +50,13 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
     }
 
     public GroovyClassDoc classNamed(GroovyClassDoc groovyClassDoc, String name) {
+        GroovyClassDoc doc = classDocs.get(name);
+        if (doc != null) {
+            return doc;
+        }
         // look for full match or match excluding package
         for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {
             String key = entry.getKey();
-            if (key.equals(name)) return entry.getValue();
             int lastSlashIdx = key.lastIndexOf('/');
             if (lastSlashIdx > 0) {
                 String shortKey = key.substring(lastSlashIdx + 1);
@@ -71,11 +74,7 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
     }
 
     public GroovyClassDoc classNamedExact(String name) {
-        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {
-            String key = entry.getKey();
-            if (key.equals(name)) return entry.getValue();
-        }
-        return null;
+        return classDocs.get(name);
     }
 
     public void setDescription(String description) {

Commit:
fe01ff61bef4584b6d6c4ea3c85de06531e4d777
sunlan
sunlan@apache.org
2018-05-23 15:49:04 +0800
Refine the test of "GROOVY-8598: Possible bug in AstBuilder Antlr4"
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
index 68c551adc0..868269f7fe 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
@@ -227,8 +227,8 @@ class SyntaxErrorTest extends GroovyTestCase {
     }
 
     void "test groovy core - Import"() {
-        TestUtils.shouldFail('fail/Import_01x.groovy');
-        TestUtils.shouldFail('fail/Import_02x.groovy');
+        TestUtils.doRunAndShouldFail('fail/Import_01x.groovy');
+        TestUtils.doRunAndShouldFail('fail/Import_02x.groovy');
     }
 
     /**************************************/

Commit:
a26c190f9a70b0c430004d80c56e37703c2edfe8
sunlan
sunlan@apache.org
2018-05-23 15:37:16 +0800
GROOVY-8598: Possible bug in AstBuilder Antlr4
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index b530c20926..37f951d3f6 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -4068,10 +4068,18 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         if (asBoolean(ctx.statement())) {
             Object astNode = this.visit(ctx.statement()); //this.configureAST((Statement) this.visit(ctx.statement()), ctx);
 
-            if (astNode instanceof MethodNode) {
+            if (null == astNode) {
+                return null;
+            }
+
+            if (astNode instanceof Statement) {
+                return (Statement) astNode;
+            } else if (astNode instanceof MethodNode) {
                 throw createParsingFailedException("Method definition not expected here", ctx);
+            } else if (astNode instanceof ImportNode) {
+                throw createParsingFailedException("Import statement not expected here", ctx);
             } else {
-                return (Statement) astNode;
+                throw createParsingFailedException("The statement(" + astNode.getClass() + ") not expected here", ctx);
             }
         }
 
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
index 0fdef50c89..68c551adc0 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
@@ -226,6 +226,11 @@ class SyntaxErrorTest extends GroovyTestCase {
         TestUtils.doRunAndShouldFail('fail/NonStaticClass_01x.groovy');
     }
 
+    void "test groovy core - Import"() {
+        TestUtils.shouldFail('fail/Import_01x.groovy');
+        TestUtils.shouldFail('fail/Import_02x.groovy');
+    }
+
     /**************************************/
     static unzipScriptAndShouldFail(String entryName, List ignoreClazzList, Map<String, String> replacementsMap=[:], boolean toCheckNewParserOnly = false) {
         ignoreClazzList.addAll(TestUtils.COMMON_IGNORE_CLASS_LIST)
diff --git a/subprojects/parser-antlr4/src/test/resources/fail/Import_01x.groovy b/subprojects/parser-antlr4/src/test/resources/fail/Import_01x.groovy
new file mode 100644
index 0000000000..55da24429f
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/fail/Import_01x.groovy
@@ -0,0 +1,22 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+{
+    import java.util.*
+}
diff --git a/subprojects/parser-antlr4/src/test/resources/fail/Import_02x.groovy b/subprojects/parser-antlr4/src/test/resources/fail/Import_02x.groovy
new file mode 100644
index 0000000000..f94f917dd4
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/fail/Import_02x.groovy
@@ -0,0 +1,22 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+def m() {
+    import java.util.*
+}

Commit:
d8f4ec430f1285c36375047b0f3488a313602555
Cedric Champeau
cchampeau@apache.org
2018-05-23 08:35:41 +0200
Use a reasonable size buffer for generated docs
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/GroovyDocTemplateEngine.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/GroovyDocTemplateEngine.java
index ce63ed56dd..052f29ca79 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/GroovyDocTemplateEngine.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/GroovyDocTemplateEngine.java
@@ -31,6 +31,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -85,7 +86,7 @@ public class GroovyDocTemplateEngine {
             Map<String, Object> binding = new LinkedHashMap<String, Object>();
             binding.put("classDoc", classDoc);
             binding.put("props", properties);
-            templateWithBindingApplied = t.make(binding).toString();
+            templateWithBindingApplied = t.make(binding).writeTo(reasonableSizeWriter()).toString();
         } catch (Exception e) {
             System.out.println("Error processing class template for: " + classDoc.getFullPathName());
             e.printStackTrace();
@@ -93,6 +94,10 @@ public class GroovyDocTemplateEngine {
         return templateWithBindingApplied;
     }
 
+    private static StringWriter reasonableSizeWriter() {
+        return new StringWriter(65536);
+    }
+
     String applyPackageTemplate(String template, GroovyPackageDoc packageDoc) {
         String templateWithBindingApplied = "";
         try {

Commit:
3a8dd6d5b3f36e7058567f32264ce9c3126e3631
Cedric Champeau
cchampeau@apache.org
2018-05-23 08:34:10 +0200
Cache class resolution
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/groovydoc/GroovyRootDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/groovydoc/GroovyRootDoc.java
index f18fd5335d..1e34c10d47 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/groovydoc/GroovyRootDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/groovydoc/GroovyRootDoc.java
@@ -35,4 +35,6 @@ public interface GroovyRootDoc extends GroovyDoc, GroovyDocErrorReporter {
     GroovyPackageDoc[] specifiedPackages();
 
     Map<String, GroovyClassDoc> getVisibleClasses(List importedClassesAndPackages);
+
+    Map<String, GroovyClassDoc> getResolvedClasses();
 }
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
index b5be4d78b4..3522fa1a0c 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
@@ -547,6 +547,17 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
 
     private GroovyClassDoc resolveClass(GroovyRootDoc rootDoc, String name) {
         if (isPrimitiveType(name)) return null;
+        Map<String, GroovyClassDoc> resolvedClasses = rootDoc.getResolvedClasses();
+        GroovyClassDoc groovyClassDoc = resolvedClasses.get(name);
+        if (groovyClassDoc != null) {
+            return groovyClassDoc;
+        }
+        groovyClassDoc = doResolveClass(rootDoc, name);
+        resolvedClasses.put(name, groovyClassDoc);
+        return groovyClassDoc;
+    }
+
+    private GroovyClassDoc doResolveClass(final GroovyRootDoc rootDoc, final String name) {
         if (name.endsWith("[]")) {
             GroovyClassDoc componentClass = resolveClass(rootDoc, name.substring(0, name.length() - 2));
             if (componentClass != null) return new ArrayClassDocWrapper(componentClass);
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
index eeffd163bc..6bb49401ac 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
@@ -24,21 +24,29 @@ import org.codehaus.groovy.groovydoc.GroovyRootDoc;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.regex.Pattern;
 
 public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDoc {
+    private final static Pattern EQUIVALENT_PACKAGE_IMPORT = Pattern.compile("[^/]+$");
+
     private final Map<String, GroovyPackageDoc> packageDocs;
     private List<GroovyPackageDoc> packageDocValues = null;
     private final Map<String, GroovyClassDoc> classDocs;
+    private final Map<String, String> equivalentPackageImports;
     private List<GroovyClassDoc> classDocValues = null;
+    private final Map<String, GroovyClassDoc> cachedResolvedClasses = new HashMap<String, GroovyClassDoc>();
+
     private String description = "";
 
     public SimpleGroovyRootDoc(String name) {
         super(name);
         packageDocs = new LinkedHashMap<String, GroovyPackageDoc>();
         classDocs = new LinkedHashMap<String, GroovyClassDoc>();
+        equivalentPackageImports = new HashMap<String, String>();
     }
 
     public GroovyClassDoc classNamed(GroovyClassDoc groovyClassDoc, String name) {
@@ -124,7 +132,7 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
         Map<String, GroovyClassDoc> visibleClasses = new LinkedHashMap<String, GroovyClassDoc>();
         for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {
             String fullClassName = entry.getKey();
-            String equivalentPackageImport = fullClassName.replaceAll("[^/]+$", "*");
+            String equivalentPackageImport = findEquivalentPackageImport(fullClassName);
             if (importedClassesAndPackages.contains(fullClassName) ||
                     importedClassesAndPackages.contains(equivalentPackageImport)) {
                 GroovyClassDoc classDoc = entry.getValue();
@@ -134,6 +142,20 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
         return visibleClasses;
     }
 
+    private String findEquivalentPackageImport(String fullClassName) {
+        String eq = equivalentPackageImports.get(fullClassName);
+        if (eq == null) {
+            eq = EQUIVALENT_PACKAGE_IMPORT.matcher(fullClassName).replaceAll("*");
+            equivalentPackageImports.put(fullClassName, eq);
+        }
+        return eq;
+    }
+
+    @Override
+    public Map<String, GroovyClassDoc> getResolvedClasses() {
+        return cachedResolvedClasses;
+    }
+
     // GroovyDocErrorReporter interface
     public void printError(String arg0) {/*todo*/}
 

Commit:
1546b1918fa1a5a58d54ac6636348ba4e8cf6229
sunlan
sunlan@apache.org
2018-05-23 08:49:24 +0800
GROOVY-8595: Expected parameter of type XXX but got YYY static compile error
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index ef3feaf4d4..27b9d09ee1 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3245,7 +3245,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, mn.get(0), call)) {
                             returnType = adjustWithTraits(directMethodCallCandidate, chosenReceiver.getType(), args, returnType);
 
-                            if (null != typeCheckingContext.getEnclosingReturnStatement() && !inNestedMethodCall()) {
+                            if (null != typeCheckingContext.getEnclosingReturnStatement() && !isNestedOrSandwichedMethodCall()) {
                                 ClassNode inferredType = infer(returnType, typeCheckingContext.getEnclosingMethod().getReturnType());
                                 if (null != inferredType) {
                                     returnType = inferredType;
@@ -3318,7 +3318,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
-    private boolean inNestedMethodCall() {
+    /**
+     * e.g. a(b()),         b() is nested method call
+     *      a().b().c(),    a() and b() are sandwiched method call
+     *
+     */
+    private boolean isNestedOrSandwichedMethodCall() {
         return typeCheckingContext.getEnclosingMethodCalls().size() > 1;
     }
 
diff --git a/src/test/groovy/bugs/Groovy8595Bug.groovy b/src/test/groovy/bugs/Groovy8595Bug.groovy
new file mode 100644
index 0000000000..d5776228a8
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8595Bug.groovy
@@ -0,0 +1,43 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+import gls.CompilableTestSupport
+
+class Groovy8595Bug extends CompilableTestSupport {
+    void testGroovy8595() {
+        shouldCompile '''
+            @groovy.transform.CompileStatic
+            class Test {
+              List<Foo> foo() {
+                return []
+              }
+            
+              List<String> bar() {
+                return foo().collect { Foo it -> it.instanceId }
+              }
+            }
+            
+            @groovy.transform.CompileStatic
+            class Foo {
+              String instanceId
+            }
+        '''
+    }
+}

Commit:
17067350c4e25a8a97cfcbb86682d904aa7e234e
John Wagenleitner
jwagenleitner@apache.org
2018-05-22 16:48:38 -0700
GROOVY-8590: STC incorrectly infers type of nested method call used in a return stmt (closes #713)
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index c538352e6d..ef3feaf4d4 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3245,7 +3245,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, mn.get(0), call)) {
                             returnType = adjustWithTraits(directMethodCallCandidate, chosenReceiver.getType(), args, returnType);
 
-                            if (null != typeCheckingContext.getEnclosingReturnStatement()) { // the method call is within return statement, we can try to infer type further
+                            if (null != typeCheckingContext.getEnclosingReturnStatement() && !inNestedMethodCall()) {
                                 ClassNode inferredType = infer(returnType, typeCheckingContext.getEnclosingMethod().getReturnType());
                                 if (null != inferredType) {
                                     returnType = inferredType;
@@ -3318,6 +3318,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private boolean inNestedMethodCall() {
+        return typeCheckingContext.getEnclosingMethodCalls().size() > 1;
+    }
+
     /**
      * A special method handling the "withTrait" call for which the type checker knows more than
      * what the type signature is able to tell. If "withTrait" is detected, then a new class node
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index ef570c6acb..37e0a99d51 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -791,4 +791,18 @@ Printer
             assert foo.toString() == 'Foo([propWithGen], [notDecl], [fieldGen:42])'
         '''
     }
+
+    //GROOVY-8590
+    void testNestedMethodCallInferredTypeInReturnStmt() {
+        assertScript '''
+            class Source {
+                Object getValue() { '32' }
+            }
+            int m(Source src) {
+                return Integer.parseInt((String) src.getValue())
+            }
+            assert m(new Source()) == 32
+        '''
+    }
+
 }

Commit:
416a693719781ff4f15dffe8acfdf0bd911c4c73
sunlan
sunlan@apache.org
2018-05-22 12:41:26 +0800
Refine the test of GROOVY-8531
diff --git a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
index 2369d884c5..53a71f26c9 100644
--- a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
+++ b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
@@ -33,6 +33,8 @@ class Groovy8531Bug extends GroovyTestCase {
                 public void reduce7(PublicStaticBaseContext context) {}
                 public void reduce8(ProtectedStaticBaseContext context) {}
                 
+                public void reduce9(InterfaceContext context) {}
+                
                 public boolean isDynamic(Type type) {
                     return Type.DYNAMIC == type
                 }
@@ -48,6 +50,8 @@ class Groovy8531Bug extends GroovyTestCase {
             new Example().reduce7(null)
             new Example().reduce8(null)
             
+            new Example().reduce9(null)
+            
             assert new Example().isDynamic(Reducer.Type.DYNAMIC)
         '''
     }
diff --git a/src/test/groovy/bugs/groovy8531/Reducer.java b/src/test/groovy/bugs/groovy8531/Reducer.java
index 6cf865fe02..8652196a12 100644
--- a/src/test/groovy/bugs/groovy8531/Reducer.java
+++ b/src/test/groovy/bugs/groovy8531/Reducer.java
@@ -18,6 +18,10 @@
  */
 package groovy.bugs.groovy8531;
 
+interface Reducable {
+    class InterfaceContext {}
+}
+
 class BaseReducer {
     public abstract class PublicBaseContext {}
     protected abstract class ProtectedBaseContext {}
@@ -26,7 +30,7 @@ class BaseReducer {
     private abstract class PrivateBaseContext {}
 }
 
-public class Reducer extends BaseReducer {
+public class Reducer extends BaseReducer implements Reducable {
     public abstract class PublicContext {}
     protected abstract class ProtectedContext {}
     public static abstract class PublicStaticContext {}

Commit:
b0d79332a3e897e821e62983ba38e5d926fa7cdd
Paul King
paulk@asert.com.au
2018-05-22 01:23:11 +1000
fix typo for delegated method
diff --git a/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
index a7097dba68..58ec973f9d 100644
--- a/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
+++ b/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
@@ -57,7 +57,7 @@ class CliBuilder {
      * Use groovy.cli.commons.CliBuilder if you need this feature.
      */
     @Deprecated
-    CommandLineParser setParser() {
+    CommandLineParser getParser() {
         delegate.getParser()
     }
 

Commit:
434de3dd37d56b5a5dc72a39ea2be7896e00ebf7
sunlan
sunlan@apache.org
2018-05-21 17:05:35 +0800
Fix "Synchronization on a non-final field 'constantMetaClassVersioningLock'"
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/DefaultMetaClassInfo.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/DefaultMetaClassInfo.java
index 91948fe680..97c89900bb 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/DefaultMetaClassInfo.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/DefaultMetaClassInfo.java
@@ -329,7 +329,7 @@ public class DefaultMetaClassInfo {
         public boolean isValid(){return valid;}
     }
     private static ConstantMetaClassVersioning constantMetaClassVersioning = new ConstantMetaClassVersioning();
-    private static Object constantMetaClassVersioningLock = new Object();
+    private static final Object constantMetaClassVersioningLock = new Object();
     
     public static ConstantMetaClassVersioning getCurrentConstantMetaClassVersioning() {
         return constantMetaClassVersioning;

Commit:
6a8682aaf0bdf1f6b84a1bf0fef761007a604dbc
sunlan
sunlan@apache.org
2018-05-21 16:58:41 +0800
Generics type parameters normally have a short name, e.g. `T`, `E`, `X`. If the classpath contains a class whose name is very short, the groovy compiler will resolve the generics type parameter with same name as the existing class when resolving the generics type parameter failed.
diff --git a/src/test/groovy/script/ClassWithScript.groovy b/src/test/groovy/script/ClassWithScript.groovy
index ed0a2efd3c..b28fd67465 100644
--- a/src/test/groovy/script/ClassWithScript.groovy
+++ b/src/test/groovy/script/ClassWithScript.groovy
@@ -16,6 +16,6 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-class X {}
-x = new X()
+class XforClassWithScript {}
+x = new XforClassWithScript()
 println(x)
\ No newline at end of file

Commit:
b85935ca6991f4010a354d1d86dccabc9614dab3
sunlan
sunlan@apache.org
2018-05-21 16:20:39 +0800
Rename class `X` to `XforStaticInitTest`
diff --git a/src/test/org/codehaus/groovy/runtime/StaticInitTest.java b/src/test/org/codehaus/groovy/runtime/StaticInitTest.java
index 0fb7ee9506..35c48313b8 100644
--- a/src/test/org/codehaus/groovy/runtime/StaticInitTest.java
+++ b/src/test/org/codehaus/groovy/runtime/StaticInitTest.java
@@ -23,13 +23,14 @@ import junit.framework.TestCase;
 
 import java.lang.reflect.Field;
 
-class X {
+class XforStaticInitTest {
 
     public static int field = 0;
 
     static {
         StaticInitTest.failed = true;
     }
+
 }
 
 public class StaticInitTest extends TestCase {
@@ -37,7 +38,7 @@ public class StaticInitTest extends TestCase {
     static boolean failed;
 
     public void testInitOrder () throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException {
-        final Field f = new GroovyClassLoader().loadClass("org.codehaus.groovy.runtime.X", false, false, false).getField("field");
+        final Field f = new GroovyClassLoader().loadClass("org.codehaus.groovy.runtime.XforStaticInitTest", false, false, false).getField("field");
         assertTrue(!failed);
         f.getInt(null);
         assertTrue(failed);

Commit:
0f187102660593d9d95d486ba4b62f5091cc4580
sunlan
sunlan@apache.org
2018-05-21 00:14:56 +0800
Fix "GROOVY-6167: Generics: within a single declaration, generic type definition order matters"
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 1b3ec1ab45..2f7bcd70c4 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -1456,6 +1456,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         if (types == null) return;
         currentClass.setUsingGenerics(true);
         List<Tuple2<ClassNode, GenericsType>> upperBoundsWithGenerics = new LinkedList<>();
+        List<Tuple2<ClassNode, ClassNode>> upperBoundsToResolve = new LinkedList<>();
         for (GenericsType type : types) {
             if (level > 0 && type.getName().equals(rootType.getName())) {
                 continue;
@@ -1478,9 +1479,9 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                                 classNode.setRedirect(upperBound);
                                 nameAdded = true;
                             }
-
                         }
-                        resolveOrFail(upperBound, classNode);
+
+                        upperBoundsToResolve.add(new Tuple2<>(upperBound, classNode));
                     }
 
                     if (asBoolean(upperBound.isUsingGenerics())) {
@@ -1504,6 +1505,12 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             }
         }
 
+        for (Tuple2<ClassNode, ClassNode> tp : upperBoundsToResolve) {
+            ClassNode upperBound = tp.getFirst();
+            ClassNode classNode = tp.getSecond();
+            resolveOrFail(upperBound, classNode);
+        }
+
         for (Tuple2<ClassNode, GenericsType> tp : upperBoundsWithGenerics) {
             ClassNode upperBound = tp.getFirst();
             GenericsType gt = tp.getSecond();
diff --git a/src/test/groovy/bugs/Groovy6171Bug.groovy b/src/test/groovy/bugs/Groovy6167Bug.groovy
similarity index 98%
rename from src/test/groovy/bugs/Groovy6171Bug.groovy
rename to src/test/groovy/bugs/Groovy6167Bug.groovy
index 0d0d6d1bc4..16573606c1 100644
--- a/src/test/groovy/bugs/Groovy6171Bug.groovy
+++ b/src/test/groovy/bugs/Groovy6167Bug.groovy
@@ -20,8 +20,8 @@ package groovy.bugs
 
 import gls.CompilableTestSupport
 
-class Groovy6171Bug extends CompilableTestSupport {
-    void testGroovy6171() {
+class Groovy6167Bug extends CompilableTestSupport {
+    void testGroovy6167() {
         shouldCompile '''
         public class Foo<T extends List<X>, X extends Number> {}
         '''

Commit:
869c365161457c050d5a54c7ff43d73d3263f34e
John Wagenleitner
jwagenleitner@apache.org
2018-05-19 18:50:29 -0700
GROOVY-8171: Escaped dollar slashy difference between old and parrot parsers (closes #712)
diff --git a/src/test/groovy/StringTest.groovy b/src/test/groovy/StringTest.groovy
index 56cb2d7b4d..7d70733ce9 100644
--- a/src/test/groovy/StringTest.groovy
+++ b/src/test/groovy/StringTest.groovy
@@ -231,6 +231,16 @@ foo
     void testDollarEscaping() {
         def text = $/a/b\c$$ $//$
         assert text == 'a/b\\c$ /'
+
+        //GROOVY-8171
+        text = $/$$//$
+        assert text == '$/'
+
+        text = $/$$$$//$
+        assert text == '$$/'
+
+        text = $/$$$$$//$
+        assert text == '$$/'
     }
 
     void testSplit() {
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/util/StringUtils.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/util/StringUtils.java
index 7b5d376128..b674734da4 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/util/StringUtils.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/util/StringUtils.java
@@ -108,8 +108,8 @@ public class StringUtils {
 			}
 
 			if (slashyType == DOLLAR_SLASHY) {
-				text = replace(text,"$$", "$");
 				text = replace(text,"$/", "/");
+				text = replace(text,"$$", "$");
 			}
 
 		} else if (slashyType == NONE_SLASHY) {

Commit:
6268f59f36a585739ab83e56704b8bb1033faeda
Paul King
paulk@asert.com.au
2018-05-20 01:01:14 +1000
move test into vm8 package
diff --git a/subprojects/tests-vm8/src/test/groovy/groovy/bugs/Groovy8579Bug.groovy b/subprojects/tests-vm8/src/test/groovy/groovy/bugs/vm8/Groovy8579Bug.groovy
similarity index 98%
rename from subprojects/tests-vm8/src/test/groovy/groovy/bugs/Groovy8579Bug.groovy
rename to subprojects/tests-vm8/src/test/groovy/groovy/bugs/vm8/Groovy8579Bug.groovy
index 1945e475c0..bd898c5b23 100644
--- a/subprojects/tests-vm8/src/test/groovy/groovy/bugs/Groovy8579Bug.groovy
+++ b/subprojects/tests-vm8/src/test/groovy/groovy/bugs/vm8/Groovy8579Bug.groovy
@@ -16,7 +16,7 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-package groovy.bugs
+package groovy.bugs.vm8
 
 class Groovy8579Bug extends GroovyTestCase {
     void testCallToStaticInterfaceMethod() {

Commit:
8f869b43003a38229f95b894149edef45b617837
Paul King
paulk@asert.com.au
2018-05-20 01:01:13 +1000
make test more robust
diff --git a/src/spec/test/cli/CliBuilderTestCase.groovy b/src/spec/test/cli/CliBuilderTestCase.groovy
index 1b6c9cc130..f1fdbc3946 100644
--- a/src/spec/test/cli/CliBuilderTestCase.groovy
+++ b/src/spec/test/cli/CliBuilderTestCase.groovy
@@ -73,7 +73,7 @@ abstract class CliBuilderTestCase extends GroovyTestCase {
         cli.writer = new PrintWriter(sw)
         cli.usage()
 
-        assert '$expected'.normalize() == sw.toString().normalize()
+        assert '''$expected'''.normalize() == sw.toString().normalize()
         """
     }
 

Commit:
64955fa5e83d72173948648992be2c22bac1a0ba
Paul King
paulk@asert.com.au
2018-05-20 01:01:12 +1000
move JDK8 test
diff --git a/src/test/groovy/bugs/Groovy8579Bug.groovy b/subprojects/tests-vm8/src/test/groovy/groovy/bugs/Groovy8579Bug.groovy
similarity index 100%
rename from src/test/groovy/bugs/Groovy8579Bug.groovy
rename to subprojects/tests-vm8/src/test/groovy/groovy/bugs/Groovy8579Bug.groovy

Commit:
11c145d01413cbdf7a562d2ab5dbc52f981a617a
Paul King
paulk@asert.com.au
2018-05-19 23:57:43 +1000
GROOVY-8579: No bytecode level check is done before producing JDK8+ bytecode (avoid fix for DGM methods)
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index c28604aeb4..c538352e6d 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3255,7 +3255,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             storeType(call, returnType);
                             storeTargetMethod(call, directMethodCallCandidate);
                             ClassNode declaringClass = directMethodCallCandidate.getDeclaringClass();
-                            if (declaringClass.isInterface() && directMethodCallCandidate.isStatic()) {
+                            if (declaringClass.isInterface() && directMethodCallCandidate.isStatic() && !(directMethodCallCandidate instanceof ExtensionMethodNode)) {
                                 typeCheckingContext.getEnclosingClassNode().putNodeMetaData(MINIMUM_BYTECODE_VERSION, Opcodes.V1_8);
                             }
                             String data = chosenReceiver.getData();

Commit:
1351501eeef42bf4b2726eb8afe946d3ae160c44
Paul King
paulk@asert.com.au
2018-05-19 23:34:55 +1000
GROOVY-8569 minor tweak (fix tests for previous change)
diff --git a/src/test/groovy/ui/GroovyMainTest.groovy b/src/test/groovy/ui/GroovyMainTest.groovy
index ab788ac41f..018bc41122 100644
--- a/src/test/groovy/ui/GroovyMainTest.groovy
+++ b/src/test/groovy/ui/GroovyMainTest.groovy
@@ -27,13 +27,13 @@ class GroovyMainTest extends GroovyTestCase {
         GroovyMain.processArgs(args, ps)
         def out = baos.toString()
         assert out.contains('Usage: groovy')
-        ['-a', '-c', '-d', '-e', '-h', '-i', '-l', '-n', '-p', '-V'].each{
+        ['-a', '-c', '-d', '-e', '-h', '-i', '-l', '-n', '-p', '-v'].each{
             assert out.contains(it)
         }
     }
 
     void testVersion() {
-        String[] args = ['-V']
+        String[] args = ['-v']
         GroovyMain.processArgs(args, ps)
         def out = baos.toString()
         assert out.contains('Groovy Version:')

Commit:
ba4d1af576dc203020eee7b3e4b89e157395a974
Paul King
paulk@asert.com.au
2018-05-19 23:07:55 +1000
GROOVY-8556 consolidate tests/doco a bit more
diff --git a/src/spec/doc/core-domain-specific-languages.adoc b/src/spec/doc/core-domain-specific-languages.adoc
index 47d854b268..e1706512bb 100644
--- a/src/spec/doc/core-domain-specific-languages.adoc
+++ b/src/spec/doc/core-domain-specific-languages.adoc
@@ -1103,22 +1103,27 @@ Here is a simple example `Greeter.groovy` script illustrating usage:
 
 [source,groovy]
 ---------------------------
+// import of CliBuilder not shown                          <1>
 // specify parameters
-def cli = new CliBuilder(usage: 'groovy Greeter [option]') <1>
-cli.a(longOpt: 'audience', args: 1, 'greeting audience')   <2>
-cli.h(longOpt: 'help', 'display usage')                    <3>
+def cli = new CliBuilder(usage: 'groovy Greeter [option]') <2>
+cli.a(longOpt: 'audience', args: 1, 'greeting audience')   <3>
+cli.h(longOpt: 'help', 'display usage')                    <4>
 
 // parse and process parameters
-def options = cli.parse(args)                              <4>
-if (options.h) cli.usage()                                 <5>
-else println "Hello ${options.a ? options.a : 'World'}"    <6>
+def options = cli.parse(args)                              <5>
+if (options.h) cli.usage()                                 <6>
+else println "Hello ${options.a ? options.a : 'World'}"    <7>
 ---------------------------
-<1> define a new `CliBuilder` instance specifying an optional usage string
-<2> specify a `-a` option taking a single argument with an optional long variant `--audience`
-<3> specify a `-h` option taking no arguments with an optional long variant `--help`
-<4> parse the commandline parameters supplied to the script
-<5> if the `h` option is found display a usage message
-<6> display a standard greeting or, if the `a` option is found, a customized greeting
+<1> Earlier versions of Groovy had a CliBuilder in the groovy.util package and no import was necessary.
+While still supported, this approach is now deprecated and you should instead choose the groovy.cli.picocli
+or groovy.cli.commons version. The groovy.util version points to the commons-cli version for backwards compatibility
+but will be removed in a future version of Groovy.
+<2> define a new `CliBuilder` instance specifying an optional usage string
+<3> specify a `-a` option taking a single argument with an optional long variant `--audience`
+<4> specify a `-h` option taking no arguments with an optional long variant `--help`
+<5> parse the commandline parameters supplied to the script
+<6> if the `h` option is found display a usage message
+<7> display a standard greeting or, if the `a` option is found, a customized greeting
 
 Running this script with no commandline parameters, i.e.:
 
@@ -1178,13 +1183,13 @@ properties are supported when specifying an allowed commandline option:
 | Name           | Description | Type
 | argName        | the name of the argument for this option used in output | `String`
 | longOpt        | the long representation or long name of the option | `String`
-| args           | the number of argument values | `int` or `String`<1>
+| args           | the number of argument values | `int` or `String` <1>
 | optionalArg    | whether the argument value is optional | `boolean`
 | required       | whether the option is mandatory | `boolean`
 | type           | the type of this option | `Class`
-| valueSeparator | the character that is the value separator | `char`<2>
+| valueSeparator | the character that is the value separator | `char` <2>
 | defaultValue   | a default value | `String`
-| convert        | converts the incoming String to the required type | `Closure`<1>
+| convert        | converts the incoming String to the required type | `Closure` <1>
 |======================
 <1> More details later
 <2> Single character Strings are coerced to chars in special cases in Groovy
@@ -1206,7 +1211,7 @@ Here is how such a specification can be defined:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationInterfaceSpec,indent=0]
+include::{projectdir}/src/spec/test/cli/GreeterI.groovy[tags=annotationInterfaceSpec,indent=0]
 ----
 <1> Specify a Boolean option set using `-h` or `--help`
 <2> Specify a String option set using `-a` or `--audience`
@@ -1221,7 +1226,7 @@ Here is how you could use the interface specification:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationInterface,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=annotationInterface,indent=0]
 ----
 <1> Create a `CliBuilder` instance as before with optional properties
 <2> Parse parameters using the interface specification
@@ -1243,7 +1248,7 @@ Here is how such a specification can be defined:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationClassSpec,indent=0]
+include::{projectdir}/src/spec/test/cli/GreeterC.groovy[tags=annotationClassSpec,indent=0]
 ----
 <1> Indicate that a Boolean property is an option
 <2> Indicate that a String property (with explicit setter) is an option
@@ -1253,7 +1258,7 @@ And here is how you could use the specification:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationClass,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=annotationClass,indent=0]
 ----
 <1> Create a `CliBuilder` instance as before with optional parameters
 <2> Create an instance for `CliBuilder` to populate
@@ -1277,7 +1282,7 @@ with the same arguments as shown for the instance example earlier:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationScript,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=annotationScript,indent=0]
 ----
 
 ===== Options with arguments
@@ -1289,7 +1294,7 @@ Here is an example involving those cases:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgument,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withArgument,indent=0]
 ----
 <1> An option that is simply a flag - the default; setting args to 0 is allowed but not needed.
 <2> An option with exactly one argument
@@ -1306,14 +1311,14 @@ illustrating such a definition:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgumentInterfaceSpec,indent=0]
+include::{projectdir}/src/spec/test/cli/WithArgsI.groovy[tags=withArgumentInterfaceSpec,indent=0]
 ----
 
 And here is how it is used:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgumentInterface,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withArgumentInterface,indent=0]
 ----
 
 This example makes use of an array-typed option specification. We cover this in more detail shortly when we discuss
@@ -1334,7 +1339,7 @@ Here is an example using types with the dynamic api argument definition style:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withType,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withType,indent=0]
 ----
 
 Primitives, numeric types, files, enums and arrays thereof, are supported (they are converted using
@@ -1347,7 +1352,7 @@ for you. Here is a sample using the dynamic api style:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvert,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withConvert,indent=0]
 ----
 
 Alternatively, you can use the annotation style by supplying the conversion closure as an annotation parameter.
@@ -1355,14 +1360,14 @@ Here is an example specification:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvertInterfaceSpec,indent=0]
+include::{projectdir}/src/spec/test/cli/WithConvertI.groovy[tags=withConvertInterfaceSpec,indent=0]
 ----
 
 And an example using that specification:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvertInterface,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withConvertInterface,indent=0]
 ----
 
 ===== Options with multiple arguments
@@ -1388,7 +1393,7 @@ Here is an excerpt highlighting the use of multiple arguments:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgs,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=multipleArgs,indent=0]
 ----
 <1> Args value supplied as a String and comma value separator specified
 <2> One or more arguments are allowed
@@ -1408,14 +1413,14 @@ array type for the annotated class member (method or property) as this example s
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgsInterfaceSpec,indent=0]
+include::{projectdir}/src/spec/test/cli/ValSepI.groovy[tags=multipleArgsInterfaceSpec,indent=0]
 ----
 
 And used as follows:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgsInterface,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=multipleArgsInterface,indent=0]
 ----
 
 ===== Types and multiple arguments
@@ -1424,7 +1429,7 @@ Here is an example using types and multiple arguments with the dynamic api argum
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeMultiple,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withTypeMultiple,indent=0]
 ----
 <1> For an array type, the trailing 's' can be used but isn't needed
 
@@ -1439,7 +1444,7 @@ Here is how you could use it using the dynamic api style:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValue,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withDefaultValue,indent=0]
 ----
 
 Similarly, you might want such a specification using the annotation style. Here is an example using an interface
@@ -1447,14 +1452,14 @@ specification:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValueInterfaceSpec,indent=0]
+include::{projectdir}/src/spec/test/cli/WithDefaultValueI.groovy[tags=withDefaultValueInterfaceSpec,indent=0]
 ----
 
 Which would be used like this:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValueInterface,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withDefaultValueInterface,indent=0]
 ----
 
 You can also use the `defaultValue` annotation attribute when using annotations with an instance,
@@ -1468,14 +1473,14 @@ annotation style, for example, here is an interface option specification:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeCheckedInterfaceSpec,indent=0]
+include::{projectdir}/src/spec/test/cli/TypeCheckedI.groovy[tags=withTypeCheckedInterfaceSpec,indent=0]
 ----
 
-And it can be used  in combination with `@TypeChecked` as shown here:
+And it can be used in combination with `@TypeChecked` as shown here:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeCheckedInterface,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withTypeCheckedInterface,indent=0]
 ----
 
 Secondly, there is a feature of the dynamic api style which offers some support. The definition statements
@@ -1508,7 +1513,7 @@ the following example:
 
 [source,groovy]
 ----
-include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeChecked,indent=0]
+include::{projectdir}/src/spec/test/cli/CliBuilderTestCase.groovy[tags=withTypeChecked,indent=0]
 ----
 
 ===== Advanced CLI Usage
@@ -1549,13 +1554,14 @@ assert !cli.parse('-d -o'.split()) // <1>
 <1> The parse will fail since only one option from a group can be used at a time.
 
 ====== Picocli
+
 Below are some features available in the picocli version of `CliBuilder`.
 
 *New property: errorWriter*
 
 When users of your application give invalid command line arguments,
 CliBuilder writes an error message and the usage help message to the `stderr` output stream.
-It doesn’t use the `stdout` stream to prevent the error message from being parsed when your program's
+It doesn't use the `stdout` stream to prevent the error message from being parsed when your program's
 output is used as input for another process.
 You can customize the destination by setting the `errorWriter` to a different value.
 
@@ -1588,28 +1594,12 @@ which gives fine-grained control over various sections of the usage help message
 
 [source,groovy]
 ----
-def cli = new CliBuilder()
-cli.name = "myapp"
-cli.usageMessage.with {
-    headerHeading("@|bold,underline Header heading:|@%n")
-    header("Header 1", "Header 2")                     // before the synopsis
-    synopsisHeading("%n@|bold,underline Usage:|@ ")
-    descriptionHeading("%n@|bold,underline Description heading:|@%n")
-    description("Description 1", "Description 2")      // after the synopsis
-    optionListHeading("%n@|bold,underline Options heading:|@%n")
-    footerHeading("%n@|bold,underline Footer heading:|@%n")
-    footer("Footer 1", "Footer 2")
-}
-cli.a('option a description')
-cli.b('option b description')
-cli.c(args: '*', 'option c description')
-cli.usage()
+include::{projectdir}/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy[tags=withUsageMessageSpec,indent=0]
 ----
 Gives this output:
 
 image::assets/img/usageMessageSpec.png[]
 
-
 *New property: parser*
 
 The `parser` property gives access to the picocli `ParserSpec` object that can be used to customize the parser behavior.
@@ -1621,19 +1611,9 @@ Finally, if your application has options that are key-value pairs, you may be in
 
 [source,groovy]
 ----
-import java.util.concurrent.TimeUnit
-import static java.util.concurrent.TimeUnit.DAYS
-import static java.util.concurrent.TimeUnit.HOURS
+include::{projectdir}/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy[tags=mapOptionImports,indent=0]
 
-def cli = new CliBuilder()
-cli.D(args: 2,   valueSeparator: '=', 'the old way')                          // <1>
-cli.X(type: Map, 'the new way')                                               // <2>
-cli.Z(type: Map, auxiliaryTypes: [TimeUnit, Integer].toArray(), 'typed map')  // <3>
-
-def options = cli.parse('-Da=b -Dc=d -Xx=y -Xi=j -ZDAYS=2 -ZHOURS=23'.split())// <4>
-assert options.Ds == ['a', 'b', 'c', 'd']                                     // <5>
-assert options.Xs == [ 'x':'y', 'i':'j' ]                                     // <6>
-assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         // <7>
+include::{projectdir}/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy[tags=mapOption,indent=0]
 ----
 <1> Previously, `key=value` pairs were split up into parts and added to a list
 <2> Picocli map support: simply specify `Map` as the type of the option
@@ -1644,7 +1624,6 @@ assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         //
 <7> Both keys and values of the map can be strongly typed
 
 
-
 ==== ObjectGraphBuilder
 
 `ObjectGraphBuilder` is a builder for an arbitrary graph of beans that
diff --git a/src/spec/test/cli/CliBuilderTestCase.groovy b/src/spec/test/cli/CliBuilderTestCase.groovy
new file mode 100644
index 0000000000..1b6c9cc130
--- /dev/null
+++ b/src/spec/test/cli/CliBuilderTestCase.groovy
@@ -0,0 +1,380 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+abstract class CliBuilderTestCase extends GroovyTestCase {
+
+    abstract String getImportCliBuilder()
+
+    void testAnnotationsInterface() {
+        assertScript """
+        import cli.GreeterI
+        $importCliBuilder
+        // tag::annotationInterface[]
+        // import CliBuilder not shown
+        def cli = new CliBuilder(usage: 'groovy Greeter')  // <1>
+        def argz = '--audience Groovologist'.split()
+        def options = cli.parseFromSpec(GreeterI, argz)             // <2>
+        assert options.audience() == 'Groovologist'                 // <3>
+
+        argz = '-h Some Other Args'.split()
+        options = cli.parseFromSpec(GreeterI, argz)                 // <4>
+        assert options.help()
+        assert options.remaining() == ['Some', 'Other', 'Args']     // <5>
+        // end::annotationInterface[]
+        """
+    }
+
+    void testAnnotationsClass() {
+        assertScript """
+        import cli.GreeterC
+        $importCliBuilder
+        // tag::annotationClass[]
+        // import CliBuilder not shown
+        def cli = new CliBuilder(usage: 'groovy Greeter [option]') // <1>
+        def options = new GreeterC()                               // <2>
+        def argz = '--audience Groovologist foo'.split()
+        cli.parseFromInstance(options, argz)                       // <3>
+        assert options.audience == 'Groovologist'                  // <4>
+        assert options.remaining == ['foo']                        // <5>
+        // end::annotationClass[]
+        """
+    }
+
+    // performs toString comparison of usage help - this isn't because we guarantee any specific output
+    // (hence expected is provided as a parameter) but we want to know when it changes significantly and
+    // in particular we want to ensure that no information that we expect to be there just disappears
+    protected void doTestAnnotationsInterfaceToString(String key, String expected) {
+        assertScript """
+        import cli.GreeterI
+        $importCliBuilder
+        def cli = new CliBuilder($key: 'groovy Greeter')
+
+        def options = cli.parseFromSpec(GreeterI, ['-h', 'Some', 'Other', 'Args'] as String[])
+        assert options.help()
+        assert options.remaining() == ['Some', 'Other', 'Args']
+        StringWriter sw = new StringWriter()
+        cli.writer = new PrintWriter(sw)
+        cli.usage()
+
+        assert '$expected'.normalize() == sw.toString().normalize()
+        """
+    }
+
+    void testParseScript() {
+        def argz = '--audience Groovologist foo'.split()
+        new GroovyShell().run("""
+            $importCliBuilder
+            // tag::annotationScript[]
+            // import CliBuilder not shown
+            import groovy.cli.OptionField
+            import groovy.cli.UnparsedField
+
+            @OptionField String audience
+            @OptionField Boolean help
+            @UnparsedField List remaining
+            new CliBuilder().parseFromInstance(this, args)
+            assert audience == 'Groovologist'
+            assert remaining == ['foo']
+            // end::annotationScript[]
+        """, 'TestScript.groovy', argz)
+    }
+
+    void testWithArgument() {
+        assertScript """
+        $importCliBuilder
+        // tag::withArgument[]
+        // import CliBuilder not shown
+        def cli = new CliBuilder()
+        cli.a(args: 0, 'a arg') // <1>
+        cli.b(args: 1, 'b arg') // <2>
+        cli.c(args: 1, optionalArg: true, 'c arg') // <3>
+        def options = cli.parse('-a -b foo -c bar baz'.split()) // <4>
+
+        assert options.a == true
+        assert options.b == 'foo'
+        assert options.c == 'bar'
+        assert options.arguments() == ['baz']
+
+        options = cli.parse('-a -c -b foo bar baz'.split()) // <5>
+
+        assert options.a == true
+        assert options.c == true
+        assert options.b == 'foo'
+        assert options.arguments() == ['bar', 'baz']
+        // end::withArgument[]
+        """
+    }
+
+    void testMultipleArgsAndOptionalValueSeparator() {
+        assertScript """
+        $importCliBuilder
+        // tag::multipleArgs[]
+        // import CliBuilder not shown
+        def cli = new CliBuilder()
+        cli.a(args: 2, 'a-arg')
+        cli.b(args: '2', valueSeparator: ',', 'b-arg') // <1>
+        cli.c(args: '+', valueSeparator: ',', 'c-arg') // <2>
+
+        def options = cli.parse('-a 1 2 3 4'.split()) // <3>
+        assert options.a == '1' // <4>
+        assert options.as == ['1', '2'] // <5>
+        assert options.arguments() == ['3', '4']
+
+        options = cli.parse('-a1 -a2 3'.split()) // <6>
+        assert options.as == ['1', '2']
+        assert options.arguments() == ['3']
+
+        options = cli.parse(['-b1,2']) // <7>
+        assert options.bs == ['1', '2']
+
+        options = cli.parse(['-c', '1'])
+        assert options.cs == ['1']
+
+        options = cli.parse(['-c1'])
+        assert options.cs == ['1']
+
+        options = cli.parse(['-c1,2,3'])
+        assert options.cs == ['1', '2', '3']
+        // end::multipleArgs[]
+        """
+    }
+
+    void testWithArgumentInterface() {
+        assertScript """
+        import cli.WithArgsI
+        $importCliBuilder
+        // tag::withArgumentInterface[]
+        def cli = new CliBuilder()
+        def options = cli.parseFromSpec(WithArgsI, '-a -b foo -c bar baz'.split())
+        assert options.a()
+        assert options.b() == 'foo'
+        assert options.c() == ['bar']
+        assert options.remaining() == ['baz']
+
+        options = cli.parseFromSpec(WithArgsI, '-a -c -b foo bar baz'.split())
+        assert options.a()
+        assert options.c() == []
+        assert options.b() == 'foo'
+        assert options.remaining() == ['bar', 'baz']
+        // end::withArgumentInterface[]
+        """
+    }
+
+    void testMultipleArgsAndOptionalValueSeparatorInterface() {
+        assertScript """
+        import cli.ValSepI
+        $importCliBuilder
+        // tag::multipleArgsInterface[]
+        def cli = new CliBuilder()
+
+        def options = cli.parseFromSpec(ValSepI, '-a 1 2 3 4'.split())
+        assert options.a() == ['1', '2']
+        assert options.remaining() == ['3', '4']
+
+        options = cli.parseFromSpec(ValSepI, '-a1 -a2 3'.split())
+        assert options.a() == ['1', '2']
+        assert options.remaining() == ['3']
+
+        options = cli.parseFromSpec(ValSepI, ['-b1,2'] as String[])
+        assert options.b() == ['1', '2']
+
+        options = cli.parseFromSpec(ValSepI, ['-c', '1'] as String[])
+        assert options.c() == ['1']
+
+        options = cli.parseFromSpec(ValSepI, ['-c1'] as String[])
+        assert options.c() == ['1']
+
+        options = cli.parseFromSpec(ValSepI, ['-c1,2,3'] as String[])
+        assert options.c() == ['1', '2', '3']
+        // end::multipleArgsInterface[]
+        """
+    }
+
+    void testType() {
+        assertScript """
+        import java.math.RoundingMode
+        $importCliBuilder
+        // tag::withType[]
+        def argz = '''-a John -b -d 21 -e 1980 -f 3.5 -g 3.14159
+            -h cv.txt -i DOWN and some more'''.split()
+        def cli = new CliBuilder()
+        cli.a(type: String, 'a-arg')
+        cli.b(type: boolean, 'b-arg')
+        cli.c(type: Boolean, 'c-arg')
+        cli.d(type: int, 'd-arg')
+        cli.e(type: Long, 'e-arg')
+        cli.f(type: Float, 'f-arg')
+        cli.g(type: BigDecimal, 'g-arg')
+        cli.h(type: File, 'h-arg')
+        cli.i(type: RoundingMode, 'i-arg')
+        def options = cli.parse(argz)
+        assert options.a == 'John'
+        assert options.b
+        assert !options.c
+        assert options.d == 21
+        assert options.e == 1980L
+        assert options.f == 3.5f
+        assert options.g == 3.14159
+        assert options.h == new File('cv.txt')
+        assert options.i == RoundingMode.DOWN
+        assert options.arguments() == ['and', 'some', 'more']
+        // end::withType[]
+        """
+    }
+
+    void testTypeMultiple() {
+        assertScript """
+        $importCliBuilder
+        // tag::withTypeMultiple[]
+        def argz = '''-j 3 4 5 -k1.5,2.5,3.5 and some more'''.split()
+        def cli = new CliBuilder()
+        cli.j(args: 3, type: int[], 'j-arg')
+        cli.k(args: '+', valueSeparator: ',', type: BigDecimal[], 'k-arg')
+        def options = cli.parse(argz)
+        assert options.js == [3, 4, 5] // <1>
+        assert options.j == [3, 4, 5]  // <1>
+        assert options.k == [1.5, 2.5, 3.5]
+        assert options.arguments() == ['and', 'some', 'more']
+        // end::withTypeMultiple[]
+        """
+    }
+
+    void testConvert() {
+        assertScript """
+        $importCliBuilder
+        // tag::withConvert[]
+        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
+        def cli = new CliBuilder()
+        def lower = { it.toLowerCase() }
+        cli.a(convert: lower, 'a-arg')
+        cli.b(convert: { it.toUpperCase() }, 'b-arg')
+        cli.d(convert: { Date.parse('yyyy-MM-dd', it) }, 'd-arg')
+        def options = cli.parse(argz)
+        assert options.a == 'john'
+        assert options.b == 'MARY'
+        assert options.d.format('dd-MMM-yyyy') == '01-Jan-2016'
+        assert options.arguments() == ['and', 'some', 'more']
+        // end::withConvert[]
+        """
+    }
+
+    void testConvertInterface() {
+        assertScript """
+        import cli.WithConvertI
+        $importCliBuilder
+        // tag::withConvertInterface[]
+        Date newYears = Date.parse("yyyy-MM-dd", "2016-01-01")
+        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
+        def cli = new CliBuilder()
+        def options = cli.parseFromSpec(WithConvertI, argz)
+        assert options.a() == 'john'
+        assert options.b() == 'MARY'
+        assert options.d() == newYears
+        assert options.remaining() == ['and', 'some', 'more']
+        // end::withConvertInterface[]
+        """
+    }
+
+    void testDefaultValue() {
+        assertScript """
+        $importCliBuilder
+        // tag::withDefaultValue[]
+        def cli = new CliBuilder()
+        cli.f longOpt: 'from', type: String, args: 1, defaultValue: 'one', 'f option'
+        cli.t longOpt: 'to', type: int, defaultValue: '35', 't option'
+
+        def options = cli.parse('-f two'.split())
+        assert options.hasOption('f')
+        assert options.f == 'two'
+        assert !options.hasOption('t')
+        assert options.t == 35
+
+        options = cli.parse('-t 45'.split())
+        assert !options.hasOption('from')
+        assert options.from == 'one'
+        assert options.hasOption('to')
+        assert options.to == 45
+        // end::withDefaultValue[]
+        """
+    }
+
+    void testDefaultValueInterface() {
+        assertScript """
+        $importCliBuilder
+        import cli.WithDefaultValueI
+        // tag::withDefaultValueInterface[]
+        def cli = new CliBuilder()
+
+        def options = cli.parseFromSpec(WithDefaultValueI, '-f two'.split())
+        assert options.from() == 'two'
+        assert options.to() == 35
+
+        options = cli.parseFromSpec(WithDefaultValueI, '-t 45'.split())
+        assert options.from() == 'one'
+        assert options.to() == 45
+        // end::withDefaultValueInterface[]
+        """
+    }
+
+    void testTypeCheckedInterfaceRunner() {
+        assertScript """
+        $importCliBuilder
+        import cli.TypeCheckedI
+        import groovy.transform.TypeChecked
+        // tag::withTypeCheckedInterface[]
+        @TypeChecked
+        void testTypeCheckedInterface() {
+            def argz = "--name John --age 21 and some more".split()
+            def cli = new CliBuilder()
+            def options = cli.parseFromSpec(TypeCheckedI, argz)
+            String n = options.name()
+            int a = options.age()
+            assert n == 'John' && a == 21
+            assert options.remaining() == ['and', 'some', 'more']
+        }
+        // end::withTypeCheckedInterface[]
+        testTypeCheckedInterface()
+        """
+    }
+
+    void testTypeCheckedRunner() {
+        assertScript """
+        $importCliBuilder
+        // tag::withTypeChecked[]
+        import groovy.cli.TypedOption
+        import groovy.transform.TypeChecked
+
+        @TypeChecked
+        void testTypeChecked() {
+            def cli = new CliBuilder()
+            TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
+            TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
+            def argz = "--name John --age 21 and some more".split()
+            def options = cli.parse(argz)
+            String n = options[name]
+            int a = options[age]
+            assert n == 'John' && a == 21
+            assert options.arguments() == ['and', 'some', 'more']
+        }
+        // end::withTypeChecked[]
+        testTypeChecked()
+        """
+    }
+}
diff --git a/src/spec/test/cli/GreeterC.groovy b/src/spec/test/cli/GreeterC.groovy
new file mode 100644
index 0000000000..500819aae5
--- /dev/null
+++ b/src/spec/test/cli/GreeterC.groovy
@@ -0,0 +1,39 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+import groovy.cli.Option
+import groovy.cli.Unparsed
+
+// tag::annotationClassSpec[]
+class GreeterC {
+    @Option(shortName='h', description='display usage')
+    Boolean help                        // <1>
+
+    private String audience
+    @Option(shortName='a', description='greeting audience')
+    void setAudience(String audience) { // <2>
+        this.audience = audience
+    }
+    String getAudience() { audience }
+
+    @Unparsed(description = "positional parameters")
+    List remaining                      // <3>
+}
+// end::annotationClassSpec[]
diff --git a/src/spec/test/cli/GreeterI.groovy b/src/spec/test/cli/GreeterI.groovy
new file mode 100644
index 0000000000..bf9ca3da5e
--- /dev/null
+++ b/src/spec/test/cli/GreeterI.groovy
@@ -0,0 +1,30 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+import groovy.cli.Option
+import groovy.cli.Unparsed
+
+// tag::annotationInterfaceSpec[]
+interface GreeterI {
+    @Option(shortName='h', description='display usage') Boolean help()        // <1>
+    @Option(shortName='a', description='greeting audience') String audience() // <2>
+    @Unparsed(description = "positional parameters") List remaining()         // <3>
+}
+// end::annotationInterfaceSpec[]
diff --git a/src/spec/test/cli/TypeCheckedI.groovy b/src/spec/test/cli/TypeCheckedI.groovy
new file mode 100644
index 0000000000..9569364e90
--- /dev/null
+++ b/src/spec/test/cli/TypeCheckedI.groovy
@@ -0,0 +1,30 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+import groovy.cli.Option
+import groovy.cli.Unparsed
+
+// tag::withTypeCheckedInterfaceSpec[]
+interface TypeCheckedI{
+    @Option String name()
+    @Option int age()
+    @Unparsed List remaining()
+}
+// end::withTypeCheckedInterfaceSpec[]
diff --git a/src/spec/test/cli/ValSepI.groovy b/src/spec/test/cli/ValSepI.groovy
new file mode 100644
index 0000000000..3dc4a2d66a
--- /dev/null
+++ b/src/spec/test/cli/ValSepI.groovy
@@ -0,0 +1,31 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+import groovy.cli.Option
+import groovy.cli.Unparsed
+
+// tag::multipleArgsInterfaceSpec[]
+interface ValSepI {
+    @Option(numberOfArguments=2) String[] a()
+    @Option(numberOfArgumentsString='2', valueSeparator=',') String[] b()
+    @Option(numberOfArgumentsString='+', valueSeparator=',') String[] c()
+    @Unparsed remaining()
+}
+// end::multipleArgsInterfaceSpec[]
diff --git a/src/spec/test/cli/WithArgsI.groovy b/src/spec/test/cli/WithArgsI.groovy
new file mode 100644
index 0000000000..aff71c0359
--- /dev/null
+++ b/src/spec/test/cli/WithArgsI.groovy
@@ -0,0 +1,31 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+import groovy.cli.Option
+import groovy.cli.Unparsed
+
+// tag::withArgumentInterfaceSpec[]
+interface WithArgsI {
+    @Option boolean a()
+    @Option String b()
+    @Option(optionalArg=true) String[] c()
+    @Unparsed List remaining()
+}
+// end::withArgumentInterfaceSpec[]
diff --git a/src/spec/test/cli/WithConvertI.groovy b/src/spec/test/cli/WithConvertI.groovy
new file mode 100644
index 0000000000..1f3d97b674
--- /dev/null
+++ b/src/spec/test/cli/WithConvertI.groovy
@@ -0,0 +1,31 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+import groovy.cli.Option
+import groovy.cli.Unparsed
+
+// tag::withConvertInterfaceSpec[]
+interface WithConvertI {
+    @Option(convert={ it.toLowerCase() }) String a()
+    @Option(convert={ it.toUpperCase() }) String b()
+    @Option(convert={ Date.parse("yyyy-MM-dd", it) }) Date d()
+    @Unparsed List remaining()
+}
+// end::withConvertInterfaceSpec[]
diff --git a/src/spec/test/cli/WithDefaultValueI.groovy b/src/spec/test/cli/WithDefaultValueI.groovy
new file mode 100644
index 0000000000..2d27379139
--- /dev/null
+++ b/src/spec/test/cli/WithDefaultValueI.groovy
@@ -0,0 +1,28 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package cli
+
+import groovy.cli.Option
+
+// tag::withDefaultValueInterfaceSpec[]
+interface WithDefaultValueI {
+    @Option(shortName='f', defaultValue='one') String from()
+    @Option(shortName='t', defaultValue='35') int to()
+}
+// end::withDefaultValueInterfaceSpec[]
diff --git a/subprojects/groovy-cli-commons/build.gradle b/subprojects/groovy-cli-commons/build.gradle
index c77cf10f5d..ccb91abf43 100644
--- a/subprojects/groovy-cli-commons/build.gradle
+++ b/subprojects/groovy-cli-commons/build.gradle
@@ -19,6 +19,7 @@
 dependencies {
     compile rootProject
     compile "commons-cli:commons-cli:$commonsCliVersion"
+    testCompile rootProject.sourceSets.test.output
     testCompile project(':groovy-test')
     testCompile project(':groovy-dateutil')
 }
diff --git a/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy b/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy
index 313a793077..7985159375 100644
--- a/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy
@@ -18,351 +18,35 @@
  */
 package builder
 
-import groovy.cli.Option
+import cli.CliBuilderTestCase
 import groovy.cli.TypedOption
-import groovy.cli.Unparsed
+import groovy.cli.commons.CliBuilder
 import groovy.transform.TypeChecked
 
-import java.math.RoundingMode
+class CliBuilderTest extends CliBuilderTestCase {
 
-class CliBuilderTest extends GroovyTestCase {
-//    void tearDown() {
-//    }
+    String getImportCliBuilder() { 'import groovy.cli.commons.CliBuilder\n' }
 
-    // tag::annotationInterfaceSpec[]
-    interface GreeterI {
-        @Option(shortName='h', description='display usage') Boolean help()        // <1>
-        @Option(shortName='a', description='greeting audience') String audience() // <2>
-        @Unparsed List remaining()                                                // <3>
+    // don't expect toString values to be the same, so test per CliBuilder implementation
+    void testAnnotationsInterfaceToString() {
+        doTestAnnotationsInterfaceToString('usage', '''\
+usage: groovy Greeter
+ -a,--audience <arg>   greeting audience
+ -h,--help             display usage
+''')
     }
-    // end::annotationInterfaceSpec[]
 
-    // tag::annotationClassSpec[]
-    class GreeterC {
-        @Option(shortName='h', description='display usage')
-        Boolean help                        // <1>
-
-        private String audience
-        @Option(shortName='a', description='greeting audience')
-        void setAudience(String audience) { // <2>
-            this.audience = audience
-        }
-        String getAudience() { audience }
-
-        @Unparsed
-        List remaining                      // <3>
-    }
-    // end::annotationClassSpec[]
-
-    void testAnnotationsInterface() {
-        // tag::annotationInterface[]
-        def cli = new CliBuilder(usage: 'groovy Greeter [option]')  // <1>
-        def argz = '--audience Groovologist'.split()
-        def options = cli.parseFromSpec(GreeterI, argz)             // <2>
-        assert options.audience() == 'Groovologist'                 // <3>
-
-        argz = '-h Some Other Args'.split()
-        options = cli.parseFromSpec(GreeterI, argz)                 // <4>
-        assert options.help()
-        assert options.remaining() == ['Some', 'Other', 'Args']     // <5>
-        // end::annotationInterface[]
-    }
-
-    void testAnnotationsClass() {
-        // tag::annotationClass[]
-        def cli = new CliBuilder(usage: 'groovy Greeter [option]') // <1>
-        def options = new GreeterC()                               // <2>
-        def argz = '--audience Groovologist foo'.split()
-        cli.parseFromInstance(options, argz)                       // <3>
-        assert options.audience == 'Groovologist'                  // <4>
-        assert options.remaining == ['foo']                        // <5>
-        // end::annotationClass[]
-    }
-
-    void testParseScript() {
-        def argz = '--audience Groovologist foo'.split()
-        new GroovyShell().run('''
-            // tag::annotationScript[]
-            import groovy.cli.OptionField
-            import groovy.cli.UnparsedField
-
-            @OptionField String audience
-            @OptionField Boolean help
-            @UnparsedField List remaining
-            new CliBuilder().parseFromInstance(this, args)
-            assert audience == 'Groovologist'
-            assert remaining == ['foo']
-            // end::annotationScript[]
-        ''', 'TestScript.groovy', argz)
-    }
-
-    void testWithArgument() {
-        // tag::withArgument[]
-        def cli = new CliBuilder()
-        cli.a(args: 0, 'a arg') // <1>
-        cli.b(args: 1, 'b arg') // <2>
-        cli.c(args: 1, optionalArg: true, 'c arg') // <3>
-        def options = cli.parse('-a -b foo -c bar baz'.split()) // <4>
-
-        assert options.a == true
-        assert options.b == 'foo'
-        assert options.c == 'bar'
-        assert options.arguments() == ['baz']
-
-        options = cli.parse('-a -c -b foo bar baz'.split()) // <5>
-
-        assert options.a == true
-        assert options.c == true
-        assert options.b == 'foo'
-        assert options.arguments() == ['bar', 'baz']
-        // end::withArgument[]
-    }
-
-    // tag::withArgumentInterfaceSpec[]
-    interface WithArgsI {
-        @Option boolean a()
-        @Option String b()
-        @Option(optionalArg=true) String[] c()
-        @Unparsed List remaining()
-    }
-    // end::withArgumentInterfaceSpec[]
-
-    void testWithArgumentInterface() {
-        // tag::withArgumentInterface[]
-        def cli = new CliBuilder()
-        def options = cli.parseFromSpec(WithArgsI, '-a -b foo -c bar baz'.split())
-        assert options.a()
-        assert options.b() == 'foo'
-        assert options.c() == ['bar']
-        assert options.remaining() == ['baz']
-
-        options = cli.parseFromSpec(WithArgsI, '-a -c -b foo bar baz'.split())
-        assert options.a()
-        assert options.c() == []
-        assert options.b() == 'foo'
-        assert options.remaining() == ['bar', 'baz']
-        // end::withArgumentInterface[]
-    }
-
-    void testMultipleArgsAndOptionalValueSeparator() {
-        // tag::multipleArgs[]
-        def cli = new CliBuilder()
-        cli.a(args: 2, 'a-arg')
-        cli.b(args: '2', valueSeparator: ',', 'b-arg') // <1>
-        cli.c(args: '+', valueSeparator: ',', 'c-arg') // <2>
-
-        def options = cli.parse('-a 1 2 3 4'.split()) // <3>
-        assert options.a == '1' // <4>
-        assert options.as == ['1', '2'] // <5>
-        assert options.arguments() == ['3', '4']
-
-        options = cli.parse('-a1 -a2 3'.split()) // <6>
-        assert options.as == ['1', '2']
-        assert options.arguments() == ['3']
-
-        options = cli.parse(['-b1,2']) // <7>
-        assert options.bs == ['1', '2']
-
-        options = cli.parse(['-c', '1'])
-        assert options.cs == ['1']
-
-        options = cli.parse(['-c1'])
-        assert options.cs == ['1']
-
-        options = cli.parse(['-c1,2,3'])
-        assert options.cs == ['1', '2', '3']
-        // end::multipleArgs[]
-    }
-
-    // tag::multipleArgsInterfaceSpec[]
-    interface ValSepI {
-        @Option(numberOfArguments=2) String[] a()
-        @Option(numberOfArgumentsString='2', valueSeparator=',') String[] b()
-        @Option(numberOfArgumentsString='+', valueSeparator=',') String[] c()
-        @Unparsed remaining()
-    }
-    // end::multipleArgsInterfaceSpec[]
-
-    void testMultipleArgsAndOptionalValueSeparatorInterface() {
-        // tag::multipleArgsInterface[]
-        def cli = new CliBuilder()
-
-        def options = cli.parseFromSpec(ValSepI, '-a 1 2 3 4'.split())
-        assert options.a() == ['1', '2']
-        assert options.remaining() == ['3', '4']
-
-        options = cli.parseFromSpec(ValSepI, '-a1 -a2 3'.split())
-        assert options.a() == ['1', '2']
-        assert options.remaining() == ['3']
-
-        options = cli.parseFromSpec(ValSepI, ['-b1,2'] as String[])
-        assert options.b() == ['1', '2']
-
-        options = cli.parseFromSpec(ValSepI, ['-c', '1'] as String[])
-        assert options.c() == ['1']
-
-        options = cli.parseFromSpec(ValSepI, ['-c1'] as String[])
-        assert options.c() == ['1']
-
-        options = cli.parseFromSpec(ValSepI, ['-c1,2,3'] as String[])
-        assert options.c() == ['1', '2', '3']
-        // end::multipleArgsInterface[]
-    }
-
-    void testType() {
-        // tag::withType[]
-        def argz = '''-a John -b -d 21 -e 1980 -f 3.5 -g 3.14159
-            -h cv.txt -i DOWN and some more'''.split()
-        def cli = new CliBuilder()
-        cli.a(type: String, 'a-arg')
-        cli.b(type: boolean, 'b-arg')
-        cli.c(type: Boolean, 'c-arg')
-        cli.d(type: int, 'd-arg')
-        cli.e(type: Long, 'e-arg')
-        cli.f(type: Float, 'f-arg')
-        cli.g(type: BigDecimal, 'g-arg')
-        cli.h(type: File, 'h-arg')
-        cli.i(type: RoundingMode, 'i-arg')
-        def options = cli.parse(argz)
-        assert options.a == 'John'
-        assert options.b
-        assert !options.c
-        assert options.d == 21
-        assert options.e == 1980L
-        assert options.f == 3.5f
-        assert options.g == 3.14159
-        assert options.h == new File('cv.txt')
-        assert options.i == RoundingMode.DOWN
-        assert options.arguments() == ['and', 'some', 'more']
-        // end::withType[]
-    }
-
-    void testTypeMultiple() {
-        // tag::withTypeMultiple[]
-        def argz = '''-j 3 4 5 -k1.5,2.5,3.5 and some more'''.split()
-        def cli = new CliBuilder()
-        cli.j(args: 3, type: int[], 'j-arg')
-        cli.k(args: '+', valueSeparator: ',', type: BigDecimal[], 'k-arg')
-        def options = cli.parse(argz)
-        assert options.js == [3, 4, 5] // <1>
-        assert options.j == [3, 4, 5]  // <1>
-        assert options.k == [1.5, 2.5, 3.5]
-        assert options.arguments() == ['and', 'some', 'more']
-        // end::withTypeMultiple[]
-    }
-
-    void testConvert() {
-        // tag::withConvert[]
-        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
-        def cli = new CliBuilder()
-        def lower = { it.toLowerCase() }
-        cli.a(convert: lower, 'a-arg')
-        cli.b(convert: { it.toUpperCase() }, 'b-arg')
-        cli.d(convert: { Date.parse('yyyy-MM-dd', it) }, 'd-arg')
-        def options = cli.parse(argz)
-        assert options.a == 'john'
-        assert options.b == 'MARY'
-        assert options.d.format('yyyy-MM-dd') == '2016-01-01'
-        assert options.arguments() == ['and', 'some', 'more']
-        // end::withConvert[]
-    }
-
-    // tag::withConvertInterfaceSpec[]
-    interface WithConvertI {
-        @Option(convert={ it.toLowerCase() }) String a()
-        @Option(convert={ it.toUpperCase() }) String b()
-        @Option(convert={ Date.parse("yyyy-MM-dd", it) }) Date d()
-        @Unparsed List remaining()
-    }
-    // end::withConvertInterfaceSpec[]
-
-    void testConvertInterface() {
-        // tag::withConvertInterface[]
-        Date newYears = Date.parse("yyyy-MM-dd", "2016-01-01")
-        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
-        def cli = new CliBuilder()
-        def options = cli.parseFromSpec(WithConvertI, argz)
-        assert options.a() == 'john'
-        assert options.b() == 'MARY'
-        assert options.d() == newYears
-        assert options.remaining() == ['and', 'some', 'more']
-        // end::withConvertInterface[]
-    }
-
-    void testDefaultValue() {
-        // tag::withDefaultValue[]
-        def cli = new CliBuilder()
-        cli.f longOpt: 'from', type: String, args: 1, defaultValue: 'one', 'f option'
-        cli.t longOpt: 'to', type: int, defaultValue: '35', 't option'
-
-        def options = cli.parse('-f two'.split())
-        assert options.hasOption('f')
-        assert options.f == 'two'
-        assert !options.hasOption('t')
-        assert options.t == 35
-
-        options = cli.parse('-t 45'.split())
-        assert !options.hasOption('from')
-        assert options.from == 'one'
-        assert options.hasOption('to')
-        assert options.to == 45
-        // end::withDefaultValue[]
-    }
-
-    // tag::withDefaultValueInterfaceSpec[]
-    interface WithDefaultValueI {
-        @Option(shortName='f', defaultValue='one') String from()
-        @Option(shortName='t', defaultValue='35') int to()
-    }
-    // end::withDefaultValueInterfaceSpec[]
-
-    void testDefaultValueInterface() {
-        // tag::withDefaultValueInterface[]
-        def cli = new CliBuilder()
-
-        def options = cli.parseFromSpec(WithDefaultValueI, '-f two'.split())
-        assert options.from() == 'two'
-        assert options.to() == 35
-
-        options = cli.parseFromSpec(WithDefaultValueI, '-t 45'.split())
-        assert options.from() == 'one'
-        assert options.to() == 45
-        // end::withDefaultValueInterface[]
-    }
-
-    // tag::withTypeCheckedInterfaceSpec[]
-    interface TypeCheckedI{
-        @Option String name()
-        @Option int age()
-        @Unparsed List remaining()
-    }
-    // end::withTypeCheckedInterfaceSpec[]
-
-    // tag::withTypeCheckedInterface[]
-    @TypeChecked
-    void testTypeCheckedInterface() {
-        def argz = "--name John --age 21 and some more".split()
-        def cli = new CliBuilder()
-        def options = cli.parseFromSpec(TypeCheckedI, argz)
-        String n = options.name()
-        int a = options.age()
-        assert n == 'John' && a == 21
-        assert options.remaining() == ['and', 'some', 'more']
-    }
-    // end::withTypeCheckedInterface[]
-
-    // tag::withTypeChecked[]
     @TypeChecked
-    void testTypeChecked() {
+    void testTypeChecked_showingSingleHyphenForLongOptSupport() {
         def cli = new CliBuilder()
         TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
         TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
-        def argz = "--name John --age 21 and some more".split()
+        def argz = "--name John -age 21 and some more".split()
         def options = cli.parse(argz)
         String n = options[name]
         int a = options[age]
         assert n == 'John' && a == 21
         assert options.arguments() == ['and', 'some', 'more']
     }
-    // end::withTypeChecked[]
+
 }
diff --git a/subprojects/groovy-cli-commons/src/spec/test/groovy/util/CliBuilderTest.groovy b/subprojects/groovy-cli-commons/src/spec/test/groovy/util/CliBuilderTest.groovy
new file mode 100644
index 0000000000..a0d513c2af
--- /dev/null
+++ b/subprojects/groovy-cli-commons/src/spec/test/groovy/util/CliBuilderTest.groovy
@@ -0,0 +1,28 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.util
+
+import cli.CliBuilderTestCase
+
+// test groovy.util legacy delegate
+class CliBuilderTest extends CliBuilderTestCase {
+
+    String getImportCliBuilder() { '' }
+
+}
diff --git a/subprojects/groovy-cli-picocli/build.gradle b/subprojects/groovy-cli-picocli/build.gradle
index dececa0485..d83ddfd479 100644
--- a/subprojects/groovy-cli-picocli/build.gradle
+++ b/subprojects/groovy-cli-picocli/build.gradle
@@ -19,6 +19,7 @@
 dependencies {
     compile rootProject
     compile "info.picocli:picocli:$picocliVersion"
+    testCompile rootProject.sourceSets.test.output
     testCompile project(':groovy-test')
     testCompile project(':groovy-dateutil')
 }
diff --git a/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
index 195ac0d590..62e00fdd34 100644
--- a/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
@@ -18,366 +18,45 @@
  */
 package builder
 
+import cli.CliBuilderTestCase
 import groovy.cli.picocli.CliBuilder
-import groovy.cli.Option
 import groovy.cli.TypedOption
-import groovy.cli.Unparsed
 import groovy.transform.TypeChecked
 
-import java.math.RoundingMode
-import java.text.SimpleDateFormat
+// tag::mapOptionImports[]
 import java.util.concurrent.TimeUnit
 import static java.util.concurrent.TimeUnit.DAYS
 import static java.util.concurrent.TimeUnit.HOURS
+// end::mapOptionImports[]
 
-//import java.math.RoundingMode
+// Core functionality we expect to remain the same for all implementations is tested in the base test case
+// here we also add any functionality specific to this implementation that we value highly
+class CliBuilderTest extends CliBuilderTestCase {
 
-class CliBuilderTest extends GroovyTestCase {
-//    void tearDown() {
-//    }
+    String getImportCliBuilder() { 'import groovy.cli.picocli.CliBuilder\n' }
 
-    // tag::annotationInterfaceSpec[]
-    interface GreeterI {
-        @Option(shortName='h', description='display usage') Boolean help()        // <1>
-        @Option(shortName='a', description='greeting audience') String audience() // <2>
-        @Unparsed(description = "positional parameters") List remaining()         // <3>
-    }
-    // end::annotationInterfaceSpec[]
-
-    // tag::annotationClassSpec[]
-    class GreeterC {
-        @Option(shortName='h', description='display usage')
-        Boolean help                        // <1>
-
-        private String audience
-        @Option(shortName='a', description='greeting audience')
-        void setAudience(String audience) { // <2>
-            this.audience = audience
-        }
-        String getAudience() { audience }
-
-        @Unparsed(description = "positional parameters")
-        List remaining                      // <3>
+    void testAnnotationsInterfaceToStringWithUsage() {
+        doTestAnnotationsInterfaceToString('usage', '''\
+Usage: groovy Greeter
+      [<remaining>...]   positional parameters
+  -a, --audience=<audience>
+                         greeting audience
+  -h, --help             display usage
+''')
     }
-    // end::annotationClassSpec[]
-
-    void testAnnotationsInterface() {
-        // tag::annotationInterface[]
-        def cli = new CliBuilder(name: 'groovy Greeter')  // <1>
-        def argz = '--audience Groovologist'.split()
-        def options = cli.parseFromSpec(GreeterI, argz)             // <2>
-        assert options.audience() == 'Groovologist'                 // <3>
-
-        argz = '-h Some Other Args'.split()
-        options = cli.parseFromSpec(GreeterI, argz)                 // <4>
-        assert options.help()
-        assert options.remaining() == ['Some', 'Other', 'Args']     // <5>
-        // end::annotationInterface[]
-
-        options = cli.parseFromSpec(GreeterI, ['-h', 'Some', 'Other', 'Args'] as String[])
-        assert options.help()
-        assert options.remaining() == ['Some', 'Other', 'Args']
-        StringWriter sw = new StringWriter()
-        cli.writer = new PrintWriter(sw)
-        cli.usage()
 
-        String expected = '''\
+    void testAnnotationsInterfaceToStringWithName() {
+        doTestAnnotationsInterfaceToString('name', '''\
 Usage: groovy Greeter [-h] [-a=<audience>] [<remaining>...]
       [<remaining>...]   positional parameters
   -a, --audience=<audience>
                          greeting audience
   -h, --help             display usage
-'''
-        assert expected.normalize() == sw.toString().normalize()
-    }
-
-    void testAnnotationsClass() {
-        // tag::annotationClass[]
-        def cli = new CliBuilder(usage: 'groovy Greeter [option]') // <1>
-        def options = new GreeterC()                               // <2>
-        def argz = '--audience Groovologist foo'.split()
-        cli.parseFromInstance(options, argz)                       // <3>
-        assert options.audience == 'Groovologist'                  // <4>
-        assert options.remaining == ['foo']                        // <5>
-        // end::annotationClass[]
-    }
-
-    void testParseScript() {
-        def argz = '--audience Groovologist foo'.split()
-        new GroovyShell().run('''
-            // tag::annotationScript[]
-            import groovy.cli.picocli.CliBuilder
-            import groovy.cli.OptionField
-            import groovy.cli.UnparsedField
-
-            @OptionField String audience
-            @OptionField Boolean help
-            @UnparsedField List remaining
-            new CliBuilder().parseFromInstance(this, args)
-            assert audience == 'Groovologist'
-            assert remaining == ['foo']
-            // end::annotationScript[]
-        ''', 'TestScript.groovy', argz)
-    }
-
-    void testWithArgument() {
-        // tag::withArgument[]
-        def cli = new CliBuilder()
-        cli.a(args: 0, 'a arg') // <1>
-        cli.b(args: 1, 'b arg') // <2>
-        cli.c(args: 1, optionalArg: true, 'c arg') // <3>
-        def options = cli.parse('-a -b foo -c bar baz'.split()) // <4>
-
-        assert options.a == true
-        assert options.b == 'foo'
-        assert options.c == 'bar'
-        assert options.arguments() == ['baz']
-
-        options = cli.parse('-a -c -b foo bar baz'.split()) // <5>
-
-        assert options.a == true
-        assert options.c == true
-        assert options.b == 'foo'
-        assert options.arguments() == ['bar', 'baz']
-        // end::withArgument[]
-    }
-
-    // tag::withArgumentInterfaceSpec[]
-    interface WithArgsI {
-        @Option boolean a()
-        @Option String b()
-        @Option(optionalArg=true) String[] c()
-        @Unparsed List remaining()
-    }
-    // end::withArgumentInterfaceSpec[]
-
-    void testWithArgumentInterface() {
-        // tag::withArgumentInterface[]
-        def cli = new CliBuilder()
-        def options = cli.parseFromSpec(WithArgsI, '-a -b foo -c bar baz'.split())
-        assert options.a()
-        assert options.b() == 'foo'
-        assert options.c() == ['bar']
-        assert options.remaining() == ['baz']
-
-        options = cli.parseFromSpec(WithArgsI, '-a -c -b foo bar baz'.split())
-        assert options.a()
-        assert options.c() == []
-        assert options.b() == 'foo'
-        assert options.remaining() == ['bar', 'baz']
-        // end::withArgumentInterface[]
-    }
-
-    void testMultipleArgsAndOptionalValueSeparator() {
-        // tag::multipleArgs[]
-        def cli = new CliBuilder()
-        cli.a(args: 2, 'a-arg')
-        cli.b(args: '2', valueSeparator: ',', 'b-arg') // <1>
-        cli.c(args: '+', valueSeparator: ',', 'c-arg') // <2>
-
-        def options = cli.parse('-a 1 2 3 4'.split()) // <3>
-        assert options.a == '1' // <4>
-        assert options.as == ['1', '2'] // <5>
-        assert options.arguments() == ['3', '4']
-
-        options = cli.parse('-a1 -a2 3'.split()) // <6>
-        assert options.as == ['1', '2']
-        assert options.arguments() == ['3']
-
-        options = cli.parse(['-b1,2']) // <7>
-        assert options.bs == ['1', '2']
-
-        options = cli.parse(['-c', '1'])
-        assert options.cs == ['1']
-
-        options = cli.parse(['-c1'])
-        assert options.cs == ['1']
-
-        options = cli.parse(['-c1,2,3'])
-        assert options.cs == ['1', '2', '3']
-        // end::multipleArgs[]
-    }
-
-    // tag::multipleArgsInterfaceSpec[]
-    interface ValSepI {
-        @Option(numberOfArguments=2) String[] a()
-        @Option(numberOfArgumentsString='2', valueSeparator=',') String[] b()
-        @Option(numberOfArgumentsString='+', valueSeparator=',') String[] c()
-        @Unparsed remaining()
-    }
-    // end::multipleArgsInterfaceSpec[]
-
-    void testMultipleArgsAndOptionalValueSeparatorInterface() {
-        // tag::multipleArgsInterface[]
-        def cli = new CliBuilder()
-
-        def options = cli.parseFromSpec(ValSepI, '-a 1 2 3 4'.split())
-        assert options.a() == ['1', '2']
-        assert options.remaining() == ['3', '4']
-
-        options = cli.parseFromSpec(ValSepI, '-a1 -a2 3'.split())
-        assert options.a() == ['1', '2']
-        assert options.remaining() == ['3']
-
-        options = cli.parseFromSpec(ValSepI, ['-b1,2'] as String[])
-        assert options.b() == ['1', '2']
-
-        options = cli.parseFromSpec(ValSepI, ['-c', '1'] as String[])
-        assert options.c() == ['1']
-
-        options = cli.parseFromSpec(ValSepI, ['-c1'] as String[])
-        assert options.c() == ['1']
-
-        options = cli.parseFromSpec(ValSepI, ['-c1,2,3'] as String[])
-        assert options.c() == ['1', '2', '3']
-        // end::multipleArgsInterface[]
-    }
-
-    void testType() {
-        // tag::withType[]
-        def argz = '''-a John -b -d 21 -e 1980 -f 3.5 -g 3.14159
-            -h cv.txt -i DOWN and some more'''.split()
-        def cli = new CliBuilder()
-        cli.a(type: String, 'a-arg')
-        cli.b(type: boolean, 'b-arg')
-        cli.c(type: Boolean, 'c-arg')
-        cli.d(type: int, 'd-arg')
-        cli.e(type: Long, 'e-arg')
-        cli.f(type: Float, 'f-arg')
-        cli.g(type: BigDecimal, 'g-arg')
-        cli.h(type: File, 'h-arg')
-        cli.i(type: RoundingMode, 'i-arg')
-        def options = cli.parse(argz)
-        assert options.a == 'John'
-        assert options.b
-        assert !options.c
-        assert options.d == 21
-        assert options.e == 1980L
-        assert options.f == 3.5f
-        assert options.g == 3.14159
-        assert options.h == new File('cv.txt')
-        assert options.i == RoundingMode.DOWN
-        assert options.arguments() == ['and', 'some', 'more']
-        // end::withType[]
-    }
-
-    void testTypeMultiple() {
-        // tag::withTypeMultiple[]
-        def argz = '''-j 3 4 5 -k1.5,2.5,3.5 and some more'''.split()
-        def cli = new CliBuilder()
-        cli.j(args: 3, type: int[], 'j-arg')
-        cli.k(args: '+', valueSeparator: ',', type: BigDecimal[], 'k-arg')
-        def options = cli.parse(argz)
-        assert options.js == [3, 4, 5] // <1>
-        assert options.j == [3, 4, 5]  // <1>
-        assert options.k == [1.5, 2.5, 3.5]
-        assert options.arguments() == ['and', 'some', 'more']
-        // end::withTypeMultiple[]
-    }
-
-    void testConvert() {
-        // tag::withConvert[]
-        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
-        def cli = new CliBuilder()
-        def lower = { it.toLowerCase() }
-        cli.a(convert: lower, 'a-arg')
-        cli.b(convert: { it.toUpperCase() }, 'b-arg')
-        cli.d(convert: { new SimpleDateFormat("yyyy-MM-dd").parse(it) }, 'd-arg')
-        def options = cli.parse(argz)
-        assert options.a == 'john'
-        assert options.b == 'MARY'
-        assert new SimpleDateFormat("dd-MMM-yyyy").format(options.d) == '01-Jan-2016'
-        assert options.arguments() == ['and', 'some', 'more']
-        // end::withConvert[]
-    }
-
-    // tag::withConvertInterfaceSpec[]
-    interface WithConvertI {
-        @Option(convert={ it.toLowerCase() }) String a()
-        @Option(convert={ it.toUpperCase() }) String b()
-        @Option(convert={ new SimpleDateFormat("yyyy-MM-dd").parse(it) }) Date d()
-        @Unparsed List remaining()
-    }
-    // end::withConvertInterfaceSpec[]
-
-    void testConvertInterface() {
-        // tag::withConvertInterface[]
-        Date newYears = new SimpleDateFormat("yyyy-MM-dd").parse("2016-01-01")
-        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
-        def cli = new CliBuilder()
-        def options = cli.parseFromSpec(WithConvertI, argz)
-        assert options.a() == 'john'
-        assert options.b() == 'MARY'
-        assert options.d() == newYears
-        assert options.remaining() == ['and', 'some', 'more']
-        // end::withConvertInterface[]
-    }
-
-    void testDefaultValue() {
-        // tag::withDefaultValue[]
-        def cli = new CliBuilder()
-        cli.f longOpt: 'from', type: String, args: 1, defaultValue: 'one', 'f option'
-        cli.t longOpt: 'to', type: int, defaultValue: '35', 't option'
-
-        def options = cli.parse('-f two'.split())
-        assert options.hasOption('f')
-        assert options.f == 'two'
-        assert !options.hasOption('t')
-        assert options.t == 35
-
-        options = cli.parse('-t 45'.split())
-        assert !options.hasOption('from')
-        assert options.from == 'one'
-        assert options.hasOption('to')
-        assert options.to == 45
-        // end::withDefaultValue[]
-    }
-
-    // tag::withDefaultValueInterfaceSpec[]
-    interface WithDefaultValueI {
-        @Option(shortName='f', defaultValue='one') String from()
-        @Option(shortName='t', defaultValue='35') int to()
-    }
-    // end::withDefaultValueInterfaceSpec[]
-
-    void testDefaultValueInterface() {
-        // tag::withDefaultValueInterface[]
-        def cli = new CliBuilder()
-
-        def options = cli.parseFromSpec(WithDefaultValueI, '-f two'.split())
-        assert options.from() == 'two'
-        assert options.to() == 35
-
-        options = cli.parseFromSpec(WithDefaultValueI, '-t 45'.split())
-        assert options.from() == 'one'
-        assert options.to() == 45
-        // end::withDefaultValueInterface[]
-    }
-
-    // tag::withTypeCheckedInterfaceSpec[]
-    interface TypeCheckedI{
-        @Option String name()
-        @Option int age()
-        @Unparsed List remaining()
-    }
-    // end::withTypeCheckedInterfaceSpec[]
-
-    // tag::withTypeCheckedInterface[]
-    @TypeChecked
-    void testTypeCheckedInterface() {
-        def argz = "--name John --age 21 and some more".split()
-        def cli = new CliBuilder()
-        def options = cli.parseFromSpec(TypeCheckedI, argz)
-        String n = options.name()
-        int a = options.age()
-        assert n == 'John' && a == 21
-        assert options.remaining() == ['and', 'some', 'more']
+''')
     }
-    // end::withTypeCheckedInterface[]
 
-    // tag::withTypeChecked[]
     @TypeChecked
-    void testTypeChecked() {
+    void testTypeChecked_addingSingleHyphenForLongOptSupport() {
         def cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
         TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
         TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
@@ -388,7 +67,6 @@ Usage: groovy Greeter [-h] [-a=<audience>] [<remaining>...]
         assert n == 'John' && a == 21
         assert options.arguments() == ['and', 'some', 'more']
     }
-    // end::withTypeChecked[]
 
     @TypeChecked
     void testTypeChecked_defaultOnlyDoubleHyphen() {
@@ -450,8 +128,8 @@ Footer 2
         assertEquals(expected.normalize(), baos.toString().normalize())
     }
 
-    public void testMapOption() {
-        // tag::MapOption[]
+    void testMapOption() {
+        // tag::mapOption[]
         def cli = new CliBuilder()
         cli.D(args: 2,   valueSeparator: '=', 'the old way')                          // <1>
         cli.X(type: Map, 'the new way')                                               // <2>
@@ -461,10 +139,10 @@ Footer 2
         assert options.Ds == ['a', 'b', 'c', 'd']                                     // <5>
         assert options.Xs == [ 'x':'y', 'i':'j' ]                                     // <6>
         assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         // <7>
-        // end::MapOption[]
+        // end::mapOption[]
     }
 
-    public void testGroovyDocAntExample() {
+    void testGroovyDocAntExample() {
         def cli = new CliBuilder(usage:'ant [options] [targets]',
                 header:'Options:')
         cli.help('print this message')
@@ -493,7 +171,7 @@ Options:
         assertEquals(expected.normalize(), sw.toString().normalize())
     }
 
-    public void testGroovyDocCurlExample() {
+    void testGroovyDocCurlExample() {
         // suppress ANSI escape codes to make this test pass on all environments
         System.setProperty("picocli.ansi", "false")
         ByteArrayOutputStream baos = new ByteArrayOutputStream()

Commit:
7d4cd792225fe60dbe0d0354ad52b29a5ca51ec1
Paul King
paulk@asert.com.au
2018-05-19 09:33:23 +1000
GROOVY-8569 minor tweak (align version short flag with previous Groovy versions)
diff --git a/src/main/groovy/groovy/ui/GroovyMain.java b/src/main/groovy/groovy/ui/GroovyMain.java
index eb2db46450..58c6635f6a 100644
--- a/src/main/groovy/groovy/ui/GroovyMain.java
+++ b/src/main/groovy/groovy/ui/GroovyMain.java
@@ -125,7 +125,6 @@ public class GroovyMain {
     static void processArgs(String[] args, final PrintStream out, final PrintStream err) {
         GroovyCommand groovyCommand = new GroovyCommand();
         CommandLine parser = new CommandLine(groovyCommand).setUnmatchedArgumentsAllowed(true).setStopAtUnmatched(true);
-        parser.getCommandSpec().mixinStandardHelpOptions(true);
         try {
             List<CommandLine> result = parser.parse(args);
             if (CommandLine.printHelpIfRequested(result, out, err, Help.Ansi.AUTO)) {
@@ -215,6 +214,12 @@ public class GroovyMain {
         @Option(names = {"-b", "--basescript"}, paramLabel = "<class>", description = "Base class name for scripts (must derive from Script)")
         private String scriptBaseClass;
 
+        @Option(names = {"-h", "--help"}, usageHelp = true, description = "Show this help message and exit")
+        private boolean helpRequested;
+
+        @Option(names = {"-v", "--version"}, versionHelp = true, description = "Print version information and exit")
+        private boolean versionRequested;
+
         @Unmatched
         List<String> arguments = new ArrayList<String>();
 

Commit:
f37ca2092327646e4524b67f83751f5e8e8cabc0
Paul King
paulk@asert.com.au
2018-05-19 09:03:44 +1000
GROOVY-8577 upgrade to picocli 3.0.1: parent command name is now automatically inserted in usage help for subcommand (closes #711)
diff --git a/build.gradle b/build.gradle
index cb5e9bfb71..fdcb7fda52 100644
--- a/build.gradle
+++ b/build.gradle
@@ -163,7 +163,7 @@ ext {
     luceneVersion = '4.7.2'
     openbeansVersion = '1.0'
     openejbVersion = '1.0'
-    picocliVersion = '3.0.0'
+    picocliVersion = '3.0.1'
     qdoxVersion = '1.12.1'
     slf4jVersion = '1.7.21'
     xmlunitVersion = '1.6'
diff --git a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
index 7c6dee2258..b51322dfd4 100644
--- a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
+++ b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
@@ -127,7 +127,6 @@ class GrapeMain implements Runnable {
     }
 
     @Command(name = 'install', header = 'Installs a particular grape',
-            synopsisHeading = 'Usage: grape ',
             description = 'Installs the specified groovy module or maven artifact. If a version is specified that specific version will be installed, otherwise the most recent version will be used (as if `*` was passed in).')
     private static class Install implements Runnable {
         @Parameters(index = '0', arity = '1', description = 'Which module group the module comes from. Translates directly to a Maven groupId or an Ivy Organization. Any group matching /groovy[x][\\..*]^/ is reserved and may have special meaning to the groovy endorsed modules.')
@@ -164,7 +163,6 @@ class GrapeMain implements Runnable {
     }
 
     @Command(name = 'list', header = 'Lists all installed grapes',
-            synopsisHeading = 'Usage: grape ',
             description = 'Lists locally installed modules (with their full maven name in the case of groovy modules) and versions.')
     private static class ListCommand implements Runnable {
 
@@ -196,7 +194,6 @@ class GrapeMain implements Runnable {
     }
 
     @Command(name = 'resolve', header = 'Enumerates the jars used by a grape',
-            synopsisHeading = 'Usage: grape ',
             description = 'Prints the file locations of the jars representing the artifcats for the specified module(s) and the respective transitive dependencies.')
     private static class Resolve implements Runnable {
 
@@ -292,7 +289,6 @@ class GrapeMain implements Runnable {
     }
 
     @Command(name = 'uninstall',
-            synopsisHeading = 'Usage: grape ',
             description = 'Uninstalls a particular grape (non-transitively removes the respective jar file from the grape cache).')
     private static class Uninstall implements Runnable {
         @Parameters(index = '0', arity = '1', description = 'Which module group the module comes from. Translates directly to a Maven groupId or an Ivy Organization. Any group matching /groovy[x][\\..*]^/ is reserved and may have special meaning to the groovy endorsed modules.')

Commit:
dc55ff5f7fb2854506ce137fd1caebab69348555
Paul King
paulk@asert.com.au
2018-05-19 09:03:41 +1000
GROOVY-8589 bugfix: should not show error about missing mandatory args when --help or --version is specified
diff --git a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
index eaa696409c..7c6dee2258 100644
--- a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
+++ b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
@@ -115,14 +115,14 @@ class GrapeMain implements Runnable {
             optionListHeading = "%nOptions:%n",
             descriptionHeading = "%n")
     private static class HelpOptionsMixin {
-        @Option(names = ["-h", "--help"], description = "usage information") boolean isHelpRequested
-        @Option(names = ["-v", "--version"], description = "display the Groovy and JVM versions") boolean isVersionRequested
+        @Option(names = ["-h", "--help"], usageHelp = true, description = "usage information") boolean isHelpRequested
+        @Option(names = ["-v", "--version"], versionHelp = true, description = "display the Groovy and JVM versions") boolean isVersionRequested
     }
 
     private static class VersionProvider implements CommandLine.IVersionProvider {
         String[] getVersion() {
             String version = GroovySystem.getVersion()
-            return "Groovy Version: $version JVM: ${System.getProperty('java.version')}"
+            return ["Groovy Version: $version JVM: ${System.getProperty('java.version')}"]
         }
     }
 

Commit:
f197fcd2ee4e288507ab276e761c20be893cda6c
Paul King
paulk@asert.com.au
2018-05-19 09:03:06 +1000
GROOVY-8588 use lowercase -v for --version in groovyc to be consistent with other Groovy command line tools (closes #710)
diff --git a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
index e9fc8b57f3..545478ca84 100644
--- a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
+++ b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
@@ -166,7 +166,6 @@ public class FileSystemCompiler {
 
     public static CommandLine configureParser(CompilationOptions options) {
         CommandLine parser = new CommandLine(options);
-        parser.getCommandSpec().mixinStandardHelpOptions(true); // programmatically so these options appear last in usage help
         parser.getCommandSpec().parser()
                 .unmatchedArgumentsAllowed(true)
                 .unmatchedOptionsArePositionalParams(true)
@@ -350,6 +349,12 @@ public class FileSystemCompiler {
         @Option(names = {"--configscript"}, paramLabel = "<script>", description = "A script for tweaking the configuration options")
         private String configScript;
 
+        @Option(names = {"-h", "--help"}, usageHelp = true, description = "Show this help message and exit")
+        private boolean helpRequested;
+
+        @Option(names = {"-v", "--version"}, versionHelp = true, description = "Print version information and exit")
+        private boolean versionRequested;
+
         @Parameters(description = "The groovy source files to compile, or @-files containing a list of source files to compile",
                     paramLabel = "<source-files>")
         private List<String> files;

Commit:
86e27aa393931cb622d33b15ddf1c846fff47a6b
sunlan
sunlan@apache.org
2018-05-18 22:47:36 +0800
Minor refactoring: remove duplicated code
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 27f2bd9ad1..2e8a103770 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -198,13 +198,12 @@ public class GenericsUtils {
         }
     }
 
-    private static String toGenericTypesString(GenericsType[] genericsTypes) {
+    public static String toGenericTypesString(GenericsType[] genericsTypes) {
         if (genericsTypes == null) return "";
         StringBuilder sb = new StringBuilder("<");
-        for (int i = 0; i < genericsTypes.length; i++) {
-            final GenericsType genericsType = genericsTypes[i];
-            sb.append(genericsType.toString());
-            if (i < genericsTypes.length - 1) {
+        for (int i = 0, n = genericsTypes.length; i < n; i++) {
+            sb.append(genericsTypes[i].toString());
+            if (i < n - 1) {
                 sb.append(",");
             }
         }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index de8af20924..c28604aeb4 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -169,6 +169,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.binX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.castX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
+import static org.codehaus.groovy.ast.tools.GenericsUtils.toGenericTypesString;
 import static org.codehaus.groovy.ast.tools.WideningCategories.LowestUpperBoundClassNode;
 import static org.codehaus.groovy.ast.tools.WideningCategories.isBigDecCategory;
 import static org.codehaus.groovy.ast.tools.WideningCategories.isBigIntCategory;
@@ -5167,17 +5168,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private static String toMethodGenericTypesString(MethodNode node) {
         GenericsType[] genericsTypes = node.getGenericsTypes();
-        if (genericsTypes == null) return "";
-        StringBuilder sb = new StringBuilder("<");
-        for (int i = 0; i < genericsTypes.length; i++) {
-            final GenericsType genericsType = genericsTypes[i];
-            sb.append(genericsType.toString());
-            if (i < genericsTypes.length - 1) {
-                sb.append(",");
-            }
-        }
-        sb.append("> ");
-        return sb.toString();
+
+        if (genericsTypes == null)
+            return "";
+
+        return toGenericTypesString(genericsTypes);
     }
 
     protected static String formatArgumentList(ClassNode[] nodes) {

Commit:
a3d97de472d71f412c2fb245e7dff1ab7e6594b5
John Wagenleitner
jwagenleitner@apache.org
2018-05-18 07:14:46 -0700
GROOVY-8509: SC error call to protected method from same package (closes #707)
diff --git a/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java b/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
index 51cab66d9a..0e1a30a5f8 100644
--- a/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
+++ b/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
@@ -310,4 +310,20 @@ public class ClassNodeUtils {
         }
         return false;
     }
+
+    /**
+     * Determine if the given ClassNode values have the same package name.
+     *
+     * @param first a ClassNode
+     * @param second a ClassNode
+     * @return true if both given nodes have the same package name
+     * @throws NullPointerException if either of the given nodes are null
+     */
+    public static boolean samePackageName(ClassNode first, ClassNode second) {
+        String firstPackage = first.getPackageName();
+        String secondPackage = second.getPackageName();
+        return (firstPackage == secondPackage)
+                || (firstPackage != null && firstPackage.equals(secondPackage));
+    }
+
 }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index b44c54469e..6f4d9488ef 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -71,6 +71,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.apache.groovy.ast.tools.ClassNodeUtils.samePackageName;
 import static org.codehaus.groovy.ast.ClassHelper.CLOSURE_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.OBJECT_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.getWrapper;
@@ -343,6 +344,7 @@ public class StaticInvocationWriter extends InvocationWriter {
                     isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();
                 }
                 if (!implicitThis && !isThisOrSuper
+                        && !samePackageName(node, classNode)
                         && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {
                     ASTNode src = receiver==null?args:receiver;
                     controller.getSourceUnit().addError(
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5750d7cb27..de8af20924 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -122,6 +122,7 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
+import static org.apache.groovy.ast.tools.ClassNodeUtils.samePackageName;
 import static org.codehaus.groovy.ast.ClassHelper.BigDecimal_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.BigInteger_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.Boolean_TYPE;
@@ -4474,10 +4475,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (methodNode.isPrivate() && !enclosingClassNode.equals(declaringClass)) {
                 continue;
             }
-            if (methodNode.isProtected() && !enclosingClassNode.isDerivedFrom(declaringClass)) {
+            if (methodNode.isProtected()
+                    && !enclosingClassNode.isDerivedFrom(declaringClass)
+                    && !samePackageName(enclosingClassNode, declaringClass)) {
                 continue;
             }
-            if (methodNode.isPackageScope() && !getPackageName(enclosingClassNode).equals(getPackageName(declaringClass))) {
+            if (methodNode.isPackageScope() && !samePackageName(enclosingClassNode, declaringClass)) {
                 continue;
             }
 
@@ -4487,12 +4490,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return result;
     }
 
-    private static String getPackageName(ClassNode cn) {
-        String name = cn.getPackageName();
-
-        return null == name ? "" : name;
-    }
-
     /**
      * Given a method name and a prefix, returns the name of the property that should be looked up,
      * following the java beans rules. For example, "getName" would return "name", while
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
index b0266d296b..40d6cd0040 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
@@ -259,6 +259,24 @@ import groovy.transform.TypeCheckingMode//import org.codehaus.groovy.classgen.as
         '''
     }
 
+    //GROOVY-8509
+    void testProtectedCallFromClassInSamePackage() {
+        assertScript '''
+            package org.foo
+
+            class A {
+                protected A() {}
+                protected int m() { 123 }
+            }
+            class B {
+                int test() {
+                    new A().m()
+                }
+            }
+            assert new B().test() == 123
+        '''
+    }
+
     public static class Base {
         protected int foo() {
             123
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
index a40fe4e5a2..94d287fa2a 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
@@ -53,24 +53,6 @@ class Groovy7883Bug extends GroovyTestCase {
         assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
     }
 
-    void test3() {
-        def errMsg = shouldFail '''
-        @groovy.transform.CompileStatic
-        class A {
-            protected void doIt() {}
-        }
-        
-        @groovy.transform.CompileStatic
-        class B {
-            public void m() { new A().doIt() }
-        }
-        
-        new B().m()
-        '''
-
-        assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
-    }
-
     void test4() {
         def errMsg = shouldFail '''
         @groovy.transform.CompileStatic

Commit:
c7ae71717fee3321f3207928f63c49cc051ac98c
John Wagenleitner
jwagenleitner@apache.org
2018-05-18 07:14:21 -0700
Revert change to groovy.sql.Sql#asList in commit b1d1232770aa
diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
index 633c0a7845..da61e9f3d7 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
@@ -3973,7 +3973,7 @@ public class Sql {
      * @return the resulting list of rows
      * @throws SQLException if a database error occurs
      */
-    public List<GroovyRowResult> asList(String sql, ResultSet rs,
+    protected List<GroovyRowResult> asList(String sql, ResultSet rs,
                                            @ClosureParams(value=SimpleType.class, options="java.sql.ResultSetMetaData") Closure metaClosure) throws SQLException {
         return asList(sql, rs, 0, 0, metaClosure);
     }
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlSTCTest.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlSTCTest.groovy
index fa2da7fad7..275690dcd1 100644
--- a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlSTCTest.groovy
+++ b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlSTCTest.groovy
@@ -66,8 +66,16 @@ class SqlSTCTest extends GroovyShellTestCase {
 
     void testAsList() {
         shell.evaluate '''
-            def test(groovy.sql.Sql sql, java.sql.ResultSet rs) { 
-                sql.asList('SELECT * FROM FOO', rs) { println it.columnCount } 
+            class CustomSql extends groovy.sql.Sql {
+                CustomSql(groovy.sql.Sql sql) {
+                    super(sql)
+                }
+                def printColumnCount(String sql, java.sql.ResultSet rs) {
+                    this.asList(sql, rs) { println it.columnCount }
+                }
+            }
+            def test(groovy.sql.Sql sql, java.sql.ResultSet rs) {
+                new CustomSql(sql).printColumnCount('SELECT * FROM FOO', rs)
             }
         '''
     }

Commit:
fa39ed1589445027de20aad76c86d98527707816
Paul King
paulk@asert.com.au
2018-05-18 22:41:24 +1000
fix classpath for docGDK in build
diff --git a/gradle/docs.gradle b/gradle/docs.gradle
index 4c0d0d0735..de9c66b8ae 100644
--- a/gradle/docs.gradle
+++ b/gradle/docs.gradle
@@ -117,14 +117,14 @@ task docProjectVersionInfo(type: Copy) {
 
 task docGDK {
     outputs.cacheIf { true }
-    dependsOn([project(':groovy-groovydoc'), project(':groovy-docgenerator')]*.classes)
+    dependsOn([project(':groovy-groovydoc'), project(':groovy-docgenerator'), project(':groovy-cli-picocli')]*.classes)
     // TODO don't hard-code these
     dependsOn([project(':groovy-nio'), project(':groovy-sql'), project(':groovy-xml'), project(':groovy-swing')]*.classes)
     dependsOn docProjectVersionInfo
     ext.destinationDir = "$buildDir/html/groovy-jdk"
     inputs.files sourceSets.main.runtimeClasspath + configurations.tools + files(docProjectVersionInfo.destinationDir)
     outputs.dir destinationDir
-    def docGeneratorPath = files(project(':groovy-docgenerator').sourceSets.main.output.classesDirs)
+    def docGeneratorPath = files(project(':groovy-docgenerator').sourceSets.main.output.classesDirs) + files(project(':groovy-cli-picocli').sourceSets.main.output.classesDirs)
     doLast { task ->
         try {
             ant {

Commit:
ded0f1b47bae01e51313712615cf19c8f18b2754
Paul King
paulk@asert.com.au
2018-05-18 21:04:16 +1000
GROOVY-8520 replace commons-cli with picocli in CliBuilder (let groovy.util version delegate to groovy-cli-commons version)
diff --git a/src/spec/doc/core-domain-specific-languages.adoc b/src/spec/doc/core-domain-specific-languages.adoc
index 1d893b2595..47d854b268 100644
--- a/src/spec/doc/core-domain-specific-languages.adoc
+++ b/src/spec/doc/core-domain-specific-languages.adoc
@@ -1206,7 +1206,7 @@ Here is how such a specification can be defined:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationInterfaceSpec,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationInterfaceSpec,indent=0]
 ----
 <1> Specify a Boolean option set using `-h` or `--help`
 <2> Specify a String option set using `-a` or `--audience`
@@ -1221,7 +1221,7 @@ Here is how you could use the interface specification:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationInterface,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationInterface,indent=0]
 ----
 <1> Create a `CliBuilder` instance as before with optional properties
 <2> Parse parameters using the interface specification
@@ -1243,7 +1243,7 @@ Here is how such a specification can be defined:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationClassSpec,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationClassSpec,indent=0]
 ----
 <1> Indicate that a Boolean property is an option
 <2> Indicate that a String property (with explicit setter) is an option
@@ -1253,7 +1253,7 @@ And here is how you could use the specification:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationClass,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationClass,indent=0]
 ----
 <1> Create a `CliBuilder` instance as before with optional parameters
 <2> Create an instance for `CliBuilder` to populate
@@ -1277,7 +1277,7 @@ with the same arguments as shown for the instance example earlier:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationScript,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=annotationScript,indent=0]
 ----
 
 ===== Options with arguments
@@ -1289,7 +1289,7 @@ Here is an example involving those cases:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgument,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgument,indent=0]
 ----
 <1> An option that is simply a flag - the default; setting args to 0 is allowed but not needed.
 <2> An option with exactly one argument
@@ -1306,14 +1306,14 @@ illustrating such a definition:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgumentInterfaceSpec,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgumentInterfaceSpec,indent=0]
 ----
 
 And here is how it is used:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgumentInterface,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withArgumentInterface,indent=0]
 ----
 
 This example makes use of an array-typed option specification. We cover this in more detail shortly when we discuss
@@ -1334,7 +1334,7 @@ Here is an example using types with the dynamic api argument definition style:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withType,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withType,indent=0]
 ----
 
 Primitives, numeric types, files, enums and arrays thereof, are supported (they are converted using
@@ -1347,7 +1347,7 @@ for you. Here is a sample using the dynamic api style:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvert,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvert,indent=0]
 ----
 
 Alternatively, you can use the annotation style by supplying the conversion closure as an annotation parameter.
@@ -1355,14 +1355,14 @@ Here is an example specification:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvertInterfaceSpec,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvertInterfaceSpec,indent=0]
 ----
 
 And an example using that specification:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvertInterface,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withConvertInterface,indent=0]
 ----
 
 ===== Options with multiple arguments
@@ -1388,7 +1388,7 @@ Here is an excerpt highlighting the use of multiple arguments:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgs,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgs,indent=0]
 ----
 <1> Args value supplied as a String and comma value separator specified
 <2> One or more arguments are allowed
@@ -1408,14 +1408,14 @@ array type for the annotated class member (method or property) as this example s
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgsInterfaceSpec,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgsInterfaceSpec,indent=0]
 ----
 
 And used as follows:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgsInterface,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=multipleArgsInterface,indent=0]
 ----
 
 ===== Types and multiple arguments
@@ -1424,7 +1424,7 @@ Here is an example using types and multiple arguments with the dynamic api argum
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeMultiple,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeMultiple,indent=0]
 ----
 <1> For an array type, the trailing 's' can be used but isn't needed
 
@@ -1439,7 +1439,7 @@ Here is how you could use it using the dynamic api style:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValue,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValue,indent=0]
 ----
 
 Similarly, you might want such a specification using the annotation style. Here is an example using an interface
@@ -1447,14 +1447,14 @@ specification:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValueInterfaceSpec,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValueInterfaceSpec,indent=0]
 ----
 
 Which would be used like this:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValueInterface,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withDefaultValueInterface,indent=0]
 ----
 
 You can also use the `defaultValue` annotation attribute when using annotations with an instance,
@@ -1468,14 +1468,14 @@ annotation style, for example, here is an interface option specification:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeCheckedInterfaceSpec,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeCheckedInterfaceSpec,indent=0]
 ----
 
 And it can be used  in combination with `@TypeChecked` as shown here:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeCheckedInterface,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeCheckedInterface,indent=0]
 ----
 
 Secondly, there is a feature of the dynamic api style which offers some support. The definition statements
@@ -1502,13 +1502,13 @@ assert a == 21
 
 Finally, there is one additional convenience method offered by `CliBuilder` to even allow the
 definition part to be type checked. It is a slightly more verbose method call. Instead of using
-the short name (the _opt_ name) in the method call, you use a fixed named of `option` and
+the short name (the _opt_ name) in the method call, you use a fixed name of `option` and
 supply the `opt` value as a property. You must also specify the type directly as shown in
 the following example:
 
 [source,groovy]
 ----
-include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeChecked,indent=0]
+include::{projectdir}/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeChecked,indent=0]
 ----
 
 ===== Advanced CLI Usage
diff --git a/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
new file mode 100644
index 0000000000..a7097dba68
--- /dev/null
+++ b/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
@@ -0,0 +1,81 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.util
+
+import org.apache.commons.cli.CommandLineParser
+import org.apache.commons.cli.HelpFormatter
+
+/**
+ * @deprecated use {@code groovy.cli.picocli.CliBuilder} or {@link groovy.cli.commons.CliBuilder} instead.
+ */
+@Deprecated
+class CliBuilder {
+    private @Delegate
+    groovy.cli.commons.CliBuilder delegate = new groovy.cli.commons.CliBuilder()
+
+    // explicit delegate to convert return type to expected legacy package
+    OptionAccessor parse(args) {
+        return new OptionAccessor(delegate: delegate.parse(args))
+    }
+
+    // explicit delegate since groovyObject methods ignored by @Delegate
+    def invokeMethod(String name, Object args) {
+        delegate.invokeMethod(name, args)
+    }
+
+    // delegated versions of the methods below are available but we want
+    // IDE warnings to encourage people not to use these methods in particular
+    // over and above the warning they should have at the class level
+
+    /**
+     * @deprecated This may not be available in future groovy.util.CliBuilder versions.
+     * Use groovy.cli.commons.CliBuilder if you need this feature.
+     */
+    @Deprecated
+    void setParser(CommandLineParser parser) {
+        delegate.setParser(parser)
+    }
+
+    /**
+     * @deprecated This may not be available in future groovy.util.CliBuilder versions.
+     * Use groovy.cli.commons.CliBuilder if you need this feature.
+     */
+    @Deprecated
+    CommandLineParser setParser() {
+        delegate.getParser()
+    }
+
+    /**
+     * @deprecated This may not be available in future groovy.util.CliBuilder versions.
+     * Use groovy.cli.commons.CliBuilder if you need this feature.
+     */
+    @Deprecated
+    void setFormatter(HelpFormatter formatter) {
+        delegate.setFormatter(formatter)
+    }
+
+    /**
+     * @deprecated This may not be available in future groovy.util.CliBuilder versions.
+     * Use groovy.cli.commons.CliBuilder if you need this feature.
+     */
+    @Deprecated
+    HelpFormatter getFormatter() {
+        delegate.getFormatter()
+    }
+}
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/OptionAccessor.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/OptionAccessor.groovy
similarity index 88%
rename from subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/OptionAccessor.groovy
rename to subprojects/groovy-cli-commons/src/main/groovy/groovy/util/OptionAccessor.groovy
index fe77e74235..935cf103ab 100644
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/OptionAccessor.groovy
+++ b/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/OptionAccessor.groovy
@@ -19,12 +19,12 @@
 package groovy.util
 
 /**
- * @deprecated use {@link groovy.cli.picocli.CliBuilder}
+ * @deprecated use {@code groovy.cli.picocli.OptionAccessor} or {@link groovy.cli.commons.OptionAccessor}
  */
 @Deprecated
 class OptionAccessor {
     @Delegate
-    groovy.cli.picocli.OptionAccessor delegate
+    groovy.cli.commons.OptionAccessor delegate
 
     // explicit delegate since groovyObject methods ignored by @Delegate
     def getProperty(String name) {
diff --git a/src/spec/test/builder/CliBuilderTest.groovy b/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy
similarity index 98%
rename from src/spec/test/builder/CliBuilderTest.groovy
rename to subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy
index a84b3a46a3..313a793077 100644
--- a/src/spec/test/builder/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-commons/src/spec/test/builder/CliBuilderTest.groovy
@@ -354,10 +354,10 @@ class CliBuilderTest extends GroovyTestCase {
     // tag::withTypeChecked[]
     @TypeChecked
     void testTypeChecked() {
-        def cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
+        def cli = new CliBuilder()
         TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
         TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
-        def argz = "--name John -age 21 and some more".split()
+        def argz = "--name John --age 21 and some more".split()
         def options = cli.parse(argz)
         String n = options[name]
         int a = options[age]
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/CliBuilder.groovy
deleted file mode 100644
index bce9ebb401..0000000000
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/CliBuilder.groovy
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.util
-
-/**
- * @deprecated use {@link groovy.cli.picocli.CliBuilder}
- */
-@Deprecated
-class CliBuilder {
-    private @Delegate groovy.cli.picocli.CliBuilder delegate = new groovy.cli.picocli.CliBuilder()
-
-    // explicit delegate to convert return type to expected legacy package
-    OptionAccessor parse(args) {
-        return new OptionAccessor(delegate: delegate.parse(args))
-    }
-
-    // explicit delegate since groovyObject methods ignored by @Delegate
-    def invokeMethod(String name, Object args) {
-        delegate.invokeMethod(name, args)
-    }
-}
diff --git a/subprojects/groovy-console/build.gradle b/subprojects/groovy-console/build.gradle
index c55970d936..dc488bb56b 100644
--- a/subprojects/groovy-console/build.gradle
+++ b/subprojects/groovy-console/build.gradle
@@ -20,7 +20,7 @@ evaluationDependsOn(':groovy-swing')
 
 dependencies {
     compile rootProject
-    compile project(':groovy-cli-picocli')
+    compile project(':groovy-cli-commons')
     compile project(':groovy-swing')
     compile project(':groovy-templates')
     testCompile project(':groovy-test')
diff --git a/subprojects/groovy-groovydoc/build.gradle b/subprojects/groovy-groovydoc/build.gradle
index 0f20879137..ef3e292824 100644
--- a/subprojects/groovy-groovydoc/build.gradle
+++ b/subprojects/groovy-groovydoc/build.gradle
@@ -19,7 +19,7 @@
 dependencies {
     compile rootProject
     testCompile rootProject.sourceSets.test.runtimeClasspath
-    compile project(':groovy-cli-picocli')
+    compile project(':groovy-cli-commons')
     compile project(':groovy-templates')
     runtime project(':groovy-dateutil')
     testCompile project(':groovy-test')
diff --git a/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy b/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
index 0579cda4c5..b3041784c1 100644
--- a/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
+++ b/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
@@ -18,7 +18,7 @@
  */
 package org.codehaus.groovy.tools.groovydoc
 
-import groovy.cli.picocli.CliBuilder
+import groovy.cli.commons.CliBuilder
 import groovy.io.FileType
 import org.codehaus.groovy.tools.groovydoc.gstringTemplates.GroovyDocTemplateInfo
 import org.codehaus.groovy.tools.shell.IO

Commit:
12905b662f03b7650a8b833fc9ad1cc6b9d9fc83
Paul King
paulk@asert.com.au
2018-05-18 21:04:16 +1000
GROOVY-8520 bugfix: fix issues raised after previous PR (closes #701)
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
index aacd8324d4..e0377b3139 100644
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
@@ -378,6 +378,7 @@ class CliBuilder {
      * <code>true</code> if the parser should recognize long options with both
      * a single hyphen and a double hyphen prefix. The default is <code>false</code>,
      * so only long options with a double hypen prefix (<code>--option</code>) are recognized.
+     * @since 2.5
      */
     boolean acceptLongOptionsWithSingleHyphen = false
 
@@ -512,9 +513,9 @@ class CliBuilder {
      * used by the underlying library.
      * @param posix whether to allow clustered short options
      */
-    void setPosix(boolean posix) {
+    void setPosix(Boolean posix) {
         this.posix = posix
-        parser.posixClusteredShortOptionsAllowed(posix)
+        parser.posixClusteredShortOptionsAllowed(posix ?: false)
     }
 
     /**
@@ -804,6 +805,7 @@ class CliBuilder {
         if (attr.type)           { builder.type(attr.type) } // cannot set type to null
         if (attr.auxiliaryTypes) { builder.auxiliaryTypes(attr.auxiliaryTypes) } // cannot set aux types to null
         builder.arity(arity)
+        builder.description(unparsed.description())
         builder.paramLabel("<$attr.label>")
         builder.getter(attr.getter)
         builder.setter(attr.setter)
diff --git a/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
index 302bef63d2..195ac0d590 100644
--- a/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
@@ -40,7 +40,7 @@ class CliBuilderTest extends GroovyTestCase {
     interface GreeterI {
         @Option(shortName='h', description='display usage') Boolean help()        // <1>
         @Option(shortName='a', description='greeting audience') String audience() // <2>
-        @Unparsed List remaining()                                                // <3>
+        @Unparsed(description = "positional parameters") List remaining()         // <3>
     }
     // end::annotationInterfaceSpec[]
 
@@ -56,14 +56,14 @@ class CliBuilderTest extends GroovyTestCase {
         }
         String getAudience() { audience }
 
-        @Unparsed
+        @Unparsed(description = "positional parameters")
         List remaining                      // <3>
     }
     // end::annotationClassSpec[]
 
     void testAnnotationsInterface() {
         // tag::annotationInterface[]
-        def cli = new CliBuilder(usage: 'groovy Greeter [option]')  // <1>
+        def cli = new CliBuilder(name: 'groovy Greeter')  // <1>
         def argz = '--audience Groovologist'.split()
         def options = cli.parseFromSpec(GreeterI, argz)             // <2>
         assert options.audience() == 'Groovologist'                 // <3>
@@ -73,6 +73,22 @@ class CliBuilderTest extends GroovyTestCase {
         assert options.help()
         assert options.remaining() == ['Some', 'Other', 'Args']     // <5>
         // end::annotationInterface[]
+
+        options = cli.parseFromSpec(GreeterI, ['-h', 'Some', 'Other', 'Args'] as String[])
+        assert options.help()
+        assert options.remaining() == ['Some', 'Other', 'Args']
+        StringWriter sw = new StringWriter()
+        cli.writer = new PrintWriter(sw)
+        cli.usage()
+
+        String expected = '''\
+Usage: groovy Greeter [-h] [-a=<audience>] [<remaining>...]
+      [<remaining>...]   positional parameters
+  -a, --audience=<audience>
+                         greeting audience
+  -h, --help             display usage
+'''
+        assert expected.normalize() == sw.toString().normalize()
     }
 
     void testAnnotationsClass() {
diff --git a/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy b/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
index e6a0e7a92d..be8b5f9310 100644
--- a/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
@@ -20,7 +20,6 @@ package groovy.cli.picocli
 
 import groovy.cli.Option
 import groovy.cli.Unparsed
-import groovy.cli.picocli.CliBuilder
 import groovy.transform.ToString
 import groovy.transform.TypeChecked
 import picocli.CommandLine.DuplicateOptionAnnotationsException
@@ -123,6 +122,38 @@ class CliBuilderTest extends GroovyTestCase {
         groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.args)
     }
 
+    void testPosixNullValueHandledCorrectly_inConstructor() {
+        def cli = new CliBuilder()
+        assert cli.posix == true
+        assert cli.parser.posixClusteredShortOptionsAllowed()
+
+        cli = new CliBuilder(posix: false)
+        assert cli.posix == false
+        assert !cli.parser.posixClusteredShortOptionsAllowed()
+
+        cli = new CliBuilder(posix: null)
+        assert cli.posix == null
+        assert !cli.parser.posixClusteredShortOptionsAllowed()
+    }
+
+    void testPosixNullValueHandledCorrectly_inSetter() {
+        def cli = new CliBuilder()
+        assert cli.posix == true
+        assert cli.parser.posixClusteredShortOptionsAllowed()
+
+        cli.posix = false
+        assert cli.posix == false
+        assert !cli.parser.posixClusteredShortOptionsAllowed()
+
+        cli = new CliBuilder()
+        assert cli.posix == true
+        assert cli.parser.posixClusteredShortOptionsAllowed()
+
+        cli.posix = null
+        assert cli.posix == null
+        assert !cli.parser.posixClusteredShortOptionsAllowed()
+    }
+
     void testFailedParsePrintsUsage() {
         def cli = new CliBuilder(writer: printWriter)
         cli.x(required: true, 'message')

Commit:
2aaed15506a96b7b6d00a4f10c419acacd9669df
Paul King
paulk@asert.com.au
2018-05-18 21:03:27 +1000
remove use of deprecated method
diff --git a/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleHelperForTests.groovy b/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleHelperForTests.groovy
index 638a1115d1..ae6f7cdefa 100644
--- a/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleHelperForTests.groovy
+++ b/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleHelperForTests.groovy
@@ -16,10 +16,9 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-
 package org.codehaus.groovy.runtime.m12n
 
-import org.codehaus.groovy.tools.FileSystemCompiler;
+import org.codehaus.groovy.runtime.DefaultGroovyStaticMethods
 
 public class ExtensionModuleHelperForTests {
     static void doInFork(String code) {
@@ -27,7 +26,7 @@ public class ExtensionModuleHelperForTests {
     }
 
     static void doInFork(String baseTestClass, String code) {
-        File baseDir = FileSystemCompiler.createTempDir()
+        File baseDir = DefaultGroovyStaticMethods.createTempDir(null)
         File source = new File(baseDir, 'Temp.groovy')
         source << """import org.codehaus.groovy.runtime.m12n.*
     class TempTest extends $baseTestClass {

Commit:
42aa69f7467c26edbac3fe623b13c24a6adf9a1b
sunlan
sunlan@apache.org
2018-05-18 18:13:11 +0800
Add a test for "GROOVY-7031: @CompileStatic breaks assign in combination with dereferencing"
diff --git a/src/test/groovy/bugs/Groovy7031Bug.groovy b/src/test/groovy/bugs/Groovy7031Bug.groovy
new file mode 100644
index 0000000000..3bb47502e2
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7031Bug.groovy
@@ -0,0 +1,44 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy7031Bug extends GroovyTestCase {
+
+    void test() {
+        assertScript """
+        @groovy.transform.CompileStatic
+        class StaticClass {
+            StringHolder holder = new StringHolder()
+            String str
+        
+            StaticClass(String s) {
+                str = holder.str = s
+            }
+        }
+        
+        class StringHolder {
+            String str
+        }
+        
+        def s = new StaticClass('test')
+        assert s.holder.str == 'test'
+        assert s.str == 'test'
+        """
+    }
+}

Commit:
c2cea059fecc3bc4a2c01adc6a30d2a1508bd64b
Paul King
paulk@asert.com.au
2018-05-18 20:00:56 +1000
prepare for additional JDK9+ work
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 545cc492cf..1b0e2203df 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -368,7 +368,7 @@ public class CompilerConfiguration {
     /**
      * Checks if the specified bytecode version string represents a JDK 1.5+ compatible
      * bytecode version.
-     * @param bytecodeVersion the bytecode version string (1.4, 1.5, 1.6, 1.7 or 1.8)
+     * @param bytecodeVersion The parameter can take one of the values in {@link #ALLOWED_JDKS}.
      * @return true if the bytecode version is JDK 1.5+
      */
     public static boolean isPostJDK5(String bytecodeVersion) {
@@ -378,13 +378,33 @@ public class CompilerConfiguration {
     /**
      * Checks if the specified bytecode version string represents a JDK 1.7+ compatible
      * bytecode version.
-     * @param bytecodeVersion the bytecode version string (1.4, 1.5, 1.6, 1.7 or 1.8)
+     * @param bytecodeVersion The parameter can take one of the values in {@link #ALLOWED_JDKS}.
      * @return true if the bytecode version is JDK 1.7+
      */
     public static boolean isPostJDK7(String bytecodeVersion) {
         return new BigDecimal(bytecodeVersion).compareTo(new BigDecimal(JDK7)) >= 0;
     }
 
+    /**
+     * Checks if the specified bytecode version string represents a JDK 1.8+ compatible
+     * bytecode version.
+     * @param bytecodeVersion The parameter can take one of the values in {@link #ALLOWED_JDKS}.
+     * @return true if the bytecode version is JDK 1.87+
+     */
+    public static boolean isPostJDK8(String bytecodeVersion) {
+        return new BigDecimal(bytecodeVersion).compareTo(new BigDecimal(JDK8)) >= 0;
+    }
+
+    /**
+     * Checks if the specified bytecode version string represents a JDK 1.8+ compatible
+     * bytecode version.
+     * @param bytecodeVersion The parameter can take one of the values in {@link #ALLOWED_JDKS}.
+     * @return true if the bytecode version is JDK 9.0+
+     */
+    public static boolean isPostJDK9(String bytecodeVersion) {
+        return new BigDecimal(bytecodeVersion).compareTo(new BigDecimal(JDK9)) >= 0;
+    }
+
     /**
      * Method to configure a CompilerConfiguration by using Properties.
      * For a list of available properties look at {@link #CompilerConfiguration(Properties)}.
diff --git a/src/test/org/codehaus/groovy/runtime/methoddispatching/vm8/StaticMethodOverloadCompileStaticTest.groovy b/src/test/org/codehaus/groovy/runtime/methoddispatching/vm8/StaticMethodOverloadCompileStaticTest.groovy
index c523d15fd4..9cc6d7aaba 100644
--- a/src/test/org/codehaus/groovy/runtime/methoddispatching/vm8/StaticMethodOverloadCompileStaticTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/methoddispatching/vm8/StaticMethodOverloadCompileStaticTest.groovy
@@ -20,6 +20,8 @@ package org.codehaus.groovy.runtime.methoddispatching.vm8
 
 import groovy.transform.CompileStatic
 
+import static org.codehaus.groovy.control.CompilerConfiguration.isPostJDK9
+
 @CompileStatic
 class StaticMethodOverloadCompileStaticTest extends GroovyTestCase {
     void testOneStaticMethod() {
@@ -46,9 +48,9 @@ class StaticMethodOverloadCompileStaticTest extends GroovyTestCase {
         assert BarThree.foo(0, 1) == "BarThree.foo(0, 1)"
     }
 
-    // FIX_JDK9 JDK9 doesn't like the way we do static methods in interfaces - remove this version
+    // FIX_JDK9 JDK9 (and presumably 10+) doesn't like the way we do static methods in interfaces - remove this version
     // check once we fix the problem
     boolean isJdk9() {
-        new BigDecimal(System.getProperty("java.specification.version")).compareTo(new BigDecimal("9.0")) >= 0
+        isPostJDK9(System.getProperty("java.specification.version"))
     }
 }

Commit:
a92a2f96a83481d456e9dba6ff963c86fe5150ee
sunlan
sunlan@apache.org
2018-05-18 16:54:18 +0800
Trivial refactoring: rename method name
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 10d162e17a..5750d7cb27 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -5426,7 +5426,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             this.parameter = parameter;
             ClassNode inferred = parameter.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
             if (inferred == null) {
-                inferred = getInferredTypeOfPlaceholder(parameter);
+                inferred = infer(parameter);
 
                 parameter.setNodeMetaData(StaticTypesMarker.INFERRED_TYPE, inferred);
             }
@@ -5473,7 +5473,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
-    private static ClassNode getInferredTypeOfPlaceholder(Variable variable) {
+    private static ClassNode infer(Variable variable) {
         ClassNode originType = variable.getOriginType();
 
         if (originType.isGenericsPlaceHolder()) {

Commit:
3ff3111fc033bf74ecdbbc4f69e0fc0f76fbdf26
sunlan
sunlan@apache.org
2018-05-18 16:45:17 +0800
Refine parameter type inference
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index f12f65a3d3..1b3ec1ab45 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -374,7 +374,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
 
         if (genericParameterNames.get(typeName) != null) {
             GenericsType gt = genericParameterNames.get(typeName);
-            type.setRedirect(gt.getType()); // FIXME lost the generics type info
+            type.setRedirect(gt.getType());
             type.setGenericsTypes(new GenericsType[]{ gt });
             type.setGenericsPlaceHolder(true);
             return true;
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 00b897440e..10d162e17a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -5426,7 +5426,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             this.parameter = parameter;
             ClassNode inferred = parameter.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
             if (inferred == null) {
-                parameter.setNodeMetaData(StaticTypesMarker.INFERRED_TYPE, parameter.getOriginType());
+                inferred = getInferredTypeOfPlaceholder(parameter);
+
+                parameter.setNodeMetaData(StaticTypesMarker.INFERRED_TYPE, inferred);
             }
         }
 
@@ -5470,4 +5472,23 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return parameter.equals(other);
         }
     }
+
+    private static ClassNode getInferredTypeOfPlaceholder(Variable variable) {
+        ClassNode originType = variable.getOriginType();
+
+        if (originType.isGenericsPlaceHolder()) {
+            GenericsType[] genericsTypes = originType.getGenericsTypes();
+
+            if (null != genericsTypes && genericsTypes.length > 0) {
+                GenericsType gt = genericsTypes[0];
+                ClassNode[] upperBounds = gt.getUpperBounds();
+
+                if (null != upperBounds && upperBounds.length > 0) {
+                    return upperBounds[0];
+                }
+            }
+        }
+
+        return variable.getOriginType();
+    }
 }
diff --git a/src/test/groovy/bugs/Groovy6171Bug.groovy b/src/test/groovy/bugs/Groovy6171Bug.groovy
index 574db5beca..0d0d6d1bc4 100644
--- a/src/test/groovy/bugs/Groovy6171Bug.groovy
+++ b/src/test/groovy/bugs/Groovy6171Bug.groovy
@@ -19,7 +19,6 @@
 package groovy.bugs
 
 import gls.CompilableTestSupport
-import groovy.transform.NotYetImplemented
 
 class Groovy6171Bug extends CompilableTestSupport {
     void testGroovy6171() {
@@ -54,8 +53,7 @@ class Groovy6171Bug extends CompilableTestSupport {
         assert errMsg.contains('The type HashSet is not a valid substitute for the bounded parameter <T extends java.util.List<X>>')
     }
 
-    @NotYetImplemented
-    void test2() {
+    void testParameter() {
         assertScript '''
         @groovy.transform.CompileStatic
         public class Foo<T extends List<X>, X extends Number> {
@@ -74,8 +72,52 @@ class Groovy6171Bug extends CompilableTestSupport {
         '''
     }
 
+    void testVariable() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        public class Foo<T extends List<X>, X extends Number> {
+            X getFirstElement() {
+                def list = new ArrayList<Integer>()
+                list.add(123)
+                T t = list
+                X x = t.get(0)
+                return x
+            }
+            
+            static void main(String[] args) {
+                def f = new Foo<ArrayList<Integer>, Integer>()
+                assert 123 == f.getFirstElement()
+            }
+        }
+        '''
+    }
+
+    void testField() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        public class Foo<T extends List<X>, X extends Number> {
+            T t
+            
+            {
+                def list = new ArrayList<Integer>()
+                list.add(123)
+                t = list
+            }
+        
+            X getFirstElement() {
+                X x = t.get(0)
+                return x
+            }
+            
+            static void main(String[] args) {
+                def f = new Foo<ArrayList<Integer>, Integer>()
+                assert 123 == f.getFirstElement()
+            }
+        }
+        '''
+    }
 
-    void test3() {
+    void testParameter2() {
         assertScript '''
         @groovy.transform.CompileStatic
         public class Foo<T extends List<X>, X extends Number> {
@@ -101,7 +143,7 @@ class Groovy6171Bug extends CompilableTestSupport {
         '''
     }
 
-    void test4() {
+    void testParameterAndVariable() {
         assertScript '''
         @groovy.transform.CompileStatic
         public class Foo<T extends List<X>, X extends Number> {
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index fcea9d0316..4b1055b793 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -1092,7 +1092,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
             Baz.qux([new Object()])
-        ''', 'Cannot call <T extends java.util.List<? extends java.lang.CharSequence>> Foo#bar(T) with arguments [T]'
+        ''', 'Cannot call <T extends java.util.List<? extends java.lang.CharSequence>> Foo#bar(T) with arguments [java.util.List <Object>]'
     }
 
     void testOutOfBoundsBySuperPlaceholderParameterType() {
@@ -1106,7 +1106,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
             Baz.qux(['abc'])
-        ''', 'Cannot call <T extends java.util.List<? super java.lang.CharSequence>> Foo#bar(T) with arguments [T]'
+        ''', 'Cannot call <T extends java.util.List<? super java.lang.CharSequence>> Foo#bar(T) with arguments [java.util.List <String>] '
     }
 
     // GROOVY-5721

Commit:
7d950582fc44a17fbef65eb9f9acbaacd32495f5
Paul King
paulk@asert.com.au
2018-05-18 18:16:08 +1000
GROOVY-8579: No bytecode level check is done before producing JDK8+ bytecode (closes #709)
diff --git a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 476337b6ef..c16190555f 100644
--- a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -171,6 +171,7 @@ public class AsmClassGenerator extends ClassGenerator {
     public static final boolean CREATE_DEBUG_INFO = true;
     public static final boolean CREATE_LINE_NUMBER_INFO = true;
     public static final boolean ASM_DEBUG = false; // add marker in the bytecode to show source-bytecode relationship
+    public static final String MINIMUM_BYTECODE_VERSION = "_MINIMUM_BYTECODE_VERSION";
 
     private ASTNode currentASTNode = null;
     private final Map genericParameterNames;
@@ -215,8 +216,16 @@ public class AsmClassGenerator extends ClassGenerator {
         }
 
         try {
+            int bytecodeVersion = controller.getBytecodeVersion();
+            Object min = classNode.getNodeMetaData(MINIMUM_BYTECODE_VERSION);
+            if (min instanceof Integer) {
+                int minVersion = (int) min;
+                if (bytecodeVersion < minVersion) {
+                    bytecodeVersion = minVersion;
+                }
+            }
             cv.visit(
-                    controller.getBytecodeVersion(),
+                    bytecodeVersion,
                     adjustedClassModifiersForClassWriting(classNode),
                     controller.getInternalClassName(),
                     BytecodeHelper.getGenericsSignature(classNode),
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5f9e1cb0d8..00b897440e 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -179,6 +179,7 @@ import static org.codehaus.groovy.ast.tools.WideningCategories.isIntCategory;
 import static org.codehaus.groovy.ast.tools.WideningCategories.isLongCategory;
 import static org.codehaus.groovy.ast.tools.WideningCategories.isNumberCategory;
 import static org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound;
+import static org.codehaus.groovy.classgen.AsmClassGenerator.MINIMUM_BYTECODE_VERSION;
 import static org.codehaus.groovy.runtime.DefaultGroovyMethods.asBoolean;
 import static org.codehaus.groovy.syntax.Types.ASSIGN;
 import static org.codehaus.groovy.syntax.Types.ASSIGNMENT_OPERATOR;
@@ -3251,6 +3252,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                             storeType(call, returnType);
                             storeTargetMethod(call, directMethodCallCandidate);
+                            ClassNode declaringClass = directMethodCallCandidate.getDeclaringClass();
+                            if (declaringClass.isInterface() && directMethodCallCandidate.isStatic()) {
+                                typeCheckingContext.getEnclosingClassNode().putNodeMetaData(MINIMUM_BYTECODE_VERSION, Opcodes.V1_8);
+                            }
                             String data = chosenReceiver.getData();
                             if (data != null) {
                                 // the method which has been chosen is supposed to be a call on delegate or owner
diff --git a/src/test/groovy/bugs/Groovy8579Bug.groovy b/src/test/groovy/bugs/Groovy8579Bug.groovy
new file mode 100644
index 0000000000..1945e475c0
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8579Bug.groovy
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy8579Bug extends GroovyTestCase {
+    void testCallToStaticInterfaceMethod() {
+        assertScript '''
+            import groovy.transform.CompileStatic
+
+            @CompileStatic
+            Comparator myMethod() {
+                Map.Entry.comparingByKey()
+            }
+
+            assert myMethod() instanceof Comparator
+        '''
+    }
+}

Commit:
31dbe4e1941e136917f703212e10091dbd45bad0
sunlan
sunlan@apache.org
2018-05-18 15:16:52 +0800
Fix the failing build
diff --git a/src/main/groovy/groovy/ui/GroovyMain.java b/src/main/groovy/groovy/ui/GroovyMain.java
index c6aee0d6c6..eb2db46450 100644
--- a/src/main/groovy/groovy/ui/GroovyMain.java
+++ b/src/main/groovy/groovy/ui/GroovyMain.java
@@ -39,6 +39,7 @@ import picocli.CommandLine.Help;
 import picocli.CommandLine.IVersionProvider;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.ParameterException;
+import picocli.CommandLine.Unmatched;
 
 import java.io.BufferedReader;
 import java.io.File;

Commit:
39bf95c2f13a21df2c13cf698012b2f489e693b8
sunlan
sunlan@apache.org
2018-05-18 14:31:11 +0800
Refine resolving generics
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index c3939b2923..f12f65a3d3 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -374,7 +374,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
 
         if (genericParameterNames.get(typeName) != null) {
             GenericsType gt = genericParameterNames.get(typeName);
-            type.setRedirect(gt.getType());
+            type.setRedirect(gt.getType()); // FIXME lost the generics type info
             type.setGenericsTypes(new GenericsType[]{ gt });
             type.setGenericsPlaceHolder(true);
             return true;
@@ -1490,9 +1490,15 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             } else {
                 if (!isWild) {
                     if (toDealWithGenerics) {
+                        GenericsType originalGt = genericParameterNames.get(name);
                         genericParameterNames.put(name, type);
                         type.setPlaceholder(true);
-                        classNode.setRedirect(ClassHelper.OBJECT_TYPE);
+
+                        if (null == originalGt) {
+                            classNode.setRedirect(ClassHelper.OBJECT_TYPE);
+                        } else {
+                            classNode.setRedirect(originalGt.getType());
+                        }
                     }
                 }
             }
diff --git a/src/test/groovy/bugs/Groovy6171Bug.groovy b/src/test/groovy/bugs/Groovy6171Bug.groovy
index abd6903e4d..574db5beca 100644
--- a/src/test/groovy/bugs/Groovy6171Bug.groovy
+++ b/src/test/groovy/bugs/Groovy6171Bug.groovy
@@ -19,6 +19,7 @@
 package groovy.bugs
 
 import gls.CompilableTestSupport
+import groovy.transform.NotYetImplemented
 
 class Groovy6171Bug extends CompilableTestSupport {
     void testGroovy6171() {
@@ -53,6 +54,7 @@ class Groovy6171Bug extends CompilableTestSupport {
         assert errMsg.contains('The type HashSet is not a valid substitute for the bounded parameter <T extends java.util.List<X>>')
     }
 
+    @NotYetImplemented
     void test2() {
         assertScript '''
         @groovy.transform.CompileStatic
@@ -72,6 +74,7 @@ class Groovy6171Bug extends CompilableTestSupport {
         '''
     }
 
+
     void test3() {
         assertScript '''
         @groovy.transform.CompileStatic
@@ -97,4 +100,25 @@ class Groovy6171Bug extends CompilableTestSupport {
         }
         '''
     }
+
+    void test4() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        public class Foo<T extends List<X>, X extends Number> {
+            X getFirstElement(List<X> t) {
+                X x = t.get(0)
+                return x
+            }
+            
+            static void main(String[] args) {
+                def f = new Foo<ArrayList<Integer>, Integer>()
+                def list = new ArrayList<Integer>()
+                list.add(123)
+                assert 123 == f.getFirstElement(list)
+            }
+        }
+        '''
+    }
+
+
 }

Commit:
8365c15556fbef4070104ef24c7a3b21f8a127e4
Paul King
paulk@asert.com.au
2018-05-18 12:56:45 +1000
GROOVY-8569 Migrate groovy.ui.GroovyMain to picocli - minor tweaks (closes #702)
diff --git a/src/main/groovy/groovy/ui/GroovyMain.java b/src/main/groovy/groovy/ui/GroovyMain.java
index 61bb946886..c6aee0d6c6 100644
--- a/src/main/groovy/groovy/ui/GroovyMain.java
+++ b/src/main/groovy/groovy/ui/GroovyMain.java
@@ -34,7 +34,11 @@ import org.codehaus.groovy.runtime.ResourceGroovyMethods;
 import org.codehaus.groovy.runtime.StackTraceUtils;
 import org.codehaus.groovy.runtime.StringGroovyMethods;
 import picocli.CommandLine;
-import picocli.CommandLine.*;
+import picocli.CommandLine.Command;
+import picocli.CommandLine.Help;
+import picocli.CommandLine.IVersionProvider;
+import picocli.CommandLine.Option;
+import picocli.CommandLine.ParameterException;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -52,13 +56,10 @@ import java.net.URL;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
-import java.util.Enumeration;
 import java.util.Iterator;
-import java.util.List;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
-import java.util.Properties;
-import java.util.concurrent.Callable;
 import java.util.regex.Pattern;
 
 /**

Commit:
05bed49a7397eb15a21f58518d2f6d8f9a362899
Paul King
paulk@asert.com.au
2018-05-18 12:28:35 +1000
GROOVY-8569 Migrate groovy.ui.GroovyMain to picocli
diff --git a/src/main/groovy/groovy/ui/GroovyMain.java b/src/main/groovy/groovy/ui/GroovyMain.java
index 24c1a9f353..61bb946886 100644
--- a/src/main/groovy/groovy/ui/GroovyMain.java
+++ b/src/main/groovy/groovy/ui/GroovyMain.java
@@ -25,12 +25,6 @@ import groovy.lang.GroovyShell;
 import groovy.lang.GroovySystem;
 import groovy.lang.MissingMethodException;
 import groovy.lang.Script;
-import org.apache.commons.cli.CommandLine;
-import org.apache.commons.cli.CommandLineParser;
-import org.apache.commons.cli.DefaultParser;
-import org.apache.commons.cli.HelpFormatter;
-import org.apache.commons.cli.Options;
-import org.apache.commons.cli.ParseException;
 import org.codehaus.groovy.control.CompilationFailedException;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.customizers.ImportCustomizer;
@@ -39,6 +33,8 @@ import org.codehaus.groovy.runtime.InvokerInvocationException;
 import org.codehaus.groovy.runtime.ResourceGroovyMethods;
 import org.codehaus.groovy.runtime.StackTraceUtils;
 import org.codehaus.groovy.runtime.StringGroovyMethods;
+import picocli.CommandLine;
+import picocli.CommandLine.*;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -59,11 +55,12 @@ import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.List;
+import java.util.LinkedHashMap;
+import java.util.Map;
 import java.util.Properties;
+import java.util.concurrent.Callable;
 import java.util.regex.Pattern;
 
-import static org.apache.commons.cli.Option.builder;
-
 /**
  * A Command line to execute groovy.
  */
@@ -114,188 +111,190 @@ public class GroovyMain {
      * @param args all command line args.
      */
     public static void main(String args[]) {
-        processArgs(args, System.out);
+        processArgs(args, System.out, System.err);
     }
 
     // package-level visibility for testing purposes (just usage/errors at this stage)
-    // TODO: should we have an 'err' printstream too for ParseException?
+    @Deprecated
     static void processArgs(String[] args, final PrintStream out) {
-        Options options = buildOptions();
-
+        processArgs(args, out, out);
+    }
+    // package-level visibility for testing purposes (just usage/errors at this stage)
+    static void processArgs(String[] args, final PrintStream out, final PrintStream err) {
+        GroovyCommand groovyCommand = new GroovyCommand();
+        CommandLine parser = new CommandLine(groovyCommand).setUnmatchedArgumentsAllowed(true).setStopAtUnmatched(true);
+        parser.getCommandSpec().mixinStandardHelpOptions(true);
         try {
-            CommandLine cmd = parseCommandLine(options, args);
-
-            if (cmd.hasOption('h')) {
-                printHelp(out, options);
-            } else if (cmd.hasOption('v')) {
-                String version = GroovySystem.getVersion();
-                out.println("Groovy Version: " + version + " JVM: " + System.getProperty("java.version") +
-                        " Vendor: " + System.getProperty("java.vm.vendor")  + " OS: " + System.getProperty("os.name"));
-            } else {
-                // If we fail, then exit with an error so scripting frameworks can catch it
-                // TODO: pass printstream(s) down through process
-                if (!process(cmd)) {
-                    System.exit(1);
-                }
+            List<CommandLine> result = parser.parse(args);
+            if (CommandLine.printHelpIfRequested(result, out, err, Help.Ansi.AUTO)) {
+                return;
             }
-        } catch (ParseException pe) {
-            out.println("error: " + pe.getMessage());
-            printHelp(out, options);
+            // TODO: pass printstream(s) down through process
+            if (!groovyCommand.process(parser)) {
+                // If we fail, then exit with an error so scripting frameworks can catch it.
+                System.exit(1);
+            }
+
+        } catch (ParameterException ex) { // command line arguments could not be parsed
+            err.println(ex.getMessage());
+            ex.getCommandLine().usage(err);
         } catch (IOException ioe) {
-            out.println("error: " + ioe.getMessage());
+            err.println("error: " + ioe.getMessage());
         }
     }
 
-    private static void printHelp(PrintStream out, Options options) {
-        HelpFormatter formatter = new HelpFormatter();
-        PrintWriter pw = new PrintWriter(out);
-
-        formatter.printHelp(
-                pw,
-                80,
-                "groovy [options] [filename] [args]",
-                "The Groovy command line processor.\nOptions:",
-                options,
-                2,
-                4,
-                null, // footer
-                false);
-
-        pw.flush();
+    static class VersionProvider implements IVersionProvider {
+        @Override
+        public String[] getVersion() {
+            return new String[] {
+                    "Groovy Version: " + GroovySystem.getVersion() + " JVM: " + System.getProperty("java.version") +
+                    " Vendor: " + System.getProperty("java.vm.vendor")  + " OS: " + System.getProperty("os.name")
+            };
+        }
     }
 
-    /**
-     * Parse the command line.
-     *
-     * @param options the options parser.
-     * @param args    the command line args.
-     * @return parsed command line.
-     * @throws ParseException if there was a problem.
-     */
-    private static CommandLine parseCommandLine(Options options, String[] args) throws ParseException {
-        CommandLineParser parser = new DefaultParser();
-        return parser.parse(options, args, true);
-    }
+    @Command(name = "groovy",
+            customSynopsis = "groovy [options] [filename] [args]",
+            description = "The Groovy command line processor.",
+            sortOptions = false,
+            versionProvider = VersionProvider.class)
+    private static class GroovyCommand {
 
-    /**
-     * Build the options parser.
-     *
-     * @return an options parser.
-     */
-    private static Options buildOptions() {
-        return new Options()
-                .addOption(builder("classpath").hasArg().argName("path").desc("Specify where to find the class files - must be first argument").build())
-                .addOption(builder("cp").longOpt("classpath").hasArg().argName("path").desc("Aliases for '-classpath'").build())
-                .addOption(builder("D").longOpt("define").desc("Define a system property").numberOfArgs(2).valueSeparator().argName("name=value").build())
-                .addOption(
-                        builder().longOpt("disableopt")
-                                .desc("Disables one or all optimization elements; " +
-                                        "optlist can be a comma separated list with the elements: " +
-                                        "all (disables all optimizations), " +
-                                        "int (disable any int based optimizations)")
-                                .hasArg().argName("optlist").build())
-                .addOption(builder("h").hasArg(false).desc("Usage information").longOpt("help").build())
-                .addOption(builder("d").hasArg(false).desc("Debug mode will print out full stack traces").longOpt("debug").build())
-                .addOption(builder("v").hasArg(false).desc("Display the Groovy and JVM versions").longOpt("version").build())
-                .addOption(builder("c").argName("charset").hasArg().desc("Specify the encoding of the files").longOpt("encoding").build())
-                .addOption(builder("e").argName("script").hasArg().desc("Specify a command line script").build())
-                .addOption(builder("i").argName("extension").optionalArg(true).desc("Modify files in place; create backup if extension is given (e.g. \'.bak\')").build())
-                .addOption(builder("n").hasArg(false).desc("Process files line by line using implicit 'line' variable").build())
-                .addOption(builder("p").hasArg(false).desc("Process files line by line and print result (see also -n)").build())
-                .addOption(builder("pa").hasArg(false).desc("Generate metadata for reflection on method parameter names (jdk8+ only)").longOpt("parameters").build())
-                .addOption(builder("l").argName("port").optionalArg(true).desc("Listen on a port and process inbound lines (default: 1960)").build())
-                .addOption(builder("a").argName("splitPattern").optionalArg(true).desc("Split lines using splitPattern (default '\\s') using implicit 'split' variable").longOpt("autosplit").build())
-                .addOption(builder().longOpt("indy").desc("Enables compilation using invokedynamic").build())
-                .addOption(builder().longOpt("configscript").hasArg().desc("A script for tweaking the configuration options").build())
-                .addOption(builder("b").longOpt("basescript").hasArg().argName("class").desc("Base class name for scripts (must derive from Script)").build());
-    }
+        // IMPLEMENTATION NOTE:
+        // classpath must be the first argument, so that the `startGroovy(.bat)` script
+        // can extract it and the JVM can be started with the classpath already correctly set.
+        // This saves us from having to fork a new JVM process with the classpath set from the processed arguments.
+        @Option(names = {"-cp", "-classpath", "--classpath"}, paramLabel = "<path>", description = "Specify where to find the class files - must be first argument")
+        private String classpath;
 
-    /**
-     * Process the users request.
-     *
-     * @param line the parsed command line.
-     * @throws ParseException if invalid options are chosen
-     */
-    private static boolean process(CommandLine line) throws ParseException, IOException {
-        List args = line.getArgList();
-
-        if (line.hasOption('D')) {
-            Properties optionProperties = line.getOptionProperties("D");
-            Enumeration<String> propertyNames = (Enumeration<String>) optionProperties.propertyNames();
-            while (propertyNames.hasMoreElements()) {
-                String nextName = propertyNames.nextElement();
-                System.setProperty(nextName, optionProperties.getProperty(nextName));
+        @Option(names = {"-D", "--define"}, paramLabel = "<property=value>", description = "Define a system property")
+        private Map<String, String> systemProperties = new LinkedHashMap<String, String>();
+
+        @Option(names = "--disableopt", paramLabel = "optlist", split = ",",
+                description = {
+                        "Disables one or all optimization elements; optlist can be a comma separated list with the elements: ",
+                                "all (disables all optimizations), ",
+                                "int (disable any int based optimizations)"})
+        private List<String> disableopt = new ArrayList<String>();
+
+        @Option(names = {"-d", "--debug"}, description = "Debug mode will print out full stack traces")
+        private boolean debug;
+
+        @Option(names = {"-c", "--encoding"}, paramLabel = "<charset>", description = "Specify the encoding of the files")
+        private String encoding;
+
+        @Option(names = {"-e"}, paramLabel = "<script>", description = "Specify a command line script")
+        private String script;
+
+        @Option(names = {"-i"}, arity = "0..1", paramLabel = "<extension>", description = "Modify files in place; create backup if extension is given (e.g. \'.bak\')")
+        private String extension;
+
+        @Option(names = {"-n"}, description = "Process files line by line using implicit 'line' variable")
+        private boolean lineByLine;
+
+        @Option(names = {"-p"}, description = "Process files line by line and print result (see also -n)")
+        private boolean lineByLinePrint;
+
+        @Option(names = {"-pa", "--parameters"}, description = "Generate metadata for reflection on method parameter names (jdk8+ only)")
+        private boolean parameterMetadata;
+
+        @Option(names = "-l", arity = "0..1", paramLabel = "<port>", description = "Listen on a port and process inbound lines (default: 1960)")
+        private String port;
+
+        @Option(names = {"-a", "--autosplit"}, arity = "0..1", paramLabel = "<splitPattern>", description = "Split lines using splitPattern (default '\\s') using implicit 'split' variable")
+        private String splitPattern;
+
+        @Option(names = {"--indy"}, description = "Enables compilation using invokedynamic")
+        private boolean indy;
+
+        @Option(names = {"--configscript"}, paramLabel = "<script>", description = "A script for tweaking the configuration options")
+        private String configscript;
+
+        @Option(names = {"-b", "--basescript"}, paramLabel = "<class>", description = "Base class name for scripts (must derive from Script)")
+        private String scriptBaseClass;
+
+        @Unmatched
+        List<String> arguments = new ArrayList<String>();
+
+        /**
+         * Process the users request.
+         *
+         * @param parser the parsed command line. Used when the user input was invalid.
+         * @throws ParameterException if the user input was invalid
+         */
+        boolean process(CommandLine parser) throws ParameterException, IOException {
+            for (String key : systemProperties.keySet()) {
+                System.setProperty(key, systemProperties.get(key));
+            }
+            GroovyMain main = new GroovyMain();
+
+            // add the ability to parse scripts with a specified encoding
+            main.conf.setSourceEncoding(encoding);
+
+            main.debug = debug;
+            main.conf.setDebug(main.debug);
+            main.conf.setParameters(parameterMetadata);
+            main.processFiles = lineByLine || lineByLinePrint;
+            main.autoOutput = lineByLinePrint;
+            main.editFiles = extension != null;
+            if (main.editFiles) {
+                main.backupExtension = extension;
             }
-        }
 
-        GroovyMain main = new GroovyMain();
+            main.autoSplit = splitPattern != null;
+            if (main.autoSplit) {
+                main.splitPattern = splitPattern;
+            }
 
-        // add the ability to parse scripts with a specified encoding
-        main.conf.setSourceEncoding(line.getOptionValue('c',main.conf.getSourceEncoding()));
+            main.isScriptFile = script == null;
+            if (main.isScriptFile) {
+                if (arguments.isEmpty()) {
+                    throw new ParameterException(parser, "error: neither -e or filename provided");
+                }
+                main.script = arguments.remove(0);
+                if (main.script.endsWith(".java")) {
+                    throw new ParameterException(parser, "error: cannot compile file with .java extension: " + main.script);
+                }
+            } else {
+                main.script = script;
+            }
 
-        main.isScriptFile = !line.hasOption('e');
-        main.debug = line.hasOption('d');
-        main.conf.setDebug(main.debug);
-        main.conf.setParameters(line.hasOption("pa"));
-        main.processFiles = line.hasOption('p') || line.hasOption('n');
-        main.autoOutput = line.hasOption('p');
-        main.editFiles = line.hasOption('i');
-        if (main.editFiles) {
-            main.backupExtension = line.getOptionValue('i');
-        }
-        main.autoSplit = line.hasOption('a');
-        String sp = line.getOptionValue('a');
-        if (sp != null)
-            main.splitPattern = sp;
-
-        if (main.isScriptFile) {
-            if (args.isEmpty())
-                throw new ParseException("neither -e or filename provided");
-
-            main.script = (String) args.remove(0);
-            if (main.script.endsWith(".java"))
-                throw new ParseException("error: cannot compile file with .java extension: " + main.script);
-        } else {
-            main.script = line.getOptionValue('e');
-        }
+            main.processSockets = port != null;
+            if (main.processSockets) {
+                String p = port.trim().length() > 0 ? port : "1960"; // default port to listen to
+                main.port = Integer.parseInt(p);
+            }
 
-        main.processSockets = line.hasOption('l');
-        if (main.processSockets) {
-            String p = line.getOptionValue('l', "1960"); // default port to listen to
-            main.port = Integer.parseInt(p);
-        }
+            for (String optimization : disableopt) {
+                main.conf.getOptimizationOptions().put(optimization, false);
+            }
 
-        // we use "," as default, because then split will create
-        // an empty array if no option is set
-        String disabled = line.getOptionValue("disableopt", ",");
-        String[] deopts = disabled.split(",");
-        for (String deopt_i : deopts) {
-            main.conf.getOptimizationOptions().put(deopt_i,false);
-        }
+            if (indy) {
+                CompilerConfiguration.DEFAULT.getOptimizationOptions().put("indy", true);
+                main.conf.getOptimizationOptions().put("indy", true);
+            }
 
-        if (line.hasOption("indy")) {
-            CompilerConfiguration.DEFAULT.getOptimizationOptions().put("indy", true);
-            main.conf.getOptimizationOptions().put("indy", true);
-        }
+            if (scriptBaseClass != null) {
+                main.conf.setScriptBaseClass(scriptBaseClass);
+            }
+
+            processConfigScripts(getConfigScripts(), main.conf);
 
-        if (line.hasOption("basescript")) {
-            main.conf.setScriptBaseClass(line.getOptionValue("basescript"));
+            main.args = arguments;
+            return main.run();
         }
 
-        String configScripts = System.getProperty("groovy.starter.configscripts", null);
-        if (line.hasOption("configscript") || (configScripts != null && !configScripts.isEmpty())) {
+        private List<String> getConfigScripts() {
             List<String> scripts = new ArrayList<String>();
-            if (line.hasOption("configscript")) {
-                scripts.add(line.getOptionValue("configscript"));
+            if (this.configscript != null) {
+                scripts.add(this.configscript);
             }
-            if (configScripts != null) {
+            String configScripts = System.getProperty("groovy.starter.configscripts", null);
+            if (configScripts != null && !configScripts.isEmpty()) {
                 scripts.addAll(StringGroovyMethods.tokenize((CharSequence) configScripts, ','));
             }
-            processConfigScripts(scripts, main.conf);
+            return scripts;
         }
-
-        main.args = args;
-        return main.run();
     }
 
     public static void processConfigScripts(List<String> scripts, CompilerConfiguration conf) throws IOException {
diff --git a/src/test/groovy/ui/GroovyMainTest.groovy b/src/test/groovy/ui/GroovyMainTest.groovy
index 6c9396e0a6..ab788ac41f 100644
--- a/src/test/groovy/ui/GroovyMainTest.groovy
+++ b/src/test/groovy/ui/GroovyMainTest.groovy
@@ -26,14 +26,14 @@ class GroovyMainTest extends GroovyTestCase {
         String[] args = ['-h']
         GroovyMain.processArgs(args, ps)
         def out = baos.toString()
-        assert out.contains('usage: groovy')
-        ['-a', '-c', '-d', '-e', '-h', '-i', '-l', '-n', '-p', '-v'].each{
+        assert out.contains('Usage: groovy')
+        ['-a', '-c', '-d', '-e', '-h', '-i', '-l', '-n', '-p', '-V'].each{
             assert out.contains(it)
         }
     }
 
     void testVersion() {
-        String[] args = ['-v']
+        String[] args = ['-V']
         GroovyMain.processArgs(args, ps)
         def out = baos.toString()
         assert out.contains('Groovy Version:')
@@ -51,7 +51,7 @@ class GroovyMainTest extends GroovyTestCase {
         String[] args = ['abc.java']
         GroovyMain.processArgs(args, ps)
         def out = baos.toString()
-        assert out.contains('error: error: cannot compile file with .java extension: abc.java')
+        assert out.contains('error: cannot compile file with .java extension: abc.java')
     }
 
     /**

Commit:
6ec88e20f94d100b73556b7453d0b1e87341add1
Paul King
paulk@asert.com.au
2018-05-18 12:22:29 +1000
remove deprecated methods
diff --git a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
index cd000538db..e9fc8b57f3 100644
--- a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
+++ b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
@@ -18,11 +18,8 @@
  */
 package org.codehaus.groovy.tools;
 
-import groovy.lang.DeprecationException;
 import groovy.lang.GroovyResourceLoader;
 import groovy.lang.GroovySystem;
-import org.apache.commons.cli.HelpFormatter;
-import org.apache.commons.cli.Options;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.ConfigurationException;
@@ -428,41 +425,6 @@ public class FileSystemCompiler {
         }
     }
 
-    /** @deprecated use {@link #displayHelp(PrintWriter)} instead */
-    @Deprecated
-    public static void displayHelp(final Options options) {
-        final HelpFormatter formatter = new HelpFormatter();
-        formatter.printHelp(80, "groovyc [options] <source-files>", "options:", options, "");
-    }
-
-    // some methods to avoid binary incompatibility - don't gain us a lot but gives the user
-    // something slightly less cryptic than a NoSuchMethodError or an IncompatibleClassChangeError
-    @Deprecated
-    public static CompilerConfiguration generateCompilerConfigurationFromOptions(org.apache.commons.cli.CommandLine cli) throws IOException {
-        throw new DeprecationException("This method is not supported for Groovy 2.5+. Consider instead using the FileSystemCompiler.CompilationOptions class.");
-    }
-
-    @Deprecated
-    public static String[] generateFileNamesFromOptions(org.apache.commons.cli.CommandLine cli) {
-        throw new DeprecationException("This method is not supported for Groovy 2.5+. Consider instead using the FileSystemCompiler.CompilationOptions class.");
-    }
-
-    @Deprecated
-    public static Options createCompilationOptions() {
-        throw new DeprecationException("This method is not supported for Groovy 2.5+. Consider instead using the FileSystemCompiler.CompilationOptions class.");
-    }
-
-    /**
-     * Creates a temporary directory in the default temporary directory (as specified by the system
-     * property <i>java.io.tmpdir</i>.
-     *
-     * @deprecated Use {@link DefaultGroovyStaticMethods#createTempDir(java.io.File, String, String)} instead.
-     */
-    @Deprecated
-    public static File createTempDir() throws IOException {
-        return DefaultGroovyStaticMethods.createTempDir(null);
-    }
-
     public static void deleteRecursive(File file) {
         if (!file.exists()) {
             return;

Commit:
76cf78ea4353a8fadc2e40850d6cddd2106e3cbc
Paul King
paulk@asert.com.au
2018-05-18 12:20:00 +1000
GROOVY-8577: GrapeMain to picocli - trivial tweak (closes #704)
diff --git a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
index 705cd2684a..eaa696409c 100644
--- a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
+++ b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
@@ -110,7 +110,7 @@ class GrapeMain implements Runnable {
     // The @Command(mixinStandardHelpOptions = true) attribute cannot be used because
     // the unix standard short option for version help is uppercase -V, while previous versions
     // of this class use lowercase -v. This custom mixin preserves option compatibility.
-    @Command(versionProvider = VersionProvider.class, sortOptions = false,
+    @Command(versionProvider = VersionProvider, sortOptions = false,
             parameterListHeading = "%nParameters:%n",
             optionListHeading = "%nOptions:%n",
             descriptionHeading = "%n")

Commit:
7de69b55d396aec343f8affdbe662ab4a5d7960c
sunlan
sunlan@apache.org
2018-05-18 09:18:27 +0800
Add more relevant tests for GROOVY-6171
diff --git a/src/test/groovy/bugs/Groovy6171Bug.groovy b/src/test/groovy/bugs/Groovy6171Bug.groovy
index 84c0fce18d..abd6903e4d 100644
--- a/src/test/groovy/bugs/Groovy6171Bug.groovy
+++ b/src/test/groovy/bugs/Groovy6171Bug.groovy
@@ -27,6 +27,32 @@ class Groovy6171Bug extends CompilableTestSupport {
         '''
     }
 
+    void testIncompatibleType1() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        public class Foo<T extends List<X>, X extends Number> {
+            static void main(String[] args) {
+                def f = new Foo<ArrayList<String>, String>()
+            }
+        }
+        '''
+
+        assert errMsg.contains('The type String is not a valid substitute for the bounded parameter <X extends java.lang.Number>')
+    }
+
+    void testIncompatibleType2() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        public class Foo<T extends List<X>, X extends Number> {
+            static void main(String[] args) {
+                def f = new Foo<HashSet<Integer>, Integer>()
+            }
+        }
+        '''
+
+        assert errMsg.contains('The type HashSet is not a valid substitute for the bounded parameter <T extends java.util.List<X>>')
+    }
+
     void test2() {
         assertScript '''
         @groovy.transform.CompileStatic
@@ -45,4 +71,30 @@ class Groovy6171Bug extends CompilableTestSupport {
         }
         '''
     }
+
+    void test3() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        public class Foo<T extends List<X>, X extends Number> {
+            X getFirstElement(List<X> list) {
+                X x = list.get(0)
+                
+                assert Number == x.getClass().getGenericSuperclass()
+                
+                return x
+            }
+            
+            Number getFirstNumber(T t) {
+                return getFirstElement(t)
+            }
+            
+            static void main(String[] args) {
+                def f = new Foo<ArrayList<Integer>, Integer>()
+                def list = new ArrayList<Integer>()
+                list.add(123)
+                assert 123 == f.getFirstNumber(list)
+            }
+        }
+        '''
+    }
 }

Commit:
ff8d74741d87133be0a49710470d4b6e23ab1f7e
Paul King
paulk@asert.com.au
2018-05-18 09:46:15 +1000
GROOVY-8577 Migrate org.codehaus.groovy.tools.GrapeMain.groovy to picocli
diff --git a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
index dd330c3b13..705cd2684a 100644
--- a/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
+++ b/src/main/groovy/org/codehaus/groovy/tools/GrapeMain.groovy
@@ -19,290 +19,323 @@
 package org.codehaus.groovy.tools
 
 import groovy.grape.Grape
-import groovy.transform.Field
-import org.apache.commons.cli.CommandLine
-import org.apache.commons.cli.DefaultParser
-import org.apache.commons.cli.HelpFormatter
-import org.apache.commons.cli.Option
-import org.apache.commons.cli.OptionGroup
-import org.apache.commons.cli.Options
 import org.apache.ivy.util.DefaultMessageLogger
 import org.apache.ivy.util.Message
-
-//commands
-
-@Field install = {arg, cmd ->
-    if (arg.size() > 5 || arg.size() < 3) {
-        println 'install requires two to four arguments: <group> <module> [<version> [<classifier>]]'
-        return
-    }
-    def ver = '*'
-    if (arg.size() >= 4) {
-        ver = arg[3]
-    }
-    def classifier = null
-    if (arg.size() >= 5) {
-        classifier = arg[4]
+import picocli.CommandLine
+import picocli.CommandLine.Command
+import picocli.CommandLine.Option
+import picocli.CommandLine.Parameters
+import picocli.CommandLine.ParentCommand
+import picocli.CommandLine.RunLast
+import picocli.CommandLine.Unmatched
+
+@Command(name = "grape", description = "Allows for the inspection and management of the local grape cache.",
+        subcommands = [
+                Install.class,
+                Uninstall.class,
+                ListCommand.class,
+                Resolve.class,
+                picocli.CommandLine.HelpCommand.class])
+class GrapeMain implements Runnable {
+    @Option(names = ["-D", "--define"], description = "define a system property", paramLabel = "<name=value>")
+    private Map<String, String> properties = new LinkedHashMap<String, String>()
+
+    @Option(names = ["-r", "--resolver"], description = "define a grab resolver (for install)", paramLabel = "<url>")
+    private List<String> resolvers = new ArrayList<String>()
+
+    @Option(names = ["-q", "--quiet"], description = "Log level 0 - only errors")
+    private boolean quiet
+
+    @Option(names = ["-w", "--warn"], description = "Log level 1 - errors and warnings")
+    private boolean warn
+
+    @Option(names = ["-i", "--info"], description = "Log level 2 - info")
+    private boolean info
+
+    @Option(names = ["-V", "--verbose"], description = "Log level 3 - verbose")
+    private boolean verbose
+
+    @Option(names = ["-d", "--debug"], description = "Log level 4 - debug")
+    private boolean debug
+
+    @Unmatched List<String> unmatched = new ArrayList<String>()
+
+    private CommandLine parser
+
+    public static void main(String[] args) {
+        GrapeMain grape = new GrapeMain()
+        def parser = new CommandLine(grape)
+        parser.addMixin("helpOptions", new HelpOptionsMixin())
+        parser.subcommands.findAll { k, v -> k != 'help' }.each { k, v -> v.addMixin("helpOptions", new HelpOptionsMixin()) }
+
+        grape.parser = parser
+        parser.parseWithHandler(new RunLast(), args)
     }
 
-    // set the instance so we can re-set the logger
-    Grape.getInstance()
-    setupLogging()
+    void run() {
+        if (unmatched) {
+            System.err.println "grape: '${unmatched[0]}' is not a grape command. See 'grape --help'"
+        } else {
+            parser.usage(System.out) // if no subcommand was specified
+        }
+    }
 
-    cmd.getOptionValues('r')?.each { String url ->
-        Grape.addResolver(name:url, root:url)
+    private void init() {
+        properties.each { k, v ->
+            System.setProperty(k, v)
+        }
     }
 
-    try {
-        Grape.grab(autoDownload: true, group: arg[1], module: arg[2], version: ver, classifier: classifier, noExceptions: true)
-    } catch (Exception e) {
-        println "An error occured : $ex"
+    private void setupLogging(int defaultLevel = 2) { // = Message.MSG_INFO -> some parsing error :(
+        if (quiet) {
+            Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_ERR))
+        } else if (warn) {
+            Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_WARN))
+        } else if (info) {
+            Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_INFO))
+        } else if (verbose) {
+            Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_VERBOSE))
+        } else if (debug) {
+            Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_DEBUG))
+        } else {
+            Message.setDefaultLogger(new DefaultMessageLogger(defaultLevel))
+        }
     }
-}
 
-@Field uninstall = {arg, cmd ->
-    if (arg.size() != 4) {
-        println 'uninstall requires three arguments: <group> <module> <version>'
-        // TODO make version optional? support classifier?
-//        println 'uninstall requires two to four arguments, <group> <module> [<version>] [<classifier>]'
-        return
+    /**
+     * Defines help options (--help and --version) and a version provider used by the top-level command and all subcommands.
+     * Intended to be installed as a picocli mixin.
+     */
+    // IMPLEMENTATION NOTE:
+    // The @Command(mixinStandardHelpOptions = true) attribute cannot be used because
+    // the unix standard short option for version help is uppercase -V, while previous versions
+    // of this class use lowercase -v. This custom mixin preserves option compatibility.
+    @Command(versionProvider = VersionProvider.class, sortOptions = false,
+            parameterListHeading = "%nParameters:%n",
+            optionListHeading = "%nOptions:%n",
+            descriptionHeading = "%n")
+    private static class HelpOptionsMixin {
+        @Option(names = ["-h", "--help"], description = "usage information") boolean isHelpRequested
+        @Option(names = ["-v", "--version"], description = "display the Groovy and JVM versions") boolean isVersionRequested
     }
-    String group = arg[1]
-    String module = arg[2]
-    String ver = arg[3]
-//    def classifier = null
-
-    // set the instance so we can re-set the logger
-    Grape.getInstance()
-    setupLogging()
-
-    if (!Grape.enumerateGrapes().find {String groupName, Map g ->
-        g.any {String moduleName, List<String> versions ->
-            group == groupName && module == moduleName && ver in versions
-        }
-    }) {
-        println "uninstall did not find grape matching: $group $module $ver"
-        def fuzzyMatches = Grape.enumerateGrapes().findAll { String groupName, Map g ->
-            g.any {String moduleName, List<String> versions ->
-                groupName.contains(group) || moduleName.contains(module) ||
-                group.contains(groupName) || module.contains(moduleName)
-            }
-        }
-        if (fuzzyMatches) {
-            println 'possible matches:'
-            fuzzyMatches.each { String groupName, Map g -> println "    $groupName: $g" }
+
+    private static class VersionProvider implements CommandLine.IVersionProvider {
+        String[] getVersion() {
+            String version = GroovySystem.getVersion()
+            return "Groovy Version: $version JVM: ${System.getProperty('java.version')}"
         }
-        return
     }
-    Grape.instance.uninstallArtifact(group, module, ver)
-}
 
-@Field list = {arg, cmd ->
-    println ""
+    @Command(name = 'install', header = 'Installs a particular grape',
+            synopsisHeading = 'Usage: grape ',
+            description = 'Installs the specified groovy module or maven artifact. If a version is specified that specific version will be installed, otherwise the most recent version will be used (as if `*` was passed in).')
+    private static class Install implements Runnable {
+        @Parameters(index = '0', arity = '1', description = 'Which module group the module comes from. Translates directly to a Maven groupId or an Ivy Organization. Any group matching /groovy[x][\\..*]^/ is reserved and may have special meaning to the groovy endorsed modules.')
+        String group
 
-    int moduleCount = 0
-    int versionCount = 0
+        @Parameters(index = '1', arity = '1', description = 'The name of the module to load. Translated directly to a Maven artifactId or an Ivy artifact.')
+        String module
 
-    // set the instance so we can re-set the logger
-    Grape.getInstance()
-    setupLogging()
+        @Parameters(index = '2', arity = '0..1', description = 'The version of the module to use. Either a literal version `1.1-RC3` or an Ivy Range `[2.2.1,)` meaning 2.2.1 or any greater version).')
+        String version = '*'
 
-    Grape.enumerateGrapes().each {String groupName, Map group ->
-        group.each {String moduleName, List<String> versions ->
-            println "$groupName $moduleName  $versions"
-            moduleCount++
-            versionCount += versions.size()
-        }
-    }
-    println ""
-    println "$moduleCount Grape modules cached"
-    println "$versionCount Grape module versions cached"
-}
+        @Parameters(index = '3', arity = '0..1', description = 'The optional classifier to use (for example, jdk15).')
+        String classifier
 
-@Field resolve = {arg, cmd ->
-    Options options = new Options();
-    options.addOption(Option.builder("a").hasArg(false).longOpt("ant").build());
-    options.addOption(Option.builder("d").hasArg(false).longOpt("dos").build());
-    options.addOption(Option.builder("s").hasArg(false).longOpt("shell").build());
-    options.addOption(Option.builder("i").hasArg(false).longOpt("ivy").build());
-    CommandLine cmd2 = new DefaultParser().parse(options, arg[1..-1] as String[], true);
-    arg = cmd2.args
-
-    // set the instance so we can re-set the logger
-    Grape.getInstance()
-    setupLogging(Message.MSG_ERR)
-
-    if ((arg.size() % 3) != 0) {
-        println 'There needs to be a multiple of three arguments: (group module version)+'
-        return
-    }
-    if (args.size() < 3) {
-        println 'At least one Grape reference is required'
-        return
-    }
-    def before, between, after
-    def ivyFormatRequested = false
-
-    if (cmd2.hasOption('a')) {
-        before = '<pathelement location="'
-        between = '">\n<pathelement location="'
-        after = '">'
-    } else if (cmd2.hasOption('d')) {
-        before = 'set CLASSPATH='
-        between = ';'
-        after = ''
-    } else if (cmd2.hasOption('s')) {
-        before = 'export CLASSPATH='
-        between = ':'
-        after = ''
-    } else if (cmd2.hasOption('i')) {
-        ivyFormatRequested = true
-        before = '<dependency '
-        between = '">\n<dependency '
-        after = '">'
-    } else {
-        before = ''
-        between = '\n'
-        after = '\n'
-    }
+        @ParentCommand GrapeMain parentCommand
 
-    iter = arg.iterator()
-    def params = [[:]]
-    def depsInfo = [] // this list will contain the module/group/version info of all resolved dependencies
-    if(ivyFormatRequested) {
-        params << depsInfo
-    }
-    while (iter.hasNext()) {
-        params.add([group: iter.next(), module: iter.next(), version: iter.next()])
-    }
-    try {
-        def results = []
-        def uris = Grape.resolve(* params)
-        if(!ivyFormatRequested) {
-            for (URI uri: uris) {
-                if (uri.scheme == 'file') {
-                    results += new File(uri).path
-                } else {
-                    results += uri.toASCIIString()
-                }
+        void run() {
+            parentCommand.init()
+
+            // set the instance so we can re-set the logger
+            Grape.getInstance()
+            parentCommand.setupLogging()
+
+            parentCommand.resolvers.each { String url ->
+                Grape.addResolver(name:url, root:url)
             }
-        } else {
-            depsInfo.each { dep ->
-                results += ('org="' + dep.group + '" name="' + dep.module + '" revision="' + dep.revision)
+
+            try {
+                Grape.grab(autoDownload: true, group: group, module: module, version: version, classifier: classifier, noExceptions: true)
+            } catch (Exception ex) {
+                println "An error occured : $ex"
             }
         }
+    }
 
-        if (results) {
-            println "${before}${results.join(between)}${after}"
-        } else {
-            println 'Nothing was resolved'
+    @Command(name = 'list', header = 'Lists all installed grapes',
+            synopsisHeading = 'Usage: grape ',
+            description = 'Lists locally installed modules (with their full maven name in the case of groovy modules) and versions.')
+    private static class ListCommand implements Runnable {
+
+        @ParentCommand GrapeMain parentCommand
+
+        void run() {
+            parentCommand.init()
+
+            println ""
+
+            int moduleCount = 0
+            int versionCount = 0
+
+            // set the instance so we can re-set the logger
+            Grape.getInstance()
+            parentCommand.setupLogging()
+
+            Grape.enumerateGrapes().each {String groupName, Map group ->
+                group.each {String moduleName, List<String> versions ->
+                    println "$groupName $moduleName  $versions"
+                    moduleCount++
+                    versionCount += versions.size()
+                }
+            }
+            println ""
+            println "$moduleCount Grape modules cached"
+            println "$versionCount Grape module versions cached"
         }
-    } catch (Exception e) {
-        println "Error in resolve:\n\t$e.message"
-        if (e.message =~ /unresolved dependency/) println "Perhaps the grape is not installed?"
     }
-}
 
-@Field help = { arg, cmd -> grapeHelp() }
-
-@Field commands = [
-    'install': [closure: install,
-        shortHelp: 'Installs a particular grape'],
-    'uninstall': [closure: uninstall,
-        shortHelp: 'Uninstalls a particular grape (non-transitively removes the respective jar file from the grape cache)'],
-    'list': [closure: list,
-        shortHelp: 'Lists all installed grapes'],
-    'resolve': [closure: resolve,
-        shortHelp: 'Enumerates the jars used by a grape'],
-    'help': [closure: help,
-        shortHelp: 'Usage information']
-]
-
-@Field grapeHelp = {
-    int spacesLen = commands.keySet().max {it.length()}.length() + 3
-    String spaces = ' ' * spacesLen
-
-    PrintWriter pw = new PrintWriter(binding.variables.out ?: System.out)
-    new HelpFormatter().printHelp(
-            pw,
-            80,
-            "grape [options] <command> [args]\n",
-            "options:",
-            options,
-            2,
-            4,
-            null, // footer
-            true);
-    pw.flush()
-
-    println ""
-    println "commands:"
-    commands.each {String k, v ->
-        println "  ${(k + spaces).substring(0, spacesLen)} $v.shortHelp"
-    }
-    println ""
-}
+    @Command(name = 'resolve', header = 'Enumerates the jars used by a grape',
+            synopsisHeading = 'Usage: grape ',
+            description = 'Prints the file locations of the jars representing the artifcats for the specified module(s) and the respective transitive dependencies.')
+    private static class Resolve implements Runnable {
 
-@Field setupLogging = {int defaultLevel = 2 -> // = Message.MSG_INFO -> some parsing error :(
-    if (cmd.hasOption('q')) {
-        Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_ERR))
-    } else if (cmd.hasOption('w')) {
-        Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_WARN))
-    } else if (cmd.hasOption('i')) {
-        Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_INFO))
-    } else if (cmd.hasOption('V')) {
-        Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_VERBOSE))
-    } else if (cmd.hasOption('d')) {
-        Message.setDefaultLogger(new DefaultMessageLogger(Message.MSG_DEBUG))
-    } else {
-        Message.setDefaultLogger(new DefaultMessageLogger(defaultLevel))
-    }
-}
+        @Option(names = ['-a', '--ant'], description = 'Express dependencies in a format applicable for an ant script')
+        private boolean ant
 
-// command line parsing
-@Field Options options = new Options();
+        @Option(names = ['-d', '--dos'], description = 'Express dependencies in a format applicable for a windows batch file')
+        private boolean dos
 
-options.addOption(Option.builder("D").longOpt("define").desc("define a system property").numberOfArgs(2).valueSeparator().argName("name=value").build());
-options.addOption(Option.builder("r").longOpt("resolver").desc("define a grab resolver (for install)").hasArg(true).argName("url").build());
-options.addOption(Option.builder("h").hasArg(false).desc("usage information").longOpt("help").build());
+        @Option(names = ['-s', '--shell'], description = 'Express dependencies in a format applicable for a unix shell script')
+        private boolean shell
 
-// Logging Level Options
-options.addOptionGroup(
-        new OptionGroup()
-                .addOption(Option.builder("q").hasArg(false).desc("Log level 0 - only errors").longOpt("quiet").build())
-                .addOption(Option.builder("w").hasArg(false).desc("Log level 1 - errors and warnings").longOpt("warn").build())
-                .addOption(Option.builder("i").hasArg(false).desc("Log level 2 - info").longOpt("info").build())
-                .addOption(Option.builder("V").hasArg(false).desc("Log level 3 - verbose").longOpt("verbose").build())
-                .addOption(Option.builder("d").hasArg(false).desc("Log level 4 - debug").longOpt("debug").build())
-)
-options.addOption(Option.builder("v").hasArg(false).desc("display the Groovy and JVM versions").longOpt("version").build());
+        @Option(names = ['-i', '--ivy'], description = 'Express dependencies in an ivy-like format')
+        private boolean ivyFormatRequested
 
-@Field CommandLine cmd
+        @ParentCommand GrapeMain parentCommand
 
-cmd = new DefaultParser().parse(options, args, true);
+        void run() {
+            parentCommand.init()
 
-if (cmd.hasOption('h')) {
-    grapeHelp()
-    return
-}
+            // set the instance so we can re-set the logger
+            Grape.getInstance()
+            parentCommand.setupLogging(Message.MSG_ERR)
 
-if (cmd.hasOption('v')) {
-    String version = GroovySystem.getVersion();
-    println "Groovy Version: $version JVM: ${System.getProperty('java.version')}"
-    return
-}
+            if ((arg.size() % 3) != 0) {
+                println 'There needs to be a multiple of three arguments: (group module version)+'
+                return
+            }
+            if (args.size() < 3) {
+                println 'At least one Grape reference is required'
+                return
+            }
+            def before, between, after
+
+            if (ant) {
+                before = '<pathelement location="'
+                between = '">\n<pathelement location="'
+                after = '">'
+            } else if (dos) {
+                before = 'set CLASSPATH='
+                between = ';'
+                after = ''
+            } else if (shell) {
+                before = 'export CLASSPATH='
+                between = ':'
+                after = ''
+            } else if (ivy) {
+                before = '<dependency '
+                between = '">\n<dependency '
+                after = '">'
+            } else {
+                before = ''
+                between = '\n'
+                after = '\n'
+            }
 
-if (options.hasOption('D')) {
-    cmd.getOptionProperties('D')?.each { k, v ->
-        System.setProperty(k, v)
+            iter = arg.iterator()
+            def params = [[:]]
+            def depsInfo = [] // this list will contain the module/group/version info of all resolved dependencies
+            if (ivyFormatRequested) {
+                params << depsInfo
+            }
+            while (iter.hasNext()) {
+                params.add([group: iter.next(), module: iter.next(), version: iter.next()])
+            }
+            try {
+                def results = []
+                def uris = Grape.resolve(* params)
+                if(!ivyFormatRequested) {
+                    for (URI uri: uris) {
+                        if (uri.scheme == 'file') {
+                            results += new File(uri).path
+                        } else {
+                            results += uri.toASCIIString()
+                        }
+                    }
+                } else {
+                    depsInfo.each { dep ->
+                        results += ('org="' + dep.group + '" name="' + dep.module + '" revision="' + dep.revision)
+                    }
+                }
+
+                if (results) {
+                    println "${before}${results.join(between)}${after}"
+                } else {
+                    println 'Nothing was resolved'
+                }
+            } catch (Exception e) {
+                println "Error in resolve:\n\t$e.message"
+                if (e.message =~ /unresolved dependency/) println "Perhaps the grape is not installed?"
+            }
+        }
     }
-}
 
-String[] arg = cmd.args
-if (arg?.length == 0) {
-    grapeHelp()
-} else if (commands.containsKey(arg[0])) {
-    commands[arg[0]].closure(arg, cmd)
-} else {
-    println "grape: '${arg[0]}' is not a grape command. See 'grape --help'"
+    @Command(name = 'uninstall',
+            synopsisHeading = 'Usage: grape ',
+            description = 'Uninstalls a particular grape (non-transitively removes the respective jar file from the grape cache).')
+    private static class Uninstall implements Runnable {
+        @Parameters(index = '0', arity = '1', description = 'Which module group the module comes from. Translates directly to a Maven groupId or an Ivy Organization. Any group matching /groovy[x][\\..*]^/ is reserved and may have special meaning to the groovy endorsed modules.')
+        String group
+
+        @Parameters(index = '1', arity = '1', description = 'The name of the module to load. Translated directly to a Maven artifactId or an Ivy artifact.')
+        String module
+
+        @Parameters(index = '2', arity = '1', description = 'The version of the module to use. Either a literal version `1.1-RC3` or an Ivy Range `[2.2.1,)` meaning 2.2.1 or any greater version).')
+        String version
+
+        // TODO make version optional? support classifier?
+        //@Parameters(index = '3', arity = '0..1', description = 'The optional classifier to use (for example, jdk15).')
+        //String classifier;
+
+        @ParentCommand GrapeMain parentCommand
+
+        void run() {
+            parentCommand.init()
+
+            // set the instance so we can re-set the logger
+            Grape.getInstance()
+            parentCommand.setupLogging()
+
+            if (!Grape.enumerateGrapes().find {String groupName, Map g ->
+                g.any {String moduleName, List<String> versions ->
+                    group == groupName && module == moduleName && version in versions
+                }
+            }) {
+                println "uninstall did not find grape matching: $group $module $version"
+                def fuzzyMatches = Grape.enumerateGrapes().findAll { String groupName, Map g ->
+                    g.any {String moduleName, List<String> versions ->
+                        groupName.contains(group) || moduleName.contains(module) ||
+                                group.contains(groupName) || module.contains(moduleName)
+                    }
+                }
+                if (fuzzyMatches) {
+                    println 'possible matches:'
+                    fuzzyMatches.each { String groupName, Map g -> println "    $groupName: $g" }
+                }
+                return
+            }
+            Grape.instance.uninstallArtifact(group, module, version)
+        }
+    }
 }

Commit:
25a414f8232eb7092869baab4ee5645dc17f39fc
Paul King
paulk@asert.com.au
2018-05-18 09:40:31 +1000
remove unused deprecated constant
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 53207c4804..545cc492cf 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -82,9 +82,6 @@ public class CompilerConfiguration {
     /** An array of the valid targetBytecode values **/
     public static final String[] ALLOWED_JDKS = JDK_TO_BYTECODE_VERSION_MAP.keySet().toArray(new String[0]);
 
-    // Just call getVMVersion() once.
-    public static final String CURRENT_JVM_VERSION = getVMVersion();
-
     private static final String GROOVY_ANTLR4_OPT = "groovy.antlr4";
 
     /**
@@ -229,7 +226,7 @@ public class CompilerConfiguration {
         setScriptBaseClass(null);
         setRecompileGroovySource(false);
         setMinimumRecompilationInterval(100);
-        setTargetBytecode(getSystemPropertySafe("groovy.target.bytecode", getVMVersion()));
+        setTargetBytecode(getSystemPropertySafe("groovy.target.bytecode", getMinBytecodeVersion()));
         setDefaultScriptExtension(getSystemPropertySafe("groovy.default.scriptExtension", ".groovy"));
 
         // Source file encoding
@@ -777,7 +774,7 @@ public class CompilerConfiguration {
         return this.targetBytecode;
     }
 
-    private static String getVMVersion() {
+    private static String getMinBytecodeVersion() {
         return JDK8;
     }
 

Commit:
c01db1539ef40adf8b6406e2eced3fecc89616c1
sunlan
sunlan@apache.org
2018-05-18 01:48:12 +0800
Improve the robustness of resolving generics
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 9ceab30b94..c3939b2923 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -77,6 +77,7 @@ import java.util.Set;
 
 import static org.codehaus.groovy.ast.tools.GeneralUtils.inSamePackage;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.isDefaultVisibility;
+import static org.codehaus.groovy.runtime.DefaultGroovyMethods.asBoolean;
 
 /**
  * Visitor to resolve Types and convert VariableExpression to
@@ -92,6 +93,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     public static final String[] DEFAULT_IMPORTS = {"java.lang.", "java.io.", "java.net.", "java.util.", "groovy.lang.", "groovy.util."};
     private static final String BIGINTEGER_STR = "BigInteger";
     private static final String BIGDECIMAL_STR = "BigDecimal";
+    public static final String QUESTION_MARK = "?";
 
     private ClassNode currentClass;
     private final CompilationUnit compilationUnit;
@@ -1462,7 +1464,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             ClassNode classNode = type.getType();
             String name = type.getName();
             ClassNode[] bounds = type.getUpperBounds();
-            boolean isWild = "?".equals(name);
+            boolean isWild = QUESTION_MARK.equals(name);
             boolean toDealWithGenerics = 0 == level || (level > 0 && null != genericParameterNames.get(name));
 
             if (bounds != null) {
@@ -1481,7 +1483,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                         resolveOrFail(upperBound, classNode);
                     }
 
-                    if (upperBound.isUsingGenerics()) {
+                    if (asBoolean(upperBound.isUsingGenerics())) {
                         upperBoundsWithGenerics.add(new Tuple2<>(upperBound, type));
                     }
                 }

Commit:
ef2fbe68d25ae7dce57ee2580c975c54e3dbaace
sunlan
sunlan@apache.org
2018-05-18 00:43:57 +0800
Recover the GROOVY-4151 test
diff --git a/src/test/groovy/bugs/Groovy4151Bug.groovy b/src/test/groovy/bugs/Groovy4151Bug.groovy
new file mode 100644
index 0000000000..656f696afe
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy4151Bug.groovy
@@ -0,0 +1,33 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+import gls.CompilableTestSupport
+
+class Groovy4151Bug extends CompilableTestSupport {
+    void testPrintThisInGString() {
+        shouldCompile """
+            class C4151 {
+                class S4151 {
+                    S4151() { println "$this" }
+                }
+            }        
+        """
+    }
+}
\ No newline at end of file

Commit:
c9eea7c30ececdc0a24939fb780c56c27eec798f
sunlan
sunlan@apache.org
2018-05-18 00:39:13 +0800
GROOVY-6167: Generics: within a single declaration, generic type definition order matters
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 45ac027794..9ceab30b94 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -1447,29 +1447,60 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     }
 
     private void resolveGenericsHeader(GenericsType[] types) {
+        resolveGenericsHeader(types, null, 0);
+    }
+
+    private void resolveGenericsHeader(GenericsType[] types, GenericsType rootType, int level) {
         if (types == null) return;
         currentClass.setUsingGenerics(true);
+        List<Tuple2<ClassNode, GenericsType>> upperBoundsWithGenerics = new LinkedList<>();
         for (GenericsType type : types) {
+            if (level > 0 && type.getName().equals(rootType.getName())) {
+                continue;
+            }
+
             ClassNode classNode = type.getType();
             String name = type.getName();
             ClassNode[] bounds = type.getUpperBounds();
+            boolean isWild = "?".equals(name);
+            boolean toDealWithGenerics = 0 == level || (level > 0 && null != genericParameterNames.get(name));
+
             if (bounds != null) {
                 boolean nameAdded = false;
                 for (ClassNode upperBound : bounds) {
-                    if (!nameAdded && upperBound != null || !resolve(classNode)) {
+                    if (!isWild) {
+                        if (!nameAdded && upperBound != null || !resolve(classNode)) {
+                            if (toDealWithGenerics) {
+                                genericParameterNames.put(name, type);
+                                type.setPlaceholder(true);
+                                classNode.setRedirect(upperBound);
+                                nameAdded = true;
+                            }
+
+                        }
+                        resolveOrFail(upperBound, classNode);
+                    }
+
+                    if (upperBound.isUsingGenerics()) {
+                        upperBoundsWithGenerics.add(new Tuple2<>(upperBound, type));
+                    }
+                }
+            } else {
+                if (!isWild) {
+                    if (toDealWithGenerics) {
                         genericParameterNames.put(name, type);
                         type.setPlaceholder(true);
-                        classNode.setRedirect(upperBound);
-                        nameAdded = true;
+                        classNode.setRedirect(ClassHelper.OBJECT_TYPE);
                     }
-                    resolveOrFail(upperBound, classNode);
                 }
-            } else {
-                genericParameterNames.put(name, type);
-                classNode.setRedirect(ClassHelper.OBJECT_TYPE);
-                type.setPlaceholder(true);
             }
         }
+
+        for (Tuple2<ClassNode, GenericsType> tp : upperBoundsWithGenerics) {
+            ClassNode upperBound = tp.getFirst();
+            GenericsType gt = tp.getSecond();
+            resolveGenericsHeader(upperBound.getGenericsTypes(), 0 == level ? gt : rootType, level + 1);
+        }
     }
 
     private boolean resolveGenericsType(GenericsType genericsType) {
diff --git a/src/test/groovy/bugs/Groovy4151Bug.groovy b/src/test/groovy/bugs/Groovy6171Bug.groovy
similarity index 54%
rename from src/test/groovy/bugs/Groovy4151Bug.groovy
rename to src/test/groovy/bugs/Groovy6171Bug.groovy
index a345ce60f1..84c0fce18d 100644
--- a/src/test/groovy/bugs/Groovy4151Bug.groovy
+++ b/src/test/groovy/bugs/Groovy6171Bug.groovy
@@ -1,33 +1,48 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-import gls.CompilableTestSupport
-
-class Groovy4151Bug extends CompilableTestSupport {
-    void testPrintThisInGString() {
-        shouldCompile """
-            class C4151 {
-                class S4151 {
-                    S4151() { println "$this" }
-                }
-            }        
-        """
-    }
-}
\ No newline at end of file
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+import gls.CompilableTestSupport
+
+class Groovy6171Bug extends CompilableTestSupport {
+    void testGroovy6171() {
+        shouldCompile '''
+        public class Foo<T extends List<X>, X extends Number> {}
+        '''
+    }
+
+    void test2() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        public class Foo<T extends List<X>, X extends Number> {
+            X getFirstElement(T t) {
+                X x = t.get(0)
+                return x
+            }
+            
+            static void main(String[] args) {
+                def f = new Foo<ArrayList<Integer>, Integer>()
+                def list = new ArrayList<Integer>()
+                list.add(123)
+                assert 123 == f.getFirstElement(list)
+            }
+        }
+        '''
+    }
+}

Commit:
f03b04a77db26a9555dac46de7bd4dd4728d7fa9
Paul King
paulk@asert.com.au
2018-05-17 23:13:42 +1000
GROOVY-8567: minor tweaks for Groovyc to picocli conversion (closes #703)
diff --git a/gradle/assemble.gradle b/gradle/assemble.gradle
index f76fe99969..d4844bdf51 100644
--- a/gradle/assemble.gradle
+++ b/gradle/assemble.gradle
@@ -199,7 +199,7 @@ allprojects {
                             return component.module in [
                                     'antlr', 'antlr-runtime', 'antlr4', 'antlr4-runtime', 'antlr4-annotations',
                                     'asm', 'asm-commons', 'asm-tree', 'asm-util',
-                                    'commons-cli']
+                                    'commons-cli', 'picocli']
                         }
                         return false
                     }
@@ -212,13 +212,17 @@ allprojects {
                     'org/codehaus/groovy/cli/GroovyPosixParser*.class',
                     'groovy/util/CliBuilder*.class',
                     'groovy/util/OptionAccessor*.class',
-                    'org/codehaus/groovy/tools/shell/util/HelpFormatter*.class'
+                    'org/codehaus/groovy/tools/shell/util/HelpFormatter*.class',
+                    'groovy/cli/commons/CliBuilder*.class',
+                    'groovy/cli/commons/OptionAccessor*.class',
+                    'groovy/cli/picocli/CliBuilder*.class'
             ]
             patterns = [
                     'antlr.**'                 : 'groovyjarjarantlr.@1', // antlr2
                     'org.antlr.**'             : 'groovyjarjarantlr4.@1', // antlr4
                     'org.objectweb.**'         : 'groovyjarjarasm.@1',
-                    'org.apache.commons.cli.**': 'groovyjarjarcommonscli.@1'
+                    'org.apache.commons.cli.**': 'groovyjarjarcommonscli.@1',
+                    'picocli.**': 'groovyjarjarpicocli.@1'
             ]
             excludesPerLibrary = [
                     '*': ['META-INF/maven/**', 'META-INF/*', 'META-INF/services/javax.annotation.processing.Processor', 'module-info.class']
diff --git a/gradle/pomconfigurer.gradle b/gradle/pomconfigurer.gradle
index 3ce9ada751..31ea58ac88 100644
--- a/gradle/pomconfigurer.gradle
+++ b/gradle/pomconfigurer.gradle
@@ -627,6 +627,9 @@ project.ext.pomConfigureClosureWithoutTweaks = {
             contributor {
                 name 'Tom Nichols'
             }
+            contributor {
+                name 'Remko Popma'
+            }
         }
         mailingLists {
             mailingList {
diff --git a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
index 8b54b308a9..cd000538db 100644
--- a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
+++ b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
@@ -18,24 +18,32 @@
  */
 package org.codehaus.groovy.tools;
 
+import groovy.lang.DeprecationException;
 import groovy.lang.GroovyResourceLoader;
 import groovy.lang.GroovySystem;
 import org.apache.commons.cli.HelpFormatter;
 import org.apache.commons.cli.Options;
-import picocli.CommandLine;
-import picocli.CommandLine.*;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.ConfigurationException;
 import org.codehaus.groovy.runtime.DefaultGroovyStaticMethods;
 import org.codehaus.groovy.runtime.StringGroovyMethods;
 import org.codehaus.groovy.tools.javac.JavaAwareCompilationUnit;
-
-import java.io.*;
+import picocli.CommandLine;
+import picocli.CommandLine.Command;
+import picocli.CommandLine.IVersionProvider;
+import picocli.CommandLine.Option;
+import picocli.CommandLine.Parameters;
+import picocli.CommandLine.ParseResult;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintWriter;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -72,13 +80,6 @@ public class FileSystemCompiler {
         unit.compile();
     }
 
-    /** @deprecated use {@link #displayHelp(PrintWriter)} instead */
-    @Deprecated
-    public static void displayHelp(final Options options) {
-        final HelpFormatter formatter = new HelpFormatter();
-        formatter.printHelp(80, "groovyc [options] <source-files>", "options:", options, "");
-    }
-
     /** Prints the usage help message for {@link CompilationOptions} to stderr.
      * @see #displayHelp(PrintWriter)
      * @since 2.5 */
@@ -86,19 +87,20 @@ public class FileSystemCompiler {
         displayHelp(new PrintWriter(System.err, true));
     }
 
-    /** Prints the usage help message for the {@link CompilationOptions} to the specified PrintWriter. */
+    /** Prints the usage help message for the {@link CompilationOptions} to the specified PrintWriter.
+     * @since 2.5 */
     public static void displayHelp(final PrintWriter writer) {
         configureParser(new CompilationOptions()).usage(writer);
     }
 
     /** Prints version information to stderr.
-     * @see #displayVersion(PrintWriter)
-     * @since 2.5 */
+     * @see #displayVersion(PrintWriter) */
     public static void displayVersion() {
         displayVersion(new PrintWriter(System.err, true));
     }
 
-    /** Prints version information to the specified PrintWriter. */
+    /** Prints version information to the specified PrintWriter.
+     * @since 2.5 */
     public static void displayVersion(final PrintWriter writer) {
         for (String line : new VersionProvider().getVersion()) {
             writer.println(line);
@@ -288,6 +290,8 @@ public class FileSystemCompiler {
         }
     }
 
+    /**
+     * @since 2.5 */
     static class VersionProvider implements IVersionProvider {
         @Override
         public String[] getVersion() {
@@ -299,6 +303,8 @@ public class FileSystemCompiler {
         }
     }
 
+    /**
+     * @since 2.5 */
     @Command(name = "groovyc",
             customSynopsis = "groovyc [options] <source-files>",
             sortOptions = false,
@@ -422,6 +428,30 @@ public class FileSystemCompiler {
         }
     }
 
+    /** @deprecated use {@link #displayHelp(PrintWriter)} instead */
+    @Deprecated
+    public static void displayHelp(final Options options) {
+        final HelpFormatter formatter = new HelpFormatter();
+        formatter.printHelp(80, "groovyc [options] <source-files>", "options:", options, "");
+    }
+
+    // some methods to avoid binary incompatibility - don't gain us a lot but gives the user
+    // something slightly less cryptic than a NoSuchMethodError or an IncompatibleClassChangeError
+    @Deprecated
+    public static CompilerConfiguration generateCompilerConfigurationFromOptions(org.apache.commons.cli.CommandLine cli) throws IOException {
+        throw new DeprecationException("This method is not supported for Groovy 2.5+. Consider instead using the FileSystemCompiler.CompilationOptions class.");
+    }
+
+    @Deprecated
+    public static String[] generateFileNamesFromOptions(org.apache.commons.cli.CommandLine cli) {
+        throw new DeprecationException("This method is not supported for Groovy 2.5+. Consider instead using the FileSystemCompiler.CompilationOptions class.");
+    }
+
+    @Deprecated
+    public static Options createCompilationOptions() {
+        throw new DeprecationException("This method is not supported for Groovy 2.5+. Consider instead using the FileSystemCompiler.CompilationOptions class.");
+    }
+
     /**
      * Creates a temporary directory in the default temporary directory (as specified by the system
      * property <i>java.io.tmpdir</i>.
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
index 7a60ac8e9a..8c57bcc0b6 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
@@ -161,7 +161,7 @@ import java.util.StringTokenizer;
  * &lt;/project&gt;
  * </pre>
  * <p>
- * Based heavily on the implementation of the Javac task in Apache Ant.
+ * Based on the implementation of the Javac task in Apache Ant.
  * <p>
  * Can also be used from {@link groovy.util.AntBuilder} to allow the build file to be scripted in Groovy.
  */
diff --git a/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
index 790cb8214c..237b631c27 100644
--- a/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
+++ b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
@@ -348,7 +348,7 @@ class CliBuilder {
      * Make options accessible from command line args with parser.
      * Returns null on bad command lines after displaying usage message.
      */
-    groovy.cli.commons.OptionAccessor parse(args) {
+    OptionAccessor parse(args) {
         if (expandArgumentFiles) args = expandArgumentFiles(args)
         if (!parser) {
             parser = posix != null && posix == false ? new GnuParser() : new DefaultParser()
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
index b196a6775c..aacd8324d4 100644
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
@@ -510,7 +510,7 @@ class CliBuilder {
      * Sets the {@link #posix} property on this <code>CliBuilder</code> and the
      * <code>posixClusteredShortOptionsAllowed</code> property on the {@link #parser}
      * used by the underlying library.
-     * @param poxis whether to allow clustered short options
+     * @param posix whether to allow clustered short options
      */
     void setPosix(boolean posix) {
         this.posix = posix
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
index 643f81fde6..acdc258f56 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
@@ -19,6 +19,7 @@
 package org.codehaus.groovy.tools.shell
 
 import groovy.cli.commons.CliBuilder
+import groovy.cli.commons.OptionAccessor
 import jline.TerminalFactory
 import jline.UnixTerminal
 import jline.UnsupportedTerminal

Commit:
96bac63a3176160090d4ca2f87a4cbf0c9b978ea
Paul King
paulk@asert.com.au
2018-05-17 20:42:47 +1000
GROOVY-8567 Migrate Groovyc to picocli
diff --git a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
index df10a023fb..8b54b308a9 100644
--- a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
+++ b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
@@ -20,12 +20,10 @@ package org.codehaus.groovy.tools;
 
 import groovy.lang.GroovyResourceLoader;
 import groovy.lang.GroovySystem;
-import org.apache.commons.cli.CommandLine;
-import org.apache.commons.cli.CommandLineParser;
-import org.apache.commons.cli.DefaultParser;
 import org.apache.commons.cli.HelpFormatter;
-import org.apache.commons.cli.Option;
 import org.apache.commons.cli.Options;
+import picocli.CommandLine;
+import picocli.CommandLine.*;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.ConfigurationException;
@@ -33,10 +31,7 @@ import org.codehaus.groovy.runtime.DefaultGroovyStaticMethods;
 import org.codehaus.groovy.runtime.StringGroovyMethods;
 import org.codehaus.groovy.tools.javac.JavaAwareCompilationUnit;
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
+import java.io.*;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
@@ -77,16 +72,37 @@ public class FileSystemCompiler {
         unit.compile();
     }
 
+    /** @deprecated use {@link #displayHelp(PrintWriter)} instead */
+    @Deprecated
     public static void displayHelp(final Options options) {
         final HelpFormatter formatter = new HelpFormatter();
         formatter.printHelp(80, "groovyc [options] <source-files>", "options:", options, "");
     }
 
+    /** Prints the usage help message for {@link CompilationOptions} to stderr.
+     * @see #displayHelp(PrintWriter)
+     * @since 2.5 */
+    public static void displayHelp() {
+        displayHelp(new PrintWriter(System.err, true));
+    }
+
+    /** Prints the usage help message for the {@link CompilationOptions} to the specified PrintWriter. */
+    public static void displayHelp(final PrintWriter writer) {
+        configureParser(new CompilationOptions()).usage(writer);
+    }
+
+    /** Prints version information to stderr.
+     * @see #displayVersion(PrintWriter)
+     * @since 2.5 */
     public static void displayVersion() {
-        String version = GroovySystem.getVersion();
-        System.err.println("Groovy compiler version " + version);
-        System.err.println("Copyright 2003-2018 The Apache Software Foundation. http://groovy-lang.org/");
-        System.err.println("");
+        displayVersion(new PrintWriter(System.err, true));
+    }
+
+    /** Prints version information to the specified PrintWriter. */
+    public static void displayVersion(final PrintWriter writer) {
+        for (String line : new VersionProvider().getVersion()) {
+            writer.println(line);
+        }
     }
 
     public static int checkFiles(String[] filenames) {
@@ -125,32 +141,20 @@ public class FileSystemCompiler {
      * the VM to exit and the lookup for .groovy files can be controlled
      */
     public static void commandLineCompile(String[] args, boolean lookupUnnamedFiles) throws Exception {
-        Options options = createCompilationOptions();
-
-        CommandLineParser cliParser = new DefaultParser();
-
-        CommandLine cli;
-        cli = cliParser.parse(options, args);
-
-        if (cli.hasOption('h')) {
-            displayHelp(options);
+        CompilationOptions options = new CompilationOptions();
+        CommandLine parser = configureParser(options);
+        ParseResult parseResult = parser.parseArgs(args);
+        if (CommandLine.printHelpIfRequested(parseResult)) {
             return;
         }
-
-        if (cli.hasOption('v')) {
-            displayVersion();
-            return;
-        }
-
-        displayStackTraceOnError = cli.hasOption('e');
-
-        CompilerConfiguration configuration = generateCompilerConfigurationFromOptions(cli);
+        displayStackTraceOnError = options.printStack;
+        CompilerConfiguration configuration = options.toCompilerConfiguration();
 
         // Load the file name list
-        String[] filenames = generateFileNamesFromOptions(cli);
+        String[] filenames = options.generateFileNames();
         boolean fileNameErrors = filenames == null;
         if (!fileNameErrors && (filenames.length == 0)) {
-            displayHelp(options);
+            parser.usage(System.err);
             return;
         }
 
@@ -161,6 +165,17 @@ public class FileSystemCompiler {
         }
     }
 
+    public static CommandLine configureParser(CompilationOptions options) {
+        CommandLine parser = new CommandLine(options);
+        parser.getCommandSpec().mixinStandardHelpOptions(true); // programmatically so these options appear last in usage help
+        parser.getCommandSpec().parser()
+                .unmatchedArgumentsAllowed(true)
+                .unmatchedOptionsArePositionalParams(true)
+                .expandAtFiles(false)
+                .toggleBooleanFlags(false);
+        return parser;
+    }
+
     /**
      * Primary entry point for compiling from the command line
      * (using the groovyc script).
@@ -234,9 +249,11 @@ public class FileSystemCompiler {
         }
     }
 
-    public static String[] generateFileNamesFromOptions(CommandLine cli) {
-        String[] filenames = cli.getArgs();
-        List<String> fileList = new ArrayList<String>(filenames.length);
+    private static String[] generateFileNamesFromOptions(List<String> filenames) {
+        if (filenames == null) {
+            return new String[0];
+        }
+        List<String> fileList = new ArrayList<String>(filenames.size());
         boolean errors = false;
         for (String filename : filenames) {
             if (filename.startsWith("@")) {
@@ -271,94 +288,138 @@ public class FileSystemCompiler {
         }
     }
 
-    public static CompilerConfiguration generateCompilerConfigurationFromOptions(CommandLine cli) throws IOException {
-        // Setup the configuration data
-        CompilerConfiguration configuration = new CompilerConfiguration();
-
-        if (cli.hasOption("classpath")) {
-            configuration.setClasspath(cli.getOptionValue("classpath"));
+    static class VersionProvider implements IVersionProvider {
+        @Override
+        public String[] getVersion() {
+            return new String[] {
+                    "Groovy compiler version " + GroovySystem.getVersion(),
+                    "Copyright 2003-2018 The Apache Software Foundation. http://groovy-lang.org/",
+                    "",
+            };
         }
+    }
 
-        if (cli.hasOption('d')) {
-            configuration.setTargetDirectory(cli.getOptionValue('d'));
-        }
+    @Command(name = "groovyc",
+            customSynopsis = "groovyc [options] <source-files>",
+            sortOptions = false,
+            versionProvider = VersionProvider.class)
+    public static class CompilationOptions {
+        // IMPLEMENTATION NOTE:
+        // classpath must be the first argument, so that the `startGroovy(.bat)` script
+        // can extract it and the JVM can be started with the classpath already correctly set.
+        // This saves us from having to fork a new JVM process with the classpath set from the processed arguments.
+        @Option(names = {"-cp", "-classpath", "--classpath"}, paramLabel = "<path>", description = "Specify where to find the class files - must be first argument")
+        private String classpath;
 
-        configuration.setParameters(cli.hasOption("pa"));
+        @Option(names = {"-sourcepath", "--sourcepath"}, paramLabel = "<path>", description = "Specify where to find the source files")
+        private File sourcepath;
 
-        if (cli.hasOption("encoding")) {
-            configuration.setSourceEncoding(cli.getOptionValue("encoding"));
-        }
+        @Option(names = {"--temp"}, paramLabel = "<temp>", description = "Specify temporary directory")
+        private File temp;
 
-        if (cli.hasOption("basescript")) {
-            configuration.setScriptBaseClass(cli.getOptionValue("basescript"));
-        }
+        @Option(names = {"--encoding"}, description = "Specify the encoding of the user class files")
+        private String encoding;
+
+        @Option(names = "-d", paramLabel = "<dir>", description = "Specify where to place generated class files")
+        private File targetDir;
 
-        // joint compilation parameters
-        if (cli.hasOption('j')) {
-            Map<String, Object> compilerOptions = new HashMap<String, Object>();
+        @Option(names = {"-e", "--exception"}, description = "Print stack trace on error")
+        private boolean printStack;
 
-            String[] namedValues = cli.getOptionValues("J");
-            compilerOptions.put("namedValues", namedValues);
+        @Option(names = {"-pa", "--parameters"}, description = "Generate metadata for reflection on method parameter names (jdk8+ only)")
+        private boolean parameterMetadata;
 
-            String[] flags = cli.getOptionValues("F");
-            if (flags != null && cli.hasOption("pa")){
-                flags = Arrays.copyOf(flags, flags.length + 1);
-                flags[flags.length - 1] = "parameters";
+        @Option(names = {"-j", "--jointCompilation"}, description = "Attach javac compiler to compile .java files")
+        private boolean jointCompilation;
+
+        @Option(names = {"-b", "--basescript"}, paramLabel = "<class>", description = "Base class name for scripts (must derive from Script)")
+        private String scriptBaseClass;
+
+        @Option(names = "-J", paramLabel = "<property=value>", description = "Name-value pairs to pass to javac")
+        private Map<String, String> javacOptionsMap;
+
+        @Option(names = "-F", paramLabel = "<flag>", description = "Passed to javac for joint compilation")
+        private List<String> flags;
+
+        @Option(names = {"--indy"}, description = "Enables compilation using invokedynamic")
+        private boolean indy;
+
+        @Option(names = {"--configscript"}, paramLabel = "<script>", description = "A script for tweaking the configuration options")
+        private String configScript;
+
+        @Parameters(description = "The groovy source files to compile, or @-files containing a list of source files to compile",
+                    paramLabel = "<source-files>")
+        private List<String> files;
+
+        public CompilerConfiguration toCompilerConfiguration() throws IOException {
+            // Setup the configuration data
+            CompilerConfiguration configuration = new CompilerConfiguration();
+
+            if (classpath != null) {
+                configuration.setClasspath(classpath);
+            }
+
+            if (targetDir != null && targetDir.getName().length() > 0) {
+                configuration.setTargetDirectory(targetDir);
+            }
+
+            configuration.setParameters(parameterMetadata);
+            configuration.setSourceEncoding(encoding);
+            configuration.setScriptBaseClass(scriptBaseClass);
+
+            // joint compilation parameters
+            if (jointCompilation) {
+                Map<String, Object> compilerOptions = new HashMap<String, Object>();
+                compilerOptions.put("namedValues", javacOptionsList());
+                compilerOptions.put("flags", flagsWithParameterMetaData());
+                configuration.setJointCompilationOptions(compilerOptions);
+            }
+
+            if (indy) {
+                configuration.getOptimizationOptions().put("int", false);
+                configuration.getOptimizationOptions().put("indy", true);
+            }
+
+            String configScripts = System.getProperty("groovy.starter.configscripts", null);
+            if (configScript != null || (configScripts != null && !configScripts.isEmpty())) {
+                List<String> scripts = new ArrayList<String>();
+                if (configScript != null) {
+                    scripts.add(configScript);
+                }
+                if (configScripts != null) {
+                    scripts.addAll(StringGroovyMethods.tokenize((CharSequence) configScripts, ','));
+                }
+                processConfigScripts(scripts, configuration);
             }
-            compilerOptions.put("flags", flags);
 
-            configuration.setJointCompilationOptions(compilerOptions);
+            return configuration;
         }
 
-        if (cli.hasOption("indy")) {
-            configuration.getOptimizationOptions().put("int", false);
-            configuration.getOptimizationOptions().put("indy", true);
+        public String[] generateFileNames() {
+            return generateFileNamesFromOptions(files);
         }
 
-        String configScripts = System.getProperty("groovy.starter.configscripts", null);
-        if (cli.hasOption("configscript") || (configScripts != null && !configScripts.isEmpty())) {
-            List<String> scripts = new ArrayList<String>();
-            if (cli.hasOption("configscript")) {
-                scripts.add(cli.getOptionValue("configscript"));
+        String[] javacOptionsList() {
+            if (javacOptionsMap == null) {
+                return null;
             }
-            if (configScripts != null) {
-                scripts.addAll(StringGroovyMethods.tokenize((CharSequence) configScripts, ','));
+            List<String> result = new ArrayList<String>();
+            for (Map.Entry<String, String> entry : javacOptionsMap.entrySet()) {
+                result.add(entry.getKey());
+                result.add(entry.getValue());
             }
-            processConfigScripts(scripts, configuration);
+            return result.toArray(new String[0]);
         }
 
-        return configuration;
-    }
-
-    @SuppressWarnings({"AccessStaticViaInstance"})
-    public static Options createCompilationOptions() {
-        Options options = new Options();
-        options.addOption(Option.builder("classpath").hasArg().argName("path").desc("Specify where to find the class files - must be first argument").build());
-        options.addOption(Option.builder("cp").longOpt("classpath").hasArg().argName("path").desc("Aliases for '-classpath'").build());
-        options.addOption(Option.builder().longOpt("sourcepath").hasArg().argName("path").desc("Specify where to find the source files").build());
-        options.addOption(Option.builder().longOpt("temp").hasArg().argName("temp").desc("Specify temporary directory").build());
-        options.addOption(Option.builder().longOpt("encoding").hasArg().argName("encoding").desc("Specify the encoding of the user class files").build());
-        options.addOption(Option.builder("d").hasArg().desc("Specify where to place generated class files").build());
-        options.addOption(Option.builder("h").longOpt("help").desc("Print a synopsis of standard options").build());
-        options.addOption(Option.builder("v").longOpt("version").desc("Print the version").build());
-        options.addOption(Option.builder("e").longOpt("exception").desc("Print stack trace on error").build());
-        options.addOption(Option.builder("pa").longOpt("parameters").desc("Generate metadata for reflection on method parameter names (jdk8+ only)").build());
-        options.addOption(Option.builder("j").longOpt("jointCompilation").desc("Attach javac compiler to compile .java files").build());
-        options.addOption(Option.builder("b").longOpt("basescript").hasArg().argName("class").desc("Base class name for scripts (must derive from Script)").build());
-        options.addOption(
-                Option.builder("J").argName("property=value")
-                        .valueSeparator()
-                        .numberOfArgs(2)
-                        .desc("Name-value pairs to pass to javac")
-                        .build());
-        options.addOption(
-                Option.builder("F").argName("flag")
-                        .hasArg()
-                        .desc("Passed to javac for joint compilation")
-                        .build());
-        options.addOption(Option.builder().longOpt("indy").desc("Enables compilation using invokedynamic").build());
-        options.addOption(Option.builder().longOpt("configscript").hasArg().desc("A script for tweaking the configuration options").build());
-        return options;
+        String[] flagsWithParameterMetaData() {
+            if (flags == null) {
+                return null;
+            }
+            if (parameterMetadata) {
+                flags.add("parameters");
+            }
+            return flags.toArray(new String[0]);
+        }
     }
 
     /**
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
index eae75e3e87..7a60ac8e9a 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
@@ -20,10 +20,6 @@ package org.codehaus.groovy.ant;
 
 import groovy.lang.GroovyClassLoader;
 import groovy.lang.GroovyResourceLoader;
-import org.apache.commons.cli.CommandLine;
-import org.apache.commons.cli.CommandLineParser;
-import org.apache.commons.cli.DefaultParser;
-import org.apache.commons.cli.Options;
 import org.apache.groovy.io.StringBuilderWriter;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
@@ -45,6 +41,7 @@ import org.codehaus.groovy.tools.ErrorReporter;
 import org.codehaus.groovy.tools.FileSystemCompiler;
 import org.codehaus.groovy.tools.RootLoader;
 import org.codehaus.groovy.tools.javac.JavaAwareCompilationUnit;
+import picocli.CommandLine;
 
 import java.io.File;
 import java.io.FileWriter;
@@ -1182,14 +1179,10 @@ public class Groovyc extends MatchingTask {
     private void runCompiler(String[] commandLine) {
         // hand crank it so we can add our own compiler configuration
         try {
-            Options options = FileSystemCompiler.createCompilationOptions();
-
-            CommandLineParser cliParser = new DefaultParser();
-
-            CommandLine cli;
-            cli = cliParser.parse(options, commandLine);
-
-            configuration = FileSystemCompiler.generateCompilerConfigurationFromOptions(cli);
+            FileSystemCompiler.CompilationOptions options = new FileSystemCompiler.CompilationOptions();
+            CommandLine parser = FileSystemCompiler.configureParser(options);
+            parser.parseArgs(commandLine);
+            configuration = options.toCompilerConfiguration();
             configuration.setScriptExtensions(getScriptExtensions());
             String tmpExtension = getScriptExtension();
             if (tmpExtension.startsWith("*."))
@@ -1197,7 +1190,7 @@ public class Groovyc extends MatchingTask {
             configuration.setDefaultScriptExtension(tmpExtension);
 
             // Load the file name list
-            String[] filenames = FileSystemCompiler.generateFileNamesFromOptions(cli);
+            String[] filenames = options.generateFileNames();
             boolean fileNameErrors = filenames == null;
 
             fileNameErrors = fileNameErrors || !FileSystemCompiler.validateFiles(filenames);

Commit:
8c45479655a0795267ff983ea44f100ae79941e5
sunlan
sunlan@apache.org
2018-05-16 07:49:44 +0800
Revert "GROOVY-8355: Instanceof inference does not work on field assigning(closes #706)" for the time being
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 61e239cdfc..b717c42e99 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -670,15 +670,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         rType = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
         if (receiver instanceof VariableExpression && rType == null) {
             // TODO: can STCV be made smarter to avoid this check?
-            Variable accessedVariable = ((VariableExpression)receiver).getAccessedVariable();
-            VariableExpression ve;
-            if (accessedVariable instanceof FieldNode) {
-                FieldNode fieldNode = (FieldNode) accessedVariable;
-                rType = getInferredTypeOfField(fieldNode);
-            } else {
-                ve = (VariableExpression) accessedVariable;
-                rType = ve.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
-            }
+            VariableExpression ve = (VariableExpression) ((VariableExpression)receiver).getAccessedVariable();
+            rType = ve.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
         }
         if (rType!=null && trySubscript(receiver, message, arguments, rType, aType, safe)) {
             return;
@@ -691,22 +684,6 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
                 "this error and file a bug report at https://issues.apache.org/jira/browse/GROOVY");
     }
 
-    private ClassNode getInferredTypeOfField(FieldNode fieldNode) {
-        ClassNode rType = null;
-
-        Map nodeMetaData = fieldNode.getNodeMetaData(controller.getMethodNode());
-        if (null != nodeMetaData) {
-            rType = (ClassNode) nodeMetaData.get(StaticTypesMarker.INFERRED_TYPE);
-//            if (null == rType) {
-//                nodeMetaData = fieldNode.getNodeMetaData(controller.getClassNode());
-//                if (null != nodeMetaData) {
-//                    rType = (ClassNode) nodeMetaData.get(StaticTypesMarker.INFERRED_TYPE);
-//                }
-//            }
-        }
-        return rType;
-    }
-
     private boolean trySubscript(final Expression receiver, final String message, final Expression arguments, ClassNode rType, final ClassNode aType, boolean safe) {
         if (getWrapper(rType).isDerivedFrom(Number_TYPE)
                 && getWrapper(aType).isDerivedFrom(Number_TYPE)) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 51d15f7ed0..5f9e1cb0d8 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -595,7 +595,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
         } else if (accessedVariable instanceof FieldNode) {
             FieldNode fieldNode = (FieldNode) accessedVariable;
-            FieldVariableExpression fieldVariableExpression = new FieldVariableExpression(fieldNode);
 
             ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
             if (null != parameterizedType) {
@@ -603,7 +602,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 ClassNode actualType = findActualTypeByPlaceholderName(originalType.getUnresolvedName(), GenericsUtils.extractPlaceholders(parameterizedType));
 
                 if (null != actualType) {
-                    fieldVariableExpression.storeInferredType(actualType);
                     storeType(vexp, actualType);
                     return;
                 }
@@ -847,13 +845,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                 // if right expression is a ClosureExpression, store parameter type information
                 if (leftExpression instanceof VariableExpression) {
-                    VariableExpression variableExpression = (VariableExpression) leftExpression;
-
-                    final Variable accessedVariable = variableExpression.getAccessedVariable();
-                    if (accessedVariable instanceof FieldNode) {
-                        new FieldVariableExpression((FieldNode) accessedVariable).storeInferredType(resultType);
-                    }
-
                     if (rightExpression instanceof ClosureExpression) {
                         Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();
                         leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);
@@ -1760,8 +1751,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (init instanceof ConstructorCallExpression) {
                     inferDiamondType((ConstructorCallExpression) init, node.getOriginType());
                 }
-
-//                new FieldVariableExpression(node).storeInferredType(getType(init));
             }
         } finally {
             currentField = null;
@@ -4539,15 +4528,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (cn != null) {
             return cn;
         }
-
-        if (exp instanceof FieldNode) {
-            ClassNode inferredType = new FieldVariableExpression((FieldNode) exp).getInferredType();
-
-            if (null != inferredType) {
-                return inferredType;
-            }
-        }
-
         if (exp instanceof ClassExpression) {
             ClassNode node = CLASS_Type.getPlainNodeReference();
             node.setGenericsTypes(new GenericsType[]{
@@ -5485,78 +5465,4 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return parameter.equals(other);
         }
     }
-
-    private class FieldVariableExpression extends VariableExpression {
-        private final FieldNode fieldNode;
-
-        FieldVariableExpression(FieldNode fieldNode) {
-            super(fieldNode);
-            this.fieldNode = fieldNode;
-
-            ClassNode inferred = getInferredType();
-            if (inferred == null) {
-                storeInferredType(fieldNode.getOriginType());
-            }
-        }
-
-        @Override
-        public ListHashMap getMetaDataMap() {
-            AnnotatedNode node = getKey();
-
-            return getMetaDataMap(node);
-        }
-
-        private ListHashMap getMetaDataMap(AnnotatedNode key) {
-            if (null == key) {
-                return new ListHashMap(); // all valid cases should have a methodNode as key. return a empty map is just to avoid NPE, the map will be abandoned finally
-            }
-
-            ListHashMap metaDataMap = fieldNode.getNodeMetaData(key);
-
-            if (null == metaDataMap) {
-                metaDataMap = new ListHashMap();
-                fieldNode.putNodeMetaData(key, metaDataMap);
-            }
-
-            return metaDataMap;
-        }
-
-        @Override
-        public int hashCode() {
-            return fieldNode.hashCode();
-        }
-
-        @Override
-        public boolean equals(Object other) {
-            return fieldNode.equals(other);
-        }
-
-        @SuppressWarnings("unchecked")
-        private ClassNode getInferredType() {
-            Map<Object, Object> enclosingMetaData = getMetaDataMap();
-
-            ClassNode inferredType = (ClassNode) enclosingMetaData.get(StaticTypesMarker.INFERRED_TYPE);
-
-            return inferredType;
-//            return null == inferredType ? (ClassNode) getMetaDataMap(getDefaultKey()).get(StaticTypesMarker.INFERRED_TYPE) : inferredType;
-        }
-
-        @SuppressWarnings("unchecked")
-        private void storeInferredType(ClassNode inferredType) {
-            Map<Object, Object> enclosingMetaData = getMetaDataMap();
-
-            enclosingMetaData.put(StaticTypesMarker.INFERRED_TYPE, inferredType);
-        }
-
-        private AnnotatedNode getKey() {
-            AnnotatedNode node = typeCheckingContext.getEnclosingMethod();
-
-            return node;
-//            return null == node ? getDefaultKey() : node;
-        }
-
-//        private ClassNode getDefaultKey() {
-//            return typeCheckingContext.getEnclosingClassNode();
-//        }
-    }
 }
diff --git a/src/spec/test/typing/TypeCheckingTest.groovy b/src/spec/test/typing/TypeCheckingTest.groovy
index 6574c3757d..fc87413438 100644
--- a/src/spec/test/typing/TypeCheckingTest.groovy
+++ b/src/spec/test/typing/TypeCheckingTest.groovy
@@ -518,7 +518,6 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
 
     }
 
-    /*
     void testTypeInferenceFieldVsLocalVariable() {
         shouldFailWithMessages '''
             // tag::typeinference_field_vs_local_variable[]
@@ -545,7 +544,6 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
             SomeClass
         ''', 'Cannot find matching method java.lang.Object#toUpperCase()'
     }
-    */
 
     void testLeastUpperBound() {
         assertScript '''import org.codehaus.groovy.ast.ClassHelper
diff --git a/src/test/groovy/bugs/Groovy8355Bug.groovy b/src/test/groovy/bugs/Groovy8355Bug.groovy
deleted file mode 100644
index b5122497c4..0000000000
--- a/src/test/groovy/bugs/Groovy8355Bug.groovy
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-
-
-
-
-package groovy.bugs
-
-class Groovy8355Bug extends GroovyTestCase {
-    void testGroovy8355() {
-        assertScript '''
-        import groovy.transform.CompileStatic
-        
-        @CompileStatic
-        class Foo {
-            Object str = new Object()
-            def bar() {
-                str = "str"
-                str.toUpperCase()
-            }
-        }
-        
-        assert "STR" == new Foo().bar()
-        '''
-    }
-
-    void test2() {
-        assertScript '''
-        import groovy.transform.CompileStatic
-        
-        @CompileStatic
-        class Foo {
-            Object str = new Object()
-            def bar() {
-                str = "str"
-                str.toUpperCase()
-            }
-            
-            def bar2() {
-                str = 1
-                str + 2
-            }
-        }
-        
-        Foo foo = new Foo()
-        assert "STR" == foo.bar()
-        assert 3 == foo.bar2()
-        '''
-    }
-
-    void testTypeInferenceFieldVsLocalVariable() {
-        assertScript '''
-            // tag::typeinference_field_vs_local_variable[]
-            class SomeClass {
-                def someUntypedField                                                                // <1>
-                String someTypedField                                                               // <2>
-
-                void someMethod() {
-                    someUntypedField = '123'                                                        // <3>
-                    someUntypedField = someUntypedField.toUpperCase()  // compile-time error        // <4>
-                }
-
-                void someSafeMethod() {
-                    someTypedField = '123'                                                          // <5>
-                    someTypedField = someTypedField.toUpperCase()                                   // <6>
-                }
-
-                void someMethodUsingLocalVariable() {
-                    def localVariable = '123'                                                       // <7>
-                    someUntypedField = localVariable.toUpperCase()                                  // <8>
-                }
-            }
-            // end::typeinference_field_vs_local_variable[]
-            SomeClass
-        '''
-    }
-
-    /*
-    void test3() {
-        assertScript '''
-        import groovy.transform.CompileStatic
-        
-        @CompileStatic
-        class Foo {
-            Object str = "str"
-            def bar() {
-                str.toUpperCase()
-            }
-        }
-        
-        assert "STR" == new Foo().bar()
-        '''
-    }
-    */
-}

Commit:
b1cc8a6ae14f15ad5a413f68fa946ecbeafe877e
sunlan
sunlan@apache.org
2018-05-15 23:41:22 +0800
GROOVY-5912: Static compilation: Groovy doesn't fail compilation when accessing package scope methods, but fails at runtime
diff --git a/src/main/java/org/codehaus/groovy/ast/MethodNode.java b/src/main/java/org/codehaus/groovy/ast/MethodNode.java
index 902502e54c..7134b860e7 100644
--- a/src/main/java/org/codehaus/groovy/ast/MethodNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/MethodNode.java
@@ -169,6 +169,10 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
         return (modifiers & ACC_PROTECTED) != 0;
     }
 
+    public boolean isPackageScope() {
+        return !(this.isPrivate() || this.isProtected() || this.isPublic());
+    }
+
     public boolean hasDefaultValue() {
         return this.hasDefaultValue;
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 490d924687..51d15f7ed0 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4483,6 +4483,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (methodNode.isProtected() && !enclosingClassNode.isDerivedFrom(declaringClass)) {
                 continue;
             }
+            if (methodNode.isPackageScope() && !getPackageName(enclosingClassNode).equals(getPackageName(declaringClass))) {
+                continue;
+            }
 
             result.add(methodNode);
         }
@@ -4490,6 +4493,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return result;
     }
 
+    private static String getPackageName(ClassNode cn) {
+        String name = cn.getPackageName();
+
+        return null == name ? "" : name;
+    }
+
     /**
      * Given a method name and a prefix, returns the name of the property that should be looked up,
      * following the java beans rules. For example, "getName" would return "name", while
diff --git a/src/test/groovy/bugs/groovy5912/PluginPathAwareFileSystemResourceLoader.java b/src/test/groovy/bugs/groovy5912/PluginPathAwareFileSystemResourceLoader.java
new file mode 100644
index 0000000000..33a18f2f61
--- /dev/null
+++ b/src/test/groovy/bugs/groovy5912/PluginPathAwareFileSystemResourceLoader.java
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy.bugs.groovy5912;
+
+import java.util.Collection;
+
+public class PluginPathAwareFileSystemResourceLoader {
+    void setSearchLocations(Collection c) {}
+}
diff --git a/src/test/groovy/bugs/groovy5912/otherpkg/Groovy5912Bug.groovy b/src/test/groovy/bugs/groovy5912/otherpkg/Groovy5912Bug.groovy
new file mode 100644
index 0000000000..b1fd605d6a
--- /dev/null
+++ b/src/test/groovy/bugs/groovy5912/otherpkg/Groovy5912Bug.groovy
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs.groovy5912.otherpkg
+
+class Groovy5912Bug extends GroovyTestCase {
+    void test() {
+        def errMsg = shouldFail '''
+        package groovy.bugs.groovy5912.otherpkg
+        
+        import groovy.bugs.groovy5912.PluginPathAwareFileSystemResourceLoader
+        
+        @groovy.transform.CompileStatic
+        class GrailsProjectLoader {
+            def access() {
+                new PluginPathAwareFileSystemResourceLoader().setSearchLocations(null)
+            }
+        }
+        
+        new GrailsProjectLoader().access()
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method groovy.bugs.groovy5912.PluginPathAwareFileSystemResourceLoader#setSearchLocations')
+    }
+}

Commit:
3dd14f618c4c3ce9588cacf535c48a0b7163c810
sunlan
sunlan@apache.org
2018-05-15 22:44:17 +0800
Add a test for "GROOVY-6938: Wrong error reported by @CompileStatic when overriding a method returning a parameterized value"
diff --git a/src/test/groovy/bugs/groovy6938/Groovy6938Bug.groovy b/src/test/groovy/bugs/groovy6938/Groovy6938Bug.groovy
new file mode 100644
index 0000000000..8b6a6d0a50
--- /dev/null
+++ b/src/test/groovy/bugs/groovy6938/Groovy6938Bug.groovy
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy.bugs.groovy6938
+
+class Groovy6938Bug extends GroovyTestCase {
+    void test() {
+        assert null == new L().doSomething()
+    }
+}
diff --git a/src/test/groovy/bugs/groovy6938/L.groovy b/src/test/groovy/bugs/groovy6938/L.groovy
new file mode 100644
index 0000000000..5d80b72aef
--- /dev/null
+++ b/src/test/groovy/bugs/groovy6938/L.groovy
@@ -0,0 +1,29 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy.bugs.groovy6938
+
+import groovy.transform.CompileStatic;
+
+@CompileStatic
+class L extends LJava<Integer> {
+    Integer doSomething() {
+        super.doSomething()
+    }
+}
diff --git a/src/test/groovy/bugs/groovy6938/LJava.java b/src/test/groovy/bugs/groovy6938/LJava.java
new file mode 100644
index 0000000000..90715b158f
--- /dev/null
+++ b/src/test/groovy/bugs/groovy6938/LJava.java
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy.bugs.groovy6938;
+
+public class LJava <T extends Number> {
+    public T doSomething() {
+        return null;
+    }
+}
\ No newline at end of file

Commit:
5df88c8f05242e828038652b0f6f762fe9b84840
sunlan
sunlan@apache.org
2018-05-15 21:59:00 +0800
GROOVY-8355: Instanceof inference does not work on field assigning(closes #706)
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index b717c42e99..61e239cdfc 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -670,8 +670,15 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         rType = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
         if (receiver instanceof VariableExpression && rType == null) {
             // TODO: can STCV be made smarter to avoid this check?
-            VariableExpression ve = (VariableExpression) ((VariableExpression)receiver).getAccessedVariable();
-            rType = ve.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+            Variable accessedVariable = ((VariableExpression)receiver).getAccessedVariable();
+            VariableExpression ve;
+            if (accessedVariable instanceof FieldNode) {
+                FieldNode fieldNode = (FieldNode) accessedVariable;
+                rType = getInferredTypeOfField(fieldNode);
+            } else {
+                ve = (VariableExpression) accessedVariable;
+                rType = ve.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+            }
         }
         if (rType!=null && trySubscript(receiver, message, arguments, rType, aType, safe)) {
             return;
@@ -684,6 +691,22 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
                 "this error and file a bug report at https://issues.apache.org/jira/browse/GROOVY");
     }
 
+    private ClassNode getInferredTypeOfField(FieldNode fieldNode) {
+        ClassNode rType = null;
+
+        Map nodeMetaData = fieldNode.getNodeMetaData(controller.getMethodNode());
+        if (null != nodeMetaData) {
+            rType = (ClassNode) nodeMetaData.get(StaticTypesMarker.INFERRED_TYPE);
+//            if (null == rType) {
+//                nodeMetaData = fieldNode.getNodeMetaData(controller.getClassNode());
+//                if (null != nodeMetaData) {
+//                    rType = (ClassNode) nodeMetaData.get(StaticTypesMarker.INFERRED_TYPE);
+//                }
+//            }
+        }
+        return rType;
+    }
+
     private boolean trySubscript(final Expression receiver, final String message, final Expression arguments, ClassNode rType, final ClassNode aType, boolean safe) {
         if (getWrapper(rType).isDerivedFrom(Number_TYPE)
                 && getWrapper(aType).isDerivedFrom(Number_TYPE)) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 0ab1ac596a..490d924687 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -595,6 +595,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
         } else if (accessedVariable instanceof FieldNode) {
             FieldNode fieldNode = (FieldNode) accessedVariable;
+            FieldVariableExpression fieldVariableExpression = new FieldVariableExpression(fieldNode);
 
             ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
             if (null != parameterizedType) {
@@ -602,6 +603,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 ClassNode actualType = findActualTypeByPlaceholderName(originalType.getUnresolvedName(), GenericsUtils.extractPlaceholders(parameterizedType));
 
                 if (null != actualType) {
+                    fieldVariableExpression.storeInferredType(actualType);
                     storeType(vexp, actualType);
                     return;
                 }
@@ -845,6 +847,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                 // if right expression is a ClosureExpression, store parameter type information
                 if (leftExpression instanceof VariableExpression) {
+                    VariableExpression variableExpression = (VariableExpression) leftExpression;
+
+                    final Variable accessedVariable = variableExpression.getAccessedVariable();
+                    if (accessedVariable instanceof FieldNode) {
+                        new FieldVariableExpression((FieldNode) accessedVariable).storeInferredType(resultType);
+                    }
+
                     if (rightExpression instanceof ClosureExpression) {
                         Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();
                         leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);
@@ -1751,6 +1760,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (init instanceof ConstructorCallExpression) {
                     inferDiamondType((ConstructorCallExpression) init, node.getOriginType());
                 }
+
+//                new FieldVariableExpression(node).storeInferredType(getType(init));
             }
         } finally {
             currentField = null;
@@ -4519,6 +4530,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (cn != null) {
             return cn;
         }
+
+        if (exp instanceof FieldNode) {
+            ClassNode inferredType = new FieldVariableExpression((FieldNode) exp).getInferredType();
+
+            if (null != inferredType) {
+                return inferredType;
+            }
+        }
+
         if (exp instanceof ClassExpression) {
             ClassNode node = CLASS_Type.getPlainNodeReference();
             node.setGenericsTypes(new GenericsType[]{
@@ -5457,4 +5477,77 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private class FieldVariableExpression extends VariableExpression {
+        private final FieldNode fieldNode;
+
+        FieldVariableExpression(FieldNode fieldNode) {
+            super(fieldNode);
+            this.fieldNode = fieldNode;
+
+            ClassNode inferred = getInferredType();
+            if (inferred == null) {
+                storeInferredType(fieldNode.getOriginType());
+            }
+        }
+
+        @Override
+        public ListHashMap getMetaDataMap() {
+            AnnotatedNode node = getKey();
+
+            return getMetaDataMap(node);
+        }
+
+        private ListHashMap getMetaDataMap(AnnotatedNode key) {
+            if (null == key) {
+                return new ListHashMap(); // all valid cases should have a methodNode as key. return a empty map is just to avoid NPE, the map will be abandoned finally
+            }
+
+            ListHashMap metaDataMap = fieldNode.getNodeMetaData(key);
+
+            if (null == metaDataMap) {
+                metaDataMap = new ListHashMap();
+                fieldNode.putNodeMetaData(key, metaDataMap);
+            }
+
+            return metaDataMap;
+        }
+
+        @Override
+        public int hashCode() {
+            return fieldNode.hashCode();
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return fieldNode.equals(other);
+        }
+
+        @SuppressWarnings("unchecked")
+        private ClassNode getInferredType() {
+            Map<Object, Object> enclosingMetaData = getMetaDataMap();
+
+            ClassNode inferredType = (ClassNode) enclosingMetaData.get(StaticTypesMarker.INFERRED_TYPE);
+
+            return inferredType;
+//            return null == inferredType ? (ClassNode) getMetaDataMap(getDefaultKey()).get(StaticTypesMarker.INFERRED_TYPE) : inferredType;
+        }
+
+        @SuppressWarnings("unchecked")
+        private void storeInferredType(ClassNode inferredType) {
+            Map<Object, Object> enclosingMetaData = getMetaDataMap();
+
+            enclosingMetaData.put(StaticTypesMarker.INFERRED_TYPE, inferredType);
+        }
+
+        private AnnotatedNode getKey() {
+            AnnotatedNode node = typeCheckingContext.getEnclosingMethod();
+
+            return node;
+//            return null == node ? getDefaultKey() : node;
+        }
+
+//        private ClassNode getDefaultKey() {
+//            return typeCheckingContext.getEnclosingClassNode();
+//        }
+    }
 }
diff --git a/src/spec/test/typing/TypeCheckingTest.groovy b/src/spec/test/typing/TypeCheckingTest.groovy
index fc87413438..6574c3757d 100644
--- a/src/spec/test/typing/TypeCheckingTest.groovy
+++ b/src/spec/test/typing/TypeCheckingTest.groovy
@@ -518,6 +518,7 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
 
     }
 
+    /*
     void testTypeInferenceFieldVsLocalVariable() {
         shouldFailWithMessages '''
             // tag::typeinference_field_vs_local_variable[]
@@ -544,6 +545,7 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
             SomeClass
         ''', 'Cannot find matching method java.lang.Object#toUpperCase()'
     }
+    */
 
     void testLeastUpperBound() {
         assertScript '''import org.codehaus.groovy.ast.ClassHelper
diff --git a/src/test/groovy/bugs/Groovy8355Bug.groovy b/src/test/groovy/bugs/Groovy8355Bug.groovy
new file mode 100644
index 0000000000..b5122497c4
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8355Bug.groovy
@@ -0,0 +1,112 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+
+
+
+package groovy.bugs
+
+class Groovy8355Bug extends GroovyTestCase {
+    void testGroovy8355() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        
+        @CompileStatic
+        class Foo {
+            Object str = new Object()
+            def bar() {
+                str = "str"
+                str.toUpperCase()
+            }
+        }
+        
+        assert "STR" == new Foo().bar()
+        '''
+    }
+
+    void test2() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        
+        @CompileStatic
+        class Foo {
+            Object str = new Object()
+            def bar() {
+                str = "str"
+                str.toUpperCase()
+            }
+            
+            def bar2() {
+                str = 1
+                str + 2
+            }
+        }
+        
+        Foo foo = new Foo()
+        assert "STR" == foo.bar()
+        assert 3 == foo.bar2()
+        '''
+    }
+
+    void testTypeInferenceFieldVsLocalVariable() {
+        assertScript '''
+            // tag::typeinference_field_vs_local_variable[]
+            class SomeClass {
+                def someUntypedField                                                                // <1>
+                String someTypedField                                                               // <2>
+
+                void someMethod() {
+                    someUntypedField = '123'                                                        // <3>
+                    someUntypedField = someUntypedField.toUpperCase()  // compile-time error        // <4>
+                }
+
+                void someSafeMethod() {
+                    someTypedField = '123'                                                          // <5>
+                    someTypedField = someTypedField.toUpperCase()                                   // <6>
+                }
+
+                void someMethodUsingLocalVariable() {
+                    def localVariable = '123'                                                       // <7>
+                    someUntypedField = localVariable.toUpperCase()                                  // <8>
+                }
+            }
+            // end::typeinference_field_vs_local_variable[]
+            SomeClass
+        '''
+    }
+
+    /*
+    void test3() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        
+        @CompileStatic
+        class Foo {
+            Object str = "str"
+            def bar() {
+                str.toUpperCase()
+            }
+        }
+        
+        assert "STR" == new Foo().bar()
+        '''
+    }
+    */
+}

Commit:
1f0c0ac6ece046e56c8f8d3aefe09c4ca3c60af4
sunlan
sunlan@apache.org
2018-05-15 12:17:21 +0800
Minor refactoring: check whether visiting return statement
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 72cce39022..0ab1ac596a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1986,22 +1986,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             super.visitConstructorOrMethod(node, isConstructor);
         }
         if (!isConstructor) {
-            returnAdder.visitMethod(node); // return statement added after visitConstructorOrMethod finished... we can not count these auto-generated return statements(GROOVY-7753), see `this.visitingReturnStatementCnt`
+            returnAdder.visitMethod(node); // return statement added after visitConstructorOrMethod finished... we can not count these auto-generated return statements(GROOVY-7753), see `typeCheckingContext.pushEnclosingReturnStatement`
         }
         typeCheckingContext.popEnclosingMethod();
     }
 
-    // GROOVY-7753 return statement added after visitConstructorOrMethod finished... current solution can not solve auto return
-    private int visitingReturnStatementCnt = 0;
-
     @Override
     public void visitReturnStatement(ReturnStatement statement) {
-        visitingReturnStatementCnt++;
+        typeCheckingContext.pushEnclosingReturnStatement(statement);
         try {
             super.visitReturnStatement(statement);
             returnListener.returnStatementAdded(statement);
         } finally {
-            visitingReturnStatementCnt--;
+            typeCheckingContext.popEnclosingReturnStatement();
         }
     }
 
@@ -3245,7 +3242,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, mn.get(0), call)) {
                             returnType = adjustWithTraits(directMethodCallCandidate, chosenReceiver.getType(), args, returnType);
 
-                            if (1 == visitingReturnStatementCnt) { // the method call is within return statement, we can try to infer type further
+                            if (null != typeCheckingContext.getEnclosingReturnStatement()) { // the method call is within return statement, we can try to infer type further
                                 ClassNode inferredType = infer(returnType, typeCheckingContext.getEnclosingMethod().getReturnType());
                                 if (null != inferredType) {
                                     returnType = inferredType;
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java b/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
index 057403fbce..13588d0896 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.ErrorCollector;
 import org.codehaus.groovy.control.SourceUnit;
@@ -54,6 +55,7 @@ public class TypeCheckingContext {
     protected final LinkedList<MethodNode> enclosingMethods = new LinkedList<MethodNode>();
     protected final LinkedList<Expression> enclosingMethodCalls = new LinkedList<Expression>();
     protected final LinkedList<BlockStatement> enclosingBlocks = new LinkedList<BlockStatement>();
+    protected final LinkedList<ReturnStatement> enclosingReturnStatements = new LinkedList<ReturnStatement>();
 
 
     // used for closure return type inference
@@ -216,6 +218,33 @@ public class TypeCheckingContext {
         return enclosingMethods.getFirst();
     }
 
+
+    /**
+     * Pushes a return statement into the return statement stack.
+     * @param returnStatement the return statement to be pushed
+     */
+    public void pushEnclosingReturnStatement(ReturnStatement returnStatement) {
+        enclosingReturnStatements.addFirst(returnStatement);
+    }
+
+    /**
+     * Pops a return statement from the enclosing return statements stack.
+     * @return the popped return statement
+     */
+    public ReturnStatement popEnclosingReturnStatement() {
+        return enclosingReturnStatements.removeFirst();
+    }
+
+    /**
+     * Returns the return statement which is on the top of the stack, or null
+     * if there's no such element.
+     * @return the enclosing return statement on top of the stack, or null if no such element.
+     */
+    public ReturnStatement getEnclosingReturnStatement() {
+        if (enclosingReturnStatements.isEmpty()) return null;
+        return enclosingReturnStatements.getFirst();
+    }
+
     /**
      * Returns the current stack of enclosing methods. The first
      * element is the top of the stack, that is to say the last visited method.

Commit:
71c9616c6fc995e7c99e56b8796fb441ad05e297
Paul King
paulk@asert.com.au
2018-05-14 23:16:02 +1000
remove blank line
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 04d9e99f05..53207c4804 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -44,7 +44,6 @@ import static org.apache.groovy.util.SystemUtil.getSystemPropertySafe;
 /**
  * Compilation control flags and coordination stuff.
  */
-
 public class CompilerConfiguration {
 
     /** This (<code>"indy"</code>) is the Optimization Option value for enabling <code>invokedynamic</code> compilation. */

Commit:
62f877abd28c62e3058a383905bb93624ef36130
Paul King
paulk@asert.com.au
2018-05-14 21:56:22 +1000
minor refactor - no need to loop through array when we have a set of names now
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index e03ea4fe58..04d9e99f05 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -762,10 +762,8 @@ public class CompilerConfiguration {
      * @param version the bytecode compatibility level
      */
     public void setTargetBytecode(String version) {
-        for (String allowedJdk : ALLOWED_JDKS) {
-            if (allowedJdk.equals(version)) {
-                this.targetBytecode = version;
-            }
+        if (JDK_TO_BYTECODE_VERSION_MAP.keySet().contains(version)) {
+            this.targetBytecode = version;
         }
     }
 

Commit:
4439e3a27ccf37c1ed5a03541ca145f12a3dd9d3
sunlan
sunlan@apache.org
2018-05-14 19:17:04 +0800
Refine "GROOVY-7753: regression of return type from ternary operator"
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 865b97f5bd..72cce39022 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3245,7 +3245,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, mn.get(0), call)) {
                             returnType = adjustWithTraits(directMethodCallCandidate, chosenReceiver.getType(), args, returnType);
 
-                            if (visitingReturnStatementCnt > 0) { // the method call is within return statement, we can try to infer type further
+                            if (1 == visitingReturnStatementCnt) { // the method call is within return statement, we can try to infer type further
                                 ClassNode inferredType = infer(returnType, typeCheckingContext.getEnclosingMethod().getReturnType());
                                 if (null != inferredType) {
                                     returnType = inferredType;

Commit:
d88dfe679d1cd958c29acaf64b7d7631c041e194
sunlan
sunlan@apache.org
2018-05-14 18:49:51 +0800
GROOVY-7753: regression of return type from ternary operator
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index e4742869bb..865b97f5bd 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1986,15 +1986,35 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             super.visitConstructorOrMethod(node, isConstructor);
         }
         if (!isConstructor) {
-            returnAdder.visitMethod(node);
+            returnAdder.visitMethod(node); // return statement added after visitConstructorOrMethod finished... we can not count these auto-generated return statements(GROOVY-7753), see `this.visitingReturnStatementCnt`
         }
         typeCheckingContext.popEnclosingMethod();
     }
 
+    // GROOVY-7753 return statement added after visitConstructorOrMethod finished... current solution can not solve auto return
+    private int visitingReturnStatementCnt = 0;
+
     @Override
     public void visitReturnStatement(ReturnStatement statement) {
-        super.visitReturnStatement(statement);
-        returnListener.returnStatementAdded(statement);
+        visitingReturnStatementCnt++;
+        try {
+            super.visitReturnStatement(statement);
+            returnListener.returnStatementAdded(statement);
+        } finally {
+            visitingReturnStatementCnt--;
+        }
+    }
+
+    private ClassNode infer(ClassNode target, ClassNode source) {
+        DeclarationExpression virtualDecl = new DeclarationExpression(
+                varX("{target}", target),
+                Token.newSymbol(EQUAL, -1, -1),
+                varX("{source}", source)
+        );
+        virtualDecl.visit(this);
+        ClassNode newlyInferred = (ClassNode) virtualDecl.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+
+        return !missesGenericsTypes(newlyInferred) ? newlyInferred : null;
     }
 
     protected ClassNode checkReturnType(final ReturnStatement statement) {
@@ -2023,15 +2043,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 ClassNode inferred = previousType == null ? type : lowestUpperBound(type, previousType);
                 if (implementsInterfaceOrIsSubclassOf(inferred, enclosingMethod.getReturnType())) {
                     if (missesGenericsTypes(inferred)) {
-                        DeclarationExpression virtualDecl = new DeclarationExpression(
-                                varX("{target}", enclosingMethod.getReturnType()),
-                                Token.newSymbol(EQUAL, -1, -1),
-                                varX("{source}", type)
-                        );
-                        virtualDecl.setSourcePosition(statement);
-                        virtualDecl.visit(this);
-                        ClassNode newlyInferred = (ClassNode) virtualDecl.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
-                        if (!missesGenericsTypes(newlyInferred)) type = newlyInferred;
+                        ClassNode newlyInferred = infer(enclosingMethod.getReturnType(), type);
+
+                        if (null != newlyInferred) {
+                            type = newlyInferred;
+                        }
                     } else {
                         checkTypeGenerics(enclosingMethod.getReturnType(), inferred, expression);
                     }
@@ -3228,6 +3244,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         }
                         if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, mn.get(0), call)) {
                             returnType = adjustWithTraits(directMethodCallCandidate, chosenReceiver.getType(), args, returnType);
+
+                            if (visitingReturnStatementCnt > 0) { // the method call is within return statement, we can try to infer type further
+                                ClassNode inferredType = infer(returnType, typeCheckingContext.getEnclosingMethod().getReturnType());
+                                if (null != inferredType) {
+                                    returnType = inferredType;
+                                }
+                            }
+
                             storeType(call, returnType);
                             storeTargetMethod(call, directMethodCallCandidate);
                             String data = chosenReceiver.getData();
diff --git a/src/test/groovy/bugs/Groovy7753Bug.groovy b/src/test/groovy/bugs/Groovy7753Bug.groovy
new file mode 100644
index 0000000000..a650444821
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7753Bug.groovy
@@ -0,0 +1,94 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+import groovy.transform.NotYetImplemented
+
+class Groovy7753Bug extends GroovyTestCase {
+    @NotYetImplemented
+    void testGroovy7753() {
+        assertScript '''
+        @groovy.transform.Field
+        String x = "X"
+        
+        @groovy.transform.CompileStatic
+        public List<String> getStrings() {
+            x ? [x] : Collections.emptyList()
+        }
+        
+        getStrings()
+        '''
+    }
+
+    void testGroovy7753WithReturn() {
+        assertScript '''
+        @groovy.transform.Field
+        String x = "X"
+        
+        @groovy.transform.CompileStatic
+        public List<String> getStrings() {
+            return x ? [x] : Collections.emptyList()
+        }
+        
+        getStrings()
+        '''
+    }
+
+    void testGroovy7753WithReturn2() {
+        assertScript '''
+        @groovy.transform.Field
+        String x = "X"
+        
+        @groovy.transform.CompileStatic
+        public List<String> getStrings() {
+            return x ? Collections.emptyList() : [x]
+        }
+        
+        getStrings()
+        '''
+    }
+
+    void test2() {
+        assertScript '''
+        @groovy.transform.Field
+        String x = "X"
+        
+        @groovy.transform.CompileStatic
+        public List<String> getStrings() {
+            Collections.emptyList()
+        }
+        
+        getStrings()
+        '''
+    }
+
+    void test3() {
+        assertScript '''
+        @groovy.transform.Field
+        String x = "X"
+        
+        @groovy.transform.CompileStatic
+        public List<String> getStrings() {
+            [x]
+        }
+        
+        getStrings()
+        '''
+    }
+}

Commit:
3e54b0477b1663a3c72fe0be24f156801bf14603
Paul King
paulk@asert.com.au
2018-05-14 19:48:21 +1000
update outdated comments
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
index 5543a327ec..eae75e3e87 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
@@ -287,10 +287,10 @@ public class Groovyc extends MatchingTask {
     }
 
     /**
-     * Sets the bytecode compatibility mode. The parameter can take
-     * one of the values <tt>1.8</tt>, <tt>1.7</tt>, <tt>1.6</tt>, <tt>1.5</tt> or <tt>1.4</tt>.
+     * Sets the bytecode compatibility level.
+     * The parameter can take one of the values in {@link CompilerConfiguration#ALLOWED_JDKS}.
      *
-     * @param version the bytecode compatibility mode
+     * @param version the bytecode compatibility level
      */
     public void setTargetBytecode(String version) {
 
@@ -303,11 +303,9 @@ public class Groovyc extends MatchingTask {
     }
 
     /**
-     * Retrieves the compiler bytecode compatibility mode.
+     * Retrieves the compiler bytecode compatibility level.
      *
-     * @return bytecode compatibility mode. Can be one of the values
-     * <tt>1.8</tt>, <tt>1.7</tt>, <tt>1.6</tt>, <tt>1.5</tt> or
-     * <tt>1.4</tt>.
+     * @return bytecode compatibility level. Can be one of the values in {@link CompilerConfiguration#ALLOWED_JDKS}.
      */
     public String getTargetBytecode() {
         return this.targetBytecode;

Commit:
b8b5bd567410203b4bb9f86f3d5f54668e1c3a90
sunlan
sunlan@apache.org
2018-05-14 00:00:34 +0800
Minor refactoring: reuse `findActualTypeByPlaceholderName`
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 3ea9764389..316953becd 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1189,14 +1189,10 @@ public abstract class StaticTypeCheckingSupport {
         return isExtensionMethodNode ? 0 : 1;
     }
 
-    private static ClassNode findGenericsTypeByPlaceholderName(String placeholderName, Map<String, GenericsType> placeholderInfo) {
-        for (Map.Entry<String, GenericsType> entry : placeholderInfo.entrySet()) {
-            if (placeholderName.equals(entry.getKey())) {
-                return entry.getValue().getType();
-            }
-        }
+    public static ClassNode findActualTypeByPlaceholderName(String placeholderName, Map<String, GenericsType> placeholderInfo) {
+        GenericsType gt = placeholderInfo.get(placeholderName);
 
-        return null;
+        return null == gt ? null : gt.getType().redirect();
     }
 
     private static Parameter[] makeRawTypes(Parameter[] params, ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
@@ -1206,7 +1202,7 @@ public abstract class StaticTypeCheckingSupport {
         for (int i = 0; i < params.length; i++) {
             Parameter oldP = params[i];
 
-            ClassNode actualType = findGenericsTypeByPlaceholderName(oldP.getType().getUnresolvedName(), placeholderInfo);
+            ClassNode actualType = findActualTypeByPlaceholderName(oldP.getType().getUnresolvedName(), placeholderInfo);
             Parameter newP = new Parameter(makeRawType(null == actualType ? oldP.getType() : actualType), oldP.getName());
             newParam[i] = newP;
         }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 34b95df456..e4742869bb 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -217,6 +217,7 @@ import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.choose
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.evaluateExpression;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsParameterMapOfThis;
+import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findActualTypeByPlaceholderName;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findSetters;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findTargetVariable;
@@ -598,11 +599,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
             if (null != parameterizedType) {
                 ClassNode originalType = fieldNode.getOriginType();
-                GenericsType gt = GenericsUtils.extractPlaceholders(parameterizedType).get(originalType.getUnresolvedName());
+                ClassNode actualType = findActualTypeByPlaceholderName(originalType.getUnresolvedName(), GenericsUtils.extractPlaceholders(parameterizedType));
 
-                if (null != gt) {
-                    ClassNode redirect = gt.getType().redirect();
-                    storeType(vexp, redirect);
+                if (null != actualType) {
+                    storeType(vexp, actualType);
                     return;
                 }
             }

Commit:
009c42c1e73d1dfa4e6f977b857414c9c1789e66
sunlan
sunlan@apache.org
2018-05-13 23:22:46 +0800
Refine "GROOVY-7691: Type checking error on generic property with covariant type in subclass"
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5638906f7a..34b95df456 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -573,7 +573,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         if (storeTypeForThis(vexp)) return;
         if (storeTypeForSuper(vexp)) return;
-        if (vexp.getAccessedVariable() instanceof PropertyNode) {
+        final Variable accessedVariable = vexp.getAccessedVariable();
+        if (accessedVariable instanceof PropertyNode) {
             // we must be careful, because the property node may be of a wrong type:
             // if a class contains a getter and a setter of different types or
             // overloaded setters, the type of the property node is arbitrary!
@@ -591,6 +592,20 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                 }
             }
+        } else if (accessedVariable instanceof FieldNode) {
+            FieldNode fieldNode = (FieldNode) accessedVariable;
+
+            ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
+            if (null != parameterizedType) {
+                ClassNode originalType = fieldNode.getOriginType();
+                GenericsType gt = GenericsUtils.extractPlaceholders(parameterizedType).get(originalType.getUnresolvedName());
+
+                if (null != gt) {
+                    ClassNode redirect = gt.getType().redirect();
+                    storeType(vexp, redirect);
+                    return;
+                }
+            }
         }
 
         TypeCheckingContext.EnclosingClosure enclosingClosure = typeCheckingContext.getEnclosingClosure();
@@ -608,14 +623,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
         }
 
-        if (!(vexp.getAccessedVariable() instanceof DynamicVariable)) {
+        if (!(accessedVariable instanceof DynamicVariable)) {
             if (typeCheckingContext.getEnclosingClosure() == null) {
                 VariableExpression variable = null;
-                if (vexp.getAccessedVariable() instanceof Parameter) {
-                    variable = new ParameterVariableExpression((Parameter) vexp.getAccessedVariable());
-                } else if (vexp.getAccessedVariable() instanceof VariableExpression) {
-                    variable = (VariableExpression) vexp.getAccessedVariable();
+                if (accessedVariable instanceof Parameter) {
+                    variable = new ParameterVariableExpression((Parameter) accessedVariable);
+                } else if (accessedVariable instanceof VariableExpression) {
+                    variable = (VariableExpression) accessedVariable;
                 }
+
                 if (variable != null) {
                     ClassNode inferredType = getInferredTypeFromTempInfo(variable, variable.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE));
                     // instanceof applies, stash away the type, reusing key used elsewhere
@@ -629,7 +645,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // a dynamic variable is either an undeclared variable
         // or a member of a class used in a 'with'
-        DynamicVariable dyn = (DynamicVariable) vexp.getAccessedVariable();
+        DynamicVariable dyn = (DynamicVariable) accessedVariable;
         // first, we must check the 'with' context
         String dynName = dyn.getName();
         if (tryVariableExpressionAsProperty(vexp, dynName)) return;
@@ -4500,17 +4516,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 FieldNode fieldNode = (FieldNode) variable;
 
                 checkOrMarkPrivateAccess(vexp, fieldNode, isLHSOfEnclosingAssignment(vexp));
-                ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
-
-                if (null != parameterizedType) {
-                    ClassNode originalType = fieldNode.getOriginType();
-                    GenericsType gt = GenericsUtils.extractPlaceholders(parameterizedType).get(originalType.getUnresolvedName());
-
-                    if (null != gt) {
-                        return gt.getType().redirect();
-                    }
-                }
-
                 return getType(fieldNode);
             }
             if (variable != null && variable != vexp && variable instanceof VariableExpression) {
@@ -5368,6 +5373,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+
     /**
      * Wrapper for a Parameter so it can be treated like a VariableExpression
      * and tracked in the ifElseForWhileAssignmentTracker.
@@ -5429,4 +5435,5 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return parameter.equals(other);
         }
     }
+
 }

Commit:
67675780a258aa27c62ce29dcbda7683502e6a67
sunlan
sunlan@apache.org
2018-05-13 21:12:59 +0800
GROOVY-7691: Type checking error on generic property with covariant type in subclass
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index a1a1c7e388..5638906f7a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1984,6 +1984,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected ClassNode checkReturnType(final ReturnStatement statement) {
         Expression expression = statement.getExpression();
         ClassNode type = getType(expression);
+
         if (typeCheckingContext.getEnclosingClosure() != null) {
             return type;
         }
@@ -4496,8 +4497,21 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (vexp == VariableExpression.SUPER_EXPRESSION) return makeSuper();
             final Variable variable = vexp.getAccessedVariable();
             if (variable instanceof FieldNode) {
-                checkOrMarkPrivateAccess(vexp, (FieldNode) variable, isLHSOfEnclosingAssignment(vexp));
-                return getType((FieldNode) variable);
+                FieldNode fieldNode = (FieldNode) variable;
+
+                checkOrMarkPrivateAccess(vexp, fieldNode, isLHSOfEnclosingAssignment(vexp));
+                ClassNode parameterizedType = GenericsUtils.findParameterizedType(fieldNode.getDeclaringClass(), typeCheckingContext.getEnclosingClassNode());
+
+                if (null != parameterizedType) {
+                    ClassNode originalType = fieldNode.getOriginType();
+                    GenericsType gt = GenericsUtils.extractPlaceholders(parameterizedType).get(originalType.getUnresolvedName());
+
+                    if (null != gt) {
+                        return gt.getType().redirect();
+                    }
+                }
+
+                return getType(fieldNode);
             }
             if (variable != null && variable != vexp && variable instanceof VariableExpression) {
                 return getType((Expression) variable);
diff --git a/src/test/groovy/bugs/Groovy7691Bug.groovy b/src/test/groovy/bugs/Groovy7691Bug.groovy
new file mode 100644
index 0000000000..58588b0e92
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7691Bug.groovy
@@ -0,0 +1,97 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy7691Bug extends GroovyTestCase {
+//    @NotYetImplemented
+    void testCovariantGenericField() {
+        assertScript '''
+            @groovy.transform.CompileStatic
+            abstract class AbstractNumberWrapper<S extends Number> {
+                protected final S number;
+
+                AbstractNumberWrapper(S number) {
+                    this.number = number
+                }
+            }
+            @groovy.transform.CompileStatic
+            class LongWrapper<S extends Long> extends AbstractNumberWrapper<S> {
+                LongWrapper(S longNumber) {
+                    super(longNumber)
+                }
+
+                S getValue() {
+                    return number;
+                }
+            }
+            assert new LongWrapper<Long>(42L).value == 42L
+        '''
+    }
+
+    void testCovariantGenericProperty() {
+        assertScript '''
+            @groovy.transform.CompileStatic
+            abstract class AbstractNumberWrapper<S extends Number> {
+                def S number;
+
+                AbstractNumberWrapper(S number) {
+                    this.number = number
+                }
+            }
+            @groovy.transform.CompileStatic
+            class LongWrapper<S extends Long> extends AbstractNumberWrapper<S> {
+                LongWrapper(S longNumber) {
+                    super(longNumber)
+                }
+
+                S getValue() {
+                    return number;
+                }
+            }
+            assert new LongWrapper<Long>(42L).value == 42L
+        '''
+    }
+
+    // this test can pass even if GROOVY-7691 is not resolved, just for ensuring the common case will pass test all the time!
+    void testCovariantGenericMethod() {
+        assertScript '''
+            @groovy.transform.CompileStatic
+            abstract class AbstractNumberWrapper<S extends Number> {
+                protected final S number;
+
+                AbstractNumberWrapper(S number) {
+                    this.number = number
+                }
+                
+                protected S getNumber() { return number; }
+            }
+            @groovy.transform.CompileStatic
+            class LongWrapper<S extends Long> extends AbstractNumberWrapper<S> {
+                LongWrapper(S longNumber) {
+                    super(longNumber)
+                }
+
+                S getValue() {
+                    return getNumber();
+                }
+            }
+            assert new LongWrapper<Long>(42L).value == 42L
+        '''
+    }
+}
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index ceae089de2..fcea9d0316 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -1791,29 +1791,6 @@ assert result == 'ok'
         '''
     }
 
-    // GROOVY-7691
-    @NotYetImplemented
-    void testCovariantGenericField() {
-        assertScript '''
-            abstract class AbstractNumberWrapper<S extends Number> {
-                protected final S number;
-
-                AbstractNumberWrapper(S number) {
-                    this.number = number
-                }
-            }
-            class LongWrapper<S extends Long> extends AbstractNumberWrapper<S> {
-                LongWrapper(S longNumber) {
-                    super(longNumber)
-                }
-
-                S getValue() {
-                    return number;
-                }
-            }
-            assert new LongWrapper<Long>(42L).value == 42L
-        '''
-    }
 
     //GROOVY-7804
     void testParameterlessClosureToGenericSAMTypeArgumentCoercion() {

Commit:
6560ce8e5541e4333a418d8dcf7f0f5ae92a71d0
sunlan
sunlan@apache.org
2018-05-12 15:06:11 +0800
Refine "GROOVY-7883 Static compiler prefers private constructor over public if private matches be(closes #705)"
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index a4c93c5ce0..a1a1c7e388 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4396,6 +4396,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         boolean isEnclosingInnerClass = enclosingClassNode instanceof InnerClassNode;
         List<ClassNode> outerClasses = enclosingClassNode.getOuterClasses();
 
+        outer:
         for (MethodNode methodNode : methods) {
             if (methodNode instanceof ExtensionMethodNode) {
                 result.add(methodNode);
@@ -4407,8 +4408,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (isEnclosingInnerClass) {
                 for (ClassNode outerClass : outerClasses) {
                     if (outerClass.isDerivedFrom(declaringClass)) {
-                        result.add(methodNode);
-                        continue;
+                        if (outerClass.equals(declaringClass)) {
+                            result.add(methodNode);
+                            continue outer;
+                        } else {
+                            if (methodNode.isPublic() || methodNode.isProtected()) {
+                                result.add(methodNode);
+                                continue outer;
+                            }
+                        }
                     }
                 }
             }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
index 51a5b1bd67..a40fe4e5a2 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
@@ -127,4 +127,49 @@ class Groovy7883Bug extends GroovyTestCase {
         new B().m()
         '''
     }
+
+    void test7() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt(ArrayList al) { doIt2(al) }
+            private void doIt2(List list, String x = "abc") {}
+            public void doIt3() { }
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            class C {
+                public void m() {
+                    doIt(new ArrayList());
+                    doIt3();
+                }
+            }
+            
+        }
+        
+        assert true
+        '''
+    }
+
+    void test8() {
+        def errMsg = shouldFail  '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt(ArrayList al) { doIt2(al) }
+            private void doIt2(List list, String x = "abc") {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            class C {
+                public void m() { doIt2(new ArrayList()) }
+            }
+            
+        }
+        
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method B$C#doIt2(java.util.ArrayList)')
+    }
 }

Commit:
b1d1232770aade9672668df4dbc6aa2e2076fa9e
sunlan
sunlan@apache.org
2018-05-12 14:05:21 +0800
GROOVY-7883 Static compiler prefers private constructor over public if private matches be(closes #705)
diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index 565e2f9cc0..64d5cff800 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -792,6 +792,22 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         return null;
     }
 
+    public List<ClassNode> getOuterClasses() {
+        if (!(this instanceof InnerClassNode)) {
+            return Collections.emptyList();
+        }
+
+        List<ClassNode> result = new LinkedList<>();
+        ClassNode outestClass = ((InnerClassNode) this).getOuterMostClass();
+        ClassNode cn = this;
+
+        do {
+            result.add(cn = cn.getOuterClass());
+        } while (!cn.equals(outestClass));
+
+        return result;
+    }
+
     /**
      * Adds a statement to the object initializer.
      *
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index a6067c27ae..a4c93c5ce0 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -179,6 +179,7 @@ import static org.codehaus.groovy.ast.tools.WideningCategories.isIntCategory;
 import static org.codehaus.groovy.ast.tools.WideningCategories.isLongCategory;
 import static org.codehaus.groovy.ast.tools.WideningCategories.isNumberCategory;
 import static org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound;
+import static org.codehaus.groovy.runtime.DefaultGroovyMethods.asBoolean;
 import static org.codehaus.groovy.syntax.Types.ASSIGN;
 import static org.codehaus.groovy.syntax.Types.ASSIGNMENT_OPERATOR;
 import static org.codehaus.groovy.syntax.Types.COMPARE_EQUAL;
@@ -4357,6 +4358,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // lookup in DGM methods too
         findDGMMethodsByNameAndArguments(getTransformLoader(), receiver, name, args, methods);
+        methods = filterMethodsByVisibility(methods);
         List<MethodNode> chosen = chooseBestMethod(receiver, methods, args);
         if (!chosen.isEmpty()) return chosen;
 
@@ -4383,6 +4385,54 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return EMPTY_METHODNODE_LIST;
     }
 
+    private List<MethodNode> filterMethodsByVisibility(List<MethodNode> methods) {
+        if (!asBoolean(methods)) {
+            return EMPTY_METHODNODE_LIST;
+        }
+
+        List<MethodNode> result = new LinkedList<>();
+
+        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();
+        boolean isEnclosingInnerClass = enclosingClassNode instanceof InnerClassNode;
+        List<ClassNode> outerClasses = enclosingClassNode.getOuterClasses();
+
+        for (MethodNode methodNode : methods) {
+            if (methodNode instanceof ExtensionMethodNode) {
+                result.add(methodNode);
+                continue;
+            }
+
+            ClassNode declaringClass = methodNode.getDeclaringClass();
+
+            if (isEnclosingInnerClass) {
+                for (ClassNode outerClass : outerClasses) {
+                    if (outerClass.isDerivedFrom(declaringClass)) {
+                        result.add(methodNode);
+                        continue;
+                    }
+                }
+            }
+
+            if (declaringClass instanceof InnerClassNode) {
+                if (declaringClass.getOuterClasses().contains(enclosingClassNode)) {
+                    result.add(methodNode);
+                    continue;
+                }
+            }
+
+            if (methodNode.isPrivate() && !enclosingClassNode.equals(declaringClass)) {
+                continue;
+            }
+            if (methodNode.isProtected() && !enclosingClassNode.isDerivedFrom(declaringClass)) {
+                continue;
+            }
+
+            result.add(methodNode);
+        }
+
+        return result;
+    }
+
     /**
      * Given a method name and a prefix, returns the name of the property that should be looked up,
      * following the java beans rules. For example, "getName" would return "name", while
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
index 95d2b0863a..b0266d296b 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
@@ -177,7 +177,7 @@ import groovy.transform.TypeCheckingMode//import org.codehaus.groovy.classgen.as
             class Bar {
                 def foo() {new Foo()}
             }
-        ''', 'Cannot call private constructor'
+        ''', '[Static type checking] - Cannot find matching method Foo#<init>()'
     }
 
     // GROOVY-7063
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
new file mode 100644
index 0000000000..51a5b1bd67
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7883Bug.groovy
@@ -0,0 +1,130 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+class Groovy7883Bug extends GroovyTestCase {
+    void testGroovy7883() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        void doIt() {
+            throw new AssertionError("abc")
+        }
+        
+        try {
+            doIt()
+            assert false: "should never reach here"
+        } catch (AssertionError e) {
+            assert 'abc' == e.message
+        }
+        '''
+    }
+
+    void test2() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        class A {
+            private void doIt() {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B {
+            public void m() { new A().doIt() }
+        }
+        
+        new B().m()
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
+    }
+
+    void test3() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt() {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B {
+            public void m() { new A().doIt() }
+        }
+        
+        new B().m()
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
+    }
+
+    void test4() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        class A {
+            private void doIt() {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            public void m() { doIt() }
+        }
+        
+        new B().m()
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method B#doIt()')
+    }
+
+    /**
+     * ensure the filtering logic does not break any code
+     */
+    void test5() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt() { doIt2() }
+            private void doIt2() {}
+            public void doIt3() { doIt() }
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            public void m() { doIt() }
+        }
+        
+        new B().m()
+        new B().doIt3()
+        '''
+    }
+
+    void test6() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt(ArrayList al) { doIt2(al) }
+            private void doIt2(List list, String x = "abc") {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            public void m() { doIt(new ArrayList()) }
+        }
+        
+        new B().m()
+        '''
+    }
+}
diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
index da61e9f3d7..633c0a7845 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
@@ -3973,7 +3973,7 @@ public class Sql {
      * @return the resulting list of rows
      * @throws SQLException if a database error occurs
      */
-    protected List<GroovyRowResult> asList(String sql, ResultSet rs,
+    public List<GroovyRowResult> asList(String sql, ResultSet rs,
                                            @ClosureParams(value=SimpleType.class, options="java.sql.ResultSetMetaData") Closure metaClosure) throws SQLException {
         return asList(sql, rs, 0, 0, metaClosure);
     }

Commit:
affc8b9b82d0a0cbfcd364d2caf5baaf79d47f38
danielsun1106
realbluesun@hotmail.com
2018-05-12 03:31:47 +0800
Revert "GROOVY-7883: Static compiler prefers private constructor over public if private matches better"
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 85daa8c089..a6067c27ae 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4357,7 +4357,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // lookup in DGM methods too
         findDGMMethodsByNameAndArguments(getTransformLoader(), receiver, name, args, methods);
-        methods = filterMethodsByVisibility(methods);
         List<MethodNode> chosen = chooseBestMethod(receiver, methods, args);
         if (!chosen.isEmpty()) return chosen;
 
@@ -4384,24 +4383,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return EMPTY_METHODNODE_LIST;
     }
 
-    private List<MethodNode> filterMethodsByVisibility(List<MethodNode> methods) {
-        List<MethodNode> result = new LinkedList<>();
-
-        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();
-        for (MethodNode methodNode : methods) {
-            if (methodNode.isPrivate() && !enclosingClassNode.equals(methodNode.getDeclaringClass())) {
-                continue;
-            }
-            if (methodNode.isProtected() && !enclosingClassNode.isDerivedFrom(methodNode.getDeclaringClass())) {
-                continue;
-            }
-
-            result.add(methodNode);
-        }
-
-        return result;
-    }
-
     /**
      * Given a method name and a prefix, returns the name of the property that should be looked up,
      * following the java beans rules. For example, "getName" would return "name", while
diff --git a/src/test/groovy/bugs/Groovy7883Bug.groovy b/src/test/groovy/bugs/Groovy7883Bug.groovy
deleted file mode 100644
index c16411892b..0000000000
--- a/src/test/groovy/bugs/Groovy7883Bug.groovy
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-class Groovy7883Bug extends GroovyTestCase {
-    void testGroovy7883() {
-        assertScript '''
-        @groovy.transform.CompileStatic
-        void doIt() {
-            throw new AssertionError("abc")
-        }
-        
-        try {
-            doIt()
-            assert false: "should never reach here"
-        } catch (AssertionError e) {
-            assert 'abc' == e.message
-        }
-        '''
-    }
-
-    void test2() {
-        def errMsg = shouldFail '''
-        @groovy.transform.CompileStatic
-        class A {
-            private void doIt() {}
-        }
-        
-        @groovy.transform.CompileStatic
-        class B {
-            public void m() { new A().doIt() }
-        }
-        
-        new B().m()
-        '''
-
-        assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
-    }
-
-    void test3() {
-        def errMsg = shouldFail '''
-        @groovy.transform.CompileStatic
-        class A {
-            protected void doIt() {}
-        }
-        
-        @groovy.transform.CompileStatic
-        class B {
-            public void m() { new A().doIt() }
-        }
-        
-        new B().m()
-        '''
-
-        assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
-    }
-
-    void test4() {
-        def errMsg = shouldFail '''
-        @groovy.transform.CompileStatic
-        class A {
-            private void doIt() {}
-        }
-        
-        @groovy.transform.CompileStatic
-        class B extends A {
-            public void m() { doIt() }
-        }
-        
-        new B().m()
-        '''
-
-        assert errMsg.contains('[Static type checking] - Cannot find matching method B#doIt()')
-    }
-
-    /**
-     * ensure the filtering logic does not break any code
-     */
-    void test5() {
-        assertScript '''
-        @groovy.transform.CompileStatic
-        class A {
-            protected void doIt() { doIt2() }
-            private void doIt2() {}
-            public void doIt3() { doIt() }
-        }
-        
-        @groovy.transform.CompileStatic
-        class B extends A {
-            public void m() { doIt() }
-        }
-        
-        new B().m()
-        new B().doIt3()
-        '''
-    }
-
-    void test6() {
-        assertScript '''
-        @groovy.transform.CompileStatic
-        class A {
-            protected void doIt(ArrayList al) { doIt2(al) }
-            private void doIt2(List list, String x = "abc") {}
-        }
-        
-        @groovy.transform.CompileStatic
-        class B extends A {
-            public void m() { doIt(new ArrayList()) }
-        }
-        
-        new B().m()
-        '''
-    }
-}

Commit:
3a0696ee3181184b84cf5975b6e0be072c6ce6d7
danielsun1106
realbluesun@hotmail.com
2018-05-12 02:40:54 +0800
Minor refactoring: simplify the logic of `filterMethodsByVisibility`
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index cb211d53d5..85daa8c089 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4357,7 +4357,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // lookup in DGM methods too
         findDGMMethodsByNameAndArguments(getTransformLoader(), receiver, name, args, methods);
-        methods = filterMethodsByVisibility(receiver, methods);
+        methods = filterMethodsByVisibility(methods);
         List<MethodNode> chosen = chooseBestMethod(receiver, methods, args);
         if (!chosen.isEmpty()) return chosen;
 
@@ -4384,31 +4384,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return EMPTY_METHODNODE_LIST;
     }
 
-    private List<MethodNode> filterMethodsByVisibility(ClassNode receiver, List<MethodNode> methods) {
+    private List<MethodNode> filterMethodsByVisibility(List<MethodNode> methods) {
         List<MethodNode> result = new LinkedList<>();
 
         ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();
-        if (enclosingClassNode.equals(receiver)) {
-            for (MethodNode methodNode : methods) {
-                if (methodNode.isPrivate() && !enclosingClassNode.equals(methodNode.getDeclaringClass())) {
-                    continue;
-                }
-
-                result.add(methodNode);
+        for (MethodNode methodNode : methods) {
+            if (methodNode.isPrivate() && !enclosingClassNode.equals(methodNode.getDeclaringClass())) {
+                continue;
             }
-        } else {
-            boolean isDerived = enclosingClassNode.isDerivedFrom(receiver);
-            for (MethodNode methodNode : methods) {
-                if (methodNode.isPrivate()) {
-                    continue;
-                }
-
-                if (!isDerived && methodNode.isProtected()) {
-                    continue;
-                }
-
-                result.add(methodNode);
+            if (methodNode.isProtected() && !enclosingClassNode.isDerivedFrom(methodNode.getDeclaringClass())) {
+                continue;
             }
+
+            result.add(methodNode);
         }
 
         return result;
diff --git a/src/test/groovy/bugs/Groovy7883Bug.groovy b/src/test/groovy/bugs/Groovy7883Bug.groovy
index d632141a10..c16411892b 100644
--- a/src/test/groovy/bugs/Groovy7883Bug.groovy
+++ b/src/test/groovy/bugs/Groovy7883Bug.groovy
@@ -98,6 +98,7 @@ class Groovy7883Bug extends GroovyTestCase {
         class A {
             protected void doIt() { doIt2() }
             private void doIt2() {}
+            public void doIt3() { doIt() }
         }
         
         @groovy.transform.CompileStatic
@@ -106,6 +107,7 @@ class Groovy7883Bug extends GroovyTestCase {
         }
         
         new B().m()
+        new B().doIt3()
         '''
     }
 

Commit:
8df09980dd4413966922fa7ef23236db809325af
danielsun1106
realbluesun@hotmail.com
2018-05-12 02:13:31 +0800
GROOVY-7883: Static compiler prefers private constructor over public if private matches better
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index a6067c27ae..cb211d53d5 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4357,6 +4357,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // lookup in DGM methods too
         findDGMMethodsByNameAndArguments(getTransformLoader(), receiver, name, args, methods);
+        methods = filterMethodsByVisibility(receiver, methods);
         List<MethodNode> chosen = chooseBestMethod(receiver, methods, args);
         if (!chosen.isEmpty()) return chosen;
 
@@ -4383,6 +4384,36 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return EMPTY_METHODNODE_LIST;
     }
 
+    private List<MethodNode> filterMethodsByVisibility(ClassNode receiver, List<MethodNode> methods) {
+        List<MethodNode> result = new LinkedList<>();
+
+        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();
+        if (enclosingClassNode.equals(receiver)) {
+            for (MethodNode methodNode : methods) {
+                if (methodNode.isPrivate() && !enclosingClassNode.equals(methodNode.getDeclaringClass())) {
+                    continue;
+                }
+
+                result.add(methodNode);
+            }
+        } else {
+            boolean isDerived = enclosingClassNode.isDerivedFrom(receiver);
+            for (MethodNode methodNode : methods) {
+                if (methodNode.isPrivate()) {
+                    continue;
+                }
+
+                if (!isDerived && methodNode.isProtected()) {
+                    continue;
+                }
+
+                result.add(methodNode);
+            }
+        }
+
+        return result;
+    }
+
     /**
      * Given a method name and a prefix, returns the name of the property that should be looked up,
      * following the java beans rules. For example, "getName" would return "name", while
diff --git a/src/test/groovy/bugs/Groovy7883Bug.groovy b/src/test/groovy/bugs/Groovy7883Bug.groovy
new file mode 100644
index 0000000000..d632141a10
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7883Bug.groovy
@@ -0,0 +1,128 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy7883Bug extends GroovyTestCase {
+    void testGroovy7883() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        void doIt() {
+            throw new AssertionError("abc")
+        }
+        
+        try {
+            doIt()
+            assert false: "should never reach here"
+        } catch (AssertionError e) {
+            assert 'abc' == e.message
+        }
+        '''
+    }
+
+    void test2() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        class A {
+            private void doIt() {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B {
+            public void m() { new A().doIt() }
+        }
+        
+        new B().m()
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
+    }
+
+    void test3() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt() {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B {
+            public void m() { new A().doIt() }
+        }
+        
+        new B().m()
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method A#doIt()')
+    }
+
+    void test4() {
+        def errMsg = shouldFail '''
+        @groovy.transform.CompileStatic
+        class A {
+            private void doIt() {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            public void m() { doIt() }
+        }
+        
+        new B().m()
+        '''
+
+        assert errMsg.contains('[Static type checking] - Cannot find matching method B#doIt()')
+    }
+
+    /**
+     * ensure the filtering logic does not break any code
+     */
+    void test5() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt() { doIt2() }
+            private void doIt2() {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            public void m() { doIt() }
+        }
+        
+        new B().m()
+        '''
+    }
+
+    void test6() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class A {
+            protected void doIt(ArrayList al) { doIt2(al) }
+            private void doIt2(List list, String x = "abc") {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class B extends A {
+            public void m() { doIt(new ArrayList()) }
+        }
+        
+        new B().m()
+        '''
+    }
+}

Commit:
4bab03ae95b1b69fc90dc32cb41f7a0687f8d277
danielsun1106
realbluesun@hotmail.com
2018-05-11 23:44:49 +0800
GROOVY-8055: @CompileStatic improperly orders parameter types
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 6d1f5eb07c..3ea9764389 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -20,6 +20,7 @@
 package org.codehaus.groovy.transform.stc;
 
 import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.ast.MethodNode;
@@ -956,7 +957,7 @@ public abstract class StaticTypeCheckingSupport {
             return dist;
         }
 
-        ClassNode ref = receiver;
+        ClassNode ref = isPrimitiveType(receiver) && !isPrimitiveType(compare) ? ClassHelper.getWrapper(receiver) : receiver;
         while (ref != null) {
             if (compare.equals(ref)) {
                 break;
diff --git a/src/test/groovy/bugs/Groovy8055Bug.groovy b/src/test/groovy/bugs/Groovy8055Bug.groovy
new file mode 100644
index 0000000000..ca15c7e538
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8055Bug.groovy
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy8055Bug extends GroovyTestCase {
+    void test1() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        
+        @CompileStatic
+        class Foo {
+            void isEqualTo(Number number) { println "Number"; assert true }
+            void isEqualTo(Object number) { println "Object"; assert false: 'wrong method invoked' }
+        }
+        
+        @CompileStatic
+        class Runner {
+            void run() {
+                new Foo().isEqualTo(4)
+            }
+        }
+        
+        new Runner().run()
+        '''
+    }
+}

Commit:
5f6689638160c44dccbf2b7155d35edff2389979
danielsun1106
realbluesun@hotmail.com
2018-05-11 22:44:00 +0800
Add a test for "GROOVY-8212: coerce GString to String when used as Map key"
diff --git a/src/test/groovy/bugs/Groovy8212Bug.groovy b/src/test/groovy/bugs/Groovy8212Bug.groovy
new file mode 100644
index 0000000000..e4bc5b6d44
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8212Bug.groovy
@@ -0,0 +1,36 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy8212Bug extends GroovyTestCase {
+    void test() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class Groovy8212 {
+            def map = ['a x': 1, 'b x': 2]
+            def get(String k) {
+                return map["$k x"]
+            }
+        }
+        
+        assert 1 == new Groovy8212().get('a')
+        assert 2 == new Groovy8212().get('b')
+        '''
+    }
+}

Commit:
ad5de10ddd0740bdb7c31690aa0f99b359a706d1
Paul King
paulk@asert.com.au
2018-05-11 23:18:21 +1000
update outdated comments
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 3de7535a20..e03ea4fe58 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -756,11 +756,10 @@ public class CompilerConfiguration {
     }
 
     /**
-     * Allow setting the bytecode compatibility. The parameter can take
-     * one of the values <tt>1.7</tt>, <tt>1.6</tt>, <tt>1.5</tt> or <tt>1.4</tt>.
-     * If wrong parameter then the value will default to VM determined version.
+     * Allow setting the bytecode compatibility level. The parameter can take
+     * one of the values in {@link #ALLOWED_JDKS}.
      *
-     * @param version the bytecode compatibility mode
+     * @param version the bytecode compatibility level
      */
     public void setTargetBytecode(String version) {
         for (String allowedJdk : ALLOWED_JDKS) {
@@ -771,9 +770,11 @@ public class CompilerConfiguration {
     }
 
     /**
-     * Retrieves the compiler bytecode compatibility mode.
+     * Retrieves the compiler bytecode compatibility level.
+     * Defaults to the minimum officially supported bytecode
+     * version for any particular Groovy version.
      *
-     * @return bytecode compatibility mode. Can be either <tt>1.5</tt> or <tt>1.4</tt>.
+     * @return bytecode compatibility level
      */
     public String getTargetBytecode() {
         return this.targetBytecode;

Commit:
ca40846618a5c0e59b8ac39dc6f1f953152130de
sunlan
sunlan@apache.org
2018-05-11 17:52:46 +0800
Refine the test for "GROOVY-6742: Groovy is unable to resolve this Generics use case"
diff --git a/src/test/groovy/bugs/groovy6742/Groovy6742Bug.groovy b/src/test/groovy/bugs/groovy6742/Groovy6742Bug.groovy
index 61f5f5d16b..fcc953aad0 100644
--- a/src/test/groovy/bugs/groovy6742/Groovy6742Bug.groovy
+++ b/src/test/groovy/bugs/groovy6742/Groovy6742Bug.groovy
@@ -71,7 +71,7 @@ class Groovy6742Bug extends GroovyTestCase {
         assertScript '''
             package groovy.bugs.groovy6742
             
-            //@groovy.transform.TypeChecked
+            @groovy.transform.TypeChecked
             class Issue3 {
                 public static <F, T> FutureCallback<F> deferredCallback(DeferredResult<T> deferredResult, final Function<F, T> function) {
                     return new FutureCallback<F>() {

Commit:
a466ec1894d48f107081857051c03420853d417b
sunlan
sunlan@apache.org
2018-05-11 17:50:37 +0800
GROOVY-6742: Groovy is unable to resolve this Generics use case
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index d5d0bf9b67..45ac027794 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -1303,14 +1303,24 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     public void visitClass(ClassNode node) {
         ClassNode oldNode = currentClass;
 
+        currentClass = node;
+
         if (node instanceof InnerClassNode) {
             if (Modifier.isStatic(node.getModifiers())) {
                 genericParameterNames = new HashMap<String, GenericsType>();
             }
+
+            InnerClassNode innerClassNode = (InnerClassNode) node;
+            if (innerClassNode.isAnonymous()) {
+                MethodNode enclosingMethod = innerClassNode.getEnclosingMethod();
+                if (null != enclosingMethod) {
+                    resolveGenericsHeader(enclosingMethod.getGenericsTypes());
+                }
+            }
         } else {
             genericParameterNames = new HashMap<String, GenericsType>();
         }
-        currentClass = node;
+
         resolveGenericsHeader(node.getGenericsTypes());
 
         ModuleNode module = node.getModule();
diff --git a/src/test/groovy/bugs/groovy6742/DeferredResult.java b/src/test/groovy/bugs/groovy6742/DeferredResult.java
new file mode 100644
index 0000000000..e61e7ef967
--- /dev/null
+++ b/src/test/groovy/bugs/groovy6742/DeferredResult.java
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy.bugs.groovy6742;
+
+public class DeferredResult<T> {
+    public boolean setResult(T result) {
+        return true;
+    }
+}
diff --git a/src/test/groovy/bugs/groovy6742/Function.java b/src/test/groovy/bugs/groovy6742/Function.java
new file mode 100644
index 0000000000..b0e6b42f34
--- /dev/null
+++ b/src/test/groovy/bugs/groovy6742/Function.java
@@ -0,0 +1,24 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy.bugs.groovy6742;
+
+public interface Function<F, T> {
+    T apply(F input);
+}
diff --git a/src/test/groovy/bugs/groovy6742/FutureCallback.java b/src/test/groovy/bugs/groovy6742/FutureCallback.java
new file mode 100644
index 0000000000..9295f032ad
--- /dev/null
+++ b/src/test/groovy/bugs/groovy6742/FutureCallback.java
@@ -0,0 +1,24 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy.bugs.groovy6742;
+
+public interface FutureCallback<V> {
+    void onSuccess(V result);
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/groovy6742/Groovy6742Bug.groovy b/src/test/groovy/bugs/groovy6742/Groovy6742Bug.groovy
new file mode 100644
index 0000000000..61f5f5d16b
--- /dev/null
+++ b/src/test/groovy/bugs/groovy6742/Groovy6742Bug.groovy
@@ -0,0 +1,93 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+
+
+package groovy.bugs.groovy6742
+
+class Groovy6742Bug extends GroovyTestCase {
+    void test1() {
+        assertScript '''
+            package groovy.bugs.groovy6742
+            
+            @groovy.transform.TypeChecked
+            class Issue1 {
+                public void issue(){
+                    Function<String,String> function = new Function<String,String>() {
+                        @Override
+                        String apply(String input) {
+                            return "ok"
+                        }
+                    }
+                }
+            }
+            
+            assert true
+        '''
+    }
+
+    void test2() {
+        assertScript '''
+            package groovy.bugs.groovy6742
+            
+            @groovy.transform.TypeChecked
+            class Issue2 {
+                public void issue() {
+                    transform(new Function<String, String>() {
+                        @Override
+                        String apply(String input) {
+                            return "ok"
+                        }
+                    })
+                }
+            
+                public <I, O> void transform(Function<? super I, ? extends O> function) {
+            
+                }
+            }
+            
+            assert true
+        '''
+    }
+
+    void test3() {
+        assertScript '''
+            package groovy.bugs.groovy6742
+            
+            //@groovy.transform.TypeChecked
+            class Issue3 {
+                public static <F, T> FutureCallback<F> deferredCallback(DeferredResult<T> deferredResult, final Function<F, T> function) {
+                    return new FutureCallback<F>() {
+                        private F f = null
+                        F f2 = null
+                        
+                        @Override
+                        void onSuccess(F result) {
+                            deferredResult.setResult(function.apply(result))
+                        }
+                    };
+                }
+            }
+            
+            assert true
+        '''
+    }
+
+}

Commit:
c321ec989b495c2fd9261c23cfacdb2a23b879fe
sunlan
sunlan@apache.org
2018-05-11 14:43:36 +0800
Add a test for "GROOVY-8059: STC overloaded generic method selection not using resolved types"
diff --git a/src/test/groovy/bugs/Groovy8059Bug.groovy b/src/test/groovy/bugs/Groovy8059Bug.groovy
new file mode 100644
index 0000000000..a86cdb2dd3
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8059Bug.groovy
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+
+
+package groovy.bugs
+
+class Groovy8059Bug extends GroovyTestCase {
+    void test1() {
+        assertScript '''
+        @groovy.transform.CompileStatic
+        class Base<K extends Serializable, V> {
+            void delete(K key) {}
+            void delete(V value) {}
+        }
+        
+        @groovy.transform.CompileStatic
+        class Foo extends Base<String, Integer> {}
+        
+        @groovy.transform.CompileStatic
+        public class Class1 {
+            Class1() {
+                Foo foo = new Foo()        
+                foo.delete(Integer.valueOf(1))
+            }
+        }
+        new Class1()
+        '''
+    }
+}

Commit:
9f14993d9e260a1277311fad78d13bd6f4c8c95f
sunlan
sunlan@apache.org
2018-05-11 14:04:57 +0800
GROOVY-7985: Wrong "incompatible generic type" error
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 98057d0487..27f2bd9ad1 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -165,6 +165,8 @@ public class GenericsUtils {
                     "\nExpected: " + node.getName() + toGenericTypesString(redirectGenericsTypes) +
                     "\nSupplied: " + node.getName() + toGenericTypesString(parameterized));
         }
+
+        List<GenericsType> valueList = new LinkedList<>();
         for (int i = 0; i < redirectGenericsTypes.length; i++) {
             GenericsType redirectType = redirectGenericsTypes[i];
             if (redirectType.isPlaceholder()) {
@@ -172,21 +174,26 @@ public class GenericsUtils {
                 if (!map.containsKey(name)) {
                     GenericsType value = parameterized[i];
                     map.put(name, value);
-                    if (value.isWildcard()) {
-                        ClassNode lowerBound = value.getLowerBound();
-                        if (lowerBound != null) {
-                            extractPlaceholders(lowerBound, map);
-                        }
-                        ClassNode[] upperBounds = value.getUpperBounds();
-                        if (upperBounds != null) {
-                            for (ClassNode upperBound : upperBounds) {
-                                extractPlaceholders(upperBound, map);
-                            }
-                        }
-                    } else if (!value.isPlaceholder()) {
-                        extractPlaceholders(value.getType(), map);
+
+                    valueList.add(value);
+                }
+            }
+        }
+
+        for (GenericsType value : valueList) {
+            if (value.isWildcard()) {
+                ClassNode lowerBound = value.getLowerBound();
+                if (lowerBound != null) {
+                    extractPlaceholders(lowerBound, map);
+                }
+                ClassNode[] upperBounds = value.getUpperBounds();
+                if (upperBounds != null) {
+                    for (ClassNode upperBound : upperBounds) {
+                        extractPlaceholders(upperBound, map);
                     }
                 }
+            } else if (!value.isPlaceholder()) {
+                extractPlaceholders(value.getType(), map);
             }
         }
     }
diff --git a/src/test/groovy/bugs/Groovy7985Bug.groovy b/src/test/groovy/bugs/Groovy7985Bug.groovy
new file mode 100644
index 0000000000..e0b45b5bd6
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7985Bug.groovy
@@ -0,0 +1,62 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+
+
+package groovy.bugs
+
+class Groovy7985Bug extends GroovyTestCase {
+    void test1() {
+        assertScript '''
+        import java.io.Serializable;
+        import java.util.Date;
+        import groovy.transform.CompileStatic
+
+        @CompileStatic
+        class Test {
+            Pair<Pair<String, Integer>, Pair<String, Integer>> doSmething() {
+                def left = (Pair<String, Integer>) Pair.of("a", 1)
+                def right = (Pair<String, Integer>) Pair.of("b", 2)
+                return Pair.of(left, right)
+            }
+        }
+
+        @CompileStatic
+        class Pair<L, R> implements Serializable {
+            public static <L, R> Pair<L, R> of(final L left, final R right) {
+                return new Pair<>(left, right);
+            }
+
+            public final L left;
+            public final R right;
+
+            private Pair(final L left, final R right) {
+                this.left = left;
+                this.right = right;
+            }
+        }
+        
+        assert 'a' == new Test().doSmething().left.left
+        assert 1 == new Test().doSmething().left.right
+        assert 'b' == new Test().doSmething().right.left
+        assert 2 == new Test().doSmething().right.right
+        '''
+    }
+}

Commit:
795e2540c2b8d3d62594b5c91631427c708047f6
sunlan
sunlan@apache.org
2018-05-11 11:37:51 +0800
Reuse `extractPlaceholders` and change error message
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 314473a167..6d1f5eb07c 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -61,7 +61,6 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -1099,8 +1098,7 @@ public abstract class StaticTypeCheckingSupport {
                 Person p = foo(b)
              */
 
-            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
-            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringAndActualGenericsTypeMap);
+            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringClassForDistance, actualReceiverForDistance);
             int dist = measureParametersAndArgumentsDistance(params, safeArgs);
             if (dist >= 0) {
                 dist += getClassDistance(declaringClassForDistance, actualReceiverForDistance);
@@ -1190,11 +1188,9 @@ public abstract class StaticTypeCheckingSupport {
         return isExtensionMethodNode ? 0 : 1;
     }
 
-    private static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
-        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
-            GenericsType declaringGenericsType = entry.getKey();
-
-            if (placeholderName.equals(declaringGenericsType.getName())) {
+    private static ClassNode findGenericsTypeByPlaceholderName(String placeholderName, Map<String, GenericsType> placeholderInfo) {
+        for (Map.Entry<String, GenericsType> entry : placeholderInfo.entrySet()) {
+            if (placeholderName.equals(entry.getKey())) {
                 return entry.getValue().getType();
             }
         }
@@ -1202,43 +1198,14 @@ public abstract class StaticTypeCheckingSupport {
         return null;
     }
 
-    /**
-     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
-     * declaring generics types:      T,      S extends Serializable
-     * actual generics types   : String,      Long
-     *
-     * the result map is [
-     *  T: String,
-     *  S: Long
-     * ]
-     *
-     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
-     * so we need actual types:  T: String, S: Long
-     */
-    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
-        ClassNode parameterizedType = GenericsUtils.findParameterizedType(declaringClass, actualReceiver);
-
-        if (null == parameterizedType) {
-            return Collections.emptyMap();
-        }
-
-        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
-        GenericsType[] actualGenericsTypes = parameterizedType.getGenericsTypes();
-
-        Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
-        for (int i = 0, n = declaringGenericsTypes.length; i < n; i++) {
-            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
-        }
-
-        return result;
-    }
+    private static Parameter[] makeRawTypes(Parameter[] params, ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
+        Map<String, GenericsType> placeholderInfo = GenericsUtils.extractPlaceholders(GenericsUtils.findParameterizedType(declaringClassForDistance, actualReceiverForDistance));
 
-    private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
         Parameter[] newParam = new Parameter[params.length];
         for (int i = 0; i < params.length; i++) {
             Parameter oldP = params[i];
 
-            ClassNode actualType = findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
+            ClassNode actualType = findGenericsTypeByPlaceholderName(oldP.getType().getUnresolvedName(), placeholderInfo);
             Parameter newP = new Parameter(makeRawType(null == actualType ? oldP.getType() : actualType), oldP.getName());
             newParam[i] = newP;
         }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 3a89bcb9bf..ceae089de2 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -76,7 +76,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<String> list = []
             list << 1
-        ''', '[Static type checking] - Cannot find matching method java.util.List#leftShift(int)'
+        ''', '[Static type checking] - Cannot call <T> java.util.List <String>#leftShift(T) with arguments [int] '
     }
 
     void testAddOnList2UsingLeftShift() {

Commit:
62f5ce6ffe8d0dad30808944201723e02d3666fd
sunlan
sunlan@apache.org
2018-05-11 10:12:19 +0800
Extract util method `findParameterizedType` and change some error messages
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 31f6c6e939..98057d0487 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -43,6 +43,7 @@ import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
@@ -649,4 +650,68 @@ public class GenericsUtils {
         }
         return newTypes;
     }
+
+    /**
+     * Get the parameterized type by search the whole class hierarchy according to generics class and actual receiver
+     *
+     * @param genericsClass the generics class
+     * @param actualReceiver the actual receiver
+     * @return the parameterized type
+     */
+    public static ClassNode findParameterizedType(ClassNode genericsClass, ClassNode actualReceiver) {
+        ClassNode parameterizedType = null;
+
+        if (null == genericsClass.getGenericsTypes()) {
+            return parameterizedType;
+        }
+
+        GenericsType[] declaringGenericsTypes = genericsClass.getGenericsTypes();
+
+        List<ClassNode> classNodeList = new LinkedList<>(getAllSuperClassesAndInterfaces(actualReceiver));
+        classNodeList.add(0, actualReceiver);
+
+        for (ClassNode cn : classNodeList) {
+            if (cn == genericsClass) {
+                continue;
+            }
+
+            if (!genericsClass.equals(cn.redirect())) {
+                continue;
+            }
+
+            if (isGenericsTypeArraysLengthEqual(declaringGenericsTypes, cn.getGenericsTypes())) {
+                parameterizedType = cn;
+                break;
+            }
+        }
+
+        return parameterizedType;
+    }
+
+    private static boolean isGenericsTypeArraysLengthEqual(GenericsType[] declaringGenericsTypes, GenericsType[] actualGenericsTypes) {
+        return null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length;
+    }
+
+    private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiver) {
+        List<ClassNode> superClassAndInterfaceList = new LinkedList<>();
+        List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiver);
+        superClassAndInterfaceList.addAll(allSuperClassNodeList);
+        superClassAndInterfaceList.addAll(actualReceiver.getAllInterfaces());
+
+        for (ClassNode superClassNode : allSuperClassNodeList) {
+            superClassAndInterfaceList.addAll(superClassNode.getAllInterfaces());
+        }
+
+        return superClassAndInterfaceList;
+    }
+
+    private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiver) {
+        List<ClassNode> superClassNodeList = new LinkedList<>();
+
+        for (ClassNode cn = actualReceiver.getUnresolvedSuperClass(); null != cn && ClassHelper.OBJECT_TYPE != cn; cn = cn.getUnresolvedSuperClass()) {
+            superClassNodeList.add(cn);
+        }
+
+        return superClassNodeList;
+    }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index fa924a696b..314473a167 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -20,7 +20,6 @@
 package org.codehaus.groovy.transform.stc;
 
 import org.codehaus.groovy.GroovyBugError;
-import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.ast.MethodNode;
@@ -62,6 +61,7 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -1216,32 +1216,16 @@ public abstract class StaticTypeCheckingSupport {
      * so we need actual types:  T: String, S: Long
      */
     private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
-        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
-        GenericsType[] actualGenericsTypes = actualReceiver.getGenericsTypes();
+        ClassNode parameterizedType = GenericsUtils.findParameterizedType(declaringClass, actualReceiver);
 
-        if (null == declaringGenericsTypes) {
+        if (null == parameterizedType) {
             return Collections.emptyMap();
         }
 
-        if (null == actualGenericsTypes) {
-            List<ClassNode> superClassAndInterfaceList = getAllSuperClassesAndInterfaces(actualReceiver);
-
-            for (ClassNode cn : superClassAndInterfaceList) {
-                if (declaringClass.equals(cn.redirect())) {
-                    actualGenericsTypes = cn.getGenericsTypes();
-
-                    if (isGenericsTypeArraysLengthEqual(declaringGenericsTypes, actualGenericsTypes)) {
-                        break;
-                    }
-                }
-            }
-        }
-
-        if (!isGenericsTypeArraysLengthEqual(declaringGenericsTypes, actualGenericsTypes)) {
-            return Collections.emptyMap();
-        }
+        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
+        GenericsType[] actualGenericsTypes = parameterizedType.getGenericsTypes();
 
-        Map<GenericsType, GenericsType> result = new HashMap<>();
+        Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
         for (int i = 0, n = declaringGenericsTypes.length; i < n; i++) {
             result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
         }
@@ -1249,33 +1233,6 @@ public abstract class StaticTypeCheckingSupport {
         return result;
     }
 
-    private static boolean isGenericsTypeArraysLengthEqual(GenericsType[] declaringGenericsTypes, GenericsType[] actualGenericsTypes) {
-        return null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length;
-    }
-
-    private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiver) {
-        List<ClassNode> superClassAndInterfaceList = new LinkedList<>();
-        List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiver);
-        superClassAndInterfaceList.addAll(allSuperClassNodeList);
-        superClassAndInterfaceList.addAll(actualReceiver.getAllInterfaces());
-
-        for (ClassNode superClassNode : allSuperClassNodeList) {
-            superClassAndInterfaceList.addAll(superClassNode.getAllInterfaces());
-        }
-
-        return superClassAndInterfaceList;
-    }
-
-    private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiver) {
-        List<ClassNode> superClassNodeList = new LinkedList<>();
-
-        for (ClassNode cn = actualReceiver.getUnresolvedSuperClass(); null != cn && ClassHelper.OBJECT_TYPE != cn; cn = cn.getUnresolvedSuperClass()) {
-            superClassNodeList.add(cn);
-        }
-
-        return superClassNodeList;
-    }
-
     private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
         Parameter[] newParam = new Parameter[params.length];
         for (int i = 0; i < params.length; i++) {
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 9c42e3e9da..3a89bcb9bf 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -116,14 +116,14 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<Integer> list = new LinkedList<>()
             list.add 'Hello'
-        ''', '[Static type checking] - Cannot find matching method java.util.LinkedList#add(java.lang.String)'
+        ''', '[Static type checking] - Cannot call java.util.LinkedList <java.lang.Integer>#add(java.lang.Integer) with arguments [java.lang.String]'
     }
 
     void testAddOnListWithDiamondAndWrongTypeUsingLeftShift() {
         shouldFailWithMessages '''
             List<Integer> list = new LinkedList<>()
             list << 'Hello'
-        ''', '[Static type checking] - Cannot find matching method java.util.LinkedList#leftShift(java.lang.String)'
+        ''', '[Static type checking] - Cannot call <T> java.util.LinkedList <java.lang.Integer>#leftShift(T) with arguments [java.lang.String]'
     }
 
     void testAddOnListWithDiamondAndNullUsingLeftShift() {
@@ -424,7 +424,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Map<String, Integer> map = new HashMap<String,Integer>()
             map.put('hello', new Object())
-        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.lang.String, java.lang.Object)'
+        ''', '[Static type checking] - Cannot call java.util.HashMap <String, Integer>#put(java.lang.String, java.lang.Integer) with arguments [java.lang.String, java.lang.Object]'
     }
 
     void testPutMethodWithPrimitiveValueAndArrayPut() {
@@ -749,7 +749,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map.put('foo', new Date())
-        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.lang.String, java.util.Date)'
+        ''', '[Static type checking] - Cannot call java.util.HashMap <java.util.Date, java.util.Date>#put(java.util.Date, java.util.Date) with arguments [java.lang.String, java.util.Date]'
     }
     void testInferDiamondForAssignmentWithDatesAndIllegalKeyUsingSquareBracket() {
         shouldFailWithMessages '''
@@ -787,7 +787,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map.put(new Date(), 'foo')
-        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.util.Date, java.lang.String)'
+        ''', '[Static type checking] - Cannot call java.util.HashMap <java.util.Date, java.util.Date>#put(java.util.Date, java.util.Date) with arguments [java.util.Date, java.lang.String]'
     }
     void testInferDiamondForAssignmentWithDatesAndIllegalValueUsingSquareBracket() {
         shouldFailWithMessages '''
diff --git a/src/test/org/codehaus/groovy/ast/tools/GenericsUtilsTest.groovy b/src/test/org/codehaus/groovy/ast/tools/GenericsUtilsTest.groovy
new file mode 100644
index 0000000000..cf2fb49a7c
--- /dev/null
+++ b/src/test/org/codehaus/groovy/ast/tools/GenericsUtilsTest.groovy
@@ -0,0 +1,212 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.codehaus.groovy.ast.tools
+
+import org.codehaus.groovy.ast.ClassNode
+import org.codehaus.groovy.ast.GenericsType
+import org.codehaus.groovy.control.CompilationUnit
+import org.codehaus.groovy.control.Phases
+
+class GenericsUtilsTest extends GroovyTestCase {
+    void testFindParameterizedType1() {
+        def code = '''
+        class Base<T, S> {}
+        class Derived extends Base<String, List> {}
+        '''
+        def ast = new CompilationUnit().tap {
+            addSource 'hello.groovy', code
+            compile Phases.SEMANTIC_ANALYSIS
+        }.ast
+
+        def classNodeList = ast.getModules()[0].getClasses()
+        ClassNode genericsClass = findClassNode('Base', classNodeList)
+        ClassNode actualReceiver = findClassNode('Derived', classNodeList)
+
+        ClassNode parameterizedClass = GenericsUtils.findParameterizedType(genericsClass, actualReceiver)
+        assert parameterizedClass.isUsingGenerics()
+        assert 'Base' == parameterizedClass.name
+        GenericsType[] genericsTypes = parameterizedClass.getGenericsTypes()
+        assert 2 == genericsTypes.length
+        assert 'java.lang.String' == genericsTypes[0].type.name
+        assert 'java.util.List' == genericsTypes[1].type.name
+        assert genericsClass.is(parameterizedClass.redirect())
+    }
+
+    void testFindParameterizedType2() {
+        def code = '''
+        class Base<T, S> {}
+        class Derived2 extends Base<String, List> {}
+        class Derived extends Derived2 {}
+        '''
+        def ast = new CompilationUnit().tap {
+            addSource 'hello.groovy', code
+            compile Phases.SEMANTIC_ANALYSIS
+        }.ast
+
+        def classNodeList = ast.getModules()[0].getClasses()
+        ClassNode genericsClass = findClassNode('Base', classNodeList)
+        ClassNode actualReceiver = findClassNode('Derived', classNodeList)
+
+        ClassNode parameterizedClass = GenericsUtils.findParameterizedType(genericsClass, actualReceiver)
+        assert parameterizedClass.isUsingGenerics()
+        assert 'Base' == parameterizedClass.name
+        GenericsType[] genericsTypes = parameterizedClass.getGenericsTypes()
+        assert 2 == genericsTypes.length
+        assert 'java.lang.String' == genericsTypes[0].type.name
+        assert 'java.util.List' == genericsTypes[1].type.name
+        assert genericsClass.is(parameterizedClass.redirect())
+    }
+
+    void testFindParameterizedType3() {
+        def code = '''
+        class Base0 {}
+        class Base<T, S> extends Base0 {}
+        class Derived2 extends Base<String, List> {}
+        class Derived extends Derived2 {}
+        '''
+        def ast = new CompilationUnit().tap {
+            addSource 'hello.groovy', code
+            compile Phases.SEMANTIC_ANALYSIS
+        }.ast
+
+        def classNodeList = ast.getModules()[0].getClasses()
+        ClassNode genericsClass = findClassNode('Base', classNodeList)
+        ClassNode actualReceiver = findClassNode('Derived', classNodeList)
+
+        ClassNode parameterizedClass = GenericsUtils.findParameterizedType(genericsClass, actualReceiver)
+        assert parameterizedClass.isUsingGenerics()
+        assert 'Base' == parameterizedClass.name
+        GenericsType[] genericsTypes = parameterizedClass.getGenericsTypes()
+        assert 2 == genericsTypes.length
+        assert 'java.lang.String' == genericsTypes[0].type.name
+        assert 'java.util.List' == genericsTypes[1].type.name
+        assert genericsClass.is(parameterizedClass.redirect())
+    }
+
+    void testFindParameterizedType4() {
+        def code = '''
+        interface Base<T, S> {}
+        class Derived2 implements Base<String, List> {}
+        class Derived extends Derived2 {}
+        '''
+        def ast = new CompilationUnit().tap {
+            addSource 'hello.groovy', code
+            compile Phases.SEMANTIC_ANALYSIS
+        }.ast
+
+        def classNodeList = ast.getModules()[0].getClasses()
+        ClassNode genericsClass = findClassNode('Base', classNodeList)
+        ClassNode actualReceiver = findClassNode('Derived', classNodeList)
+
+        ClassNode parameterizedClass = GenericsUtils.findParameterizedType(genericsClass, actualReceiver)
+        assert parameterizedClass.isUsingGenerics()
+        assert 'Base' == parameterizedClass.name
+        GenericsType[] genericsTypes = parameterizedClass.getGenericsTypes()
+        assert 2 == genericsTypes.length
+        assert 'java.lang.String' == genericsTypes[0].type.name
+        assert 'java.util.List' == genericsTypes[1].type.name
+        assert genericsClass.is(parameterizedClass.redirect())
+    }
+
+    void testFindParameterizedType5() {
+        def code = '''
+        interface Base<T, S> {}
+        interface Base2 extends Base<String, List> {}
+        class Derived2 implements Base2 {}
+        class Derived extends Derived2 {}
+        '''
+        def ast = new CompilationUnit().tap {
+            addSource 'hello.groovy', code
+            compile Phases.SEMANTIC_ANALYSIS
+        }.ast
+
+        def classNodeList = ast.getModules()[0].getClasses()
+        ClassNode genericsClass = findClassNode('Base', classNodeList)
+        ClassNode actualReceiver = findClassNode('Derived', classNodeList)
+
+        ClassNode parameterizedClass = GenericsUtils.findParameterizedType(genericsClass, actualReceiver)
+        assert parameterizedClass.isUsingGenerics()
+        assert 'Base' == parameterizedClass.name
+        GenericsType[] genericsTypes = parameterizedClass.getGenericsTypes()
+        assert 2 == genericsTypes.length
+        assert 'java.lang.String' == genericsTypes[0].type.name
+        assert 'java.util.List' == genericsTypes[1].type.name
+        assert genericsClass.is(parameterizedClass.redirect())
+    }
+
+    void testFindParameterizedType6() {
+        def code = '''
+        interface Base<T, S> {}
+        interface Base2 extends Base<String, List> {}
+        class Derived2 implements Base2 {}
+        class Derived3 extends Derived2 {}
+        class Derived extends Derived3 {}
+        '''
+        def ast = new CompilationUnit().tap {
+            addSource 'hello.groovy', code
+            compile Phases.SEMANTIC_ANALYSIS
+        }.ast
+
+        def classNodeList = ast.getModules()[0].getClasses()
+        ClassNode genericsClass = findClassNode('Base', classNodeList)
+        ClassNode actualReceiver = findClassNode('Derived', classNodeList)
+
+        ClassNode parameterizedClass = GenericsUtils.findParameterizedType(genericsClass, actualReceiver)
+        assert parameterizedClass.isUsingGenerics()
+        assert 'Base' == parameterizedClass.name
+        GenericsType[] genericsTypes = parameterizedClass.getGenericsTypes()
+        assert 2 == genericsTypes.length
+        assert 'java.lang.String' == genericsTypes[0].type.name
+        assert 'java.util.List' == genericsTypes[1].type.name
+        assert genericsClass.is(parameterizedClass.redirect())
+    }
+
+    void testFindParameterizedType7() {
+        def code = '''
+        interface Base0 {}
+        interface Base<T, S> extends Base0 {}
+        interface Base2 extends Base<String, List> {}
+        class Derived2 implements Base2 {}
+        class Derived3 extends Derived2 {}
+        class Derived extends Derived3 {}
+        '''
+        def ast = new CompilationUnit().tap {
+            addSource 'hello.groovy', code
+            compile Phases.SEMANTIC_ANALYSIS
+        }.ast
+
+        def classNodeList = ast.getModules()[0].getClasses()
+        ClassNode genericsClass = findClassNode('Base', classNodeList)
+        ClassNode actualReceiver = findClassNode('Derived', classNodeList)
+
+        ClassNode parameterizedClass = GenericsUtils.findParameterizedType(genericsClass, actualReceiver)
+        assert parameterizedClass.isUsingGenerics()
+        assert 'Base' == parameterizedClass.name
+        GenericsType[] genericsTypes = parameterizedClass.getGenericsTypes()
+        assert 2 == genericsTypes.length
+        assert 'java.lang.String' == genericsTypes[0].type.name
+        assert 'java.util.List' == genericsTypes[1].type.name
+        assert genericsClass.is(parameterizedClass.redirect())
+    }
+
+    static ClassNode findClassNode(String name, List<ClassNode> classNodeList) {
+        return classNodeList.find { it.name == name }
+    }
+}

Commit:
936a7a9fc5547f9a41ebdf7091061f00dbaee151
Paul King
paulk@asert.com.au
2018-05-11 01:51:02 +1000
GROOVY-8576 Remove Java2GroovyMain dependency on commons-cli
diff --git a/src/main/java/org/codehaus/groovy/antlr/java/Java2GroovyMain.java b/src/main/java/org/codehaus/groovy/antlr/java/Java2GroovyMain.java
index d7384e0a6a..3cd02a713c 100644
--- a/src/main/java/org/codehaus/groovy/antlr/java/Java2GroovyMain.java
+++ b/src/main/java/org/codehaus/groovy/antlr/java/Java2GroovyMain.java
@@ -18,25 +18,16 @@
  */
 package org.codehaus.groovy.antlr.java;
 
-import org.apache.commons.cli.CommandLine;
-import org.apache.commons.cli.CommandLineParser;
-import org.apache.commons.cli.DefaultParser;
-import org.apache.commons.cli.Options;
-
 import java.util.Arrays;
 
 public class Java2GroovyMain {
 
     public static void main(String[] args) {
         try {
-            Options options = new Options();
-            CommandLineParser cliParser = new DefaultParser();
-            CommandLine cli = cliParser.parse(options, args);
-            String[] filenames = cli.getArgs();
-            if (filenames.length == 0) {
+            if (args.length == 0) {
                 System.err.println("Needs at least one filename");
             }
-            Java2GroovyProcessor.processFiles(Arrays.asList(filenames));
+            Java2GroovyProcessor.processFiles(Arrays.asList(args));
         } catch (Throwable t) {
             t.printStackTrace();
         }

Commit:
e7766ffad4a70377a2e80b2a797261b0cb197ed4
sunlan
sunlan@apache.org
2018-05-10 19:20:16 +0800
Simplify finding generics implementation class
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 6da4abc1dd..fa924a696b 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1215,29 +1215,29 @@ public abstract class StaticTypeCheckingSupport {
      * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
      * so we need actual types:  T: String, S: Long
      */
-    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
-        GenericsType[] declaringGenericsTypes = declaringClassForDistance.getGenericsTypes();
-        GenericsType[] actualGenericsTypes = actualReceiverForDistance.getGenericsTypes();
+    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
+        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
+        GenericsType[] actualGenericsTypes = actualReceiver.getGenericsTypes();
 
         if (null == declaringGenericsTypes) {
             return Collections.emptyMap();
         }
 
         if (null == actualGenericsTypes) {
-            List<ClassNode> superClassAndInterfaceList = getAllSuperClassesAndInterfaces(actualReceiverForDistance);
+            List<ClassNode> superClassAndInterfaceList = getAllSuperClassesAndInterfaces(actualReceiver);
 
             for (ClassNode cn : superClassAndInterfaceList) {
-                if (cn.isDerivedFrom(declaringClassForDistance)) {
+                if (declaringClass.equals(cn.redirect())) {
                     actualGenericsTypes = cn.getGenericsTypes();
 
-                    if (null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length) {
+                    if (isGenericsTypeArraysLengthEqual(declaringGenericsTypes, actualGenericsTypes)) {
                         break;
                     }
                 }
             }
         }
 
-        if (null == actualGenericsTypes || declaringGenericsTypes.length != actualGenericsTypes.length) {
+        if (!isGenericsTypeArraysLengthEqual(declaringGenericsTypes, actualGenericsTypes)) {
             return Collections.emptyMap();
         }
 
@@ -1249,11 +1249,15 @@ public abstract class StaticTypeCheckingSupport {
         return result;
     }
 
-    private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiverForDistance) {
+    private static boolean isGenericsTypeArraysLengthEqual(GenericsType[] declaringGenericsTypes, GenericsType[] actualGenericsTypes) {
+        return null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length;
+    }
+
+    private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiver) {
         List<ClassNode> superClassAndInterfaceList = new LinkedList<>();
-        List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiverForDistance);
+        List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiver);
         superClassAndInterfaceList.addAll(allSuperClassNodeList);
-        superClassAndInterfaceList.addAll(actualReceiverForDistance.getAllInterfaces());
+        superClassAndInterfaceList.addAll(actualReceiver.getAllInterfaces());
 
         for (ClassNode superClassNode : allSuperClassNodeList) {
             superClassAndInterfaceList.addAll(superClassNode.getAllInterfaces());
@@ -1262,10 +1266,10 @@ public abstract class StaticTypeCheckingSupport {
         return superClassAndInterfaceList;
     }
 
-    private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiverForDistance) {
+    private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiver) {
         List<ClassNode> superClassNodeList = new LinkedList<>();
 
-        for (ClassNode cn = actualReceiverForDistance.getUnresolvedSuperClass(); null != cn && ClassHelper.OBJECT_TYPE != cn; cn = cn.getUnresolvedSuperClass()) {
+        for (ClassNode cn = actualReceiver.getUnresolvedSuperClass(); null != cn && ClassHelper.OBJECT_TYPE != cn; cn = cn.getUnresolvedSuperClass()) {
             superClassNodeList.add(cn);
         }
 

Commit:
7757065964922ee344e362b18413a0012308088b
sunlan
sunlan@apache.org
2018-05-10 16:31:46 +0800
Add documentation for metaclasses(closes #698)
diff --git a/gradle/asciidoctor.gradle b/gradle/asciidoctor.gradle
index 0718f5e21c..90f352bbde 100644
--- a/gradle/asciidoctor.gradle
+++ b/gradle/asciidoctor.gradle
@@ -51,6 +51,7 @@ asciidoctor {
                 jdk: "http://docs.oracle.com/javase/8/docs/api/index.html",
                 gjdk: "http://docs.groovy-lang.org/${version}/html/groovy-jdk/index.html",
                 gapi: "http://docs.groovy-lang.org/${version}/html/gapi/index.html",
+                gapid:  "http://docs.groovy-lang.org/${version}/html/gapi/",
         ]
 
         baseUrls.each { macroName, baseURL ->
@@ -59,12 +60,23 @@ asciidoctor {
                     def (className, anchor) = target.split('#') as List
                     options = [
                             "type"  : ":link",
-                            "target": calculateDocUrl(baseURL, className, anchor)
+                            "target": calculateDocUrl(baseURL, className, anchor),
                     ]
 
                     createInline(parent, "anchor", attributes.text?:target, attributes, options).render()
             }
         }
+
+        inlinemacro('gapid') { parent, target, attributes ->
+            def (className, anchor) = target.split('#') as List
+
+            def partialUrl = { -> className.replace('.', '/') + '.html' + (anchor ? '#' + anchor.replace(',',', ') : '')}
+            options = [
+                    "type": ":link",
+                    "target": "${baseUrls['gapid']}${partialUrl()}",
+            ]
+            createInline(parent, "anchor", attributes.text?:target, attributes, options).render()
+        }
     }
 }
 
@@ -148,4 +160,4 @@ String calculateDocUrl(String baseUrl, String className, String anchor) {
     if (className == "index") return baseUrl
 
     return baseUrl + "?" + className.replace('.', '/') + '.html' + (anchor ? '#' + anchor : '')
-}
+}
\ No newline at end of file
diff --git a/src/spec/doc/core-metaprogramming.adoc b/src/spec/doc/core-metaprogramming.adoc
index 960e98a9a7..0247589c84 100644
--- a/src/spec/doc/core-metaprogramming.adoc
+++ b/src/spec/doc/core-metaprogramming.adoc
@@ -345,24 +345,122 @@ There is a distinct section on `@Category` in the <<core-metaprogramming.adoc#xf
 
 === Metaclasses
 
-(TBD)
+As explained in other section, Metaclasses has a central role in the method resolution. For every method invocation from groovy code, Groovy will find the `MetaClass` for the given object and delegate the method resolution to the metaclass via gapid:groovy.lang.MetaClass#invokeMethod(java.lang.Class,java.lang.Object,java.lang.String,java.lang.Object,boolean,boolean)[MetaClass#invokeMethod] which should not be confused with gapid:groovy.lang.GroovyObject#invokeMethod(java.lang.String,java.lang.Object)[GroovyObject#invokeMethod].
+
+
+==== The default metaclass `MetaClassImpl`
+By default objects get an instance of `MetaClassImpl` that implements the default method lookup. This method lookup includes looking up of the method in the object class ("regular" method) but also if no method is found this way it will resort to calling `methodMissing` and ultimately gapid:groovy.lang.GroovyObject.html#invokeMethod(java.lang.String,java.lang.Object)[GroovyObject#invokeMethod]
+
+
+[source,groovy]
+----
+class Foo {}
+
+def f = new Foo()
+
+assert f.metaClass =~ /MetaClassImpl/
+----
+
+
 
 ==== Custom metaclasses
 
-(TBD)
+You can change the metaclass of any object or class and replace with a custom implementation of the `MetaClass` gapi:groovy.lang.MetaClass[interface]. Usually you will want to subclass one of the existing metaclasses `MetaClassImpl`, `DelegatingMetaClass`, `ExpandoMetaClass`, `ProxyMetaClass`, etc. otherwise you will need to implement the complete method lookup logic. Before using a new metaclass instance you should call  gapid:groovy.lang.MetaClass#initialize()[] otherwise the metaclass may or may not behave as expected.
 
 ===== Delegating metaclass
 
-(TBD)
+If you only need to decorate an existing metaclass the `DelegatingMetaClass` simplifies that use case. The old metaclass implementation is still accessible via `super` making easy to apply pretransformations to the inputs, routing to other methods and postprocess the outputs.
 
-===== Magic package (Maksym Stavytskyi)
+[source,groovy]
+----
+class Foo { def bar() { "bar" } }
+
+class MyFooMetaClass extends DelegatingMetaClass {
+  MyFooMetaClass(MetaClass metaClass) { super(metaClass) }
+  MyFooMetaClass(Class theClass) { super(theClass) }
+
+  Object invokeMethod(Object object, String methodName, Object[] args) {
+     def result = super.invokeMethod(object,methodName.toLowerCase(), args)
+     result.toUpperCase();
+  }
+}
+
+
+def mc =  new MyFooMetaClass(Foo.metaClass)
+mc.initialize()
+
+Foo.metaClass = mc
+def f = new Foo()
+
+assert f.BAR() == "BAR" // the new metaclass routes .BAR() to .bar() and uppercases the result
+----
+
+===== Magic package
+
+It is possible to change the metaclass at startup time by giving the metaclass a specially crafted (magic) class name  and package name. In order to change the metaclass for `java.lang.Integer` it's enough to put a class `groovy.runtime.metaclass.java.lang.IntegerMetaClass` in the classpath. This is useful, for example,  when working with frameworks if you want to to metaclass changes before your code is executed by the framework. The general form of the magic package is `groovy.runtime.metaclass.[package].[class]MetaClass`. In the example below the `[package]` is `java.lang` and the `[class]` is `Integer`:
+
+
+[source,groovy]
+----
+// file: IntegerMetaClass.groovy
+package groovy.runtime.metaclass.java.lang;
+
+class IntegerMetaClass extends DelegatingMetaClass {
+  IntegerMetaClass(MetaClass metaClass) { super(metaClass) }
+  IntegerMetaClass(Class theClass) { super(theClass) }
+  Object invokeMethod(Object object, String name, Object[] args) {
+    if (name =~ /isBiggerThan/) {
+      def other = name.split(/isBiggerThan/)[1].toInteger()
+      object > other
+    } else {
+      return super.invokeMethod(object,name, args);
+    }
+  }
+}
+----
+
+By compiling the above file with `groovyc IntegerMetaClass.groovy` a `./groovy/runtime/metaclass/java/lang/IntegerMetaClass.class` will be generated. The example below will use this new metaclass:
+
+[source,groovy]
+----
+// File testInteger.groovy
+def i = 10
+
+assert i.isBiggerThan5()
+assert !i.isBiggerThan15()
+
+println i.isBiggerThan5()
+----
+
+By running that file with `groovy -cp . testInteger.groovy` the `IntegerMetaClass` will be in the classpath and therefore it will become the metaclass for `java.lang.Integer` intercepting the method calls to `isBiggerThan*()` methods.
 
-(TBD)
 
 ==== Per instance metaclass
 
-(TBD)
+You can change the metaclass of individual objects separately, so it's possible to have multiple object of the same class with different metaclasses.
+
+[source,groovy]
+----
+class Foo { def bar() { "bar" }}
+
+class FooMetaClass extends DelegatingMetaClass {
+  FooMetaClass(MetaClass metaClass) { super(metaClass) }
+  Object invokeMethod(Object object, String name, Object[] args) {
+      super.invokeMethod(object,name,args).toUpperCase()
+  }
+}
+
+def f1 = new Foo()
+def f2 = new Foo()
+f2.metaClass = new FooMetaClass(f2.metaClass)
 
+assert f1.bar() == "bar"
+assert f2.bar() == "BAR"
+assert f1.metaClass =~ /MetaClassImpl/
+assert f2.metaClass =~ /FooMetaClass/
+assert f1.class.toString() == "class Foo"
+assert f2.class.toString() == "class Foo"
+----
 
 [[metaprogramming_emc]]
 ==== ExpandoMetaClass

Commit:
6d5bc0db7a0e8c8c69911d7e4f064e9a27ba40a6
sunlan
sunlan@apache.org
2018-05-10 15:46:37 +0800
GROOVY-7204: Static type checking and compilation fail when multiple generics in use(closes #699)
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index bc413a0054..6da4abc1dd 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -20,6 +20,7 @@
 package org.codehaus.groovy.transform.stc;
 
 import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.ast.MethodNode;
@@ -72,6 +73,7 @@ import java.util.UUID;
 import java.util.WeakHashMap;
 import java.util.regex.Matcher;
 
+import static java.lang.Math.min;
 import static org.codehaus.groovy.ast.ClassHelper.BigDecimal_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.BigInteger_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.Boolean_TYPE;
@@ -441,7 +443,7 @@ public abstract class StaticTypeCheckingSupport {
         ClassNode ptype = lastParamType.getComponentType();
         ClassNode arg = args[args.length - 1];
         if (isNumberType(ptype) && isNumberType(arg) && !ptype.equals(arg)) return -1;
-        return isAssignableTo(arg, ptype) ? Math.min(getDistance(arg, lastParamType), getDistance(arg, ptype)) : -1;
+        return isAssignableTo(arg, ptype) ? min(getDistance(arg, lastParamType), getDistance(arg, ptype)) : -1;
     }
 
     /**
@@ -1097,7 +1099,8 @@ public abstract class StaticTypeCheckingSupport {
                 Person p = foo(b)
              */
 
-            Parameter[] params = makeRawTypes(safeNode.getParameters());
+            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
+            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringAndActualGenericsTypeMap);
             int dist = measureParametersAndArgumentsDistance(params, safeArgs);
             if (dist >= 0) {
                 dist += getClassDistance(declaringClassForDistance, actualReceiverForDistance);
@@ -1187,11 +1190,95 @@ public abstract class StaticTypeCheckingSupport {
         return isExtensionMethodNode ? 0 : 1;
     }
 
-    private static Parameter[] makeRawTypes(Parameter[] params) {
+    private static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
+        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
+            GenericsType declaringGenericsType = entry.getKey();
+
+            if (placeholderName.equals(declaringGenericsType.getName())) {
+                return entry.getValue().getType();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
+     * declaring generics types:      T,      S extends Serializable
+     * actual generics types   : String,      Long
+     *
+     * the result map is [
+     *  T: String,
+     *  S: Long
+     * ]
+     *
+     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
+     * so we need actual types:  T: String, S: Long
+     */
+    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
+        GenericsType[] declaringGenericsTypes = declaringClassForDistance.getGenericsTypes();
+        GenericsType[] actualGenericsTypes = actualReceiverForDistance.getGenericsTypes();
+
+        if (null == declaringGenericsTypes) {
+            return Collections.emptyMap();
+        }
+
+        if (null == actualGenericsTypes) {
+            List<ClassNode> superClassAndInterfaceList = getAllSuperClassesAndInterfaces(actualReceiverForDistance);
+
+            for (ClassNode cn : superClassAndInterfaceList) {
+                if (cn.isDerivedFrom(declaringClassForDistance)) {
+                    actualGenericsTypes = cn.getGenericsTypes();
+
+                    if (null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length) {
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (null == actualGenericsTypes || declaringGenericsTypes.length != actualGenericsTypes.length) {
+            return Collections.emptyMap();
+        }
+
+        Map<GenericsType, GenericsType> result = new HashMap<>();
+        for (int i = 0, n = declaringGenericsTypes.length; i < n; i++) {
+            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
+        }
+
+        return result;
+    }
+
+    private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiverForDistance) {
+        List<ClassNode> superClassAndInterfaceList = new LinkedList<>();
+        List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiverForDistance);
+        superClassAndInterfaceList.addAll(allSuperClassNodeList);
+        superClassAndInterfaceList.addAll(actualReceiverForDistance.getAllInterfaces());
+
+        for (ClassNode superClassNode : allSuperClassNodeList) {
+            superClassAndInterfaceList.addAll(superClassNode.getAllInterfaces());
+        }
+
+        return superClassAndInterfaceList;
+    }
+
+    private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiverForDistance) {
+        List<ClassNode> superClassNodeList = new LinkedList<>();
+
+        for (ClassNode cn = actualReceiverForDistance.getUnresolvedSuperClass(); null != cn && ClassHelper.OBJECT_TYPE != cn; cn = cn.getUnresolvedSuperClass()) {
+            superClassNodeList.add(cn);
+        }
+
+        return superClassNodeList;
+    }
+
+    private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
         Parameter[] newParam = new Parameter[params.length];
         for (int i = 0; i < params.length; i++) {
             Parameter oldP = params[i];
-            Parameter newP = new Parameter(makeRawType(oldP.getType()), oldP.getName());
+
+            ClassNode actualType = findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
+            Parameter newP = new Parameter(makeRawType(null == actualType ? oldP.getType() : actualType), oldP.getName());
             newParam[i] = newP;
         }
         return newParam;
@@ -1522,7 +1609,7 @@ public abstract class StaticTypeCheckingSupport {
         Set<String> fixedGenericsPlaceHolders = extractResolvedPlaceHolders(resolvedMethodGenerics);
 
         for (int i = 0; i < arguments.length; i++) {
-            int pindex = Math.min(i, parameters.length - 1);
+            int pindex = min(i, parameters.length - 1);
             ClassNode wrappedArgument = arguments[i];
             ClassNode type = parameters[pindex].getOriginType();
 
diff --git a/src/spec/test/typing/TypeCheckingTest.groovy b/src/spec/test/typing/TypeCheckingTest.groovy
index f32ca3f6a3..fc87413438 100644
--- a/src/spec/test/typing/TypeCheckingTest.groovy
+++ b/src/spec/test/typing/TypeCheckingTest.groovy
@@ -685,7 +685,7 @@ import static org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound
             }
             // end::flowtyping_typeconstraints_failure[]
             flowTypingWithExplicitType()
-        ''', 'Cannot call java.util.List <java.lang.String>#add(java.lang.String) with arguments [int]'
+        ''', '[Static type checking] - Cannot find matching method java.util.List#add(int)'
 
         assertScript '''
             // tag::flowtyping_typeconstraints_fixed[]
diff --git a/src/test/groovy/bugs/Groovy7204Bug.groovy b/src/test/groovy/bugs/Groovy7204Bug.groovy
new file mode 100644
index 0000000000..09375ac772
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7204Bug.groovy
@@ -0,0 +1,546 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy7204Bug extends GroovyTestCase {
+    void testTypeChecked1() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @TypeChecked
+        interface MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked2() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @TypeChecked
+        abstract class MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked3() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @TypeChecked
+        interface MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        interface MyRepository extends MyRepository2 {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked4() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @TypeChecked
+        abstract class MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked5() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @TypeChecked
+        abstract class MyRepository2 implements CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+
+    void testCompileStatic1() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @CompileStatic
+        interface MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic2() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @CompileStatic
+        abstract class MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic3() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @CompileStatic
+        interface MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        interface MyRepository extends MyRepository2 {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic4() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @CompileStatic
+        abstract class MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic5() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @CompileStatic
+        abstract class MyRepository2 implements CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic6() {
+        assertScript '''
+        import java.io.Serializable;
+        import groovy.transform.CompileStatic;
+
+        @CompileStatic
+        class Repository<T, S extends Serializable> {
+            void delete(T arg) { assert true }
+            void delete(S arg) { assert false: 'wrong method invoked' }
+        }
+        
+        @CompileStatic
+        def test() {
+            Repository<String, Long> r = new Repository<String, Long>()
+            r.delete('foo')
+        }
+        
+        test()
+        '''
+    }
+}
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index a35506caf3..9c42e3e9da 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -50,7 +50,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<String> list = []
             list.add(1)
-        ''', "Cannot call java.util.List <String>#add(java.lang.String) with arguments [int]"
+        ''', "[Static type checking] - Cannot find matching method java.util.List#add(int)"
     }
 
     void testAddOnList2() {
@@ -76,7 +76,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<String> list = []
             list << 1
-        ''', 'Cannot call <T> java.util.List <String>#leftShift(T) with arguments [int]'
+        ''', '[Static type checking] - Cannot find matching method java.util.List#leftShift(int)'
     }
 
     void testAddOnList2UsingLeftShift() {
@@ -116,14 +116,14 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<Integer> list = new LinkedList<>()
             list.add 'Hello'
-        ''', 'Cannot call java.util.LinkedList <java.lang.Integer>#add(java.lang.Integer) with arguments [java.lang.String]'
+        ''', '[Static type checking] - Cannot find matching method java.util.LinkedList#add(java.lang.String)'
     }
 
     void testAddOnListWithDiamondAndWrongTypeUsingLeftShift() {
         shouldFailWithMessages '''
             List<Integer> list = new LinkedList<>()
             list << 'Hello'
-        ''', 'Cannot call <T> java.util.LinkedList <java.lang.Integer>#leftShift(T) with arguments [java.lang.String]'
+        ''', '[Static type checking] - Cannot find matching method java.util.LinkedList#leftShift(java.lang.String)'
     }
 
     void testAddOnListWithDiamondAndNullUsingLeftShift() {
@@ -424,7 +424,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Map<String, Integer> map = new HashMap<String,Integer>()
             map.put('hello', new Object())
-        ''', 'Cannot call java.util.HashMap <String, Integer>#put(java.lang.String, java.lang.Integer) with arguments [java.lang.String, java.lang.Object]'
+        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.lang.String, java.lang.Object)'
     }
 
     void testPutMethodWithPrimitiveValueAndArrayPut() {
@@ -749,7 +749,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map.put('foo', new Date())
-        ''', 'Cannot call java.util.HashMap <java.util.Date, java.util.Date>#put(java.util.Date, java.util.Date) with arguments [java.lang.String, java.util.Date]'
+        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.lang.String, java.util.Date)'
     }
     void testInferDiamondForAssignmentWithDatesAndIllegalKeyUsingSquareBracket() {
         shouldFailWithMessages '''
@@ -787,7 +787,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map.put(new Date(), 'foo')
-        ''', 'Cannot call java.util.HashMap <java.util.Date, java.util.Date>#put(java.util.Date, java.util.Date) with arguments [java.util.Date, java.lang.String]'
+        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.util.Date, java.lang.String)'
     }
     void testInferDiamondForAssignmentWithDatesAndIllegalValueUsingSquareBracket() {
         shouldFailWithMessages '''
@@ -1306,7 +1306,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 Foo<Map> f = new Foo<Map>("a",1)
             }
             bar()
-        ''', '[Static type checking] - Cannot call Foo <Map>#<init>(java.util.Map, java.util.Map) with arguments [java.lang.String, int]'
+        ''', '[Static type checking] - Cannot find matching method Foo#<init>(java.lang.String, int)'
     }
     
     // Groovy-5742
diff --git a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
index 123c91d615..8b69d07844 100644
--- a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
@@ -221,7 +221,7 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
             assert op.toString() == '3|DOWN'
         """
         assert message.contains('Cannot call OrderPublisher <RoundingMode>#<init>(java.util.Deque <java.lang.Integer>) with arguments [java.util.LinkedList <String>]')
-        assert message.contains('Cannot call OrderPublisher <RoundingMode>#<init>(java.math.RoundingMode) with arguments [java.util.Date]')
+        assert message.contains('Cannot find matching method OrderPublisher#<init>(java.util.Date)')
         assert message.contains('Cannot call OrderPublisher <RoundingMode>#<init>(java.util.Set <RoundingMode>) with arguments [java.util.HashSet <Date>]')
     }
 

Commit:
84771d3b0b731add85a4b8f6d52f4ebc04e2e796
sunlan
sunlan@apache.org
2018-05-09 18:56:41 +0800
Revert "GROOVY-8543: Support setting compileStatic by default via system properties"
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 749f8797f4..3de7535a20 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -19,11 +19,6 @@
 package org.codehaus.groovy.control;
 
 import org.apache.groovy.util.Maps;
-import org.codehaus.groovy.ast.AnnotationNode;
-import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
-import org.codehaus.groovy.ast.ClassHelper;
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.control.customizers.CompilationCustomizer;
 import org.codehaus.groovy.control.io.NullWriter;
 import org.codehaus.groovy.control.messages.WarningMessage;
@@ -899,51 +894,55 @@ public class CompilerConfiguration {
         return indyEnabled;
     }
 
-    {
-        // this object initializer assures that `enableCompileStaticByDefault` must be invoked no matter which constructor called.
-        if (getBooleanSafe("groovy.compile.static")) {
-            enableCompileStaticByDefault();
-        }
-    }
-
-    private void enableCompileStaticByDefault() {
-        compilationCustomizers.add(
-            new CompilationCustomizer(CompilePhase.CONVERSION) {
-                @Override
-                public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {
-                    for (ClassNode cn : source.getAST().getClasses()) {
-                        newClassCodeVisitor(source).visitClass(cn);
-                    }
-                }
-
-                private ClassCodeVisitorSupport newClassCodeVisitor(SourceUnit source) {
-                    return new ClassCodeVisitorSupport() {
-                        @Override
-                        public void visitClass(ClassNode node) {
-                            enableCompileStatic(node);
-                        }
-
-                        private void enableCompileStatic(ClassNode classNode) {
-                            if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
-                                return;
-                            }
-                            if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
-                                return;
-                            }
-
-                            classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)));
-                        }
-
-                        @Override
-                        protected SourceUnit getSourceUnit() {
-                            return source;
-                        }
-
-                        private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
-                        private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
-                    };
-                }
-            }
-        );
-    }
+//       See http://groovy.329449.n5.nabble.com/What-the-static-compile-by-default-tt5750118.html
+//           https://issues.apache.org/jira/browse/GROOVY-8543
+//
+//    {
+//        // this object initializer assures that `enableCompileStaticByDefault` must be invoked no matter which constructor called.
+//        if (getBooleanSafe("groovy.compile.static")) {
+//            enableCompileStaticByDefault();
+//        }
+//    }
+//
+//
+//    private void enableCompileStaticByDefault() {
+//        compilationCustomizers.add(
+//            new CompilationCustomizer(CompilePhase.CONVERSION) {
+//                @Override
+//                public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {
+//                    for (ClassNode cn : source.getAST().getClasses()) {
+//                        newClassCodeVisitor(source).visitClass(cn);
+//                    }
+//                }
+//
+//                private ClassCodeVisitorSupport newClassCodeVisitor(SourceUnit source) {
+//                    return new ClassCodeVisitorSupport() {
+//                        @Override
+//                        public void visitClass(ClassNode node) {
+//                            enableCompileStatic(node);
+//                        }
+//
+//                        private void enableCompileStatic(ClassNode classNode) {
+//                            if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
+//                                return;
+//                            }
+//                            if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
+//                                return;
+//                            }
+//
+//                            classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)));
+//                        }
+//
+//                        @Override
+//                        protected SourceUnit getSourceUnit() {
+//                            return source;
+//                        }
+//
+//                        private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
+//                        private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
+//                    };
+//                }
+//            }
+//        );
+//    }
 }

Commit:
2e31936d2258fce130102a0097bd40d54d5646c2
sunlan
sunlan@apache.org
2018-05-09 18:49:50 +0800
Fix a potential NPE introduced when extracting common variable
diff --git a/subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/methods/MacroGroovyMethods.java b/subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/methods/MacroGroovyMethods.java
index 2a14a30e51..6a8480ee33 100644
--- a/subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/methods/MacroGroovyMethods.java
+++ b/subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/methods/MacroGroovyMethods.java
@@ -195,8 +195,8 @@ public class MacroGroovyMethods {
     protected static ClosureExpression getClosureArgument(SourceUnit source, MethodCallExpression call) {
         TupleExpression tupleArguments = getMacroArguments(source, call);
 
-        int size = tupleArguments.getExpressions().size();
-        if (tupleArguments == null || size < 1) {
+        int size = tupleArguments == null ? -1 : tupleArguments.getExpressions().size();
+        if (size < 1) {
             source.addError(new SyntaxException("Call arguments should have at least one argument" + '\n', tupleArguments));
             return null;
         }

Commit:
91f44d85916861e762be5f4aa87b8f4f27e948d3
sunlan
sunlan@apache.org
2018-05-07 09:27:30 +0800
Add test for "GROOVY-8138: Compile static to support streams"
diff --git a/src/test/groovy/bugs/Groovy8138Bug.groovy b/src/test/groovy/bugs/Groovy8138Bug.groovy
new file mode 100644
index 0000000000..e89ac25669
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8138Bug.groovy
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy8138Bug extends GroovyTestCase {
+    void test() {
+        assertScript '''
+            import groovy.transform.CompileStatic
+            
+            import static java.util.stream.Collectors.toList
+            
+            @CompileStatic
+            class Test {
+                static void main(String[] args) {
+                    List<String> tables = ['a', 'b']
+                    assert ['a'] == tables.stream().filter { tableName -> tableName.contains('a') }.collect(toList())
+                }
+            }
+        '''
+    }
+}

Commit:
ad664b181249c4b8e8821003d7e750632943ce36
sunlan
sunlan@apache.org
2018-05-04 07:48:54 +0800
GROOVY-3867: Allow methodMissing/propertyMissing to be defined through category(closes #693)
diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index c798f7615e..66abb2d6a2 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -945,6 +945,14 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 onInvokeMethodFoundInHierarchy(method);
                 return method.invoke(instance, invokeMethodArgs);
             }
+
+            // last resort look in the category
+            if (method == null && GroovyCategorySupport.hasCategoryInCurrentThread()) {
+                method = getCategoryMethodMissing(instanceKlazz);
+                if (method != null) {
+                    return method.invoke(instance, new Object[]{methodName, arguments});
+                }
+            }
         }
 
         if (methodMissing != null) {
@@ -1866,11 +1874,18 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             }
         }
 
+        // check for propertyMissing provided through a category
+        Object[] arguments = EMPTY_ARGUMENTS;
+        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {
+            method = getCategoryMethodGetter(sender, "propertyMissing", true);
+            if (method != null) arguments = new Object[]{name};
+        }
+
+
         //----------------------------------------------------------------------
         // generic get method
         //----------------------------------------------------------------------
         // check for a generic get method provided through a category
-        Object[] arguments = EMPTY_ARGUMENTS;
         if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {
             method = getCategoryMethodGetter(sender, "get", true);
             if (method != null) arguments = new Object[]{name};
@@ -2097,6 +2112,24 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         return new Tuple2<MetaMethod, MetaProperty>(method, mp);
     }
 
+
+    private static MetaMethod getCategoryMethodMissing(Class sender) {
+        List possibleGenericMethods = GroovyCategorySupport.getCategoryMethods("methodMissing");
+        if (possibleGenericMethods != null) {
+            for (Iterator iter = possibleGenericMethods.iterator(); iter.hasNext();) {
+                MetaMethod mmethod = (MetaMethod) iter.next();
+                if (!mmethod.getDeclaringClass().getTheClass().isAssignableFrom(sender))
+                    continue;
+
+                CachedClass[] paramTypes = mmethod.getParameterTypes();
+                if (paramTypes.length == 2 && paramTypes[0].getTheClass() == String.class) {
+                    return mmethod;
+                }
+            }
+        }
+        return null;
+    }
+
     private static MetaMethod getCategoryMethodGetter(Class sender, String name, boolean useLongVersion) {
         List possibleGenericMethods = GroovyCategorySupport.getCategoryMethods(name);
         if (possibleGenericMethods != null) {
diff --git a/src/test/groovy/CategoryTest.groovy b/src/test/groovy/CategoryTest.groovy
index b6cb8e8512..efec30c4f5 100644
--- a/src/test/groovy/CategoryTest.groovy
+++ b/src/test/groovy/CategoryTest.groovy
@@ -228,12 +228,60 @@ class CategoryTest extends GroovyTestCase {
             }
         '''
     }
+    // GROOVY-3867
+    void testPropertyMissing() {
+        def x = new X()
+
+        shouldFail(MissingPropertyException) {
+            assert x.baz != "works" // accessing x.baz should throw MPE
+        }
+
+        use(XCat4) {
+            assert x.baz == "works"
+        }
+
+        shouldFail(MissingPropertyException) {
+            assert x.baz != "works" // accessing x.baz should throw MPE
+        }
+    }
+
+    // GROOVY-3867
+    void testMethodMissing() {
+        def x = new X()
+        assert foo(x) == 1
+        use (XCat3) {
+            assert foo(x) == 1 // regular foo() is not affected by methodMissing in category
+            assert x.baz() == 4 // XCat3.methodMissing is called
+        }
+        assert foo(x) == 1
+        def t = Thread.start {use (XCat3){assert x.baz()==4}}
+        t.join()
+        assert foo(x) == 1
+        shouldFail(MissingMethodException) {
+            x.baz()
+        }
+    }
+
+    // GROOVY-3867
+    void testMethodMissingNoStatic() {
+        def x = new X()
+        use (XCat3) {
+            assert x.baz() == 4 // XCat3.methodMissing is called for instance
+            shouldFail(MissingMethodException) {
+                assert X.baz() != 4 // XCat3.methodMissing should not be called for static method of X
+            }
+        }
+    }
+
+
 
 }
 
 class X{ def bar(){1}}
 class XCat{ static bar(X x){2}}
 class XCat2{ static bar(X x){3}}
+class XCat3{ static methodMissing(X x, String name, args) {4}}
+class XCat4{ static propertyMissing(X x, String name) {"works"}}
 
 class StringCategory {
     static String lower(String string) {
@@ -261,4 +309,4 @@ class CategoryTestHelperPropertyReplacer {
     private static aVal = "anotherValue"
     static getaProperty(CategoryTestHelper self) { return aVal }
     static void setaProperty(CategoryTestHelper self, newValue) { aVal = newValue }
-}
+}
\ No newline at end of file

Commit:
c2404180a4374e8dfe99707e88c427cb925909a7
sunlan
sunlan@apache.org
2018-05-03 18:50:52 +0800
Fix `testMemoizeConcurrently`
diff --git a/src/test/org/codehaus/groovy/runtime/memoize/MemoizeTest.groovy b/src/test/org/codehaus/groovy/runtime/memoize/MemoizeTest.groovy
index db91778e9a..b99f749716 100644
--- a/src/test/org/codehaus/groovy/runtime/memoize/MemoizeTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/memoize/MemoizeTest.groovy
@@ -167,7 +167,7 @@ public class MemoizeTest extends AbstractMemoizeTestCase {
                 Utils.combinations(things, 2) 
             } 
         }
-        threadList << (0..<5).collect {
+        threadList.addAll((0..<5).collect {
             Thread.start {
                 def things = [
                     [1, 2, 3],
@@ -181,7 +181,7 @@ public class MemoizeTest extends AbstractMemoizeTestCase {
                 ]
                 Utils.combinations(things, 2) 
             }
-        }
+        })
         
         threadList*.join()
         

Commit:
24d888ac4c04774aa879316947a191094530dfd9
sunlan
sunlan@apache.org
2018-05-02 01:06:49 +0800
Trivial refactoring: rename method name
diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index 7be4264594..c798f7615e 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -1075,7 +1075,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                     Class arrayType =
                             arguments.length == arrayDimension
                                     ? ArrayTypeUtils.elementType(ownerClass) // Just for better performance, though we can use reduceDimension only
-                                    : ArrayTypeUtils.reduceDimension(ownerClass, (arrayDimension - arguments.length));
+                                    : ArrayTypeUtils.elementType(ownerClass, (arrayDimension - arguments.length));
                     return Array.newInstance(arrayType, sizeArray);
                 }
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/ArrayTypeUtils.java b/src/main/java/org/codehaus/groovy/runtime/ArrayTypeUtils.java
index 2a6e4097dd..8abea2e730 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ArrayTypeUtils.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ArrayTypeUtils.java
@@ -62,13 +62,13 @@ public class ArrayTypeUtils {
     }
 
     /**
-     * Reduce the dimension of array
+     * Get the type of array elements by the dimension
      *
      * @param clazz the type of array
      * @param dim the target dimension
      * @return the result array
      */
-    public static Class reduceDimension(Class clazz, int dim) {
+    public static Class elementType(Class clazz, int dim) {
         checkArrayType(clazz);
 
         if (dim < 0) {

Commit:
aa1ad8fe2ab2c37a0b95215e692e73bdc37297f7
Paul King
paulk@asert.com.au
2018-05-01 23:46:27 +1000
bump picocli version
diff --git a/build.gradle b/build.gradle
index 009381f3d0..cb5e9bfb71 100644
--- a/build.gradle
+++ b/build.gradle
@@ -163,7 +163,7 @@ ext {
     luceneVersion = '4.7.2'
     openbeansVersion = '1.0'
     openejbVersion = '1.0'
-    picocliVersion = '3.0.0-beta-2'
+    picocliVersion = '3.0.0'
     qdoxVersion = '1.12.1'
     slf4jVersion = '1.7.21'
     xmlunitVersion = '1.6'

Commit:
4993dba0746bfa473ae7fabd14e094f830abb058
Paul King
paulk@asert.com.au
2018-05-01 19:39:43 +1000
GROOVY-8520 CliBuilder groovydoc improvements (closes #692)
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
index 4030be560c..b196a6775c 100644
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
@@ -111,21 +111,21 @@ import java.lang.reflect.Method
  * <p>
  * Another example showing long options (partial emulation of arg processing for 'curl' command line):
  * <pre>
- * def cli = new CliBuilder(usage:'curl [options] &lt;url&gt;')
+ * def cli = new CliBuilder(name:'curl')
  * cli._(longOpt:'basic', 'Use HTTP Basic Authentication')
  * cli.d(longOpt:'data', args:1, argName:'data', 'HTTP POST data')
  * cli.G(longOpt:'get', 'Send the -d data with a HTTP GET')
  * cli.q('If used as the first parameter disables .curlrc')
- * cli._(longOpt:'url', args:1, argName:'URL', 'Set URL to work with')
+ * cli._(longOpt:'url', type:URL, argName:'URL', 'Set URL to work with')
  * </pre>
  * Which has the following usage message:
  * <pre>
- * Usage: curl [options] &lt;url>
- *       -basic, --basic         Use HTTP Basic Authentication
- *   -d, -data, --data=&lt;data>    HTTP POST data
- *   -G, -get, --get             Send the -d data with a HTTP GET
- *   -q                          If used as the first parameter disables .curlrc
- *       -url, --url=&lt;URL>       Set URL to work with
+ * Usage: curl [-Gq] [--basic] [--url=&lt;URL>] [-d=&lt;data>]
+ *       --basic         Use HTTP Basic Authentication
+ *   -d, --data=&lt;data>   HTTP POST data
+ *   -G, --get           Send the -d data with a HTTP GET
+ *   -q                  If used as the first parameter disables .curlrc
+ *       --url=&lt;URL>     Set URL to work with
  * </pre>
  * This example shows a common convention. When mixing short and long names, the
  * short names are often one character in size. One character options with
@@ -154,6 +154,24 @@ import java.lang.reflect.Method
  *                      description('Set URL to work with').build()
  * ...
  * </pre>
+ * As another example, the <code>usageMessage</code> property gives
+ * fine-grained control over the usage help message (see the
+ * <a href="http://picocli.info/#_usage_help_with_styles_and_colors">picocli user manual</a>
+ * for details):
+ *
+ * <pre>
+ * def cli = new CliBuilder()
+ * cli.name = "myapp"
+ * cli.usageMessage.with {
+ *     headerHeading("@|bold,underline Header heading:|@%n")
+ *     header("Header 1", "Header 2")                     // before the synopsis
+ *     synopsisHeading("%n@|bold,underline Usage:|@ ")
+ *     descriptionHeading("%n@|bold,underline Description heading:|@%n")
+ *     description("Description 1", "Description 2")      // after the synopsis
+ *     optionListHeading("%n@|bold,underline Options heading:|@%n")
+ *     footerHeading("%n@|bold,underline Footer heading:|@%n")
+ *     footer("Footer 1", "Footer 2")
+ * }</pre>
  *
  * <p>
  * <b>Supported Option Properties</b>:
@@ -174,7 +192,9 @@ import java.lang.reflect.Method
  *     <th><code>longOpt</code></th>
  *     <td>String</td>
  *     <td><code>names</code></td>
- *     <td>Long name for the option, which may be prefixed with either a single hypen or two hyphens.
+ *     <td>Long name for the option, will be prefixed with two hyphens
+ *       unless {@link CliBuilder#acceptLongOptionsWithSingleHyphen acceptLongOptionsWithSingleHyphen}
+ *       is <code>true</code>.
  *       An option must have either a long name or a short name (or both).</td>
  *   </tr>
  *   <tr>
@@ -185,6 +205,7 @@ import java.lang.reflect.Method
  *       A String value of '+' indicates at least one up to any number of parameters.
  *       The minimum number of parameters depends on the type (booleans require no parameters)
  *       and the <code>optionalArg</code> setting.
+ *       <code>args</code> can often be omitted if a <code>type</code> is specified.
  *       </td>
  *   </tr>
  *   <tr>
@@ -238,7 +259,7 @@ import java.lang.reflect.Method
  *       </td>
  *   </tr>
  * </table>
- * See {@link CliBuilderTest} for further examples.
+ * See {@link groovy.cli.picocli.CliBuilderTest} for further examples.
  * <p>
  * <b>@-files</b>
  * <p>
@@ -322,6 +343,7 @@ class CliBuilder {
     /**
      * The command synopsis displayed as the first line in the usage help message, e.g., when <code>cli.usage()</code> is called.
      * When not set, a default synopsis is generated that shows the supported options and parameters.
+     * @see #name
      */
     String usage = 'groovy'
 
@@ -360,7 +382,7 @@ class CliBuilder {
     boolean acceptLongOptionsWithSingleHyphen = false
 
     /**
-     * The PrintWriter to write the {@linkplain #usage} help message to
+     * The PrintWriter to write the {@link #usage} help message to
      * when <code>cli.usage()</code> is called.
      * Defaults to stdout but you can provide your own PrintWriter if desired.
      */
@@ -414,6 +436,9 @@ class CliBuilder {
     // The values collected here are copied into the UsageMessageSpec of the command.
     final UsageMessageSpec usageMessage = new UsageMessageSpec()
 
+    /**
+     * Internal data structure mapping option names to their associated {@link TypedOption} object.
+     */
     Map<String, TypedOption> savedTypeOptions = new HashMap<String, TypedOption>()
 
     // CommandSpec is the entry point into the picocli object model for a command.
@@ -429,16 +454,31 @@ class CliBuilder {
     // replaced with a new one. This allows the outer CliBuilder instance can be reused.
     private CommandSpec commandSpec = CommandSpec.create()
 
+    /**
+     * Sets the {@link #usage usage} property on this <code>CliBuilder</code> and the
+     * <code>customSynopsis</code> on the {@link #usageMessage} used by the underlying library.
+     * @param usage the custom synopsis of the usage help message
+     */
     void setUsage(String usage) {
         this.usage = usage
         usageMessage.customSynopsis(usage)
     }
 
+    /**
+     * Sets the {@link #footer} property on this <code>CliBuilder</code>
+     * and on the {@link #usageMessage} used by the underlying library.
+     * @param footer the footer of the usage help message
+     */
     void setFooter(String footer) {
         this.footer = footer
         usageMessage.footer(footer)
     }
 
+    /**
+     * Sets the {@link #header} property on this <code>CliBuilder</code> and the
+     * <code>description</code> on the {@link #usageMessage} used by the underlying library.
+     * @param header the description text of the usage help message
+     */
     void setHeader(String header) {
         this.header = header
         // "header" is displayed after the synopsis in previous CliBuilder versions.
@@ -446,21 +486,46 @@ class CliBuilder {
         usageMessage.description(header)
     }
 
+    /**
+     * Sets the {@link #width} property on this <code>CliBuilder</code>
+     * and on the {@link #usageMessage} used by the underlying library.
+     * @param width the width of the usage help message
+     */
     void setWidth(int width) {
         this.width = width
         usageMessage.width(width)
     }
 
+    /**
+     * Sets the {@link #expandArgumentFiles} property on this <code>CliBuilder</code>
+     * and on the {@link #parser} used by the underlying library.
+     * @param expand whether to expand argument @-files
+     */
     void setExpandArgumentFiles(boolean expand) {
         this.expandArgumentFiles = expand
         parser.expandAtFiles(expand)
     }
 
+    /**
+     * Sets the {@link #posix} property on this <code>CliBuilder</code> and the
+     * <code>posixClusteredShortOptionsAllowed</code> property on the {@link #parser}
+     * used by the underlying library.
+     * @param poxis whether to allow clustered short options
+     */
     void setPosix(boolean posix) {
         this.posix = posix
         parser.posixClusteredShortOptionsAllowed(posix)
     }
 
+    /**
+     * Sets the {@link #stopAtNonOption} property on this <code>CliBuilder</code> and the
+     * <code>stopAtPositional</code> property on the {@link #parser}
+     * used by the underlying library.
+     * @param stopAtNonOption when <code>true</code> (the default), the
+     *          remaining arguments are all treated as positional parameters.
+     *          When <code>false</code>, the parser will continue to look for options, and
+     *          only the unrecognized arguments are treated as positional parameters.
+     */
     void setStopAtNonOption(boolean stopAtNonOption) {
         this.stopAtNonOption = stopAtNonOption
         parser.stopAtPositional(stopAtNonOption)
diff --git a/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
index 6bca802b82..302bef63d2 100644
--- a/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
@@ -446,6 +446,61 @@ Footer 2
         assert options.Xs == [ 'x':'y', 'i':'j' ]                                     // <6>
         assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         // <7>
         // end::MapOption[]
+    }
+
+    public void testGroovyDocAntExample() {
+        def cli = new CliBuilder(usage:'ant [options] [targets]',
+                header:'Options:')
+        cli.help('print this message')
+        cli.logfile(type:File, argName:'file', 'use given file for log')
+        cli.D(type:Map, argName:'property=value', 'use value for given property')
+        cli.lib(argName:'path', valueSeparator:',', args: '3',
+                'comma-separated list of 3 paths to search for jars and classes')
+
+        // suppress ANSI escape codes to make this test pass on all environments
+        System.setProperty("picocli.ansi", "false")
+        StringWriter sw = new StringWriter()
+        cli.writer = new PrintWriter(sw)
+
+        cli.usage()
+
+        String expected = '''\
+Usage: ant [options] [targets]
+Options:
+  -D= <property=value>   use value for given property
+      -help              print this message
+      -lib=<path>,<path>,<path>
+                         comma-separated list of 3 paths to search for jars and
+                           classes
+      -logfile=<file>    use given file for log
+'''
+        assertEquals(expected.normalize(), sw.toString().normalize())
+    }
 
+    public void testGroovyDocCurlExample() {
+        // suppress ANSI escape codes to make this test pass on all environments
+        System.setProperty("picocli.ansi", "false")
+        ByteArrayOutputStream baos = new ByteArrayOutputStream()
+        System.setOut(new PrintStream(baos, true))
+
+        def cli = new CliBuilder(name:'curl')
+        cli._(longOpt:'basic', 'Use HTTP Basic Authentication')
+        cli.d(longOpt:'data', args:1, argName:'data', 'HTTP POST data')
+        cli.G(longOpt:'get', 'Send the -d data with a HTTP GET')
+        cli.q('If used as the first parameter disables .curlrc')
+        cli._(longOpt:'url', type:URL, argName:'URL', 'Set URL to work with')
+
+        cli.usageMessage.sortOptions(false)
+        cli.usage()
+
+        String expected = '''\
+Usage: curl [-Gq] [--basic] [--url=<URL>] [-d=<data>]
+      --basic         Use HTTP Basic Authentication
+  -d, --data=<data>   HTTP POST data
+  -G, --get           Send the -d data with a HTTP GET
+  -q                  If used as the first parameter disables .curlrc
+      --url=<URL>     Set URL to work with
+'''
+        assertEquals(expected.normalize(), baos.toString().normalize())
     }
 }

Commit:
854eca3605f5078952514fa7f2ba3306d4d21628
Paul King
paulk@asert.com.au
2018-04-30 17:08:39 +1000
whitespace
diff --git a/src/test/groovy/GroovyMethodsTest.groovy b/src/test/groovy/GroovyMethodsTest.groovy
index 903ea02c44..b773890a91 100644
--- a/src/test/groovy/GroovyMethodsTest.groovy
+++ b/src/test/groovy/GroovyMethodsTest.groovy
@@ -811,7 +811,7 @@ class GroovyMethodsTest extends GroovyTestCase {
     void doIt(col) {
         col.clear()
         col.addAll(leftCol)
-        // not really concerned about  correctness, rather that the method can be called, however..
+        // not really concerned about correctness, rather that the method can be called, however..
         assert col.intersect(rightCol) as List == ["2"]
     }
 

Commit:
1af31492bf58813a168f84bbf3834cdd40ec675c
Paul King
paulk@asert.com.au
2018-04-28 16:31:11 +1000
picocli related changes: * add collate for array * deprecate groovy.util.CliBuilder and make it a simple delegate to picocli version * make "less preferred" modules not appear in groovy-all pom
diff --git a/gradle/pomconfigurer.gradle b/gradle/pomconfigurer.gradle
index 9438dc18e8..3ce9ada751 100644
--- a/gradle/pomconfigurer.gradle
+++ b/gradle/pomconfigurer.gradle
@@ -443,6 +443,9 @@ project.ext.pomConfigureClosureWithoutTweaks = {
             contributor {
                 name 'Bernhard Huber'
             }
+            contributor {
+                name 'Yasuharu Nakano'
+            }
             contributor {
                 name 'Marc DeXeT'
             }
diff --git a/gradle/upload.gradle b/gradle/upload.gradle
index 246df83391..5c7e07b686 100644
--- a/gradle/upload.gradle
+++ b/gradle/upload.gradle
@@ -201,6 +201,8 @@ allprojects {
     }
 }
 
+def optionalModules = ['groovy-dateutil', 'groovy-cli-commons', 'groovy-json-direct']
+
 ext.pomAll = {
     addFilter('groovy') { artifact, file ->
         !(artifact.name.contains('groovy-all')) &&
@@ -209,6 +211,7 @@ ext.pomAll = {
     }
     addFilter('all') { artifact, file ->
         // add an arbitrary artifact, so that the pom file is generated
+        // we adjust the packaging attribute later
         artifact.name.contains('groovy-binary')
     }
     addFilter('binary') { artifact, file ->
@@ -253,7 +256,7 @@ ext.pomAll = {
         // defer setting packaging until here otherwise gets overwritten
         p.packaging = 'pom'
         allprojects {
-            if (it.name.startsWith('groovy')) {
+            if (it.name.startsWith('groovy') && !optionalModules.contains(it.name)) {
                 def dep = dependencyClass.newInstance()
                 dep.groupId = 'org.codehaus.groovy'
                 dep.artifactId = it.name
diff --git a/src/main/groovy/groovy/io/FileVisitResult.java b/src/main/groovy/groovy/io/FileVisitResult.java
index 55ecb4af2b..5e53ef574e 100644
--- a/src/main/groovy/groovy/io/FileVisitResult.java
+++ b/src/main/groovy/groovy/io/FileVisitResult.java
@@ -20,7 +20,7 @@ package groovy.io;
 
 /**
  * Represents special return values for the 'preDir', 'postDir' and 'visit'/supplied Closures used with
- * {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#traverse(java.io.File, java.util.Map, groovy.lang.Closure)}
+ * {@link org.codehaus.groovy.runtime.ResourceGroovyMethods#traverse(java.io.File, java.util.Map, groovy.lang.Closure)}
  * and related methods to control subsequent traversal behavior.
  */
 public enum FileVisitResult {
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index e6d57658c3..57e0a8c08a 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -3240,6 +3240,19 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return collate(self, size, true);
     }
 
+    /**
+     * Collates an array.
+     *
+     * @param self          an array
+     * @param size          the length of each sub-list in the returned list
+     * @return a List containing the array values collated into sub-lists
+     * @see #collate(Iterable, int)
+     * @since 2.5.0
+     */
+    public static <T> List<List<T>> collate(T[] self, int size) {
+        return collate((Iterable)Arrays.asList(self), size, true);
+    }
+
     /**
      * @deprecated use the Iterable variant instead
      * @see #collate(Iterable, int)
@@ -3268,6 +3281,20 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return collate(self, size, step, true);
     }
 
+    /**
+     * Collates an array into sub-lists.
+     *
+     * @param self          an array
+     * @param size          the length of each sub-list in the returned list
+     * @param step          the number of elements to step through for each sub-list
+     * @return a List containing the array elements collated into sub-lists
+     * @see #collate(Iterable, int, int)
+     * @since 2.5.0
+     */
+    public static <T> List<List<T>> collate(T[] self, int size, int step) {
+        return collate((Iterable)Arrays.asList(self), size, step, true);
+    }
+
     /**
      * @deprecated use the Iterable variant instead
      * @see #collate(Iterable, int, int)
@@ -3296,6 +3323,20 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return collate(self, size, size, keepRemainder);
     }
 
+    /**
+     * Collates this array into sub-lists.
+     *
+     * @param self          an array
+     * @param size          the length of each sub-list in the returned list
+     * @param keepRemainder if true, any remaining elements are returned as sub-lists.  Otherwise they are discarded
+     * @return a List containing the array elements collated into sub-lists
+     * @see #collate(Iterable, int, boolean)
+     * @since 2.5.0
+     */
+    public static <T> List<List<T>> collate(T[] self, int size, boolean keepRemainder) {
+        return collate((Iterable)Arrays.asList(self), size, size, keepRemainder);
+    }
+
     /**
      * @deprecated use the Iterable variant instead
      * @see #collate(Iterable, int, boolean)
@@ -3347,6 +3388,20 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return answer ;
     }
 
+    /**
+     * Collates this array into into sub-lists.
+     *
+     * @param self          an array
+     * @param size          the length of each sub-list in the returned list
+     * @param step          the number of elements to step through for each sub-list
+     * @param keepRemainder if true, any remaining elements are returned as sub-lists.  Otherwise they are discarded
+     * @return a List containing the array elements collated into sub-lists
+     * @since 2.5.0
+     */
+    public static <T> List<List<T>> collate(T[] self, int size, int step, boolean keepRemainder) {
+        return collate((Iterable)Arrays.asList(self), size, step, keepRemainder);
+    }
+
     /**
      * @deprecated use the Iterable variant instead
      * @see #collate(Iterable, int, int, boolean)
diff --git a/src/spec/test/builder/CliBuilderTest.groovy b/src/spec/test/builder/CliBuilderTest.groovy
index b086fe6f53..a84b3a46a3 100644
--- a/src/spec/test/builder/CliBuilderTest.groovy
+++ b/src/spec/test/builder/CliBuilderTest.groovy
@@ -25,8 +25,6 @@ import groovy.transform.TypeChecked
 
 import java.math.RoundingMode
 
-//import java.math.RoundingMode
-
 class CliBuilderTest extends GroovyTestCase {
 //    void tearDown() {
 //    }
@@ -356,7 +354,7 @@ class CliBuilderTest extends GroovyTestCase {
     // tag::withTypeChecked[]
     @TypeChecked
     void testTypeChecked() {
-        def cli = new CliBuilder()
+        def cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
         TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
         TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
         def argz = "--name John -age 21 and some more".split()
diff --git a/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
similarity index 83%
rename from subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
rename to subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
index bc7d44a561..790cb8214c 100644
--- a/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
+++ b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/CliBuilder.groovy
@@ -16,14 +16,13 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-package groovy.util
+package groovy.cli.commons
 
 import groovy.cli.CliBuilderException
 import groovy.cli.Option
 import groovy.cli.TypedOption
 import groovy.cli.Unparsed
 import groovy.transform.Undefined
-import org.apache.commons.cli.CommandLine
 import org.apache.commons.cli.CommandLineParser
 import org.apache.commons.cli.DefaultParser
 import org.apache.commons.cli.GnuParser
@@ -33,7 +32,6 @@ import org.apache.commons.cli.Options
 import org.apache.commons.cli.ParseException
 import org.codehaus.groovy.runtime.InvokerHelper
 import org.codehaus.groovy.runtime.MetaClassHelper
-import org.codehaus.groovy.runtime.StringGroovyMethods
 
 import java.lang.annotation.Annotation
 import java.lang.reflect.Array
@@ -350,7 +348,7 @@ class CliBuilder {
      * Make options accessible from command line args with parser.
      * Returns null on bad command lines after displaying usage message.
      */
-    OptionAccessor parse(args) {
+    groovy.cli.commons.OptionAccessor parse(args) {
         if (expandArgumentFiles) args = expandArgumentFiles(args)
         if (!parser) {
             parser = posix != null && posix == false ? new GnuParser() : new DefaultParser()
@@ -660,139 +658,3 @@ class CliBuilder {
     }
 
 }
-
-class OptionAccessor {
-    CommandLine commandLine
-    Map<String, TypedOption> savedTypeOptions
-
-    OptionAccessor(CommandLine commandLine) {
-        this.commandLine = commandLine
-    }
-
-    boolean hasOption(TypedOption typedOption) {
-        commandLine.hasOption(typedOption.longOpt ?: typedOption.opt)
-    }
-
-    public <T> T defaultValue(String name) {
-        Class<T> type = savedTypeOptions[name]?.type
-        String value = savedTypeOptions[name]?.defaultValue() ? savedTypeOptions[name].defaultValue() : null
-        return (T) value ? getTypedValue(type, name, value) : null
-    }
-
-    public <T> T getOptionValue(TypedOption<T> typedOption) {
-        getOptionValue(typedOption, null)
-    }
-
-    public <T> T getOptionValue(TypedOption<T> typedOption, T defaultValue) {
-        String optionName = (String) typedOption.longOpt ?: typedOption.opt
-        if (commandLine.hasOption(optionName)) {
-            if (typedOption.containsKey('type') && typedOption.type.isArray()) {
-                def compType = typedOption.type.componentType
-                return (T) getTypedValuesFromName(optionName, compType)
-            }
-            return getTypedValueFromName(optionName)
-        }
-        return defaultValue
-    }
-
-    private <T> T[] getTypedValuesFromName(String optionName, Class<T> compType) {
-        CliOption option = commandLine.options.find{ it.longOpt == optionName }
-        T[] result = null
-        if (option) {
-            int count = 0
-            def optionValues = commandLine.getOptionValues(optionName)
-            for (String optionValue : optionValues) {
-                if (result == null) {
-                    result = (T[]) Array.newInstance(compType, optionValues.length)
-                }
-                result[count++] = (T) getTypedValue(compType, optionName, optionValue)
-            }
-        }
-        if (result == null) {
-            result = (T[]) Array.newInstance(compType, 0)
-        }
-        return result
-    }
-
-    public <T> T getAt(TypedOption<T> typedOption) {
-        getAt(typedOption, null)
-    }
-
-    public <T> T getAt(TypedOption<T> typedOption, T defaultValue) {
-        String optionName = (String) typedOption.longOpt ?: typedOption.opt
-        if (savedTypeOptions.containsKey(optionName)) {
-            return getTypedValueFromName(optionName)
-        }
-        return defaultValue
-    }
-
-    private <T> T getTypedValueFromName(String optionName) {
-        Class type = savedTypeOptions[optionName].type
-        String optionValue = commandLine.getOptionValue(optionName)
-        return (T) getTypedValue(type, optionName, optionValue)
-    }
-
-    private <T> T getTypedValue(Class<T> type, String optionName, String optionValue) {
-        if (savedTypeOptions[optionName]?.cliOption?.numberOfArgs == 0) {
-            return (T) commandLine.hasOption(optionName)
-        }
-        def convert = savedTypeOptions[optionName]?.convert
-        return getValue(type, optionValue, convert)
-    }
-
-    private <T> T getValue(Class<T> type, String optionValue, Closure convert) {
-        if (!type) {
-            return (T) optionValue
-        }
-        if (Closure.isAssignableFrom(type) && convert) {
-            return (T) convert(optionValue)
-        }
-        if (type?.simpleName?.toLowerCase() == 'boolean') {
-            return (T) Boolean.parseBoolean(optionValue)
-        }
-        StringGroovyMethods.asType(optionValue, (Class<T>) type)
-    }
-
-    def invokeMethod(String name, Object args) {
-        return InvokerHelper.getMetaClass(commandLine).invokeMethod(commandLine, name, args)
-    }
-
-    def getProperty(String name) {
-        if (!savedTypeOptions.containsKey(name)) {
-            def alt = savedTypeOptions.find{ it.value.opt == name }
-            if (alt) name = alt.key
-        }
-        def methodname = 'getOptionValue'
-        Class type = savedTypeOptions[name]?.type
-        def foundArray = type?.isArray()
-        if (name.size() > 1 && name.endsWith('s')) {
-            def singularName = name[0..-2]
-            if (commandLine.hasOption(singularName) || foundArray) {
-                name = singularName
-                methodname += 's'
-                type = savedTypeOptions[name]?.type
-            }
-        }
-        if (type?.isArray()) {
-            methodname = 'getOptionValues'
-        }
-        if (name.size() == 1) name = name as char
-        def result = InvokerHelper.getMetaClass(commandLine).invokeMethod(commandLine, methodname, name)
-        if (result != null) {
-            if (result instanceof String[]) {
-                result = result.collect{ type ? getTypedValue(type.isArray() ? type.componentType : type, name, it) : it }
-            } else {
-                if (type) result = getTypedValue(type, name, result)
-            }
-        } else if (type?.simpleName != 'boolean' && savedTypeOptions[name]?.defaultValue) {
-            result = getTypedValue(type, name, savedTypeOptions[name].defaultValue)
-        } else {
-            result = commandLine.hasOption(name)
-        }
-        return result
-    }
-
-    List<String> arguments() {
-        commandLine.args.toList()
-    }
-}
diff --git a/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/OptionAccessor.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/OptionAccessor.groovy
new file mode 100644
index 0000000000..8e0b7b3fba
--- /dev/null
+++ b/subprojects/groovy-cli-commons/src/main/groovy/groovy/cli/commons/OptionAccessor.groovy
@@ -0,0 +1,163 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.cli.commons
+
+import groovy.cli.TypedOption
+import org.apache.commons.cli.CommandLine
+import org.apache.commons.cli.Option as CliOption
+import org.codehaus.groovy.runtime.InvokerHelper
+import org.codehaus.groovy.runtime.StringGroovyMethods
+
+import java.lang.reflect.Array
+
+class OptionAccessor {
+    CommandLine commandLine
+    Map<String, TypedOption> savedTypeOptions
+
+    OptionAccessor(CommandLine commandLine) {
+        this.commandLine = commandLine
+    }
+
+    boolean hasOption(TypedOption typedOption) {
+        commandLine.hasOption(typedOption.longOpt ?: typedOption.opt)
+    }
+
+    public <T> T defaultValue(String name) {
+        Class<T> type = savedTypeOptions[name]?.type
+        String value = savedTypeOptions[name]?.defaultValue() ? savedTypeOptions[name].defaultValue() : null
+        return (T) value ? getTypedValue(type, name, value) : null
+    }
+
+    public <T> T getOptionValue(TypedOption<T> typedOption) {
+        getOptionValue(typedOption, null)
+    }
+
+    public <T> T getOptionValue(TypedOption<T> typedOption, T defaultValue) {
+        String optionName = (String) typedOption.longOpt ?: typedOption.opt
+        if (commandLine.hasOption(optionName)) {
+            if (typedOption.containsKey('type') && typedOption.type.isArray()) {
+                def compType = typedOption.type.componentType
+                return (T) getTypedValuesFromName(optionName, compType)
+            }
+            return getTypedValueFromName(optionName)
+        }
+        return defaultValue
+    }
+
+    private <T> T[] getTypedValuesFromName(String optionName, Class<T> compType) {
+        CliOption option = commandLine.options.find{ it.longOpt == optionName }
+        T[] result = null
+        if (option) {
+            int count = 0
+            def optionValues = commandLine.getOptionValues(optionName)
+            for (String optionValue : optionValues) {
+                if (result == null) {
+                    result = (T[]) Array.newInstance(compType, optionValues.length)
+                }
+                result[count++] = (T) getTypedValue(compType, optionName, optionValue)
+            }
+        }
+        if (result == null) {
+            result = (T[]) Array.newInstance(compType, 0)
+        }
+        return result
+    }
+
+    public <T> T getAt(TypedOption<T> typedOption) {
+        getAt(typedOption, null)
+    }
+
+    public <T> T getAt(TypedOption<T> typedOption, T defaultValue) {
+        String optionName = (String) typedOption.longOpt ?: typedOption.opt
+        if (savedTypeOptions.containsKey(optionName)) {
+            return getTypedValueFromName(optionName)
+        }
+        return defaultValue
+    }
+
+    private <T> T getTypedValueFromName(String optionName) {
+        Class type = savedTypeOptions[optionName].type
+        String optionValue = commandLine.getOptionValue(optionName)
+        return (T) getTypedValue(type, optionName, optionValue)
+    }
+
+    private <T> T getTypedValue(Class<T> type, String optionName, String optionValue) {
+        if (savedTypeOptions[optionName]?.cliOption?.numberOfArgs == 0) {
+            return (T) commandLine.hasOption(optionName)
+        }
+        def convert = savedTypeOptions[optionName]?.convert
+        return getValue(type, optionValue, convert)
+    }
+
+    private <T> T getValue(Class<T> type, String optionValue, Closure convert) {
+        if (!type) {
+            return (T) optionValue
+        }
+        if (Closure.isAssignableFrom(type) && convert) {
+            return (T) convert(optionValue)
+        }
+        if (type?.simpleName?.toLowerCase() == 'boolean') {
+            return (T) Boolean.parseBoolean(optionValue)
+        }
+        StringGroovyMethods.asType(optionValue, (Class<T>) type)
+    }
+
+    def invokeMethod(String name, Object args) {
+        return InvokerHelper.getMetaClass(commandLine).invokeMethod(commandLine, name, args)
+    }
+
+    def getProperty(String name) {
+        if (!savedTypeOptions.containsKey(name)) {
+            def alt = savedTypeOptions.find{ it.value.opt == name }
+            if (alt) name = alt.key
+        }
+        def methodname = 'getOptionValue'
+        Class type = savedTypeOptions[name]?.type
+        def foundArray = type?.isArray()
+        if (name.size() > 1 && name.endsWith('s')) {
+            def singularName = name[0..-2]
+            if (commandLine.hasOption(singularName) || foundArray) {
+                name = singularName
+                methodname += 's'
+                type = savedTypeOptions[name]?.type
+            }
+        }
+        if (type?.isArray()) {
+            methodname = 'getOptionValues'
+        }
+        if (name.size() == 1) name = name as char
+        def result = InvokerHelper.getMetaClass(commandLine).invokeMethod(commandLine, methodname, name)
+        if (result != null) {
+            if (result instanceof String[]) {
+                result = result.collect{ type ? getTypedValue(type.isArray() ? type.componentType : type, name, it) : it }
+            } else {
+                if (type) result = getTypedValue(type, name, result)
+            }
+        } else if (type?.simpleName != 'boolean' && savedTypeOptions[name]?.defaultValue) {
+            result = getTypedValue(type, name, savedTypeOptions[name].defaultValue)
+        } else {
+            result = commandLine.hasOption(name)
+        }
+        return result
+    }
+
+    List<String> arguments() {
+        commandLine.args.toList()
+    }
+}
diff --git a/subprojects/groovy-cli-commons/src/test/groovy/groovy/util/CliBuilderTest.groovy b/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
similarity index 99%
rename from subprojects/groovy-cli-commons/src/test/groovy/groovy/util/CliBuilderTest.groovy
rename to subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
index 938c79aca1..f5dd3e8ec6 100644
--- a/subprojects/groovy-cli-commons/src/test/groovy/groovy/util/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-commons/src/test/groovy/groovy/cli/commons/CliBuilderTest.groovy
@@ -16,7 +16,7 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-package groovy.util
+package groovy.cli.commons
 
 import groovy.cli.Option
 import groovy.cli.Unparsed
@@ -40,7 +40,6 @@ import static org.apache.commons.cli.Option.builder
  * and really need behavior that can only be supplied by one of the legacy parsers, we also include
  * some test case runs against some of the legacy parsers.
  */
-
 class CliBuilderTest extends GroovyTestCase {
 
     private StringWriter stringWriter
@@ -674,6 +673,7 @@ usage: groovy
         new GroovyShell().run('''
             import groovy.cli.OptionField
             import groovy.cli.UnparsedField
+            import groovy.cli.commons.CliBuilder
             import java.math.RoundingMode
             @OptionField String first
             @OptionField String last
diff --git a/subprojects/groovy-cli-picocli/build.gradle b/subprojects/groovy-cli-picocli/build.gradle
index e41bea9eec..dececa0485 100644
--- a/subprojects/groovy-cli-picocli/build.gradle
+++ b/subprojects/groovy-cli-picocli/build.gradle
@@ -19,7 +19,6 @@
 dependencies {
     compile rootProject
     compile "info.picocli:picocli:$picocliVersion"
-//    compile files ('C:/Users/remko/IdeaProjects/picocli/build/libs/picocli-3.0.0-beta-3-SNAPSHOT.jar')
     testCompile project(':groovy-test')
     testCompile project(':groovy-dateutil')
 }
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
index 352eb68b9e..4030be560c 100644
--- a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
@@ -25,7 +25,6 @@ import groovy.cli.Unparsed
 import groovy.transform.Undefined
 import org.codehaus.groovy.runtime.InvokerHelper
 import org.codehaus.groovy.runtime.MetaClassHelper
-import org.codehaus.groovy.runtime.StringGroovyMethods
 import picocli.CommandLine
 import picocli.CommandLine.ITypeConverter
 import picocli.CommandLine.Model.CommandSpec
@@ -35,7 +34,6 @@ import picocli.CommandLine.Model.OptionSpec
 import picocli.CommandLine.Model.ParserSpec
 import picocli.CommandLine.Model.PositionalParamSpec
 import picocli.CommandLine.Model.UsageMessageSpec
-import picocli.CommandLine.ParseResult
 
 import java.lang.reflect.Field
 import java.lang.reflect.Method
@@ -544,7 +542,7 @@ class CliBuilder {
      * Make options accessible from command line args with parser.
      * Returns null on bad command lines after displaying usage message.
      */
-    OptionAccessor parse(args) {
+    groovy.cli.picocli.OptionAccessor parse(args) {
         CommandLine commandLine = createCommandLine()
         try {
             def accessor = new OptionAccessor(commandLine.parseArgs(args as String[]))
@@ -902,127 +900,3 @@ class CliBuilder {
         result
     }
 }
-
-class OptionAccessor {
-    ParseResult parseResult
-    Map<String, TypedOption> savedTypeOptions
-
-    OptionAccessor(ParseResult parseResult) {
-        this.parseResult = parseResult
-    }
-
-    boolean hasOption(TypedOption typedOption) {
-        parseResult.hasMatchedOption(typedOption.longOpt ?: typedOption.opt as String)
-    }
-
-    public <T> T defaultValue(String name) {
-        Class<T> type = savedTypeOptions[name]?.type
-        String value = savedTypeOptions[name]?.defaultValue() ? savedTypeOptions[name].defaultValue() : null
-        return (T) value ? getTypedValue(type, name, value) : null
-    }
-
-    public <T> T getOptionValue(TypedOption<T> typedOption) {
-        getOptionValue(typedOption, null)
-    }
-
-    public <T> T getOptionValue(TypedOption<T> typedOption, T defaultValue) {
-        String optionName = (String) typedOption.longOpt ?: typedOption.opt
-        if (parseResult.hasMatchedOption(optionName)) {
-            return parseResult.matchedOptionValue(optionName, defaultValue)
-        } else {
-            OptionSpec option = parseResult.commandSpec().findOption(optionName)
-            return option ? option.value : defaultValue
-        }
-    }
-
-    public <T> T getAt(TypedOption<T> typedOption) {
-        getAt(typedOption, null)
-    }
-
-    public <T> T getAt(TypedOption<T> typedOption, T defaultValue) {
-        getOptionValue(typedOption, defaultValue)
-    }
-
-    private <T> T getTypedValue(Class<T> type, String optionName, String optionValue) {
-        if (savedTypeOptions[optionName]?.cliOption?.arity?.min == 0) { // TODO is this not a bug?
-            return (T) parseResult.hasMatchedOption(optionName) // TODO should defaultValue not simply convert the type regardless of the matched value?
-        }
-        def convert = savedTypeOptions[optionName]?.convert
-        return getValue(type, optionValue, convert)
-    }
-
-    private <T> T getValue(Class<T> type, String optionValue, Closure convert) {
-        if (!type) {
-            return (T) optionValue
-        }
-        if (Closure.isAssignableFrom(type) && convert) {
-            return (T) convert(optionValue)
-        }
-        if (type == Boolean || type == Boolean.TYPE) {
-            return type.cast(Boolean.parseBoolean(optionValue))
-        }
-        StringGroovyMethods.asType(optionValue, (Class<T>) type)
-    }
-
-    Properties getOptionProperties(String name) {
-        if (!parseResult.hasMatchedOption(name)) {
-            return null
-        }
-        List<String> keyValues = parseResult.matchedOption(name).stringValues()
-        Properties result = new Properties()
-        keyValues.toSpreadMap().each { k, v -> result.setProperty(k, v) }
-        result
-    }
-
-    def invokeMethod(String name, Object args) {
-        // TODO we could just declare normal methods to map commons-cli CommandLine methods to picocli ParseResult methods
-        if (name == 'hasOption')      { name = 'hasMatchedOption';   args = [args[0]      ].toArray() }
-        if (name == 'getOptionValue') { name = 'matchedOptionValue'; args = [args[0], null].toArray() }
-        return InvokerHelper.getMetaClass(parseResult).invokeMethod(parseResult, name, args)
-    }
-
-    def getProperty(String name) {
-        if (name == 'parseResult') { return parseResult }
-        if (parseResult.hasMatchedOption(name)) {
-            def result = parseResult.matchedOptionValue(name, null)
-
-            // if user specified an array type, return the full array (regardless of 's' suffix on name)
-            Class userSpecifiedType = savedTypeOptions[name]?.type
-            if (userSpecifiedType?.isArray()) { return result }
-
-            // otherwise, if the result is multi-value, return the first value
-            Class derivedType = parseResult.matchedOption(name).type()
-            if (derivedType.isArray()) {
-                return result ? result[0] : null
-            } else if (Collection.class.isAssignableFrom(derivedType)) {
-                return (result as Collection)?.first()
-            }
-            if (!userSpecifiedType && result == '' && parseResult.matchedOption(name).arity().min == 0) {
-                return true
-            }
-            return parseResult.matchedOption(name).typedValues().get(0)
-        }
-        if (parseResult.commandSpec().findOption(name)) { // requested option was not matched: return its default
-            def option = parseResult.commandSpec().findOption(name)
-            def result = option.value
-            return result ? result : false
-        }
-        if (name.size() > 1 && name.endsWith('s')) { // user wants multi-value result
-            def singularName = name[0..-2]
-            if (parseResult.hasMatchedOption(singularName)) {
-                // if picocli has a strongly typed multi-value result, return it
-                Class type = parseResult.matchedOption(singularName).type()
-                if (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {
-                    return parseResult.matchedOptionValue(singularName, null)
-                }
-                // otherwise, return the raw string values as a list
-                return parseResult.matchedOption(singularName).stringValues()
-            }
-        }
-        false
-    }
-
-    List<String> arguments() {
-        parseResult.hasMatchedPositional(0) ? parseResult.matchedPositional(0).stringValues() : []
-    }
-}
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/OptionAccessor.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/OptionAccessor.groovy
new file mode 100644
index 0000000000..2ce0bb8447
--- /dev/null
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/OptionAccessor.groovy
@@ -0,0 +1,149 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.cli.picocli
+
+import groovy.cli.TypedOption
+import org.codehaus.groovy.runtime.InvokerHelper
+import org.codehaus.groovy.runtime.StringGroovyMethods
+import picocli.CommandLine.Model.OptionSpec
+import picocli.CommandLine.ParseResult
+
+class OptionAccessor {
+    ParseResult parseResult
+    Map<String, TypedOption> savedTypeOptions
+
+    OptionAccessor(ParseResult parseResult) {
+        this.parseResult = parseResult
+    }
+
+    boolean hasOption(TypedOption typedOption) {
+        parseResult.hasMatchedOption(typedOption.longOpt ?: typedOption.opt as String)
+    }
+
+    public <T> T defaultValue(String name) {
+        Class<T> type = savedTypeOptions[name]?.type
+        String value = savedTypeOptions[name]?.defaultValue() ? savedTypeOptions[name].defaultValue() : null
+        return (T) value ? getTypedValue(type, name, value) : null
+    }
+
+    public <T> T getOptionValue(TypedOption<T> typedOption) {
+        getOptionValue(typedOption, null)
+    }
+
+    public <T> T getOptionValue(TypedOption<T> typedOption, T defaultValue) {
+        String optionName = (String) typedOption.longOpt ?: typedOption.opt
+        if (parseResult.hasMatchedOption(optionName)) {
+            return parseResult.matchedOptionValue(optionName, defaultValue)
+        } else {
+            OptionSpec option = parseResult.commandSpec().findOption(optionName)
+            return option ? option.value : defaultValue
+        }
+    }
+
+    public <T> T getAt(TypedOption<T> typedOption) {
+        getAt(typedOption, null)
+    }
+
+    public <T> T getAt(TypedOption<T> typedOption, T defaultValue) {
+        getOptionValue(typedOption, defaultValue)
+    }
+
+    private <T> T getTypedValue(Class<T> type, String optionName, String optionValue) {
+        if (savedTypeOptions[optionName]?.cliOption?.arity?.min == 0) { // TODO is this not a bug?
+            return (T) parseResult.hasMatchedOption(optionName) // TODO should defaultValue not simply convert the type regardless of the matched value?
+        }
+        def convert = savedTypeOptions[optionName]?.convert
+        return getValue(type, optionValue, convert)
+    }
+
+    private <T> T getValue(Class<T> type, String optionValue, Closure convert) {
+        if (!type) {
+            return (T) optionValue
+        }
+        if (Closure.isAssignableFrom(type) && convert) {
+            return (T) convert(optionValue)
+        }
+        if (type == Boolean || type == Boolean.TYPE) {
+            return type.cast(Boolean.parseBoolean(optionValue))
+        }
+        StringGroovyMethods.asType(optionValue, (Class<T>) type)
+    }
+
+    Properties getOptionProperties(String name) {
+        if (!parseResult.hasMatchedOption(name)) {
+            return null
+        }
+        List<String> keyValues = parseResult.matchedOption(name).stringValues()
+        Properties result = new Properties()
+        keyValues.toSpreadMap().each { k, v -> result.setProperty(k, v) }
+        result
+    }
+
+    def invokeMethod(String name, Object args) {
+        // TODO we could just declare normal methods to map commons-cli CommandLine methods to picocli ParseResult methods
+        if (name == 'hasOption')      { name = 'hasMatchedOption';   args = [args[0]      ].toArray() }
+        if (name == 'getOptionValue') { name = 'matchedOptionValue'; args = [args[0], null].toArray() }
+        return InvokerHelper.getMetaClass(parseResult).invokeMethod(parseResult, name, args)
+    }
+
+    def getProperty(String name) {
+        if (name == 'parseResult') { return parseResult }
+        if (parseResult.hasMatchedOption(name)) {
+            def result = parseResult.matchedOptionValue(name, null)
+
+            // if user specified an array type, return the full array (regardless of 's' suffix on name)
+            Class userSpecifiedType = savedTypeOptions[name]?.type
+            if (userSpecifiedType?.isArray()) { return result }
+
+            // otherwise, if the result is multi-value, return the first value
+            Class derivedType = parseResult.matchedOption(name).type()
+            if (derivedType.isArray()) {
+                return result ? result[0] : null
+            } else if (Collection.class.isAssignableFrom(derivedType)) {
+                return (result as Collection)?.first()
+            }
+            if (!userSpecifiedType && result == '' && parseResult.matchedOption(name).arity().min == 0) {
+                return true
+            }
+            return parseResult.matchedOption(name).typedValues().get(0)
+        }
+        if (parseResult.commandSpec().findOption(name)) { // requested option was not matched: return its default
+            def option = parseResult.commandSpec().findOption(name)
+            def result = option.value
+            return result ? result : false
+        }
+        if (name.size() > 1 && name.endsWith('s')) { // user wants multi-value result
+            def singularName = name[0..-2]
+            if (parseResult.hasMatchedOption(singularName)) {
+                // if picocli has a strongly typed multi-value result, return it
+                Class type = parseResult.matchedOption(singularName).type()
+                if (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {
+                    return parseResult.matchedOptionValue(singularName, null)
+                }
+                // otherwise, return the raw string values as a list
+                return parseResult.matchedOption(singularName).stringValues()
+            }
+        }
+        false
+    }
+
+    List<String> arguments() {
+        parseResult.hasMatchedPositional(0) ? parseResult.matchedPositional(0).stringValues() : []
+    }
+}
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/CliBuilder.groovy
new file mode 100644
index 0000000000..bce9ebb401
--- /dev/null
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/CliBuilder.groovy
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.util
+
+/**
+ * @deprecated use {@link groovy.cli.picocli.CliBuilder}
+ */
+@Deprecated
+class CliBuilder {
+    private @Delegate groovy.cli.picocli.CliBuilder delegate = new groovy.cli.picocli.CliBuilder()
+
+    // explicit delegate to convert return type to expected legacy package
+    OptionAccessor parse(args) {
+        return new OptionAccessor(delegate: delegate.parse(args))
+    }
+
+    // explicit delegate since groovyObject methods ignored by @Delegate
+    def invokeMethod(String name, Object args) {
+        delegate.invokeMethod(name, args)
+    }
+}
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/OptionAccessor.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/OptionAccessor.groovy
new file mode 100644
index 0000000000..fe77e74235
--- /dev/null
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/util/OptionAccessor.groovy
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.util
+
+/**
+ * @deprecated use {@link groovy.cli.picocli.CliBuilder}
+ */
+@Deprecated
+class OptionAccessor {
+    @Delegate
+    groovy.cli.picocli.OptionAccessor delegate
+
+    // explicit delegate since groovyObject methods ignored by @Delegate
+    def getProperty(String name) {
+        delegate.getProperty(name)
+    }
+
+    // explicit delegate since groovyObject methods ignored by @Delegate
+    def invokeMethod(String name, Object args) {
+        delegate.invokeMethod(name, args)
+    }
+}
diff --git a/subprojects/groovy-console/build.gradle b/subprojects/groovy-console/build.gradle
index dc488bb56b..c55970d936 100644
--- a/subprojects/groovy-console/build.gradle
+++ b/subprojects/groovy-console/build.gradle
@@ -20,7 +20,7 @@ evaluationDependsOn(':groovy-swing')
 
 dependencies {
     compile rootProject
-    compile project(':groovy-cli-commons')
+    compile project(':groovy-cli-picocli')
     compile project(':groovy-swing')
     compile project(':groovy-templates')
     testCompile project(':groovy-test')
diff --git a/subprojects/groovy-docgenerator/build.gradle b/subprojects/groovy-docgenerator/build.gradle
index 40b7da5646..552d4bdc6b 100644
--- a/subprojects/groovy-docgenerator/build.gradle
+++ b/subprojects/groovy-docgenerator/build.gradle
@@ -18,7 +18,6 @@
  */
 dependencies {
     compile rootProject
-    compile project(':groovy-cli-commons')
     compile project(':groovy-cli-picocli')
     compile project(':groovy-templates')
     testCompile project(':groovy-test')
diff --git a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy b/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
index eb1c35e411..3822935f4d 100644
--- a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
+++ b/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
@@ -23,6 +23,7 @@ import com.thoughtworks.qdox.model.JavaClass
 import com.thoughtworks.qdox.model.JavaMethod
 import com.thoughtworks.qdox.model.JavaParameter
 import com.thoughtworks.qdox.model.Type
+import groovy.cli.picocli.CliBuilder
 import groovy.text.SimpleTemplateEngine
 import groovy.text.Template
 import groovy.text.TemplateEngine
@@ -36,8 +37,6 @@ import java.util.concurrent.ConcurrentHashMap
 /**
  * Generate documentation about the methods provided by the Groovy Development Kit
  * that enhance the standard JDK classes.
- *
- * @author Guillaume Laforge, John Wilson, Bernhard Huber, Paul King, Yasuharu Nakano
  */
 class DocGenerator {
     private static final MessageSource messages = new MessageSource(DocGenerator)
diff --git a/subprojects/groovy-groovydoc/build.gradle b/subprojects/groovy-groovydoc/build.gradle
index 0fa7a315ea..0f20879137 100644
--- a/subprojects/groovy-groovydoc/build.gradle
+++ b/subprojects/groovy-groovydoc/build.gradle
@@ -19,7 +19,6 @@
 dependencies {
     compile rootProject
     testCompile rootProject.sourceSets.test.runtimeClasspath
-    compile project(':groovy-cli-commons')
     compile project(':groovy-cli-picocli')
     compile project(':groovy-templates')
     runtime project(':groovy-dateutil')
diff --git a/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy b/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
index 8266b83bb3..0579cda4c5 100644
--- a/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
+++ b/subprojects/groovy-groovydoc/src/main/groovy/org/codehaus/groovy/tools/groovydoc/Main.groovy
@@ -18,6 +18,7 @@
  */
 package org.codehaus.groovy.tools.groovydoc
 
+import groovy.cli.picocli.CliBuilder
 import groovy.io.FileType
 import org.codehaus.groovy.tools.groovydoc.gstringTemplates.GroovyDocTemplateInfo
 import org.codehaus.groovy.tools.shell.IO
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
index 51696ad760..643f81fde6 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Main.groovy
@@ -18,6 +18,7 @@
  */
 package org.codehaus.groovy.tools.shell
 
+import groovy.cli.commons.CliBuilder
 import jline.TerminalFactory
 import jline.UnixTerminal
 import jline.UnsupportedTerminal
@@ -40,7 +41,6 @@ import static org.apache.groovy.util.SystemUtil.setSystemPropertyFrom
  * Clients may use configureAndStartGroovysh to provide the same CLI params
  * but a different Groovysh implementation (implementing getIO() and run()).
  *
- *
  * The class also has static utility methods to manipulate the
  * static ansi state using the jAnsi library.
  *

Commit:
237f8cceb6933bdb191ef47a4d4556b6db6fa2df
Paul King
paulk@asert.com.au
2018-04-28 08:36:40 +1000
GROOVY-8520 add picocli-based CliBuilder (closes #688)
diff --git a/build.gradle b/build.gradle
index 20a9b61a89..009381f3d0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -163,6 +163,7 @@ ext {
     luceneVersion = '4.7.2'
     openbeansVersion = '1.0'
     openejbVersion = '1.0'
+    picocliVersion = '3.0.0-beta-2'
     qdoxVersion = '1.12.1'
     slf4jVersion = '1.7.21'
     xmlunitVersion = '1.6'
@@ -181,6 +182,7 @@ dependencies {
     compile "org.ow2.asm:asm-util:$asmVersion"
 
     compile "commons-cli:commons-cli:$commonsCliVersion"
+    compile "info.picocli:picocli:$picocliVersion"
     compile "org.apache.ant:ant:$antVersion"
     compile("com.thoughtworks.xstream:xstream:$xstreamVersion") {
         exclude(group: 'xpp3', module: 'xpp3_min')
diff --git a/gradle/binarycompatibility.gradle b/gradle/binarycompatibility.gradle
index 66b41c2516..274838b459 100644
--- a/gradle/binarycompatibility.gradle
+++ b/gradle/binarycompatibility.gradle
@@ -35,7 +35,7 @@ task checkBinaryCompatibility {
 check.dependsOn(checkBinaryCompatibility)
 
 // for comparing between versions with different modules, set excludeModules to differing modules, e.g.
-def excludeModules = ['groovy-cli-commons', 'groovy-dateutil', 'groovy-datetime', 'performance', 'groovy-macro', 'tests-vm8', 'groovy-json-direct']
+def excludeModules = ['groovy-cli-picocli', 'groovy-cli-commons', 'groovy-dateutil', 'groovy-datetime', 'performance', 'groovy-macro', 'tests-vm8', 'groovy-json-direct']
 //def excludeModules = []
 
 Set projectsToCheck = allprojects.findAll{ !(it.name in excludeModules) }
diff --git a/settings.gradle b/settings.gradle
index e1441f30aa..0405148218 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -19,6 +19,7 @@
 def subprojects = ['groovy-ant',
         'groovy-bsf',
         'groovy-cli-commons',
+        'groovy-cli-picocli',
         'groovy-console',
         'groovy-datetime',
         'groovy-dateutil',
diff --git a/src/spec/assets/img/usageMessageSpec.png b/src/spec/assets/img/usageMessageSpec.png
new file mode 100644
index 0000000000..09e2c09b15
Binary files /dev/null and b/src/spec/assets/img/usageMessageSpec.png differ
diff --git a/src/spec/doc/core-domain-specific-languages.adoc b/src/spec/doc/core-domain-specific-languages.adoc
index c9c8e8147b..1d893b2595 100644
--- a/src/spec/doc/core-domain-specific-languages.adoc
+++ b/src/spec/doc/core-domain-specific-languages.adoc
@@ -1184,7 +1184,7 @@ properties are supported when specifying an allowed commandline option:
 | type           | the type of this option | `Class`
 | valueSeparator | the character that is the value separator | `char`<2>
 | defaultValue   | a default value | `String`
-| convert        | converts the incoming String to the required type | `Closure`<2>
+| convert        | converts the incoming String to the required type | `Closure`<1>
 |======================
 <1> More details later
 <2> Single character Strings are coerced to chars in special cases in Groovy
@@ -1324,7 +1324,7 @@ multiple arguments.
 Arguments on the commandline are by nature Strings (or arguably can be considered Booleans for flags) but can be
 converted to richer types automatically by supplying additional typing information. For the
 annotation-based argument definition style, these types are supplied using the field types for annotation
-properties or return types of annotated methods (are the setter argument type for setter methods).
+properties or return types of annotated methods (or the setter argument type for setter methods).
 For the dynamic method style of argument definition a special 'type' property is supported
 which allows you to specify a Class name.
 
@@ -1367,14 +1367,15 @@ include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withConve
 
 ===== Options with multiple arguments
 
-Multiple arguments are also supported using an args value greater than 1. There is a special named parameter,
+Multiple arguments are also supported using an `args` value greater than 1. There is a special named parameter,
 `valueSeparator`, which can also be optionally used when processing multiple arguments. It allows some additional
 flexibility in the syntax supported when supplying such argument lists on the commandline. For example,
 supplying a value separator of ',' allows a comma-delimited list of values to be passed on the commandline.
 
 The `args` value is normally an integer. It can be optionally supplied as a String. There are two special
-String symbols: `+` and `*`. The `*` value means 0 or more. The `+` value means 1 or more. The `*` value is
-the same as using `+` and also setting the `optionalArg` value to true.
+String symbols: `&plus;` and `&#42;`.
+The `&#42;` value means 0 or more. The `&plus;` value means 1 or more.
+The `&#42;` value is the same as using `&plus;` and also setting the `optionalArg` value to true.
 
 Accessing the multiple arguments follows a special convention. Simply add an 's' to the normal property
 you would use to access the argument option and you will retrieve all the supplied arguments as a list.
@@ -1495,8 +1496,8 @@ Then, the following statements can be in a separate part of your code which is t
 ----
 def args = '--age 21'.split()
 def options = cli.parse(args)
-int age = options[age]
-assert age == 21
+int a = options[age]
+assert a == 21
 ----
 
 Finally, there is one additional convenience method offered by `CliBuilder` to even allow the
@@ -1516,7 +1517,8 @@ include::{projectdir}/src/spec/test/builder/CliBuilderTest.groovy[tags=withTypeC
 ===============================
 *NOTE* Advanced CLI features
 
-`CliBuilder` can be thought of as a Groovy friendly wrapper on top of (currently) Apache Commons CLI.
+`CliBuilder` can be thought of as a Groovy friendly wrapper on top of either
+https://github.com/remkop/picocli[picocli] or https://commons.apache.org/proper/commons-cli/[Apache Commons CLI].
 If there is a feature not provided by `CliBuilder` that you know is supported in the underlying
 library, the current `CliBuilder` implementation (and various Groovy language features) make it easy for you
 to call the underlying library methods directly. Doing so is a pragmatic way to leverage the Groovy-friendly
@@ -1525,6 +1527,8 @@ A word of caution however; future versions of `CliBuilder` could potentially use
 and in that event, some porting work may be required for your Groovy classes and/or scripts.
 ===============================
 
+====== Apache Commons CLI
+
 As an example, here is some code for making use of Apache Commons CLI's grouping mechanism:
 
 [source,groovy]
@@ -1544,6 +1548,103 @@ assert !cli.parse('-d -o'.split()) // <1>
 ----
 <1> The parse will fail since only one option from a group can be used at a time.
 
+====== Picocli
+Below are some features available in the picocli version of `CliBuilder`.
+
+*New property: errorWriter*
+
+When users of your application give invalid command line arguments,
+CliBuilder writes an error message and the usage help message to the `stderr` output stream.
+It doesn’t use the `stdout` stream to prevent the error message from being parsed when your program's
+output is used as input for another process.
+You can customize the destination by setting the `errorWriter` to a different value.
+
+On the other hand, `CliBuilder.usage()` prints the usage help message to the `stdout` stream.
+This way, when users request help (e.g. with a `--help` parameter),
+they can pipe the output to a utility like `less` or `grep`.
+
+You can specify different writers for testing.
+_Be aware that for backwards compatibility, setting the `writer` property to a different value
+will set *both* the `writer` and the `errorWriter` to the specified writer._
+
+*ANSI colors*
+
+The picocli version of CliBuilder renders the usage help message in ANSI colors on supported platforms automatically.
+If desired you can http://picocli.info/#_usage_help_with_styles_and_colors[customize] this.
+(An example follows below.)
+
+*New property: name*
+
+As before, you can set the synopsis of the usage help message with the `usage` property.
+You may be interested in a small improvement:
+if you only set the command `name`, a synopsis will be generated automatically,
+with repeating elements followed by `...` and optional elements surrounded with `[` and `]`.
+(An example follows below.)
+
+*New property: usageMessage*
+
+This property exposes a `UsageMessageSpec` object from the underlying picocli library,
+which gives fine-grained control over various sections of the usage help message. For example:
+
+[source,groovy]
+----
+def cli = new CliBuilder()
+cli.name = "myapp"
+cli.usageMessage.with {
+    headerHeading("@|bold,underline Header heading:|@%n")
+    header("Header 1", "Header 2")                     // before the synopsis
+    synopsisHeading("%n@|bold,underline Usage:|@ ")
+    descriptionHeading("%n@|bold,underline Description heading:|@%n")
+    description("Description 1", "Description 2")      // after the synopsis
+    optionListHeading("%n@|bold,underline Options heading:|@%n")
+    footerHeading("%n@|bold,underline Footer heading:|@%n")
+    footer("Footer 1", "Footer 2")
+}
+cli.a('option a description')
+cli.b('option b description')
+cli.c(args: '*', 'option c description')
+cli.usage()
+----
+Gives this output:
+
+image::assets/img/usageMessageSpec.png[]
+
+
+*New property: parser*
+
+The `parser` property gives access to the picocli `ParserSpec` object that can be used to customize the parser behavior.
+See the http://picocli.info/apidocs/picocli/CommandLine.Model.ParserSpec.html[documentation] for details.
+
+*Map options*
+
+Finally, if your application has options that are key-value pairs, you may be interested in picocli's support for maps. For example:
+
+[source,groovy]
+----
+import java.util.concurrent.TimeUnit
+import static java.util.concurrent.TimeUnit.DAYS
+import static java.util.concurrent.TimeUnit.HOURS
+
+def cli = new CliBuilder()
+cli.D(args: 2,   valueSeparator: '=', 'the old way')                          // <1>
+cli.X(type: Map, 'the new way')                                               // <2>
+cli.Z(type: Map, auxiliaryTypes: [TimeUnit, Integer].toArray(), 'typed map')  // <3>
+
+def options = cli.parse('-Da=b -Dc=d -Xx=y -Xi=j -ZDAYS=2 -ZHOURS=23'.split())// <4>
+assert options.Ds == ['a', 'b', 'c', 'd']                                     // <5>
+assert options.Xs == [ 'x':'y', 'i':'j' ]                                     // <6>
+assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         // <7>
+----
+<1> Previously, `key=value` pairs were split up into parts and added to a list
+<2> Picocli map support: simply specify `Map` as the type of the option
+<3> You can even specify the type of the map elements
+<4> To compare, let's specify two key-value pairs for each option
+<5> Previously, all key-value pairs end up in a list and it is up to the application to work with this list
+<6> Picocli returns the key-value pairs as a `Map`
+<7> Both keys and values of the map can be strongly typed
+
+
+
 ==== ObjectGraphBuilder
 
 `ObjectGraphBuilder` is a builder for an arbitrary graph of beans that
diff --git a/subprojects/groovy-cli-picocli/build.gradle b/subprojects/groovy-cli-picocli/build.gradle
new file mode 100644
index 0000000000..e41bea9eec
--- /dev/null
+++ b/subprojects/groovy-cli-picocli/build.gradle
@@ -0,0 +1,25 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+dependencies {
+    compile rootProject
+    compile "info.picocli:picocli:$picocliVersion"
+//    compile files ('C:/Users/remko/IdeaProjects/picocli/build/libs/picocli-3.0.0-beta-3-SNAPSHOT.jar')
+    testCompile project(':groovy-test')
+    testCompile project(':groovy-dateutil')
+}
diff --git a/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
new file mode 100644
index 0000000000..352eb68b9e
--- /dev/null
+++ b/subprojects/groovy-cli-picocli/src/main/groovy/groovy/cli/picocli/CliBuilder.groovy
@@ -0,0 +1,1028 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.cli.picocli
+
+import groovy.cli.CliBuilderException
+import groovy.cli.Option
+import groovy.cli.TypedOption
+import groovy.cli.Unparsed
+import groovy.transform.Undefined
+import org.codehaus.groovy.runtime.InvokerHelper
+import org.codehaus.groovy.runtime.MetaClassHelper
+import org.codehaus.groovy.runtime.StringGroovyMethods
+import picocli.CommandLine
+import picocli.CommandLine.ITypeConverter
+import picocli.CommandLine.Model.CommandSpec
+import picocli.CommandLine.Model.IGetter
+import picocli.CommandLine.Model.ISetter
+import picocli.CommandLine.Model.OptionSpec
+import picocli.CommandLine.Model.ParserSpec
+import picocli.CommandLine.Model.PositionalParamSpec
+import picocli.CommandLine.Model.UsageMessageSpec
+import picocli.CommandLine.ParseResult
+
+import java.lang.reflect.Field
+import java.lang.reflect.Method
+
+/**
+ * Provides a builder to assist the processing of command line arguments.
+ * Two styles are supported: dynamic api style (declarative method calls provide a mini DSL for describing options)
+ * and annotation style (annotations on an interface or class describe options).
+ * <p>
+ * <b>Dynamic api style</b>
+ * <p>
+ * Typical usage (emulate partial arg processing of unix command: ls -alt *.groovy):
+ * <pre>
+ * def cli = new CliBuilder(name:'ls')
+ * cli.a('display all files')
+ * cli.l('use a long listing format')
+ * cli.t('sort by modification time')
+ * def options = cli.parse(args)
+ * assert options // would be null (false) on failure
+ * assert options.arguments() == ['*.groovy']
+ * assert options.a && options.l && options.t
+ * </pre>
+ * The usage message for this example (obtained using <code>cli.usage()</code>) is shown below:
+ * <pre>
+ * Usage: ls [-alt]
+ *   -a     display all files
+ *   -l     use a long listing format
+ *   -t     sort by modification time
+ * </pre>
+ * An underlying parser that supports what is called argument 'bursting' is used
+ * by default. Bursting would convert '-alt' into '-a -l -t' provided no long
+ * option exists with value 'alt' and provided that none of 'a', 'l' or 't'
+ * takes an argument (in fact the last one is allowed to take an argument).
+ * The bursting behavior can be turned off by configuring the underlying parser.
+ * The simplest way to achieve this is by setting the posix property on the CliBuilder
+ * to false, i.e. include {@code posix: false} in the constructor call.
+ * <p>
+ * Another example (partial emulation of arg processing for 'ant' command line):
+ * <pre>
+ * def cli = new CliBuilder(usage:'ant [options] [targets]',
+ *                          header:'Options:')
+ * cli.help('print this message')
+ * cli.logfile(type:File, argName:'file', 'use given file for log')
+ * cli.D(type:Map, argName:'property=value', 'use value for given property')
+ * cli.lib(argName:'path', valueSeparator:',', args: '3',
+ *      'comma-separated list of 3 paths to search for jars and classes')
+ * def options = cli.parse(args)
+ * ...
+ * </pre>
+ * Usage message would be:
+ * <pre>
+ * Usage: ant [options] [targets]
+ * Options:
+ *   -D= &lt;property=value>   use value for given property
+ *       -help              print this message
+ *       -lib=&lt;path>,&lt;path>,&lt;path>
+ *                          comma-separated list of 3 paths to search for jars and
+ *                            classes
+ *       -logfile=&lt;file>    use given file for log
+ * </pre>
+ * And if called with the following arguments '-logfile foo -Dbar=baz -lib=/tmp,/usr/lib,~/libs target'
+ * then the following assertions would be true:
+ * <pre>
+ * assert options // would be null (false) on failure
+ * assert options.arguments() == ['target']
+ * assert options.D == ['bar': 'baz']
+ * assert options.libs == ['/tmp', '/usr/lib', '~/libs']
+ * assert options.lib == '/tmp'
+ * assert options.logfile == new File('foo')
+ * </pre>
+ * Note the use of some special notation. By adding 's' onto an option
+ * that may appear multiple times and has an argument or as in this case
+ * uses a valueSeparator to separate multiple argument values
+ * causes the list of associated argument values to be returned.
+ * <p>
+ * Another example showing long options (partial emulation of arg processing for 'curl' command line):
+ * <pre>
+ * def cli = new CliBuilder(usage:'curl [options] &lt;url&gt;')
+ * cli._(longOpt:'basic', 'Use HTTP Basic Authentication')
+ * cli.d(longOpt:'data', args:1, argName:'data', 'HTTP POST data')
+ * cli.G(longOpt:'get', 'Send the -d data with a HTTP GET')
+ * cli.q('If used as the first parameter disables .curlrc')
+ * cli._(longOpt:'url', args:1, argName:'URL', 'Set URL to work with')
+ * </pre>
+ * Which has the following usage message:
+ * <pre>
+ * Usage: curl [options] &lt;url>
+ *       -basic, --basic         Use HTTP Basic Authentication
+ *   -d, -data, --data=&lt;data>    HTTP POST data
+ *   -G, -get, --get             Send the -d data with a HTTP GET
+ *   -q                          If used as the first parameter disables .curlrc
+ *       -url, --url=&lt;URL>       Set URL to work with
+ * </pre>
+ * This example shows a common convention. When mixing short and long names, the
+ * short names are often one character in size. One character options with
+ * arguments don't require a space between the option and the argument, e.g.
+ * <code>-Ddebug=true</code>. The example also shows
+ * the use of '_' when no short option is applicable.
+ * <p>
+ * Also note that '_' was used multiple times. This is supported but if
+ * any other shortOpt or any longOpt is repeated, then the underlying library throws an exception.
+ * <p>
+ * Short option names may not contain a hyphen. If a long option name contains a hyphen, e.g. '--max-wait' then you can either
+ * use the long hand method call <code>options.hasOption('max-wait')</code> or surround
+ * the option name in quotes, e.g. <code>options.'max-wait'</code>.
+ * <p>
+ * Although CliBuilder on the whole hides away the underlying library used
+ * for processing the arguments, it does provide some hooks which let you
+ * make use of the underlying library directly should the need arise. For
+ * example, the last two lines of the 'curl' example above could be replaced
+ * with the following:
+ * <pre>
+ * import picocli.CommandLine.Model.*
+ * ... as before ...
+ * cli << OptionSpec.builder('-q').
+ *                      description('If used as the first parameter disables .curlrc').build()
+ * cli << OptionSpec.builder('--url').type(URL.class).paramLabel('&lt;URL>').
+ *                      description('Set URL to work with').build()
+ * ...
+ * </pre>
+ *
+ * <p>
+ * <b>Supported Option Properties</b>:
+ * <table border="1" cellspacing="0">
+ *   <tr>
+ *     <th>Property</th>
+ *     <th>Type</th>
+ *     <th>Picocli equivalent</th>
+ *     <th>Description</th>
+ *   </tr>
+ *   <tr>
+ *     <th><code>argName</code></th>
+ *     <td>String</td>
+ *     <td><code>names</code></td>
+ *     <td>Short name for the option, will be prefixed with a single hyphen.</td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>longOpt</code></th>
+ *     <td>String</td>
+ *     <td><code>names</code></td>
+ *     <td>Long name for the option, which may be prefixed with either a single hypen or two hyphens.
+ *       An option must have either a long name or a short name (or both).</td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>args</code></th>
+ *     <td>int&nbsp;or&nbsp;String</td>
+ *     <td><code>arity</code></td>
+ *     <td><code>args</code> indicates the number of parameters for this option.
+ *       A String value of '+' indicates at least one up to any number of parameters.
+ *       The minimum number of parameters depends on the type (booleans require no parameters)
+ *       and the <code>optionalArg</code> setting.
+ *       </td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>optionalArg</code></th>
+ *     <td>boolean</td>
+ *     <td><code>arity</code></td>
+ *     <td>If <code>optionalArg=true</code>, then <code>args=3</code>
+ *       is the equivalent of <code>arity="0..3"</code> in picocli.
+ *       When <code>optionalArg=true</code>, <code>args='+'</code>
+ *       is equivalent to <code>arity="0..*"</code>.
+ *       </td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>required</code></th>
+ *     <td>boolean</td>
+ *     <td><code>required</code></td>
+ *     <td>If <code>true</code>, this option must be specified on the command line, or an exception is thrown.
+ *       </td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>type</code></th>
+ *     <td>Class</td>
+ *     <td><code>type</code></td>
+ *     <td>Option parameters are converted to this type. The underlying library has built-in converters for
+ *     <a href="http://picocli.info/#_built_in_types">many types</a>.
+ *       A custom converter can be specified with the <code>convert</code> property.
+ *       </td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>convert</code></th>
+ *     <td>Closure</td>
+ *     <td><code>converter</code></td>
+ *     <td>A closure that takes a single String parameter and returns an object converted to the <code>type</code> of this option.
+ *       The picocli equivalent is the <code><a href="http://picocli.info/#_custom_type_converters">ITypeConverter</a></code> interface.
+ *       </td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>valueSeparator</code></th>
+ *     <td>char</td>
+ *     <td><code>splitRegex</code></td>
+ *     <td>The character used to split a single command line argument into parts.
+ *       </td>
+ *   </tr>
+ *   <tr>
+ *     <th><code>defaultValue</code></th>
+ *     <td>String</td>
+ *     <td><code>defaultValue</code></td>
+ *     <td>The value the option should have if it did not appear on the command line.
+ *       The specified String value will be split into parts with the <code>valueSeparator</code> and
+ *       converted to the option <code>type</code> before it is set.
+ *       </td>
+ *   </tr>
+ * </table>
+ * See {@link CliBuilderTest} for further examples.
+ * <p>
+ * <b>@-files</b>
+ * <p>
+ * CliBuilder also supports Argument File processing. If an argument starts with
+ * an '@' character followed by a filename, then the contents of the file with name
+ * filename are placed into the command line. The feature can be turned off by
+ * setting expandArgumentFiles to false. If turned on, you can still pass a real
+ * parameter with an initial '@' character by escaping it with an additional '@'
+ * symbol, e.g. '@@foo' will become '@foo' and not be subject to expansion. As an
+ * example, if the file temp.args contains the content:
+ * <pre>
+ * -arg1
+ * paramA
+ * paramB paramC
+ * </pre>
+ * Then calling the command line with:
+ * <pre>
+ * someCommand @temp.args -arg2 paramD
+ * </pre>
+ * Is the same as calling this:
+ * <pre>
+ * someCommand -arg1 paramA paramB paramC -arg2 paramD
+ * </pre>
+ * This feature is particularly useful on operating systems which place limitations
+ * on the size of the command line (e.g. Windows). The feature is similar to
+ * the 'Command Line Argument File' processing supported by javadoc and javac.
+ * Consult the corresponding documentation for those tools if you wish to see further examples.
+ * <p>
+ * <b>Annotation style with an interface</b>
+ * <p>
+ * With this style an interface is defined containing an annotated method for each option.
+ * It might look like this (following roughly the earlier 'ls' example):
+ * <pre>
+ * import groovy.cli.Option
+ * import groovy.cli.Unparsed
+ *
+ * interface OptionInterface {
+ *     @{@link groovy.cli.Option}(shortName='a', description='display all files') boolean all()
+ *     @{@link groovy.cli.Option}(shortName='l', description='use a long listing format') boolean longFormat()
+ *     @{@link groovy.cli.Option}(shortName='t', description='sort by modification time') boolean time()
+ *     @{@link groovy.cli.Unparsed} List remaining()
+ * }
+ * </pre>
+ * Then this description is supplied to CliBuilder during parsing, e.g.:
+ * <pre>
+ * def args = '-alt *.groovy'.split() // normally from commandline itself
+ * def cli = new CliBuilder(usage:'ls')
+ * def options = cli.parseFromSpec(OptionInterface, args)
+ * assert options.remaining() == ['*.groovy']
+ * assert options.all() && options.longFormat() && options.time()
+ * </pre>
+ * <p>
+ * <b>Annotation style with a class</b>
+ * <p>
+ * With this style a user-supplied instance is used. Annotations on that instance's class
+ * members (properties and setter methods) indicate how to set options and provide the option details
+ * using annotation attributes.
+ * It might look like this (again using the earlier 'ls' example):
+ * <pre>
+ * import groovy.cli.Option
+ * import groovy.cli.Unparsed
+ *
+ * class OptionClass {
+ *     @{@link groovy.cli.Option}(shortName='a', description='display all files') boolean all
+ *     @{@link groovy.cli.Option}(shortName='l', description='use a long listing format') boolean longFormat
+ *     @{@link groovy.cli.Option}(shortName='t', description='sort by modification time') boolean time
+ *     @{@link groovy.cli.Unparsed} List remaining
+ * }
+ * </pre>
+ * Then this description is supplied to CliBuilder during parsing, e.g.:
+ * <pre>
+ * def args = '-alt *.groovy'.split() // normally from commandline itself
+ * def cli = new CliBuilder(usage:'ls')
+ * def options = new OptionClass()
+ * cli.parseFromInstance(options, args)
+ * assert options.remaining == ['*.groovy']
+ * assert options.all && options.longFormat && options.time
+ * </pre>
+ */
+class CliBuilder {
+    /**
+     * The command synopsis displayed as the first line in the usage help message, e.g., when <code>cli.usage()</code> is called.
+     * When not set, a default synopsis is generated that shows the supported options and parameters.
+     */
+    String usage = 'groovy'
+
+    /**
+     * This property allows customizing the program name displayed in the synopsis when <code>cli.usage()</code> is called.
+     * Ignored if the {@link #usage} property is set.
+     * @since 2.5
+     */
+    String name = 'groovy'
+
+    /**
+     * To disallow clustered POSIX short options, set this to false.
+     */
+    Boolean posix = true
+
+    /**
+     * Whether arguments of the form '{@code @}<i>filename</i>' will be expanded into the arguments contained within the file named <i>filename</i> (default true).
+     */
+    boolean expandArgumentFiles = true
+
+    /**
+     * Configures what the parser should do when arguments not recognized
+     * as options are encountered: when <code>true</code> (the default), the
+     * remaining arguments are all treated as positional parameters.
+     * When <code>false</code>, the parser will continue to look for options, and
+     * only the unrecognized arguments are treated as positional parameters.
+     */
+    boolean stopAtNonOption = true
+
+    /**
+     * For backwards compatibility with Apache Commons CLI, set this property to
+     * <code>true</code> if the parser should recognize long options with both
+     * a single hyphen and a double hyphen prefix. The default is <code>false</code>,
+     * so only long options with a double hypen prefix (<code>--option</code>) are recognized.
+     */
+    boolean acceptLongOptionsWithSingleHyphen = false
+
+    /**
+     * The PrintWriter to write the {@linkplain #usage} help message to
+     * when <code>cli.usage()</code> is called.
+     * Defaults to stdout but you can provide your own PrintWriter if desired.
+     */
+    PrintWriter writer = new PrintWriter(System.out)
+
+    /**
+     * The PrintWriter to write to when invalid user input was provided to
+     * the {@link #parse(java.lang.String[])} method.
+     * Defaults to stderr but you can provide your own PrintWriter if desired.
+     * @since 2.5
+     */
+    PrintWriter errorWriter = new PrintWriter(System.err)
+
+    /**
+     * Optional additional message for usage; displayed after the usage summary
+     * but before the options are displayed.
+     */
+    String header = null
+
+    /**
+     * Optional additional message for usage; displayed after the options.
+     */
+    String footer = null
+
+    /**
+     * Allows customisation of the usage message width.
+     */
+    int width = UsageMessageSpec.DEFAULT_USAGE_WIDTH
+
+    /**
+     * Not normally accessed directly but allows fine-grained control over the
+     * parser behaviour via the API of the underlying library if needed.
+     * @since 2.5
+     */
+    // Implementation note: this object is separate from the CommandSpec.
+    // The values collected here are copied into the ParserSpec of the command.
+    final ParserSpec parser = new ParserSpec()
+            .stopAtPositional(true)
+            .unmatchedOptionsArePositionalParams(true)
+            .aritySatisfiedByAttachedOptionParam(true)
+            .limitSplit(true)
+            .overwrittenOptionsAllowed(true)
+            .toggleBooleanFlags(false)
+
+    /**
+     * Not normally accessed directly but allows fine-grained control over the
+     * usage help message via the API of the underlying library if needed.
+     * @since 2.5
+     */
+    // Implementation note: this object is separate from the CommandSpec.
+    // The values collected here are copied into the UsageMessageSpec of the command.
+    final UsageMessageSpec usageMessage = new UsageMessageSpec()
+
+    Map<String, TypedOption> savedTypeOptions = new HashMap<String, TypedOption>()
+
+    // CommandSpec is the entry point into the picocli object model for a command.
+    // It gives access to a ParserSpec to customize the parser behaviour and
+    // a UsageMessageSpec to customize the usage help message.
+    // Add OptionSpec and PositionalParamSpec objects to this object to define
+    // the options and positional parameters this command recognizes.
+    //
+    // This field is private for now.
+    // It is initialized to an empty spec so options and positional parameter specs
+    // can be added dynamically via the programmatic API.
+    // When a command spec is defined via annotations, the existing instance is
+    // replaced with a new one. This allows the outer CliBuilder instance can be reused.
+    private CommandSpec commandSpec = CommandSpec.create()
+
+    void setUsage(String usage) {
+        this.usage = usage
+        usageMessage.customSynopsis(usage)
+    }
+
+    void setFooter(String footer) {
+        this.footer = footer
+        usageMessage.footer(footer)
+    }
+
+    void setHeader(String header) {
+        this.header = header
+        // "header" is displayed after the synopsis in previous CliBuilder versions.
+        // The picocli equivalent is the "description".
+        usageMessage.description(header)
+    }
+
+    void setWidth(int width) {
+        this.width = width
+        usageMessage.width(width)
+    }
+
+    void setExpandArgumentFiles(boolean expand) {
+        this.expandArgumentFiles = expand
+        parser.expandAtFiles(expand)
+    }
+
+    void setPosix(boolean posix) {
+        this.posix = posix
+        parser.posixClusteredShortOptionsAllowed(posix)
+    }
+
+    void setStopAtNonOption(boolean stopAtNonOption) {
+        this.stopAtNonOption = stopAtNonOption
+        parser.stopAtPositional(stopAtNonOption)
+    }
+
+    /**
+     * For backwards compatibility reasons, if a custom {@code writer} is set, this sets
+     * both the {@link #writer} and the {@link #errorWriter} to the specified writer.
+     * @param writer the writer to initialize both the {@code writer} and the {@code errorWriter} to
+     */
+    void setWriter(PrintWriter writer) {
+        this.writer = writer
+        this.errorWriter = writer
+    }
+
+    public <T> TypedOption<T> option(Map args, Class<T> type, String description) {
+        def name = args.opt ?: '_'
+        args.type = type
+        args.remove('opt')
+        "$name"(args, description)
+    }
+
+    /**
+     * Internal method: Detect option specification method calls.
+     */
+    def invokeMethod(String name, Object args) {
+        if (args instanceof Object[]) {
+            if (args.size() == 1 && (args[0] instanceof String || args[0] instanceof GString)) {
+                def option = option(name, [:], args[0]) // args[0] is description
+                commandSpec.addOption(option)
+                return create(option, null, null, null)
+            }
+            if (args.size() == 1 && args[0] instanceof OptionSpec && name == 'leftShift') {
+                OptionSpec option = args[0] as OptionSpec
+                commandSpec.addOption(option)
+                return create(option, null, null, null)
+            }
+            if (args.size() == 2 && args[0] instanceof Map) {
+                Map m = args[0] as Map
+                if (m.type && !(m.type instanceof Class)) {
+                    throw new CliBuilderException("'type' must be a Class")
+                }
+                def option = option(name, m, args[1])
+                commandSpec.addOption(option)
+                return create(option, m.type, option.defaultValue(), option.converters())
+            }
+        }
+        return InvokerHelper.getMetaClass(this).invokeMethod(this, name, args)
+    }
+
+    private TypedOption create(OptionSpec o, Class theType, defaultValue, convert) {
+        String opt = o.names().sort { a, b -> a.length() - b.length() }.first()
+        opt = opt?.length() == 2 ? opt.substring(1) : null
+
+        String longOpt = o.names().sort { a, b -> b.length() - a.length() }.first()
+        longOpt = longOpt?.startsWith("--") ? longOpt.substring(2) : null
+
+        Map<String, Object> result = new TypedOption<Object>()
+        if (opt != null) result.put("opt", opt)
+        result.put("longOpt", longOpt)
+        result.put("cliOption", o)
+        if (defaultValue) {
+            result.put("defaultValue", defaultValue)
+        }
+        if (convert) {
+            if (theType) {
+                throw new CliBuilderException("You can't specify 'type' when using 'convert'")
+            }
+            result.put("convert", convert)
+            result.put("type", convert instanceof Class ? convert : convert.getClass())
+        } else {
+            result.put("type", theType)
+        }
+        savedTypeOptions[longOpt ?: opt] = result
+        result
+    }
+
+    /**
+     * Make options accessible from command line args with parser.
+     * Returns null on bad command lines after displaying usage message.
+     */
+    OptionAccessor parse(args) {
+        CommandLine commandLine = createCommandLine()
+        try {
+            def accessor = new OptionAccessor(commandLine.parseArgs(args as String[]))
+            accessor.savedTypeOptions = savedTypeOptions
+            return accessor
+        } catch (CommandLine.ParameterException pe) {
+            errorWriter.println("error: " + pe.message)
+            printUsage(pe.commandLine, errorWriter)
+            return null
+        }
+    }
+
+    private CommandLine createCommandLine() {
+        commandSpec.parser(parser)
+        commandSpec.name(name).usageMessage(usageMessage)
+        if (commandSpec.positionalParameters().empty) {
+            commandSpec.addPositional(PositionalParamSpec.builder().type(String[]).arity("*").paramLabel("P").hidden(true).build())
+        }
+        return new CommandLine(commandSpec)
+    }
+
+    /**
+     * Prints the usage message with the specified {@link #header header}, {@link #footer footer} and {@link #width width}
+     * to the specified {@link #writer writer} (default: System.out).
+     */
+    void usage() {
+        printUsage(commandSpec.commandLine() ?: createCommandLine(), writer)
+    }
+
+    private void printUsage(CommandLine commandLine, PrintWriter pw) {
+        commandLine.usage(pw)
+        pw.flush()
+    }
+
+    /**
+     * Given an interface containing members with annotations, derive
+     * the options specification.
+     *
+     * @param optionsClass
+     * @param args
+     * @return an instance containing the processed options
+     */
+    public <T> T parseFromSpec(Class<T> optionsClass, String[] args) {
+        def cliOptions = [:]
+        commandSpec = CommandSpec.create()
+        addOptionsFromAnnotations(optionsClass, cliOptions, true)
+        addPositionalsFromAnnotations(optionsClass, cliOptions, true)
+        parse(args)
+        cliOptions as T
+    }
+
+    /**
+     * Given an instance containing members with annotations, derive
+     * the options specification.
+     *
+     * @param optionInstance
+     * @param args
+     * @return the options instance populated with the processed options
+     */
+    public <T> T parseFromInstance(T optionInstance, args) {
+        commandSpec = CommandSpec.create()
+        addOptionsFromAnnotations(optionInstance.getClass(), optionInstance, false)
+        addPositionalsFromAnnotations(optionInstance.getClass(), optionInstance, false)
+        def optionAccessor = parse(args)
+
+        // initialize the boolean properties that were not matched
+        if (optionAccessor) {
+            optionAccessor.parseResult.commandSpec().options().each { option ->
+                if (!optionAccessor.parseResult.hasMatchedOption(option)) {
+                    boolean isFlag = option.arity().max == 0 && option.type().simpleName.toLowerCase() == 'boolean'
+                    if (isFlag) { option.value = false } // else default has already been applied
+                }
+            }
+        }
+        optionInstance
+    }
+
+    private void addOptionsFromAnnotations(Class optionClass, Object target, boolean isCoercedMap) {
+        optionClass.methods.findAll{ it.getAnnotation(Option) }.each { Method m ->
+            Option annotation = m.getAnnotation(Option)
+            ArgSpecAttributes attributes = extractAttributesFromMethod(m, isCoercedMap, target)
+            commandSpec.addOption(createOptionSpec(annotation, attributes, target))
+        }
+        def optionFields = optionClass.declaredFields.findAll { it.getAnnotation(Option) }
+        if (optionClass.isInterface() && !optionFields.isEmpty()) {
+            throw new CliBuilderException("@Option only allowed on methods in interface " + optionClass.simpleName)
+        }
+        optionFields.each { Field f ->
+            Option annotation = f.getAnnotation(Option)
+            ArgSpecAttributes attributes = extractAttributesFromField(f, target)
+            commandSpec.addOption(createOptionSpec(annotation, attributes, target))
+        }
+    }
+
+    private void addPositionalsFromAnnotations(Class optionClass, Object target, boolean isCoercedMap) {
+        optionClass.methods.findAll{ it.getAnnotation(Unparsed) }.each { Method m ->
+            Unparsed annotation = m.getAnnotation(Unparsed)
+            ArgSpecAttributes attributes = extractAttributesFromMethod(m, isCoercedMap, target)
+            commandSpec.addPositional(createPositionalParamSpec(annotation, attributes, target))
+        }
+        def optionFields = optionClass.declaredFields.findAll { it.getAnnotation(Unparsed) }
+        if (optionClass.isInterface() && !optionFields.isEmpty()) {
+            throw new CliBuilderException("@Unparsed only allowed on methods in interface " + optionClass.simpleName)
+        }
+        optionFields.each { Field f ->
+            Unparsed annotation = f.getAnnotation(Unparsed)
+            ArgSpecAttributes attributes = extractAttributesFromField(f, target)
+            commandSpec.addPositional(createPositionalParamSpec(annotation, attributes, target))
+        }
+    }
+
+    private static class ArgSpecAttributes {
+        Class type
+        Class[] auxiliaryTypes
+        String label
+        IGetter getter
+        ISetter setter
+        Object initialValue
+        boolean hasInitialValue
+    }
+
+    private ArgSpecAttributes extractAttributesFromMethod(Method m, boolean isCoercedMap, target) {
+        Class type = isCoercedMap ? m.returnType : (m.parameterTypes.size() > 0 ? m.parameterTypes[0] : m.returnType)
+        type = type && type == Void.TYPE ? null : type
+
+        Class[] auxTypes = null // TODO extract generic types like List<Integer> or Map<Integer,Double>
+
+        // If the method is a real setter, we can't invoke it to get its value,
+        // so instead we need to keep track of its current value ourselves.
+        // Additionally, implementation classes may annotate _getter_ methods with @Option;
+        // if the getter returns a Collection or Map, picocli will add parsed values to it.
+        def currentValue = initialValue(type, m, target, isCoercedMap)
+        def getter = {
+            currentValue
+        }
+        def setter = {
+            def old = currentValue
+            currentValue = it
+            if (!isCoercedMap && m.parameterTypes.size() > 0) {
+                m.invoke(target, [currentValue].toArray())
+            }
+            return old
+        }
+        if (isCoercedMap) {
+            target[m.name] = getter
+        }
+        def label = m.name.startsWith("set") || m.name.startsWith("get") ? MetaClassHelper.convertPropertyName(m.name.substring(3)) : m.name
+        new ArgSpecAttributes(type: type, auxiliaryTypes: auxTypes, label: label, getter: getter, setter: setter, initialValue: currentValue, hasInitialValue: isCoercedMap)
+    }
+
+    private Object initialValue(Class<?> cls, Method m, Object target, boolean isCoercedMap) {
+        if (m.parameterTypes.size() == 0 && m.returnType != Void.TYPE) { // annotated getter
+            if (!isCoercedMap) {
+                return m.invoke(target)
+            }
+            if (cls.primitive) {
+                if (cls.simpleName.toLowerCase() == 'boolean') {
+                    return false
+                }
+                return 0
+            }
+            return target[m.name]
+        }
+        // annotated setter
+        if (List.class.isAssignableFrom(cls)) { // TODO support other Collections in future
+            return new ArrayList()
+        }
+        if (Map.class.isAssignableFrom(cls)) {
+            return new LinkedHashMap()
+        }
+        null
+    }
+
+    private ArgSpecAttributes extractAttributesFromField(Field f, target) {
+        def getter = {
+            f.accessible = true
+            f.get(target);
+        }
+        def setter = { newValue ->
+            f.accessible = true
+            def oldValue = f.get(target)
+            f.set(target, newValue)
+            oldValue
+        }
+        Class[] auxTypes = null // TODO extract generic types like List<Integer> or Map<Integer,Double>
+        new ArgSpecAttributes(type: f.type, auxiliaryTypes: auxTypes, label: f.name, getter: getter, setter: setter, initialValue: getter.call(), hasInitialValue: true)
+    }
+
+    private PositionalParamSpec createPositionalParamSpec(Unparsed unparsed, ArgSpecAttributes attr, Object target) {
+        PositionalParamSpec.Builder builder = PositionalParamSpec.builder();
+
+        CommandLine.Range arity = CommandLine.Range.valueOf("0..*")
+        if (attr.type == Object) { attr.type = String[] }
+        if (attr.type)           { builder.type(attr.type) } // cannot set type to null
+        if (attr.auxiliaryTypes) { builder.auxiliaryTypes(attr.auxiliaryTypes) } // cannot set aux types to null
+        builder.arity(arity)
+        builder.paramLabel("<$attr.label>")
+        builder.getter(attr.getter)
+        builder.setter(attr.setter)
+        builder.hasInitialValue(attr.hasInitialValue)
+        if (arity.max == 0 && attr.type.simpleName.toLowerCase() == 'boolean' && !attr.initialValue) {
+            attr.initialValue = false
+        }
+        try {
+            builder.initialValue(attr.initialValue)
+        } catch (Exception ex) {
+            throw new CliBuilderException("Could not get initial value of positional parameters: " + ex, ex)
+        }
+        builder.build()
+    }
+
+    private OptionSpec createOptionSpec(Option annotation, ArgSpecAttributes attr, Object target) {
+        Map names = calculateNames(annotation.longName(), annotation.shortName(), attr.label)
+        String arityString = extractArity(attr.type, annotation.optionalArg(), annotation.numberOfArguments(), annotation.numberOfArgumentsString(), names)
+        CommandLine.Range arity = CommandLine.Range.valueOf(arityString)
+        if (attr.type == Object && arity.max == 0) { attr.type = boolean }
+        OptionSpec.Builder builder = OptionSpec.builder(hyphenate(names))
+        if (attr.type)           { builder.type(attr.type) } // cannot set type to null
+        if (attr.auxiliaryTypes) { builder.auxiliaryTypes(attr.auxiliaryTypes) } // cannot set aux types to null
+        builder.arity(arity)
+        builder.description(annotation.description())
+        builder.splitRegex(annotation.valueSeparator())
+        if (annotation.defaultValue()) { builder.defaultValue(annotation.defaultValue()) } // don't default picocli model to empty string
+        builder.paramLabel("<$attr.label>")
+        if (annotation.convert() != Undefined.CLASS) {
+            if (annotation.convert() instanceof Class) {
+                builder.converters(annotation.convert().newInstance(target, target) as ITypeConverter)
+            }
+        }
+        builder.getter(attr.getter)
+        builder.setter(attr.setter)
+        builder.hasInitialValue(attr.hasInitialValue)
+        if (arity.max == 0 && attr.type.simpleName.toLowerCase() == 'boolean' && !attr.initialValue) {
+            attr.initialValue = false
+        }
+        try {
+            builder.initialValue(attr.initialValue)
+        } catch (Exception ex) {
+            throw new CliBuilderException("Could not get initial value of option " + names + ": " + ex, ex)
+        }
+        builder.build()
+    }
+
+    private String[] hyphenate(Map<String, String> names) {
+        def both = acceptLongOptionsWithSingleHyphen
+        names.values().findAll { it && it != "_" }.collect { it.length() == 1 ? "-$it" : (both ? ["-$it", "--$it"] : ["--$it"]) }.flatten().toArray()
+    }
+
+    private String extractArity(Class<?> type, boolean optionalArg, int numberOfArguments, String numberOfArgumentsString, Map names) {
+        if (optionalArg && (!type || !isMultiValue(type))) {
+            throw new CliBuilderException("Attempted to set optional argument for single-value type on flag '${names.long ?: names.short}'")
+        }
+        if (numberOfArguments != 1 && numberOfArgumentsString) {
+            throw new CliBuilderException("You can't specify both 'numberOfArguments' and 'numberOfArgumentsString' on flag '${names.long ?: names.short}'")
+        }
+        def isFlag = type.simpleName.toLowerCase() == 'boolean' ||
+                     (type.simpleName.toLowerCase() == 'object' && (numberOfArguments == 0 || numberOfArgumentsString == "0"))
+        String arity = "0"
+        if (numberOfArgumentsString) {
+            String max = numberOfArgumentsString.replace('+', '*')
+            arity = optionalArg ? "0..$max" : "1..$max"
+        } else {
+            if (!isFlag) {
+                arity = optionalArg ? "0..$numberOfArguments" : "1..$numberOfArguments"
+            }
+        }
+        if (arity == "0" && !(isFlag || type.name == 'java.lang.Object')) {
+            throw new CliBuilderException("Flag '${names.long ?: names.short}' must be Boolean or Object")
+        }
+        arity
+    }
+    private static boolean isMultiValue(Class<?> cls) {
+        cls.isArray() || Collection.class.isAssignableFrom(cls) || Map.class.isAssignableFrom(cls)
+    }
+
+    private Map calculateNames(String longName, String shortName, String label) {
+        boolean useShort = longName == '_'
+        if (longName == '_') longName = ""
+        def result = longName ?: label
+        [long: useShort ? "" : result, short: (useShort && !shortName) ? result : shortName]
+    }
+
+    // implementation details -------------------------------------
+    /**
+     * Internal method: How to create an OptionSpec from the specification.
+     */
+    OptionSpec option(shortname, Map details, description) {
+        OptionSpec.Builder builder
+        if (shortname == '_') {
+            builder = OptionSpec.builder("--$details.longOpt").description(description)
+            if (acceptLongOptionsWithSingleHyphen) {
+                builder.names("-$details.longOpt", "--$details.longOpt")
+            }
+            details.remove('longOpt')
+        } else {
+            builder = OptionSpec.builder("-$shortname").description(description)
+        }
+        commons2picocli(shortname, details).each { key, value ->
+            if (builder.hasProperty(key)) {
+                builder[key] = value
+            } else {
+                builder.invokeMethod(key, value)
+            }
+        }
+        if (!builder.type() && !builder.arity() && builder.converters()?.length > 0) {
+            builder.arity("1").type(details.convert ? Object : String[])
+        }
+        return builder.build()
+    }
+
+    /** Commons-cli constant that specifies the number of argument values is infinite */
+    private static final int COMMONS_CLI_UNLIMITED_VALUES = -2;
+
+    // - argName:        String
+    // - longOpt:        String
+    // - args:           int or String
+    // - optionalArg:    boolean
+    // - required:       boolean
+    // - type:           Class
+    // - valueSeparator: char
+    // - convert:        Closure
+    // - defaultValue:   String
+    private Map commons2picocli(shortname, Map m) {
+        if (m.args && m.optionalArg) {
+            m.arity = "0..${m.args}"
+            m.remove('args')
+            m.remove('optionalArg')
+        }
+        if (!m.defaultValue) {
+            m.remove('defaultValue') // don't default the picocli model to empty string
+        }
+        def result = m.collectMany { k, v ->
+            if (k == 'args' && v == '+') {
+                [[arity: '1..*']]
+            } else if (k == 'args' && v == 0) {
+                [[arity: '0']]
+            } else if (k == 'args') {
+                v == COMMONS_CLI_UNLIMITED_VALUES ? [[arity: "*"]] : [[arity: "$v"]]
+            } else if (k == 'optionalArg') {
+                v ? [[arity: '0..1']] : [[arity: '1']]
+            } else if (k == 'argName') {
+                [[paramLabel: "<$v>"]]
+            } else if (k == 'longOpt') {
+                acceptLongOptionsWithSingleHyphen ?
+                        [[names: ["-$shortname", "-$v", "--$v"] as String[] ]] :
+                        [[names: ["-$shortname",        "--$v"] as String[] ]]
+            } else if (k == 'valueSeparator') {
+                [[splitRegex: "$v"]]
+            } else if (k == 'convert') {
+                [[converters: [v] as ITypeConverter[] ]]
+            } else {
+                [[(k): v]]
+            }
+        }.sum() as Map
+        result
+    }
+}
+
+class OptionAccessor {
+    ParseResult parseResult
+    Map<String, TypedOption> savedTypeOptions
+
+    OptionAccessor(ParseResult parseResult) {
+        this.parseResult = parseResult
+    }
+
+    boolean hasOption(TypedOption typedOption) {
+        parseResult.hasMatchedOption(typedOption.longOpt ?: typedOption.opt as String)
+    }
+
+    public <T> T defaultValue(String name) {
+        Class<T> type = savedTypeOptions[name]?.type
+        String value = savedTypeOptions[name]?.defaultValue() ? savedTypeOptions[name].defaultValue() : null
+        return (T) value ? getTypedValue(type, name, value) : null
+    }
+
+    public <T> T getOptionValue(TypedOption<T> typedOption) {
+        getOptionValue(typedOption, null)
+    }
+
+    public <T> T getOptionValue(TypedOption<T> typedOption, T defaultValue) {
+        String optionName = (String) typedOption.longOpt ?: typedOption.opt
+        if (parseResult.hasMatchedOption(optionName)) {
+            return parseResult.matchedOptionValue(optionName, defaultValue)
+        } else {
+            OptionSpec option = parseResult.commandSpec().findOption(optionName)
+            return option ? option.value : defaultValue
+        }
+    }
+
+    public <T> T getAt(TypedOption<T> typedOption) {
+        getAt(typedOption, null)
+    }
+
+    public <T> T getAt(TypedOption<T> typedOption, T defaultValue) {
+        getOptionValue(typedOption, defaultValue)
+    }
+
+    private <T> T getTypedValue(Class<T> type, String optionName, String optionValue) {
+        if (savedTypeOptions[optionName]?.cliOption?.arity?.min == 0) { // TODO is this not a bug?
+            return (T) parseResult.hasMatchedOption(optionName) // TODO should defaultValue not simply convert the type regardless of the matched value?
+        }
+        def convert = savedTypeOptions[optionName]?.convert
+        return getValue(type, optionValue, convert)
+    }
+
+    private <T> T getValue(Class<T> type, String optionValue, Closure convert) {
+        if (!type) {
+            return (T) optionValue
+        }
+        if (Closure.isAssignableFrom(type) && convert) {
+            return (T) convert(optionValue)
+        }
+        if (type == Boolean || type == Boolean.TYPE) {
+            return type.cast(Boolean.parseBoolean(optionValue))
+        }
+        StringGroovyMethods.asType(optionValue, (Class<T>) type)
+    }
+
+    Properties getOptionProperties(String name) {
+        if (!parseResult.hasMatchedOption(name)) {
+            return null
+        }
+        List<String> keyValues = parseResult.matchedOption(name).stringValues()
+        Properties result = new Properties()
+        keyValues.toSpreadMap().each { k, v -> result.setProperty(k, v) }
+        result
+    }
+
+    def invokeMethod(String name, Object args) {
+        // TODO we could just declare normal methods to map commons-cli CommandLine methods to picocli ParseResult methods
+        if (name == 'hasOption')      { name = 'hasMatchedOption';   args = [args[0]      ].toArray() }
+        if (name == 'getOptionValue') { name = 'matchedOptionValue'; args = [args[0], null].toArray() }
+        return InvokerHelper.getMetaClass(parseResult).invokeMethod(parseResult, name, args)
+    }
+
+    def getProperty(String name) {
+        if (name == 'parseResult') { return parseResult }
+        if (parseResult.hasMatchedOption(name)) {
+            def result = parseResult.matchedOptionValue(name, null)
+
+            // if user specified an array type, return the full array (regardless of 's' suffix on name)
+            Class userSpecifiedType = savedTypeOptions[name]?.type
+            if (userSpecifiedType?.isArray()) { return result }
+
+            // otherwise, if the result is multi-value, return the first value
+            Class derivedType = parseResult.matchedOption(name).type()
+            if (derivedType.isArray()) {
+                return result ? result[0] : null
+            } else if (Collection.class.isAssignableFrom(derivedType)) {
+                return (result as Collection)?.first()
+            }
+            if (!userSpecifiedType && result == '' && parseResult.matchedOption(name).arity().min == 0) {
+                return true
+            }
+            return parseResult.matchedOption(name).typedValues().get(0)
+        }
+        if (parseResult.commandSpec().findOption(name)) { // requested option was not matched: return its default
+            def option = parseResult.commandSpec().findOption(name)
+            def result = option.value
+            return result ? result : false
+        }
+        if (name.size() > 1 && name.endsWith('s')) { // user wants multi-value result
+            def singularName = name[0..-2]
+            if (parseResult.hasMatchedOption(singularName)) {
+                // if picocli has a strongly typed multi-value result, return it
+                Class type = parseResult.matchedOption(singularName).type()
+                if (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {
+                    return parseResult.matchedOptionValue(singularName, null)
+                }
+                // otherwise, return the raw string values as a list
+                return parseResult.matchedOption(singularName).stringValues()
+            }
+        }
+        false
+    }
+
+    List<String> arguments() {
+        parseResult.hasMatchedPositional(0) ? parseResult.matchedPositional(0).stringValues() : []
+    }
+}
diff --git a/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
new file mode 100644
index 0000000000..6bca802b82
--- /dev/null
+++ b/subprojects/groovy-cli-picocli/src/spec/test/builder/CliBuilderTest.groovy
@@ -0,0 +1,451 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package builder
+
+import groovy.cli.picocli.CliBuilder
+import groovy.cli.Option
+import groovy.cli.TypedOption
+import groovy.cli.Unparsed
+import groovy.transform.TypeChecked
+
+import java.math.RoundingMode
+import java.text.SimpleDateFormat
+import java.util.concurrent.TimeUnit
+import static java.util.concurrent.TimeUnit.DAYS
+import static java.util.concurrent.TimeUnit.HOURS
+
+//import java.math.RoundingMode
+
+class CliBuilderTest extends GroovyTestCase {
+//    void tearDown() {
+//    }
+
+    // tag::annotationInterfaceSpec[]
+    interface GreeterI {
+        @Option(shortName='h', description='display usage') Boolean help()        // <1>
+        @Option(shortName='a', description='greeting audience') String audience() // <2>
+        @Unparsed List remaining()                                                // <3>
+    }
+    // end::annotationInterfaceSpec[]
+
+    // tag::annotationClassSpec[]
+    class GreeterC {
+        @Option(shortName='h', description='display usage')
+        Boolean help                        // <1>
+
+        private String audience
+        @Option(shortName='a', description='greeting audience')
+        void setAudience(String audience) { // <2>
+            this.audience = audience
+        }
+        String getAudience() { audience }
+
+        @Unparsed
+        List remaining                      // <3>
+    }
+    // end::annotationClassSpec[]
+
+    void testAnnotationsInterface() {
+        // tag::annotationInterface[]
+        def cli = new CliBuilder(usage: 'groovy Greeter [option]')  // <1>
+        def argz = '--audience Groovologist'.split()
+        def options = cli.parseFromSpec(GreeterI, argz)             // <2>
+        assert options.audience() == 'Groovologist'                 // <3>
+
+        argz = '-h Some Other Args'.split()
+        options = cli.parseFromSpec(GreeterI, argz)                 // <4>
+        assert options.help()
+        assert options.remaining() == ['Some', 'Other', 'Args']     // <5>
+        // end::annotationInterface[]
+    }
+
+    void testAnnotationsClass() {
+        // tag::annotationClass[]
+        def cli = new CliBuilder(usage: 'groovy Greeter [option]') // <1>
+        def options = new GreeterC()                               // <2>
+        def argz = '--audience Groovologist foo'.split()
+        cli.parseFromInstance(options, argz)                       // <3>
+        assert options.audience == 'Groovologist'                  // <4>
+        assert options.remaining == ['foo']                        // <5>
+        // end::annotationClass[]
+    }
+
+    void testParseScript() {
+        def argz = '--audience Groovologist foo'.split()
+        new GroovyShell().run('''
+            // tag::annotationScript[]
+            import groovy.cli.picocli.CliBuilder
+            import groovy.cli.OptionField
+            import groovy.cli.UnparsedField
+
+            @OptionField String audience
+            @OptionField Boolean help
+            @UnparsedField List remaining
+            new CliBuilder().parseFromInstance(this, args)
+            assert audience == 'Groovologist'
+            assert remaining == ['foo']
+            // end::annotationScript[]
+        ''', 'TestScript.groovy', argz)
+    }
+
+    void testWithArgument() {
+        // tag::withArgument[]
+        def cli = new CliBuilder()
+        cli.a(args: 0, 'a arg') // <1>
+        cli.b(args: 1, 'b arg') // <2>
+        cli.c(args: 1, optionalArg: true, 'c arg') // <3>
+        def options = cli.parse('-a -b foo -c bar baz'.split()) // <4>
+
+        assert options.a == true
+        assert options.b == 'foo'
+        assert options.c == 'bar'
+        assert options.arguments() == ['baz']
+
+        options = cli.parse('-a -c -b foo bar baz'.split()) // <5>
+
+        assert options.a == true
+        assert options.c == true
+        assert options.b == 'foo'
+        assert options.arguments() == ['bar', 'baz']
+        // end::withArgument[]
+    }
+
+    // tag::withArgumentInterfaceSpec[]
+    interface WithArgsI {
+        @Option boolean a()
+        @Option String b()
+        @Option(optionalArg=true) String[] c()
+        @Unparsed List remaining()
+    }
+    // end::withArgumentInterfaceSpec[]
+
+    void testWithArgumentInterface() {
+        // tag::withArgumentInterface[]
+        def cli = new CliBuilder()
+        def options = cli.parseFromSpec(WithArgsI, '-a -b foo -c bar baz'.split())
+        assert options.a()
+        assert options.b() == 'foo'
+        assert options.c() == ['bar']
+        assert options.remaining() == ['baz']
+
+        options = cli.parseFromSpec(WithArgsI, '-a -c -b foo bar baz'.split())
+        assert options.a()
+        assert options.c() == []
+        assert options.b() == 'foo'
+        assert options.remaining() == ['bar', 'baz']
+        // end::withArgumentInterface[]
+    }
+
+    void testMultipleArgsAndOptionalValueSeparator() {
+        // tag::multipleArgs[]
+        def cli = new CliBuilder()
+        cli.a(args: 2, 'a-arg')
+        cli.b(args: '2', valueSeparator: ',', 'b-arg') // <1>
+        cli.c(args: '+', valueSeparator: ',', 'c-arg') // <2>
+
+        def options = cli.parse('-a 1 2 3 4'.split()) // <3>
+        assert options.a == '1' // <4>
+        assert options.as == ['1', '2'] // <5>
+        assert options.arguments() == ['3', '4']
+
+        options = cli.parse('-a1 -a2 3'.split()) // <6>
+        assert options.as == ['1', '2']
+        assert options.arguments() == ['3']
+
+        options = cli.parse(['-b1,2']) // <7>
+        assert options.bs == ['1', '2']
+
+        options = cli.parse(['-c', '1'])
+        assert options.cs == ['1']
+
+        options = cli.parse(['-c1'])
+        assert options.cs == ['1']
+
+        options = cli.parse(['-c1,2,3'])
+        assert options.cs == ['1', '2', '3']
+        // end::multipleArgs[]
+    }
+
+    // tag::multipleArgsInterfaceSpec[]
+    interface ValSepI {
+        @Option(numberOfArguments=2) String[] a()
+        @Option(numberOfArgumentsString='2', valueSeparator=',') String[] b()
+        @Option(numberOfArgumentsString='+', valueSeparator=',') String[] c()
+        @Unparsed remaining()
+    }
+    // end::multipleArgsInterfaceSpec[]
+
+    void testMultipleArgsAndOptionalValueSeparatorInterface() {
+        // tag::multipleArgsInterface[]
+        def cli = new CliBuilder()
+
+        def options = cli.parseFromSpec(ValSepI, '-a 1 2 3 4'.split())
+        assert options.a() == ['1', '2']
+        assert options.remaining() == ['3', '4']
+
+        options = cli.parseFromSpec(ValSepI, '-a1 -a2 3'.split())
+        assert options.a() == ['1', '2']
+        assert options.remaining() == ['3']
+
+        options = cli.parseFromSpec(ValSepI, ['-b1,2'] as String[])
+        assert options.b() == ['1', '2']
+
+        options = cli.parseFromSpec(ValSepI, ['-c', '1'] as String[])
+        assert options.c() == ['1']
+
+        options = cli.parseFromSpec(ValSepI, ['-c1'] as String[])
+        assert options.c() == ['1']
+
+        options = cli.parseFromSpec(ValSepI, ['-c1,2,3'] as String[])
+        assert options.c() == ['1', '2', '3']
+        // end::multipleArgsInterface[]
+    }
+
+    void testType() {
+        // tag::withType[]
+        def argz = '''-a John -b -d 21 -e 1980 -f 3.5 -g 3.14159
+            -h cv.txt -i DOWN and some more'''.split()
+        def cli = new CliBuilder()
+        cli.a(type: String, 'a-arg')
+        cli.b(type: boolean, 'b-arg')
+        cli.c(type: Boolean, 'c-arg')
+        cli.d(type: int, 'd-arg')
+        cli.e(type: Long, 'e-arg')
+        cli.f(type: Float, 'f-arg')
+        cli.g(type: BigDecimal, 'g-arg')
+        cli.h(type: File, 'h-arg')
+        cli.i(type: RoundingMode, 'i-arg')
+        def options = cli.parse(argz)
+        assert options.a == 'John'
+        assert options.b
+        assert !options.c
+        assert options.d == 21
+        assert options.e == 1980L
+        assert options.f == 3.5f
+        assert options.g == 3.14159
+        assert options.h == new File('cv.txt')
+        assert options.i == RoundingMode.DOWN
+        assert options.arguments() == ['and', 'some', 'more']
+        // end::withType[]
+    }
+
+    void testTypeMultiple() {
+        // tag::withTypeMultiple[]
+        def argz = '''-j 3 4 5 -k1.5,2.5,3.5 and some more'''.split()
+        def cli = new CliBuilder()
+        cli.j(args: 3, type: int[], 'j-arg')
+        cli.k(args: '+', valueSeparator: ',', type: BigDecimal[], 'k-arg')
+        def options = cli.parse(argz)
+        assert options.js == [3, 4, 5] // <1>
+        assert options.j == [3, 4, 5]  // <1>
+        assert options.k == [1.5, 2.5, 3.5]
+        assert options.arguments() == ['and', 'some', 'more']
+        // end::withTypeMultiple[]
+    }
+
+    void testConvert() {
+        // tag::withConvert[]
+        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
+        def cli = new CliBuilder()
+        def lower = { it.toLowerCase() }
+        cli.a(convert: lower, 'a-arg')
+        cli.b(convert: { it.toUpperCase() }, 'b-arg')
+        cli.d(convert: { new SimpleDateFormat("yyyy-MM-dd").parse(it) }, 'd-arg')
+        def options = cli.parse(argz)
+        assert options.a == 'john'
+        assert options.b == 'MARY'
+        assert new SimpleDateFormat("dd-MMM-yyyy").format(options.d) == '01-Jan-2016'
+        assert options.arguments() == ['and', 'some', 'more']
+        // end::withConvert[]
+    }
+
+    // tag::withConvertInterfaceSpec[]
+    interface WithConvertI {
+        @Option(convert={ it.toLowerCase() }) String a()
+        @Option(convert={ it.toUpperCase() }) String b()
+        @Option(convert={ new SimpleDateFormat("yyyy-MM-dd").parse(it) }) Date d()
+        @Unparsed List remaining()
+    }
+    // end::withConvertInterfaceSpec[]
+
+    void testConvertInterface() {
+        // tag::withConvertInterface[]
+        Date newYears = new SimpleDateFormat("yyyy-MM-dd").parse("2016-01-01")
+        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
+        def cli = new CliBuilder()
+        def options = cli.parseFromSpec(WithConvertI, argz)
+        assert options.a() == 'john'
+        assert options.b() == 'MARY'
+        assert options.d() == newYears
+        assert options.remaining() == ['and', 'some', 'more']
+        // end::withConvertInterface[]
+    }
+
+    void testDefaultValue() {
+        // tag::withDefaultValue[]
+        def cli = new CliBuilder()
+        cli.f longOpt: 'from', type: String, args: 1, defaultValue: 'one', 'f option'
+        cli.t longOpt: 'to', type: int, defaultValue: '35', 't option'
+
+        def options = cli.parse('-f two'.split())
+        assert options.hasOption('f')
+        assert options.f == 'two'
+        assert !options.hasOption('t')
+        assert options.t == 35
+
+        options = cli.parse('-t 45'.split())
+        assert !options.hasOption('from')
+        assert options.from == 'one'
+        assert options.hasOption('to')
+        assert options.to == 45
+        // end::withDefaultValue[]
+    }
+
+    // tag::withDefaultValueInterfaceSpec[]
+    interface WithDefaultValueI {
+        @Option(shortName='f', defaultValue='one') String from()
+        @Option(shortName='t', defaultValue='35') int to()
+    }
+    // end::withDefaultValueInterfaceSpec[]
+
+    void testDefaultValueInterface() {
+        // tag::withDefaultValueInterface[]
+        def cli = new CliBuilder()
+
+        def options = cli.parseFromSpec(WithDefaultValueI, '-f two'.split())
+        assert options.from() == 'two'
+        assert options.to() == 35
+
+        options = cli.parseFromSpec(WithDefaultValueI, '-t 45'.split())
+        assert options.from() == 'one'
+        assert options.to() == 45
+        // end::withDefaultValueInterface[]
+    }
+
+    // tag::withTypeCheckedInterfaceSpec[]
+    interface TypeCheckedI{
+        @Option String name()
+        @Option int age()
+        @Unparsed List remaining()
+    }
+    // end::withTypeCheckedInterfaceSpec[]
+
+    // tag::withTypeCheckedInterface[]
+    @TypeChecked
+    void testTypeCheckedInterface() {
+        def argz = "--name John --age 21 and some more".split()
+        def cli = new CliBuilder()
+        def options = cli.parseFromSpec(TypeCheckedI, argz)
+        String n = options.name()
+        int a = options.age()
+        assert n == 'John' && a == 21
+        assert options.remaining() == ['and', 'some', 'more']
+    }
+    // end::withTypeCheckedInterface[]
+
+    // tag::withTypeChecked[]
+    @TypeChecked
+    void testTypeChecked() {
+        def cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
+        TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
+        TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
+        def argz = "--name John -age 21 and some more".split()
+        def options = cli.parse(argz)
+        String n = options[name]
+        int a = options[age]
+        assert n == 'John' && a == 21
+        assert options.arguments() == ['and', 'some', 'more']
+    }
+    // end::withTypeChecked[]
+
+    @TypeChecked
+    void testTypeChecked_defaultOnlyDoubleHyphen() {
+        def cli = new CliBuilder()
+        TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
+        TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
+        def argz = "--name John -age 21 and some more".split()
+        def options = cli.parse(argz)
+        assert options[name] == 'John'
+        assert options[age] == null
+        assert options.arguments() == ['-age', '21', 'and', 'some', 'more']
+    }
+
+    void testUsageMessageSpec() {
+        // suppress ANSI escape codes to make this test pass on all environments
+        System.setProperty("picocli.ansi", "false")
+        ByteArrayOutputStream baos = new ByteArrayOutputStream()
+        System.setOut(new PrintStream(baos, true))
+
+        // tag::withUsageMessageSpec[]
+        def cli = new CliBuilder()
+        cli.name = "myapp"
+        cli.usageMessage.with {
+            headerHeading("@|bold,underline Header heading:|@%n")
+            header("Header 1", "Header 2")                     // before the synopsis
+            synopsisHeading("%n@|bold,underline Usage:|@ ")
+            descriptionHeading("%n@|bold,underline Description heading:|@%n")
+            description("Description 1", "Description 2")      // after the synopsis
+            optionListHeading("%n@|bold,underline Options heading:|@%n")
+            footerHeading("%n@|bold,underline Footer heading:|@%n")
+            footer("Footer 1", "Footer 2")
+        }
+        cli.a('option a description')
+        cli.b('option b description')
+        cli.c(args: '*', 'option c description')
+        cli.usage()
+        // end::withUsageMessageSpec[]
+
+        String expected = '''\
+Header heading:
+Header 1
+Header 2
+
+Usage: myapp [-ab] [-c[=PARAM...]]...
+
+Description heading:
+Description 1
+Description 2
+
+Options heading:
+  -a               option a description
+  -b               option b description
+  -c= [PARAM...]   option c description
+
+Footer heading:
+Footer 1
+Footer 2
+'''
+        assertEquals(expected.normalize(), baos.toString().normalize())
+    }
+
+    public void testMapOption() {
+        // tag::MapOption[]
+        def cli = new CliBuilder()
+        cli.D(args: 2,   valueSeparator: '=', 'the old way')                          // <1>
+        cli.X(type: Map, 'the new way')                                               // <2>
+        cli.Z(type: Map, auxiliaryTypes: [TimeUnit, Integer].toArray(), 'typed map')  // <3>
+
+        def options = cli.parse('-Da=b -Dc=d -Xx=y -Xi=j -ZDAYS=2 -ZHOURS=23'.split())// <4>
+        assert options.Ds == ['a', 'b', 'c', 'd']                                     // <5>
+        assert options.Xs == [ 'x':'y', 'i':'j' ]                                     // <6>
+        assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         // <7>
+        // end::MapOption[]
+
+    }
+}
diff --git a/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy b/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
new file mode 100644
index 0000000000..e6a0e7a92d
--- /dev/null
+++ b/subprojects/groovy-cli-picocli/src/test/groovy/groovy/cli/picocli/CliBuilderTest.groovy
@@ -0,0 +1,1002 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.cli.picocli
+
+import groovy.cli.Option
+import groovy.cli.Unparsed
+import groovy.cli.picocli.CliBuilder
+import groovy.transform.ToString
+import groovy.transform.TypeChecked
+import picocli.CommandLine.DuplicateOptionAnnotationsException
+
+import java.math.RoundingMode
+import java.text.SimpleDateFormat
+
+import static picocli.CommandLine.Model.OptionSpec.builder
+
+/**
+ * Test class for the picocli version of CliBuilder.
+ * <p>
+ * Ensures compatibility with the commons-cli version of CliBuilder and tests
+ * picocli-specific functionality.
+ */
+
+class CliBuilderTest extends GroovyTestCase {
+    /** Commons-cli constant that specifies the number of argument values is infinite */
+    private static final int COMMONS_CLI_UNLIMITED_VALUES = -2;
+
+    private StringWriter stringWriter
+    private PrintWriter printWriter
+
+    void setUp() {
+        resetPrintWriter()
+    }
+
+    private final expectedParameter = 'ASCII'
+    private final usageString = 'groovy [option]* filename'
+
+    private void runSample(optionList) {
+        resetPrintWriter()
+        def cli = new CliBuilder(usage: usageString, writer: printWriter)
+        cli.h(longOpt: 'help', 'usage information')
+        cli.c(argName: 'charset', args: 1, longOpt: 'encoding', 'character encoding')
+        cli.i(argName: 'extension', optionalArg: true, 'modify files in place, create backup if extension is specified (e.g. \'.bak\')')
+        def stringified = cli.commandSpec.toString()
+//        assert stringified =~ /i=\[ option: i  :: modify files in place, create backup if extension is given/
+//        assert stringified =~ /c=\[ option: c encoding  \[ARG] :: character encoding/
+//        assert stringified =~ /h=\[ option: h help  :: usage information/
+//        assert stringified =~ /encoding=\[ option: c encoding  \[ARG] :: character encoding/
+//        assert stringified =~ /help=\[ option: h help  :: usage information/
+        def options = cli.parse(optionList)
+        assert options.hasOption('h')
+        assert options.hasOption('help')
+        assert options.h
+        assert options.help
+        if (options.h) { cli.usage() }
+        def expectedUsage = """Usage: $usageString
+  -c, --encoding=<charset>   character encoding
+  -h, --help                 usage information
+  -i= [<extension>]          modify files in place, create backup if extension is
+                               specified (e.g. '.bak')"""
+        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+        resetPrintWriter()
+        cli.writer = printWriter
+        if (options.help) { cli.usage() }
+        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+        assert options.hasOption('c')
+        assert options.c
+        assert options.hasOption('encoding')
+        assert options.encoding
+        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.getOptionValue('c'))
+        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.c)
+        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.getOptionValue('encoding'))
+        groovy.util.GroovyTestCase.assertEquals(expectedParameter, options.encoding)
+        groovy.util.GroovyTestCase.assertEquals(false, options.noSuchOptionGiven)
+        junit.framework.TestCase.assertEquals(false, options.hasOption('noSuchOptionGiven'))
+        groovy.util.GroovyTestCase.assertEquals(false, options.x)
+        junit.framework.TestCase.assertEquals(false, options.hasOption('x'))
+    }
+
+    private void resetPrintWriter() {
+        stringWriter = new StringWriter()
+        printWriter = new PrintWriter(stringWriter)
+    }
+
+    void testSampleShort() {
+        runSample(['-h', '-c', expectedParameter])
+    }
+
+    void testSampleLong() {
+        runSample( ['--help', '--encoding', expectedParameter])
+    }
+
+    void testSimpleArg() {
+        def cli = new CliBuilder()
+        cli.a([:], '')
+        def options = cli.parse(['-a', '1', '2'])
+        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.arguments())
+    }
+
+    void testMultipleArgs() {
+        def cli = new CliBuilder()
+        cli.a(longOpt: 'arg', args: 2, valueSeparator: ',' as char, 'arguments')
+        def options = cli.parse(['-a', '1,2'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.as)
+        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.args)
+    }
+
+    void testFailedParsePrintsUsage() {
+        def cli = new CliBuilder(writer: printWriter)
+        cli.x(required: true, 'message')
+        cli.parse([])
+        // NB: This test is very fragile and is bound to fail on different locales and versions of commons-cli... :-(
+        assert stringWriter.toString() == String.format(
+                "error: Missing required option '-x=PARAM'%n" +\
+                "Usage: groovy -x%n" +\
+                "  -x           message%n")
+    }
+
+    void testLongOptsOnly_nonOptionShouldStopArgProcessing() {
+        def cli = new CliBuilder()
+        def anOption = builder('anOption').arity("1").description('An option.')
+                .build()
+        cli.commandSpec.addOption(anOption)
+        def options = cli.parse(['-v', '--anOption', 'something'])
+        // no options should be found
+        assert options.getOptionValue('anOption') == null
+        assert !options.anOption
+        assert !options.v
+        // arguments should be still sitting there
+        assert options.arguments() == ['-v', '--anOption', 'something']
+    }
+
+    void testLongAndShortOpts_allOptionsValid() {
+        def cli = new CliBuilder()
+        def anOption = builder('--anOption').arity("1").description('An option.').build()
+        cli.commandSpec.addOption(anOption)
+        cli.v(longOpt: 'verbose', 'verbose mode')
+        def options = cli.parse(['-v', '--anOption', 'something'])
+        assert options.v
+        assert options.getOptionValue('anOption') == 'something'
+        assert options.anOption == 'something'
+        assert !options.arguments()
+    }
+
+    void testUnrecognizedOptions() {
+        def cli = new CliBuilder()
+        cli.v(longOpt: 'verbose', 'verbose mode')
+        def options = cli.parse(['-x', '-yyy', '--zzz', 'something'])
+        groovy.util.GroovyTestCase.assertEquals(['-x', '-yyy', '--zzz', 'something'], options.arguments())
+    }
+
+    void testMultipleOccurrencesSeparateSeparate() {
+        def cli = new CliBuilder()
+        cli.a(longOpt: 'arg', args: COMMONS_CLI_UNLIMITED_VALUES, 'arguments')
+        def options = cli.parse(['-a', '1', '-a', '2', '-a', '3'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
+        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.args)
+        groovy.util.GroovyTestCase.assertEquals([], options.arguments())
+    }
+
+    void testMandatoryParametersDoNotConsumeOtherOptions() {
+        def cli = new CliBuilder()
+        cli.a(args: 2, 'arguments')
+        cli.b(args: 2, valueSeparator: ',', 'arguments')
+        cli.c(args: '+', valueSeparator: ',', 'arguments')
+
+        def options = cli.parse(['-a', '1', '-a', '2'])
+        junit.framework.TestCase.assertNull(options)
+
+        options = cli.parse(['-a', '1', '-a', '2', '-a', '3'])
+        junit.framework.TestCase.assertNull(options)
+    }
+
+    void testMultipleOccurrencesSeparateSeparate3() {
+        def cli = new CliBuilder()
+//        cli.a(longOpt: 'arg', args: COMMONS_CLI_UNLIMITED_VALUES, 'arguments')
+        cli.a(args: 2, 'arguments')
+        cli.b(args: 2, valueSeparator: ',', 'arguments')
+        cli.c(args: '+', valueSeparator: ',', 'arguments')
+
+        def options = cli.parse(['-a', '1'])
+        junit.framework.TestCase.assertNull(options)
+
+        options = cli.parse(['-a1'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1'], options.as)
+
+//        options = cli.parse(['-a', '1', '-a', '2']) // TODO
+//        assertNull(options)
+
+        options = cli.parse(['-a1', '-a2'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.as)
+
+        options = cli.parse(['-a1', '-a2', '-a3'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
+
+//        options = cli.parse(['-a', '1', '-a', '2', '-a', '3'])
+//        assertNull(options)
+
+        options = cli.parse(['-a', '1', '2'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2'], options.as)
+
+        options = cli.parse(['-a1', '2'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        assert options.arguments() == ['2']
+        groovy.util.GroovyTestCase.assertEquals(['1'], options.as)
+
+        options = cli.parse(['-a', '1', '2', '-a', '3', '4'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3', '4'], options.as)
+
+        options = cli.parse(['-a', '1', '2', '-a3', '-a4', '-a5'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3', '4', '5'], options.as)
+
+        options = cli.parse(['-a', '1', '2', '-a3', '-a', '4', '5' ])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3', '4', '5'], options.as)
+
+        options = cli.parse(['-a1', '2', '-a3', '4'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        assert options.arguments() == ['2', '-a3', '4']
+        //assertEquals(['1', '2', '3', '4'], options.as)
+
+        options = cli.parse(['-b1,2'])
+        assert options.bs == ['1', '2']
+
+        options = cli.parse(['-b1,2,3'])
+        assert options.bs == ['1', '2,3']
+
+        options = cli.parse(['-b', '1,2', '3,4'])
+        assert options.bs == ['1', '2']
+        assert options.arguments() == ['3,4']
+
+        options = cli.parse(['-b', '1,2', '-b', '3,4'])
+        assert options.bs == ['1', '2', '3', '4']
+//        assert options.arguments() == []
+
+        options = cli.parse(['-b', '1', '2', '-b', '3', '4'])
+        assert options.bs == ['1', '2', '3', '4']
+    }
+
+    void testMultipleOccurrencesSeparateJuxtaposed() {
+        def cli = new CliBuilder()
+//        cli.a ( longOpt : 'arg' , args : COMMONS_CLI_UNLIMITED_VALUES , 'arguments' )
+        cli.a(longOpt: 'arg', args: 1, 'arguments')
+        def options = cli.parse(['-a1', '-a2', '-a3'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
+        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.args)
+        groovy.util.GroovyTestCase.assertEquals([], options.arguments())
+    }
+
+    void testMultipleOccurrencesTogetherSeparate() {
+        def cli = new CliBuilder()
+        cli.a(longOpt: 'arg', args: COMMONS_CLI_UNLIMITED_VALUES, valueSeparator: ',' as char, 'arguments')
+        def options = cli.parse(['-a 1,2,3'])
+        groovy.util.GroovyTestCase.assertEquals(' 1', options.a)
+        groovy.util.GroovyTestCase.assertEquals([' 1', '2', '3'], options.as)
+        groovy.util.GroovyTestCase.assertEquals(' 1', options.arg)
+        groovy.util.GroovyTestCase.assertEquals([' 1', '2', '3'], options.args)
+        groovy.util.GroovyTestCase.assertEquals([], options.arguments())
+    }
+
+    void testMultipleOccurrencesTogetherJuxtaposed() {
+        def cli1 = new CliBuilder()
+        cli1.a(longOpt: 'arg', args: COMMONS_CLI_UNLIMITED_VALUES, valueSeparator: ',' as char, 'arguments')
+        def options = cli1.parse(['-a1,2,3'])
+        groovy.util.GroovyTestCase.assertEquals('1', options.a)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.as)
+        groovy.util.GroovyTestCase.assertEquals('1', options.arg)
+        groovy.util.GroovyTestCase.assertEquals(['1', '2', '3'], options.args)
+        groovy.util.GroovyTestCase.assertEquals([], options.arguments()) }
+
+    /*
+     *  Behaviour with unrecognized options.
+     */
+
+    void testUnrecognizedOptionSilentlyIgnored_GnuParser() {
+        def cli = new CliBuilder(usage: usageString, writer: printWriter)
+        def options = cli.parse(['-v'])
+        groovy.util.GroovyTestCase.assertEquals('''''', stringWriter.toString().tokenize('\r\n').join('\n'))
+        assert !options.v
+    }
+
+    private void checkNoOutput() {
+        assert stringWriter.toString().tokenize('\r\n').join('\n') == ''''''
+    }
+
+    void testUnrecognizedOptionSilentlyIgnored_DefaultParser() {
+        def cli = new CliBuilder(usage: usageString, writer: printWriter/*, parser: new DefaultParser()*/)
+        def options = cli.parse(['-v'])
+        checkNoOutput()
+        assert !options.v
+    }
+
+    void testUnrecognizedOptionTerminatesParse_GnuParser() {
+        def cli = new CliBuilder(usage: usageString, writer: printWriter/*, parser: new GnuParser()*/)
+        cli.h(longOpt: 'help', 'usage information')
+        def options = cli.parse(['-v', '-h'])
+        checkNoOutput()
+        assert !options.v
+        assert !options.h
+        groovy.util.GroovyTestCase.assertEquals(['-v', '-h'], options.arguments())
+    }
+
+    void testUnrecognizedOptionTerminatesParse_DefaultParser() {
+        def cli = new CliBuilder(usage: usageString, writer: printWriter/*, parser: new DefaultParser()*/)
+        cli.h(longOpt: 'help', 'usage information')
+        def options = cli.parse(['-v', '-h'])
+        checkNoOutput()
+        assert !options.v
+        assert !options.h
+        groovy.util.GroovyTestCase.assertEquals(['-v', '-h'], options.arguments())
+    }
+
+    void testMultiCharShortOpt() {
+        def cli = new CliBuilder(writer: printWriter)
+        cli.abc('abc option')
+        cli.def(longOpt: 'defdef', 'def option')
+        def options = cli.parse(['-abc', '--defdef', 'ghi'])
+        assert options
+        assert options.arguments() == ['ghi']
+        assert options.abc && options.def && options.defdef
+        checkNoOutput()
+    }
+
+    void testArgumentBursting_DefaultParserOnly() {
+        def cli = new CliBuilder(writer: printWriter)
+        // must not have longOpt 'abc' and also no args for a or b
+        cli.a('a')
+        cli.b('b')
+        cli.c('c')
+        def options = cli.parse(['-abc', '-d'])
+        assert options
+        assert options.arguments() == ['-d']
+        assert options.a && options.b && options.c && !options.d
+        checkNoOutput()
+    }
+
+    void testLongOptEndingWithS() {
+        def cli = new CliBuilder()
+        cli.s(longOpt: 'number_of_seconds', 'a long arg that ends with an "s"')
+
+        def options = cli.parse(['-s'])
+
+        assert options.hasOption('s')
+        assert options.hasOption('number_of_seconds')
+        assert options.s
+        assert options.number_of_seconds
+    }
+
+    void testArgumentFileExpansion() {
+        def cli = new CliBuilder(usage: 'test usage')
+        cli.h(longOpt: 'help', 'usage information')
+        cli.d(longOpt: 'debug', 'turn on debug info')
+        def args = ['-h', '@temp.args', 'foo', '@@baz']
+        def temp = new File('temp.args')
+        temp.deleteOnExit()
+        temp.text = '-d bar'
+        def options = cli.parse(args)
+        assert options.h
+        assert options.d
+        assert options.arguments() == ['bar', 'foo', '@baz']
+    }
+
+    void testArgumentFileExpansionArgOrdering() {
+        def cli = new CliBuilder(usage: 'test usage')
+        def args = ['one', '@temp1.args', 'potato', '@temp2.args', 'four']
+        def temp1 = new File('temp1.args')
+        temp1.deleteOnExit()
+        temp1.text = 'potato two'
+        def temp2 = new File('temp2.args')
+        temp2.deleteOnExit()
+        temp2.text = 'three potato'
+        def options = cli.parse(args)
+        assert options.arguments() == 'one potato two potato three potato four'.split()
+    }
+
+    void testArgumentFileExpansionTurnedOff() {
+        def cli = new CliBuilder(usage: 'test usage', expandArgumentFiles:false)
+        cli.h(longOpt: 'help', 'usage information')
+        cli.d(longOpt: 'debug', 'turn on debug info')
+        def args = ['-h', '@temp.args', 'foo', '@@baz']
+        def temp = new File('temp.args')
+        temp.deleteOnExit()
+        temp.text = '-d bar'
+        def options = cli.parse(args)
+        assert options.h
+        assert !options.d
+        assert options.arguments() == ['@temp.args', 'foo', '@@baz']
+    }
+
+    void testGStringSpecification_Groovy4621() {
+        def user = 'scott'
+        def pass = 'tiger'
+        def ignore = false
+        def longOptName = 'user'
+        def cli = new CliBuilder(usage: 'blah')
+        cli.dbusername(longOpt:"$longOptName", args: 1, "Database username [default $user]")
+        cli.dbpassword(args: 1, "Database password [default $pass]")
+        cli.i("ignore case [default $ignore]")
+        def args = ['-dbpassword', 'foo', '--user', 'bar', '-i']
+        def options = cli.parse(args)
+        assert options.user == 'bar'
+        assert options.dbusername == 'bar'
+        assert options.dbpassword == 'foo'
+        assert options.i
+    }
+
+    void testNoExpandArgsWithEmptyArg() {
+        def cli = new CliBuilder(expandArgumentFiles: false)
+        cli.parse(['something', ''])
+    }
+
+    void testExpandArgsWithEmptyArg() {
+        def cli = new CliBuilder(expandArgumentFiles: true)
+        cli.parse(['something', ''])
+    }
+
+    void testDoubleHyphenShortOptions() {
+        def cli = new CliBuilder()
+        cli.a([:], '')
+        cli.b([:], '')
+        def options = cli.parse(['-a', '--', '-b', 'foo'])
+        assert options.arguments() == ['-b', 'foo']
+    }
+
+    void testDoubleHyphenLongOptions() {
+        def cli = new CliBuilder()
+        cli._([longOpt:'alpha'], '')
+        cli._([longOpt:'beta'], '')
+        def options = cli.parse(['--alpha', '--', '--beta', 'foo'])
+        assert options.alpha
+        assert options.arguments() == ['--beta', 'foo']
+    }
+
+    void testMixedShortAndLongOptions() {
+        def cli = new CliBuilder()
+        cli.a([longOpt:'alpha', args:1], '')
+        cli.b([:], '')
+        def options = cli.parse(['-b', '--alpha', 'param', 'foo'])
+        assert options.a == 'param'
+        assert options.arguments() == ['foo']
+    }
+
+    void testMixedBurstingAndLongOptions() {
+        def cli = new CliBuilder()
+        cli.a([:], '')
+        cli.b([:], '')
+        cli.c([:], '')
+        cli.d([longOpt:'abacus'], '')
+        def options = cli.parse(['-abc', 'foo'])
+        assert options.a
+        assert options.b
+        assert options.c
+        assert options.arguments() == ['foo']
+        options = cli.parse(['--abacus', 'foo'])
+        assert !options.a
+        assert !options.b
+        assert !options.c
+        assert options.d
+        assert options.arguments() == ['foo']
+
+        //this passed in previous version of CliBuilder:
+        // longOpt may have 1 or 2 hyphens
+        resetPrintWriter()
+        cli.writer = printWriter
+        options = cli.parse(['-abacus', 'foo'])
+        assert options == null
+        assertTrue(stringWriter.toString().startsWith('error: Unmatched argument [-us]'))
+    }
+
+    void testMixedBurstingAndLongOptions_singleHyphen() {
+        def cli = new CliBuilder()
+        cli.acceptLongOptionsWithSingleHyphen = true
+
+        cli.a([:], '')
+        cli.b([:], '')
+        cli.c([:], '')
+        cli.d([longOpt:'abacus'], '')
+        def options = cli.parse(['-abc', 'foo'])
+        assert options.a
+        assert options.b
+        assert options.c
+        assert options.arguments() == ['foo']
+        options = cli.parse(['--abacus', 'foo'])
+        assert !options.a
+        assert !options.b
+        assert !options.c
+        assert options.d
+        assert options.arguments() == ['foo']
+
+        //this passed in previous version of CliBuilder:
+        // longOpt may have 1 or 2 hyphens
+        options = cli.parse(['-abacus', 'foo'])
+        assert !options.a
+        assert !options.b
+        assert !options.c
+        assert options.d
+        assert options.arguments() == ['foo']
+    }
+
+    interface PersonI {
+        @Option String first()
+        @Option String last()
+        @Option boolean flag1()
+        @Option Boolean flag2()
+        @Option(longName = 'specialFlag') Boolean flag3()
+        @Option flag4()
+        @Option int age()
+        @Option Integer born()
+        @Option float discount()
+        @Option BigDecimal pi()
+        @Option File biography()
+        @Option RoundingMode roundingMode()
+        @Unparsed List remaining()
+    }
+
+    def argz = "--first John --last Smith --flag1 --flag2 --specialFlag --age  21 --born 1980 --discount 3.5 --pi 3.14159 --biography cv.txt --roundingMode DOWN and some more".split()
+
+    void testParseFromSpec() {
+        def builder1 = new CliBuilder()
+        def p1 = builder1.parseFromSpec(PersonI, argz)
+        assert p1.first() == 'John'
+        assert p1.last() == 'Smith'
+        assert p1.flag1()
+        assert p1.flag2()
+        assert p1.flag3()
+        assert !p1.flag4()
+        assert p1.born() == 1980
+        assert p1.age() == 21
+        assert p1.discount() == 3.5f
+        assert p1.pi() == 3.14159
+        assert p1.biography() == new File('cv.txt')
+        assert p1.roundingMode() == RoundingMode.DOWN
+        assert p1.remaining() == ['and', 'some', 'more']
+    }
+
+    @ToString(includeFields=true, includePackage=false)
+    class PersonC {
+        @Option String first
+        private String last
+        @Option boolean flag1
+        private Boolean flag2
+        private Boolean flag3
+        private Boolean flag4
+        private int age
+        private Integer born
+        private float discount
+        private BigDecimal pi
+        private File biography
+        private RoundingMode roundingMode
+        private List remaining
+
+        @Option void setLast(String last) {
+            this.last = last
+        }
+        @Option void setFlag2(boolean flag2) {
+            this.flag2 = flag2
+        }
+        @Option(longName = 'specialFlag') void setFlag3(boolean flag3) {
+            this.flag3 = flag3
+        }
+        @Option void setFlag4(boolean flag4) {
+            this.flag4 = flag4
+        }
+        @Option void setAge(int age) {
+            this.age = age
+        }
+        @Option void setBorn(Integer born) {
+            this.born = born
+        }
+        @Option void setDiscount(float discount) {
+            this.discount = discount
+        }
+        @Option void setPi(BigDecimal pi) {
+            this.pi = pi
+        }
+        @Option void setBiography(File biography) {
+            this.biography = biography
+        }
+        @Option void setRoundingMode(RoundingMode roundingMode) {
+            this.roundingMode = roundingMode
+        }
+        @Unparsed void setRemaining(List remaining) {
+            this.remaining = remaining
+        }
+    }
+    class DefaultValueC {
+        @Option(shortName='f', defaultValue='one') String from
+        @Option(shortName='t', defaultValue='35') int to
+        @Option(shortName='b') int by = 1
+    }
+
+    void testDefaultValueClass() {
+        def cli = new CliBuilder()
+        def options = new DefaultValueC()
+        cli.parseFromInstance(options, '-f two'.split())
+        assert options.from == 'two'
+        assert options.to == 35
+        assert options.by == 1
+
+        options = new DefaultValueC()
+        cli.parseFromInstance(options, '-t 45 --by 2'.split())
+        assert options.from == 'one'
+        assert options.to == 45
+        assert options.by == 2
+    }
+
+    class ValSepC {
+        @Option(numberOfArguments=2) String[] a
+        @Option(numberOfArgumentsString='2', valueSeparator=',') String[] b
+        @Option(numberOfArgumentsString='+', valueSeparator=',') String[] c
+        @Unparsed remaining
+    }
+
+    void testValSepClass() {
+        def cli = new CliBuilder()
+
+        def options = new ValSepC()
+        cli.parseFromInstance(options, '-a 1 2 3 4'.split())
+        assert options.a == ['1', '2']
+        assert options.remaining == ['3', '4']
+
+        options = new ValSepC()
+        cli.parseFromInstance(options, '-a 1 2 -a 3 4'.split())
+        assert options.a == ['1', '2', '3', '4']
+//        assert options.remaining == []
+
+        options = new ValSepC()
+        cli.parseFromInstance(options, '-a1 -a2 3'.split())
+        assert options.a == ['1', '2']
+        assert options.remaining == ['3']
+
+        options = new ValSepC()
+        cli.parseFromInstance(options, ['-b1,2'] as String[])
+        assert options.b == ['1', '2']
+
+        options = new ValSepC()
+        cli.parseFromInstance(options, ['-b1,2,3'] as String[])
+        assert options.b == ['1', '2,3']
+
+        options = new ValSepC()
+        cli.parseFromInstance(options, ['-c', '1'] as String[])
+        assert options.c == ['1']
+
+        options = new ValSepC()
+        cli.parseFromInstance(options, ['-c1'] as String[])
+        assert options.c == ['1']
+
+        options = new ValSepC()
+        cli.parseFromInstance(options, ['-c1,2,3'] as String[])
+        assert options.c == ['1', '2', '3']
+    }
+
+    class WithConvertC {
+        @Option(convert={ it.toLowerCase() }) String a
+        @Option(convert={ it.toUpperCase() }) String b
+        @Option(convert={ new SimpleDateFormat("yyyy-MM-dd").parse(it) }) Date d
+        @Unparsed List remaining
+    }
+
+    void testConvertClass() {
+        Date newYears = new SimpleDateFormat("yyyy-MM-dd").parse("2016-01-01")
+        def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
+        def cli = new CliBuilder()
+        def options = new WithConvertC()
+        cli.parseFromInstance(options, argz)
+        assert options.a == 'john'
+        assert options.b == 'MARY'
+        assert options.d == newYears
+        assert options.remaining == ['and', 'some', 'more']
+    }
+
+    class TypeCheckedC {
+        @Option String name
+        @Option int age
+        @Unparsed List remaining
+    }
+
+    @TypeChecked
+    void testTypeCheckedClass() {
+        def argz = "--name John --age 21 and some more".split()
+        def cli = new CliBuilder()
+        def options = new TypeCheckedC()
+        cli.parseFromInstance(options, argz)
+        String n = options.name
+        int a = options.age
+        assert n == 'John' && a == 21
+        assert options.remaining == ['and', 'some', 'more']
+    }
+
+    void testParseFromInstance() {
+        def p2 = new PersonC()
+        def builder2 = new CliBuilder()
+        builder2.parseFromInstance(p2, argz)
+        // properties show first in toString()
+        assert p2.toString() == 'CliBuilderTest$PersonC(John, true, Smith, true, true, false, 21, 1980, 3.5, 3.14159,' +
+                ' cv.txt, DOWN, [and, some, more])'
+    }
+
+    interface RetTypeI {
+        @Unparsed Integer[] nums()
+    }
+
+    // this feature is incubating
+    void testTypedUnparsedFromSpec() {
+        def argz = '12 34 56'.split()
+        def cli = new CliBuilder()
+        def options = cli.parseFromSpec(RetTypeI, argz)
+        assert options.nums() == [12, 34, 56]
+    }
+
+    class RetTypeC {
+        @Unparsed Integer[] nums
+    }
+
+    // this feature is incubating
+    void testTypedUnparsedFromInstance() {
+        def argz = '12 34 56'.split()
+        def cli = new CliBuilder()
+        def options = new RetTypeC()
+        cli.parseFromInstance(options, argz)
+        assert options.nums == [12, 34, 56]
+    }
+
+    interface FlagEdgeCasesI {
+        @Option boolean abc()
+        @Option(numberOfArgumentsString='1') boolean efg()
+        @Option(numberOfArguments=1) ijk()
+        @Option(numberOfArguments=0) lmn()
+        @Unparsed List remaining()
+    }
+
+    void testParseFromInstanceFlagEdgeCases_singleHyphen() {
+        def cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
+        def options = cli.parseFromSpec(FlagEdgeCasesI, '-abc -efg true -ijk foo -lmn bar baz'.split())
+
+        assert options.abc() && options.efg()
+        assert options.ijk() == 'foo'
+        assert options.lmn() == true
+        assert options.remaining() == ['bar', 'baz']
+
+        options = cli.parseFromSpec(FlagEdgeCasesI, '-abc -ijk cat -efg false bar baz'.split())
+        assert options.abc()
+        assert options.ijk() == 'cat'
+        assert !options.efg()
+        assert options.lmn() == false
+        assert options.remaining() == ['bar', 'baz']
+    }
+
+    void testParseFromInstanceFlagEdgeCases_doubleHyphen() {
+        def cli = new CliBuilder()
+        def options = cli.parseFromSpec(FlagEdgeCasesI, '--abc --efg true --ijk foo --lmn bar baz'.split())
+
+        assert options.abc() && options.efg()
+        assert options.ijk() == 'foo'
+        assert options.lmn() == true
+        assert options.remaining() == ['bar', 'baz']
+
+        options = cli.parseFromSpec(FlagEdgeCasesI, '--abc --ijk cat --efg false bar baz'.split())
+        assert options.abc()
+        assert options.ijk() == 'cat'
+        assert !options.efg()
+        assert options.lmn() == false
+        assert options.remaining() == ['bar', 'baz']
+    }
+
+    void testParseScript() {
+        new GroovyShell().run('''
+            import groovy.cli.OptionField
+            import groovy.cli.UnparsedField
+            import groovy.cli.picocli.CliBuilder
+            import java.math.RoundingMode
+            
+            @OptionField String first
+            @OptionField String last
+            @OptionField boolean flag1
+            @OptionField Boolean flag2
+            @OptionField(longName = 'specialFlag') Boolean flag3
+            @OptionField Boolean flag4
+            @OptionField int age
+            @OptionField Integer born
+            @OptionField float discount
+            @OptionField BigDecimal pi
+            @OptionField File biography
+            @OptionField RoundingMode roundingMode
+            @UnparsedField List remaining
+            new CliBuilder().parseFromInstance(this, args)
+            assert first == 'John'
+            assert last == 'Smith'
+            assert flag1
+            assert flag2
+            assert flag3
+            assert !flag4
+            assert born == 1980
+            assert age == 21
+            assert discount == 3.5f
+            assert pi == 3.14159
+            assert biography == new File('cv.txt')
+            assert roundingMode == RoundingMode.DOWN
+            assert remaining == ['and', 'some', 'more']
+        ''', 'CliBuilderTestScript.groovy', argz)
+    }
+
+    public void testOptionProperties() {
+        CliBuilder cli = new CliBuilder(usage: 'groovyConsole [options] [filename]', stopAtNonOption: false)
+        cli.with {
+            D(longOpt: 'define', args: 2, argName: 'name=value', valueSeparator: '=', 'description')
+        }
+        OptionAccessor options = cli.parse('-Dk=v -Dk2=v2'.split())
+        assert options.hasOption('D')
+        Properties props = options.getOptionProperties('D')
+        assert 'v' == props.getProperty('k')
+        assert 'v2' == props.getProperty('k2')
+    }
+
+    public void testAcceptLongOptionsWithSingleHyphen_defaultFalse() {
+        assert !new CliBuilder().acceptLongOptionsWithSingleHyphen
+    }
+
+    public void testAcceptLongOptionsWithSingleHyphen_DuplicateOptionAnnotationsException() {
+        CliBuilder cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
+        try {
+            cli.with {
+                classpath('description')
+                cp(longOpt: 'classpath', 'description')
+            }
+        } catch (DuplicateOptionAnnotationsException expected) {
+            assert expected.message == 'Option name \'-classpath\' is used by both option --classpath and option -classpath'
+        }
+    }
+
+    public void testLongOptionsRequireDoubleHyphenByDefault() {
+        CliBuilder cli = new CliBuilder()
+        cli.with {
+            classpath('description')
+            cp(longOpt: 'classpath', 'cli.option.cp.description')
+            h(longOpt: 'help', 'cli.option.help.description')
+            V(longOpt: 'version', 'cli.option.version.description')
+            pa(longOpt: 'parameters', 'cli.option.parameters.description')
+            i(longOpt: 'indy', 'cli.option.indy.description')
+            D(longOpt: 'define', args: 2, argName: 'name=value', valueSeparator: '=', 'cli.option.define.description')
+            _(longOpt: 'configscript', args: 1, 'cli.option.configscript.description')
+        }
+
+        assert cli.parse(['--classpath']).cp
+        assert cli.parse(['-cp']).cp
+        assert cli.parse(['-classpath']).classpath
+
+        assert cli.parse(['--parameters']).parameters
+        assert cli.parse(['--parameters']).pa
+
+        def options = cli.parse(['-parameters'])
+        assert !options.parameters
+        assert !options.pa
+        assert options.arguments() == ['-parameters']
+
+        assert cli.parse(['--indy']).indy
+        assert cli.parse(['--indy']).i
+        resetPrintWriter()
+        cli.writer = printWriter
+        assert cli.parse(['-indy']) == null
+        assertTrue(stringWriter.toString().startsWith('error: Unmatched argument [-ndy]'))
+
+        assert cli.parse(['--help']).help
+        assert cli.parse(['--help']).h
+        resetPrintWriter()
+        cli.writer = printWriter
+        assert cli.parse(['-help']) == null
+        assertTrue(stringWriter.toString().startsWith('error: Unmatched argument [-elp]'))
+
+        assert cli.parse(['--version']).version
+        assert cli.parse(['--version']).V
+
+        options = cli.parse(['-version'])
+        assert !options.version
+        assert !options.V
+        assert options.arguments() == ['-version']
+
+        assert cli.parse('--configscript abc'.split()).configscript == 'abc'
+
+        options = cli.parse('-configscript abc'.split())
+        assert !options.configscript
+        assert options.arguments() == ['-configscript', 'abc']
+    }
+
+    public void testAcceptLongOptionsWithSingleHyphen_registersLongOptionsTwice() {
+        CliBuilder cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true)
+        cli.with {
+            cp(longOpt: 'classpath', 'cli.option.cp.description')
+            h(longOpt: 'help', 'cli.option.help.description')
+            V(longOpt: 'version', 'cli.option.version.description')
+            pa(longOpt: 'parameters', 'cli.option.parameters.description')
+            i(longOpt: 'indy', 'cli.option.indy.description')
+            D(longOpt: 'define', args: 2, argName: 'name=value', valueSeparator: '=', 'cli.option.define.description')
+            _(longOpt: 'configscript', args: 1, 'cli.option.configscript.description')
+        }
+
+        assert cli.parse(['--classpath']).cp
+        assert cli.parse(['-classpath']).cp
+        assert cli.parse(['-cp']).classpath
+
+        assert cli.parse(['--parameters']).pa
+        assert cli.parse(['-parameters']).pa
+        assert cli.parse(['-pa']).parameters
+
+        assert cli.parse(['--indy']).i
+        assert cli.parse(['-indy']).i
+        assert cli.parse(['-i']).indy
+
+        assert cli.parse(['--help']).h
+        assert cli.parse(['-help']).h
+        assert cli.parse(['-h']).help
+
+        assert cli.parse(['--version']).V
+        assert cli.parse(['-version']).V
+        assert cli.parse(['-V']).version
+
+        assert cli.parse('--configscript abc'.split()).configscript == 'abc'
+        assert cli.parse( '-configscript abc'.split()).configscript == 'abc'
+    }
+
+    public void testAcceptLongOptionsWithSingleHyphen_usage() {
+        resetPrintWriter()
+        CliBuilder cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: true, writer: printWriter)
+        cli.with {
+            cp(longOpt: 'classpath', 'cli.option.cp.description')
+            h(longOpt: 'help', 'cli.option.help.description')
+            V(longOpt: 'version', 'cli.option.version.description')
+            pa(longOpt: 'parameters', 'cli.option.parameters.description')
+            i(longOpt: 'indy', 'cli.option.indy.description')
+            D(longOpt: 'define', args: 2, argName: 'String', valueSeparator: '=', 'cli.option.define.description')
+            _(longOpt: 'configscript', args: 1, 'cli.option.configscript.description')
+        }
+        cli.usage()
+        def expectedUsage = """\
+Usage: groovy [-hiV] [-cp] [-pa] [-configscript=PARAM] [-D=<String>=<String>]...
+      -configscript, --configscript=PARAM
+                            cli.option.configscript.description
+      -cp, -classpath, --classpath
+                            cli.option.cp.description
+  -D, -define, --define=<String>=<String>
+                            cli.option.define.description
+  -h, -help, --help         cli.option.help.description
+  -i, -indy, --indy         cli.option.indy.description
+      -pa, -parameters, --parameters
+                            cli.option.parameters.description
+  -V, -version, --version   cli.option.version.description"""
+        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+
+        resetPrintWriter()
+        cli = new CliBuilder(acceptLongOptionsWithSingleHyphen: false, writer: printWriter)
+        cli.with {
+            cp(longOpt: 'classpath', 'cli.option.cp.description')
+            h(longOpt: 'help', 'cli.option.help.description')
+            V(longOpt: 'version', 'cli.option.version.description')
+            pa(longOpt: 'parameters', 'cli.option.parameters.description')
+            i(longOpt: 'indy', 'cli.option.indy.description')
+            D(longOpt: 'define', args: 2, argName: 'String', valueSeparator: '=', 'cli.option.define.description')
+            _(longOpt: 'configscript', args: 1, 'cli.option.configscript.description')
+        }
+        cli.usage()
+        expectedUsage = """\
+Usage: groovy [-hiV] [-cp] [-pa] [--configscript=PARAM]
+              [-D=<String>=<String>]...
+      --configscript=PARAM   cli.option.configscript.description
+      -cp, --classpath       cli.option.cp.description
+  -D, --define=<String>=<String>
+                             cli.option.define.description
+  -h, --help                 cli.option.help.description
+  -i, --indy                 cli.option.indy.description
+      -pa, --parameters      cli.option.parameters.description
+  -V, --version              cli.option.version.description"""
+        groovy.util.GroovyTestCase.assertEquals(expectedUsage, stringWriter.toString().tokenize('\r\n').join('\n'))
+    }
+}
diff --git a/subprojects/groovy-docgenerator/build.gradle b/subprojects/groovy-docgenerator/build.gradle
index 77d93f2e0a..40b7da5646 100644
--- a/subprojects/groovy-docgenerator/build.gradle
+++ b/subprojects/groovy-docgenerator/build.gradle
@@ -19,6 +19,7 @@
 dependencies {
     compile rootProject
     compile project(':groovy-cli-commons')
+    compile project(':groovy-cli-picocli')
     compile project(':groovy-templates')
     testCompile project(':groovy-test')
     compile "com.thoughtworks.qdox:qdox:$qdoxVersion"
diff --git a/subprojects/groovy-groovydoc/build.gradle b/subprojects/groovy-groovydoc/build.gradle
index ef3e292824..0fa7a315ea 100644
--- a/subprojects/groovy-groovydoc/build.gradle
+++ b/subprojects/groovy-groovydoc/build.gradle
@@ -20,6 +20,7 @@ dependencies {
     compile rootProject
     testCompile rootProject.sourceSets.test.runtimeClasspath
     compile project(':groovy-cli-commons')
+    compile project(':groovy-cli-picocli')
     compile project(':groovy-templates')
     runtime project(':groovy-dateutil')
     testCompile project(':groovy-test')

Commit:
3e2035ac34d0143de138d8f31aff0337779c3b18
Paul King
paulk@asert.com.au
2018-04-26 23:10:17 +1000
avoid collected source list for groovydoc from being overwritten
diff --git a/gradle/docs.gradle b/gradle/docs.gradle
index ac4fc7d334..4c0d0d0735 100644
--- a/gradle/docs.gradle
+++ b/gradle/docs.gradle
@@ -37,7 +37,6 @@ def javadocSpec = {
         docTitle = doc.title
         locale = 'en_US'
         encoding = 'UTF-8'
-        author = true
         version = true
         overview = rootProject.file('src/main/java/overviewj.html')
         footer = doc.footer
@@ -48,10 +47,8 @@ def javadocSpec = {
     }
 }
 
-def groovydocSpec = {
+def groovydocBaseSpec = {
     use = true
-    source = project.sourceSets.main.allSource
-    classpath = javadoc.classpath
     ext.windowtitle = doc.title
     ext.doctitle = doc.title
     header = doc.title
@@ -66,6 +63,11 @@ def groovydocSpec = {
     link 'http://commons.apache.org/proper/commons-cli/javadocs/api-release/', 'org.apache.commons.cli.'
 }
 
+def groovydocSpec = groovydocBaseSpec >> {
+    source = project.sourceSets.main.allSource
+    classpath = javadoc.classpath
+}
+
 allprojects {
     javadoc javadocSpec
     groovydoc groovydocSpec
@@ -100,7 +102,7 @@ groovydocAll {
         groovyClasspath += sp.groovydoc.groovyClasspath
     }
 }
-groovydocAll groovydocSpec
+groovydocAll groovydocBaseSpec
 
 // when docgenerator is run by the build, it requires a groovy-release-info file
 // but the file is only generated by the 'jar' task, so as a workaround, we copy

Commit:
ebebbb31fb949ffbe515edc8bf5810aa2ae9a3b2
Paul King
paulk@asert.com.au
2018-04-25 23:56:19 +1000
GROOVY-8559: CLONE - Add @Repeatable java8 annotation support (handle pre-compiled annotations)
diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index e5d1f036f9..565e2f9cc0 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -1440,9 +1440,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public boolean isAnnotationDefinition() {
-        return redirect().isPrimaryNode &&
-               isInterface() &&
-               (getModifiers() & Opcodes.ACC_ANNOTATION)!=0;
+        return /* redirect().isPrimaryNode && */
+                isInterface() && (getModifiers() & Opcodes.ACC_ANNOTATION) != 0;
     }
 
     public List<AnnotationNode> getAnnotations() {
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 1bdf9b86e2..d5d0bf9b67 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -63,6 +63,7 @@ import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.trait.Traits;
 import org.objectweb.asm.Opcodes;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Modifier;
@@ -1222,12 +1223,13 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 member.setValue(newValue);
                 checkAnnotationMemberValue(newValue);
             }
-            if(annType.isResolved()) {
+            if (annType.isResolved()) {
                 Class annTypeClass = annType.getTypeClass();
                 Retention retAnn = (Retention) annTypeClass.getAnnotation(Retention.class);
-                if (retAnn != null && retAnn.value().equals(RetentionPolicy.RUNTIME)) {
+                if (retAnn != null && retAnn.value().equals(RetentionPolicy.RUNTIME) && !isRepeatable(annTypeClass)) {
+                    // remember runtime/non-repeatable annos (auto collecting of Repeatable annotations is handled elsewhere)
                     AnnotationNode anyPrevAnnNode = tmpAnnotations.put(annTypeClass.getName(), an);
-                    if(anyPrevAnnNode != null) {
+                    if (anyPrevAnnNode != null) {
                         addError("Cannot specify duplicate annotation on the same member : " + annType.getName(), an);
                     }
                 }
@@ -1235,6 +1237,16 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         }
     }
 
+    private boolean isRepeatable(Class annTypeClass) {
+        Annotation[] annTypeAnnotations = annTypeClass.getAnnotations();
+        for (Annotation annTypeAnnotation : annTypeAnnotations) {
+            if (annTypeAnnotation.annotationType().getName().equals("java.lang.annotation.Repeatable")) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     // resolve constant-looking expressions statically (do here as gets transformed away later)
     private Expression transformInlineConstants(Expression exp) {
         if (exp instanceof PropertyExpression) {
diff --git a/src/test/gls/annotations/AnnotationTest.groovy b/src/test/gls/annotations/AnnotationTest.groovy
index be77a1635e..78aa260159 100644
--- a/src/test/gls/annotations/AnnotationTest.groovy
+++ b/src/test/gls/annotations/AnnotationTest.groovy
@@ -755,6 +755,45 @@ class AnnotationTest extends CompilableTestSupport {
         '''
     }
 
+    void testAnnotationWithRepeatableSupportedPrecompiledJava() {
+        assertScript '''
+            import java.lang.annotation.*
+            import gls.annotations.*
+
+            class MyClass {
+                // TODO confirm the JDK9 behavior is what we expect
+                private static final List<String> expected = [
+                    '@gls.annotations.Requires(value=[@gls.annotations.Require(value=val1), @gls.annotations.Require(value=val2)])',    // JDK5-8
+                    '@gls.annotations.Requires(value={@gls.annotations.Require(value="val1"), @gls.annotations.Require(value="val2")})' // JDK9
+                ]
+
+                // control
+                @Requires([@Require("val1"), @Require("val2")])
+                String method1() { 'method1' }
+
+                // duplicate candidate for auto collection
+                @Require(value = "val1")
+                @Require(value = "val2")
+                String method2() { 'method2' }
+
+                static void main(String... args) {
+                    MyClass myc = new MyClass()
+                    assert 'method1' == myc.method1()
+                    assert 'method2' == myc.method2()
+                    assert expected.contains(checkAnnos(myc, "method1"))
+                    assert expected.contains(checkAnnos(myc, "method2"))
+                }
+
+                private static String checkAnnos(MyClass myc, String name) {
+                    def m = myc.getClass().getMethod(name)
+                    List annos = m.getAnnotations()
+                    assert annos.size() == 1
+                    annos[0].toString()
+                }
+            }
+        '''
+    }
+
     //Parametrized tests in Spock would allow to make it much more readable
     private static String codeWithMetaAnnotationWithTarget(String targetElementTypeName) {
         """
diff --git a/src/test/gls/annotations/Require.java b/src/test/gls/annotations/Require.java
new file mode 100644
index 0000000000..7d51cf2293
--- /dev/null
+++ b/src/test/gls/annotations/Require.java
@@ -0,0 +1,32 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package gls.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Repeatable;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD})
+@Repeatable(Requires.class)
+public @interface Require {
+    String value() default "";
+}
diff --git a/src/test/gls/annotations/Requires.java b/src/test/gls/annotations/Requires.java
new file mode 100644
index 0000000000..b828a59919
--- /dev/null
+++ b/src/test/gls/annotations/Requires.java
@@ -0,0 +1,30 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package gls.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD})
+public @interface Requires {
+    Require[] value();
+}

Commit:
9bcdd74df31e0a0701040d44718a8345a83b4c1e
sunlan
sunlan@apache.org
2018-04-24 21:22:34 +0800
Trivial refactoring for `getLocation`
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 78ed2ca3e1..e6d57658c3 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -599,23 +599,6 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         mixin(getMetaClass(self), Arrays.asList(categoryClass));
     }
 
-    /**
-     * Gets the url of the jar containing the specified class
-     *
-     * @param self the class
-     * @return the url of the jar, {@code null} if the specified class is from JDK
-     * @since 2.5.0
-     */
-    public static URL getLocation(Class self) {
-        CodeSource codeSource = self.getProtectionDomain().getCodeSource();
-
-        if (null == codeSource) {
-            return null;
-        }
-
-        return codeSource.getLocation();
-    }
-
     /**
      * Extend class globally with category methods.
      *
@@ -638,6 +621,19 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         mixin(self, Arrays.asList(categoryClass));
     }
 
+    /**
+     * Gets the url of the jar file/source file containing the specified class
+     *
+     * @param self the class
+     * @return the url of the jar, {@code null} if the specified class is from JDK
+     * @since 2.5.0
+     */
+    public static URL getLocation(Class self) {
+        CodeSource codeSource = self.getProtectionDomain().getCodeSource();
+
+        return null == codeSource ? null : codeSource.getLocation();
+    }
+
     /**
      * Scoped use method with list of categories.
      *

Commit:
66857c57242be7d5a1141f3d93f0ab531e47455b
sunlan
sunlan@apache.org
2018-04-24 20:41:48 +0800
Rename `where` to `getLocation`
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 05d588a4e8..78ed2ca3e1 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -606,7 +606,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return the url of the jar, {@code null} if the specified class is from JDK
      * @since 2.5.0
      */
-    public static URL where(Class self) {
+    public static URL getLocation(Class self) {
         CodeSource codeSource = self.getProtectionDomain().getCodeSource();
 
         if (null == codeSource) {
diff --git a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
index 95fb2c88a0..a29ad91d24 100644
--- a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
@@ -309,7 +309,7 @@ class DefaultGroovyMethodsTest extends GroovyTestCase {
     }
 
     void testWhichJar() {
-        assert DefaultGroovyMethods.where(org.objectweb.asm.Opcodes).getFile().matches(/(.+\/)?asm[-].+\.jar/)
-        assert null == DefaultGroovyMethods.where(String)
+        assert DefaultGroovyMethods.getLocation(org.objectweb.asm.Opcodes).getFile().matches(/(.+\/)?asm[-].+\.jar/)
+        assert null == DefaultGroovyMethods.getLocation(String)
     }
 }

Commit:
e6083d4e865c177d2779a9c2acd6c59545c6763b
sunlan
sunlan@apache.org
2018-04-24 18:46:49 +0800
Rename `whichJar` to `where`
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index dbb819c85b..05d588a4e8 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -606,7 +606,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return the url of the jar, {@code null} if the specified class is from JDK
      * @since 2.5.0
      */
-    public static URL whichJar(Class self) {
+    public static URL where(Class self) {
         CodeSource codeSource = self.getProtectionDomain().getCodeSource();
 
         if (null == codeSource) {
diff --git a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
index 8ad57c4afb..95fb2c88a0 100644
--- a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
@@ -309,7 +309,7 @@ class DefaultGroovyMethodsTest extends GroovyTestCase {
     }
 
     void testWhichJar() {
-        assert DefaultGroovyMethods.whichJar(org.objectweb.asm.Opcodes).getFile().matches(/(.+\/)?asm[-].+\.jar/)
-        assert null == DefaultGroovyMethods.whichJar(String)
+        assert DefaultGroovyMethods.where(org.objectweb.asm.Opcodes).getFile().matches(/(.+\/)?asm[-].+\.jar/)
+        assert null == DefaultGroovyMethods.where(String)
     }
 }

Commit:
f0ae635097b3d69a5beab490c27bf9dc7f88ed5c
sunlan
sunlan@apache.org
2018-04-24 15:18:57 +0800
Add `@since` to javadoc
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 1ef341feb3..dbb819c85b 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -604,6 +604,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      *
      * @param self the class
      * @return the url of the jar, {@code null} if the specified class is from JDK
+     * @since 2.5.0
      */
     public static URL whichJar(Class self) {
         CodeSource codeSource = self.getProtectionDomain().getCodeSource();

Commit:
bf8c655179471c0a703ce9f9c13a880bb06e9a4a
sunlan
sunlan@apache.org
2018-04-24 14:42:04 +0800
Add DGM `whichJar` to get the url of the jar containing the specified class(closes #690)
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 4d4e3f6bd1..1ef341feb3 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -108,7 +108,9 @@ import java.lang.reflect.Proxy;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.RoundingMode;
+import java.net.URL;
 import java.security.AccessController;
+import java.security.CodeSource;
 import java.security.PrivilegedAction;
 import java.text.MessageFormat;
 import java.util.AbstractCollection;
@@ -597,6 +599,22 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         mixin(getMetaClass(self), Arrays.asList(categoryClass));
     }
 
+    /**
+     * Gets the url of the jar containing the specified class
+     *
+     * @param self the class
+     * @return the url of the jar, {@code null} if the specified class is from JDK
+     */
+    public static URL whichJar(Class self) {
+        CodeSource codeSource = self.getProtectionDomain().getCodeSource();
+
+        if (null == codeSource) {
+            return null;
+        }
+
+        return codeSource.getLocation();
+    }
+
     /**
      * Extend class globally with category methods.
      *
diff --git a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
index e332407c33..8ad57c4afb 100644
--- a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
@@ -308,4 +308,8 @@ class DefaultGroovyMethodsTest extends GroovyTestCase {
         assertFalse(DefaultGroovyMethods.implies(true, null))
     }
 
+    void testWhichJar() {
+        assert DefaultGroovyMethods.whichJar(org.objectweb.asm.Opcodes).getFile().matches(/(.+\/)?asm[-].+\.jar/)
+        assert null == DefaultGroovyMethods.whichJar(String)
+    }
 }

Commit:
fc65d78d88a8f9ebd11c6065ddf145b1e1e17c9c
Paul King
paulk@asert.com.au
2018-04-24 13:43:10 +1000
Handle SecurityException for system properties in a consistent way.
diff --git a/src/main/java/org/apache/groovy/util/SystemUtil.java b/src/main/java/org/apache/groovy/util/SystemUtil.java
index 967b37b030..2dfe69242b 100644
--- a/src/main/java/org/apache/groovy/util/SystemUtil.java
+++ b/src/main/java/org/apache/groovy/util/SystemUtil.java
@@ -20,10 +20,12 @@ package org.apache.groovy.util;
 
 public class SystemUtil {
     /**
-     * Sets a system property from a name=value String
+     * Sets a system property from a {@code name=value} String.
+     * If no '=' is found, the property is assumed to be a Boolean flag with value {@code true}.
      *
      * @param nameValue the non-null name=value String
      * @return the found name
+     * @throws IllegalArgumentException if nameValue is null
      */
     public static String setSystemPropertyFrom(final String nameValue) {
         if (nameValue == null) throw new IllegalArgumentException("argument should not be null");
@@ -43,4 +45,78 @@ public class SystemUtil {
         System.setProperty(name, value);
         return name;
     }
+
+    /**
+     * Sets a system property from a {@code name=value} String.
+     * If no '=' is found, the property is assumed to be a Boolean flag with value {@code true}.
+     * Does nothing if a Security manager is in place which doesn't allow the operation.
+     *
+     * @param nameValue the non-null name=value String
+     * @return the found property name or null if the operation wasn't successful
+     * @throws IllegalArgumentException if nameValue is null
+     */
+    public static String setSystemPropertyFromSafe(final String nameValue) {
+        try {
+            return setSystemPropertyFrom(nameValue);
+        } catch (SecurityException ignore) {
+            // suppress exception
+        }
+        return null;
+    }
+
+    /**
+     * Retrieves a System property, or returns some default value if:
+     * <ul>
+     * <li>the property isn't found</li>
+     * <li>the property name is null or empty</li>
+     * <li>if a security manager exists and its checkPropertyAccess method doesn't allow access to the specified system property.</li>
+     * </ul>
+     *
+     * @param name         the name of the system property.
+     * @param defaultValue a default value.
+     * @return value of the system property or the default value
+     */
+    public static String getSystemPropertySafe(String name, String defaultValue) {
+        try {
+            return System.getProperty(name, defaultValue);
+        } catch (SecurityException | NullPointerException | IllegalArgumentException ignore) {
+            // suppress exception
+        }
+        return defaultValue;
+    }
+
+    /**
+     * Retrieves a System property, or null if:
+     * <ul>
+     * <li>the property isn't found</li>
+     * <li>the property name is null or empty</li>
+     * <li>if a security manager exists and its checkPropertyAccess method doesn't allow access to the specified system property.</li>
+     * </ul>
+     *
+     * @param name the name of the system property.
+     * @return value of the system property or null
+     */
+    public static String getSystemPropertySafe(String name) {
+        return getSystemPropertySafe(name, null);
+    }
+
+    /**
+     * Retrieves a Boolean System property, or returns false if:
+     * <ul>
+     * <li>the property isn't found</li>
+     * <li>the property name is null or empty</li>
+     * <li>if a security manager exists and its checkPropertyAccess method doesn't allow access to the specified system property.</li>
+     * </ul>
+     *
+     * @param name the name of the system property.
+     * @return value of the Boolean system property or false
+     */
+    public static boolean getBooleanSafe(String name) {
+        try {
+            return Boolean.getBoolean(name);
+        } catch (SecurityException ignore) {
+            // suppress exception
+        }
+        return false;
+    }
 }
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index a2164bb38d..749f8797f4 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -43,6 +43,9 @@ import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 
+import static org.apache.groovy.util.SystemUtil.getBooleanSafe;
+import static org.apache.groovy.util.SystemUtil.getSystemPropertySafe;
+
 /**
  * Compilation control flags and coordination stuff.
  */
@@ -227,17 +230,17 @@ public class CompilerConfiguration {
         setClasspath("");
         setVerbose(false);
         setDebug(false);
-        setParameters(safeGetSystemProperty("groovy.parameters") != null);
+        setParameters(getSystemPropertySafe("groovy.parameters") != null);
         setTolerance(10);
         setScriptBaseClass(null);
         setRecompileGroovySource(false);
         setMinimumRecompilationInterval(100);
-        setTargetBytecode(safeGetSystemProperty("groovy.target.bytecode", getVMVersion()));
-        setDefaultScriptExtension(safeGetSystemProperty("groovy.default.scriptExtension", ".groovy"));
+        setTargetBytecode(getSystemPropertySafe("groovy.target.bytecode", getVMVersion()));
+        setDefaultScriptExtension(getSystemPropertySafe("groovy.default.scriptExtension", ".groovy"));
 
         // Source file encoding
-        String encoding = safeGetSystemProperty("file.encoding", DEFAULT_SOURCE_ENCODING);
-        encoding = safeGetSystemProperty("groovy.source.encoding", encoding);
+        String encoding = getSystemPropertySafe("file.encoding", DEFAULT_SOURCE_ENCODING);
+        encoding = getSystemPropertySafe("groovy.source.encoding", encoding);
         setSourceEncoding(encoding);
 
         try {
@@ -247,17 +250,12 @@ public class CompilerConfiguration {
         }
 
 
-        String target = safeGetSystemProperty("groovy.target.directory");
+        String target = getSystemPropertySafe("groovy.target.directory");
         if (target != null) {
             setTargetDirectory(target);
         }
 
-        boolean indy = false;
-        try {
-            indy = Boolean.getBoolean("groovy.target.indy");
-        } catch (Exception e) {
-            // IGNORE
-        }
+        boolean indy = getBooleanSafe("groovy.target.indy");
         if (DEFAULT!=null && Boolean.TRUE.equals(DEFAULT.getOptimizationOptions().get(INVOKEDYNAMIC))) {
             indy = true;
         }
@@ -268,7 +266,7 @@ public class CompilerConfiguration {
         setOptimizationOptions(options);
 
         try {
-            String groovyAntlr4Opt = System.getProperty(GROOVY_ANTLR4_OPT);
+            String groovyAntlr4Opt = getSystemPropertySafe(GROOVY_ANTLR4_OPT);
 
             this.parserVersion =
                     null == groovyAntlr4Opt || Boolean.valueOf(groovyAntlr4Opt)
@@ -279,45 +277,6 @@ public class CompilerConfiguration {
         }
     }
 
-    /**
-     * Retrieves a System property, or null if any of the following exceptions occur.
-     * <ul>
-     *     <li>SecurityException - if a security manager exists and its checkPropertyAccess method doesn't allow access to the specified system property.</li>
-     *     <li>NullPointerException - if key is null.</li>
-     *     <li>IllegalArgumentException - if key is empty.</li>
-     * </ul>
-     * @param key the name of the system property.
-     * @return value of the system property or null
-     */
-    private static String safeGetSystemProperty(String key){
-        return safeGetSystemProperty(key, null);
-    }
-
-    /**
-     * Retrieves a System property, or null if any of the following exceptions occur (Warning: Exception messages are
-     * suppressed).
-     * <ul>
-     *     <li>SecurityException - if a security manager exists and its checkPropertyAccess method doesn't allow access to the specified system property.</li>
-     *     <li>NullPointerException - if key is null.</li>
-     *     <li>IllegalArgumentException - if key is empty.</li>
-     * </ul>
-     * @param key the name of the system property.
-     * @param def a default value.
-     * @return  value of the system property or null
-     */
-    private static String safeGetSystemProperty(String key, String def){
-        try {
-            return System.getProperty(key, def);
-        } catch (SecurityException t){
-            // suppress exception
-        } catch (NullPointerException t){
-            // suppress exception
-        } catch (IllegalArgumentException t){
-            // suppress exception
-        }
-        return def;
-    }
-
     /**
      * Copy constructor.  Use this if you have a mostly correct configuration
      * for your compilation but you want to make a some changes programatically.
@@ -942,10 +901,11 @@ public class CompilerConfiguration {
 
     {
         // this object initializer assures that `enableCompileStaticByDefault` must be invoked no matter which constructor called.
-        if (Boolean.getBoolean("groovy.compile.static")) {
+        if (getBooleanSafe("groovy.compile.static")) {
             enableCompileStaticByDefault();
         }
     }
+
     private void enableCompileStaticByDefault() {
         compilationCustomizers.add(
             new CompilationCustomizer(CompilePhase.CONVERSION) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/StackTraceUtils.java b/src/main/java/org/codehaus/groovy/runtime/StackTraceUtils.java
index 0a8d4b788e..fc34ccd737 100644
--- a/src/main/java/org/codehaus/groovy/runtime/StackTraceUtils.java
+++ b/src/main/java/org/codehaus/groovy/runtime/StackTraceUtils.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy.runtime;
 
 import groovy.lang.Closure;
+import org.apache.groovy.util.SystemUtil;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 import java.io.PrintWriter;
@@ -100,7 +101,7 @@ public class StackTraceUtils {
      */
     public static Throwable sanitize(Throwable t) {
         // Note that this getBoolean access may well be synced...
-        if (!Boolean.getBoolean("groovy.full.stacktrace")) {
+        if (!SystemUtil.getBooleanSafe("groovy.full.stacktrace")) {
             StackTraceElement[] trace = t.getStackTrace();
             List<StackTraceElement> newTrace = new ArrayList<StackTraceElement>();
             for (StackTraceElement stackTraceElement : trace) {
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java
index f6cf4140eb..53ba7156b4 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java
@@ -25,6 +25,7 @@ import groovy.lang.GroovyCodeSource;
 import groovy.lang.GroovyObject;
 import groovy.lang.GroovyRuntimeException;
 import groovy.lang.Writable;
+import org.apache.groovy.util.SystemUtil;
 import org.codehaus.groovy.control.CompilationFailedException;
 
 import java.io.IOException;
@@ -91,14 +92,11 @@ import java.util.concurrent.atomic.AtomicInteger;
  * &lt;/servlet&gt;
  * </pre>
  * In this case, your template source file should be HTML with the appropriate embedded placeholders.
- *
- * @author tug@wilson.co.uk
- * @author Paul King
  */
 public class GStringTemplateEngine extends TemplateEngine {
     private final ClassLoader parentLoader;
     private static AtomicInteger counter = new AtomicInteger();
-    private static final boolean reuseClassLoader = Boolean.getBoolean("groovy.GStringTemplateEngine.reuseClassLoader");
+    private static final boolean reuseClassLoader = SystemUtil.getBooleanSafe("groovy.GStringTemplateEngine.reuseClassLoader");
 
     public GStringTemplateEngine() {
         this(GStringTemplate.class.getClassLoader());

Commit:
708af94e6b5d39b510063fef8a9fa0f259af9d98
sunlan
sunlan@apache.org
2018-04-24 10:12:59 +0800
Bump jansi to 1.17.1
diff --git a/build.gradle b/build.gradle
index 32e3bd8a89..20a9b61a89 100644
--- a/build.gradle
+++ b/build.gradle
@@ -153,7 +153,7 @@ ext {
     eclipseOsgiVersion = '3.9.1-v20140110-1610'
     gparsVersion = '1.2.1'
     ivyVersion = '2.4.0'
-    jansiVersion = '1.17'
+    jansiVersion = '1.17.1'
     jarjarVersion = '1.6.5'
     jlineVersion = '2.14.6'
     jmockVersion = '1.2.0'

Commit:
977c91a59d63c92d8a53310fe583f308e7aa3c2c
sunlan
sunlan@apache.org
2018-04-24 08:04:37 +0800
Grant read "line.separator" property permission to ScriptTest.groovy
diff --git a/security/groovy.policy b/security/groovy.policy
index 848de085e3..c688abbfdf 100644
--- a/security/groovy.policy
+++ b/security/groovy.policy
@@ -238,6 +238,9 @@ grant codeBase "file:${user.dir}/src/test/groovy/script/ScriptTest.groovy" {
     // Required for JUnit to report errors for scripts that are junit test cases
     permission java.util.PropertyPermission "user.home", "read";
     permission java.io.FilePermission "${user.home}${/}junit.properties", "read";
+
+    // Required for Gradle 4.7+ printing a line triggered by running the script
+    permission java.util.PropertyPermission "line.separator", "read";
 };
 
 grant codeBase "file:${user.dir}/src/test/groovy/script/EvalInScript.groovy" {

Commit:
4297c4f5c9811a0e8ac52e8b718fcd1551afa111
sunlan
sunlan@apache.org
2018-04-24 08:03:06 +0800
Bump gradle to 4.7
diff --git a/gradle.properties b/gradle.properties
index 2fff8ce341..5a105f4516 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -17,7 +17,7 @@ groovyVersion = 3.0.0-SNAPSHOT
 # bundle version format: major('.'minor('.'micro('.'qualifier)?)?)? (first 3 only digits)
 groovyBundleVersion = 3.0.0.SNAPSHOT
 
-gradle_version=4.6
+gradle_version=4.7
 
 groovyJUnit_ms=512m
 groovyJUnit_mx=1g
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index c44b679acd..f6b961fd5a 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ea720f986f..16d28051c9 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.7-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-bin.zip

Commit:
798c47993fcc0e66e3b747cb03a6a86c04badf2b
sunlan
sunlan@apache.org
2018-04-23 14:08:45 +0800
Refine readme of the new Parrot parser
diff --git a/subprojects/parser-antlr4/README.adoc b/subprojects/parser-antlr4/README.adoc
index 187addefaa..4075afb5f3 100644
--- a/subprojects/parser-antlr4/README.adoc
+++ b/subprojects/parser-antlr4/README.adoc
@@ -38,6 +38,8 @@ The new parser(Parrot) can parse Groovy source code and construct the related AS
 
 === How to enable the new parser
 
+The new parser is enabled by default since Groovy 3.0.0
+
 * In the gradle build the property useAntlr4 has to be set to enable the build of the parser and the execution of all tests with it. Command line example:
 ```
 ./gradlew -PuseAntlr4=true bootstrapJar
@@ -54,9 +56,10 @@ groovyOptions.forkOptions.jvmArgs += ["-Dgroovy.antlr4=true"]
 
 === JVM system properties to control parsing
 
-* `groovy.antlr4.cache.threshold`: how frequently to clear DFA cache(default: 50). **Notice:** The more frequently the DFA cache is cleared, the poorer parsing performance will be(you can not set the value that is less than the default value). But the DFA cache has to be cleared to avoid OutOfMemoryError's occurring. 
+* `groovy.antlr4.cache.threshold`: how frequently to clear DFA cache(default: 64). **Notice:** The more frequently the DFA cache is cleared, the poorer parsing performance will be(you can not set the value that is less than the default value). But the DFA cache has to be cleared to avoid OutOfMemoryError's occurring.
 * `groovy.attach.groovydoc`: whether to attach groovydoc to node as metadata while parsing groovy source code(default: false)
-* `groovy.attach.runtime.groovydoc`: whether to attach `@Groovydoc` annotation to all members which have groovydoc(i.e. `/** ... */`).
+* `groovy.attach.runtime.groovydoc`: whether to attach `@Groovydoc` annotation to all members which have groovydoc(i.e. `/** ... */`)
+* `groovy.extract.doc.comment`: whether to collect groovydoc while parsing groovy source code(default: false). **DEPRECATED, USE `groovy.attach.groovydoc` INSTEAD**
 
 *P.S. Parrot is based on the highly optimized version of antlr4(com.tunnelvisionlabs:antlr4), which is licensed under BSD.*
 

Commit:
f25d072ac5e872e514c70794ce970675ffb45f6f
sunlan
sunlan@apache.org
2018-04-23 14:04:49 +0800
Tweak word
diff --git a/subprojects/parser-antlr4/README.adoc b/subprojects/parser-antlr4/README.adoc
index e6453d004e..187addefaa 100644
--- a/subprojects/parser-antlr4/README.adoc
+++ b/subprojects/parser-antlr4/README.adoc
@@ -33,7 +33,7 @@ The new parser(Parrot) can parse Groovy source code and construct the related AS
 * additional places for type annotations
 * new operators: identity operators(`===`, `!==`), elvis assignment(`?=`), `!in`, `!instanceof`
 * safe index, e.g. `nullableVar?[1, 2]`
-* create instances of non-static inner classes with Java-Like syntax, e.g. `outer.new Inner()`
+* non-static inner class instantiation, e.g. `outer.new Inner()`
 * runtime groovydoc, i.e. groovydoc with `@Groovydoc`; groovydoc attached to AST node as metadata
 
 === How to enable the new parser

Commit:
645531be94f57eee7c170a5b74c86749e71f1298
sunlan
sunlan@apache.org
2018-04-23 11:30:46 +0800
Refine readme of the new Parrot parser
diff --git a/subprojects/parser-antlr4/README.adoc b/subprojects/parser-antlr4/README.adoc
index 7aa0ade024..e6453d004e 100644
--- a/subprojects/parser-antlr4/README.adoc
+++ b/subprojects/parser-antlr4/README.adoc
@@ -33,6 +33,7 @@ The new parser(Parrot) can parse Groovy source code and construct the related AS
 * additional places for type annotations
 * new operators: identity operators(`===`, `!==`), elvis assignment(`?=`), `!in`, `!instanceof`
 * safe index, e.g. `nullableVar?[1, 2]`
+* create instances of non-static inner classes with Java-Like syntax, e.g. `outer.new Inner()`
 * runtime groovydoc, i.e. groovydoc with `@Groovydoc`; groovydoc attached to AST node as metadata
 
 === How to enable the new parser

Commit:
e4df27ab1db50c52f8573b3a652f96e3b9473c50
sunlan
sunlan@apache.org
2018-04-23 07:52:32 +0800
Optimize imports for "GROOVY-8490: Extend @Newify to support a class name pattern parameter"(commit e91e736)
diff --git a/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java
index aade78cdca..ae71b147ac 100644
--- a/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java
@@ -18,17 +18,41 @@
  */
 package org.codehaus.groovy.transform;
 
-import groovy.lang.*;
+import groovy.lang.Newify;
+import groovy.lang.Reference;
 import org.codehaus.groovy.GroovyBugError;
-import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.ASTNode;
+import org.codehaus.groovy.ast.AnnotatedNode;
+import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassCodeExpressionTransformer;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.ClassExpression;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
+import org.codehaus.groovy.ast.expr.ConstantExpression;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.DeclarationExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.ListExpression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;

Commit:
e91e73651e0c6f48d54ecda28a8cb492b427d648
sunlan
sunlan@apache.org
2018-04-23 07:30:56 +0800
Newify pattern support for pull(closes #689 #686)
diff --git a/src/main/groovy/groovy/lang/Newify.java b/src/main/groovy/groovy/lang/Newify.java
index 525cecbc9b..023a0b3a0a 100644
--- a/src/main/groovy/groovy/lang/Newify.java
+++ b/src/main/groovy/groovy/lang/Newify.java
@@ -30,13 +30,30 @@ import java.lang.annotation.Target;
  * keyword. Instead they can be written "Ruby-style" as a method call to a 'new'
  * method or "Python-style" by just omitting the 'new' keyword.
  * <p>
- * It allows you to write code snippets like this ("Python-style"):
+ * WARNING: For the Python style with class-name-matching pattern, the pattern should be chosen as to avoid matching
+ * method names if possible. If following Java/Groovy naming convention, class names (contrary to method names) start
+ * with an uppercase letter. In this case {@code pattern="[A-Z].*"} (see {@link java.util.regex.Pattern} for supported
+ * Java pattern syntax) is the recommended pattern to allow all classes to be created without requiring a new keyword.
+ * Using a pattern that also matches method names (e.g. ".+", ".*" or "[a-zA-Z].*") might negatively impact build
+ * performance, since the Groovy compiler will have to match every class in context against any potential constructor
+ * call.
+ * <p>
+ * {@literal @Newify} allows you to write code snippets like this ("Python-style"):
  * <pre>
  * {@code @Newify([Tree,Leaf])} class MyTreeProcessor {
  *     def myTree = Tree(Tree(Leaf("A"), Leaf("B")), Leaf("C"))
  *     def process() { ... }
  * }
  * </pre>
+ * <pre>
+ * {@code // Any class whose name matches pattern can be created without new}
+ * {@code @Newify(pattern="[A-Z].*")} class MyTreeProcessor {
+ *     final myTree = Tree(Tree(Leaf("A"), Leaf("B")), Leaf("C"))
+ *     final sb = StringBuilder("...")
+ *     def dir = File('.')
+ *     def root = XmlSlurper().parseText(File(dir, sb.toString()).text)
+ * }
+ * </pre>
  * or this ("Ruby-style"):
  * <pre>
  * {@code @Newify} class MyTreeProcessor {
@@ -59,8 +76,9 @@ import java.lang.annotation.Target;
  * flag is given when using the annotation. You might do this if you create a new method
  * using meta programming.
  * <p>
- * The "Python-style" conversions require you to specify each class on which you want them
- * to apply. The transformation then works by matching the basename of the provided classes to any
+ * For the "Python-style" conversions you can either specify each class name on which you want them
+ * to apply, or supply a pattern to match class names against. The transformation then works by matching the basename
+ * of the provided classes to any
  * similarly named instance method calls not specifically bound to an object, i.e. associated
  * with the 'this' object. In other words <code>Leaf("A")</code> would be transformed to
  * <code>new Leaf("A")</code> but <code>x.Leaf("A")</code> would not be touched.
@@ -73,9 +91,9 @@ import java.lang.annotation.Target;
  *     def field1 = java.math.BigInteger.new(42)
  *     def field2, field3, field4
  *
- *     {@code @Newify(Bar)}
+ *     {@code @Newify(pattern="[A-z][A-Za-z0-9_]*")} // Any class name that starts with an uppercase letter
  *     def process() {
- *         field2 = Bar("my bar")
+ *         field2 = A(Bb(Ccc("my bar")))
  *     }
  *
  *     {@code @Newify(Baz)}
@@ -94,6 +112,7 @@ import java.lang.annotation.Target;
  * field level if already turned on at the class level.
  *
  * @author Paul King
+ * @author mgroovy
  */
 @java.lang.annotation.Documented
 @Retention(RetentionPolicy.SOURCE)
@@ -106,4 +125,6 @@ public @interface Newify {
      * @return if automatic conversion of "Ruby-style" new method calls should occur
      */
     boolean auto() default true;
+
+    String pattern() default "";
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java
index 9cd5c3fc4d..aade78cdca 100644
--- a/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/NewifyASTTransformation.java
@@ -18,31 +18,20 @@
  */
 package org.codehaus.groovy.transform;
 
-import groovy.lang.Newify;
+import groovy.lang.*;
 import org.codehaus.groovy.GroovyBugError;
-import org.codehaus.groovy.ast.ASTNode;
-import org.codehaus.groovy.ast.AnnotatedNode;
-import org.codehaus.groovy.ast.AnnotationNode;
-import org.codehaus.groovy.ast.ClassCodeExpressionTransformer;
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.FieldNode;
-import org.codehaus.groovy.ast.MethodNode;
-import org.codehaus.groovy.ast.expr.ClassExpression;
-import org.codehaus.groovy.ast.expr.ClosureExpression;
-import org.codehaus.groovy.ast.expr.ConstantExpression;
-import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
-import org.codehaus.groovy.ast.expr.DeclarationExpression;
-import org.codehaus.groovy.ast.expr.Expression;
-import org.codehaus.groovy.ast.expr.ListExpression;
-import org.codehaus.groovy.ast.expr.MethodCallExpression;
-import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
 
 import static org.codehaus.groovy.ast.ClassHelper.make;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
@@ -61,6 +50,65 @@ public class NewifyASTTransformation extends ClassCodeExpressionTransformer impl
     private ListExpression classesToNewify;
     private DeclarationExpression candidate;
     private boolean auto;
+    private Pattern classNamePattern;
+
+    private static Map<String, ClassNode> nameToGlobalClassesNodesMap;
+    private Map<String, NewifyClassData> nameToInnerClassesNodesMap;
+
+    // ClassHelper.classes minus interfaces, abstract classes, and classes with private ctors
+    private static final Class[] globalClasses = new Class[]{
+            Object.class,
+            Boolean.TYPE,
+            Character.TYPE,
+            Byte.TYPE,
+            Short.TYPE,
+            Integer.TYPE,
+            Long.TYPE,
+            Double.TYPE,
+            Float.TYPE,
+            // Void.TYPE,
+            // Closure.class,
+            // GString.class,
+            // List.class,
+            // Map.class,
+            // Range.class,
+            //Pattern.class,
+            // Script.class,
+            String.class,
+            Boolean.class,  // Shall we allow this ? Using Boolean ctors is usually not what user wants...
+            Character.class,
+            Byte.class,
+            Short.class,
+            Integer.class,
+            Long.class,
+            Double.class,
+            Float.class,
+            BigDecimal.class,
+            BigInteger.class,
+            //Number.class,
+            //Void.class,
+            Reference.class,
+            //Class.class,
+            //MetaClass.class,
+            //Iterator.class,
+            //GeneratedClosure.class,
+            //GeneratedLambda.class,
+            //GroovyObjectSupport.class
+    };
+
+    static {
+        nameToGlobalClassesNodesMap = new ConcurrentHashMap<String, ClassNode>(16, 0.9f, 1);
+        for (Class globalClass : globalClasses) {
+            nameToGlobalClassesNodesMap.put(globalClass.getSimpleName(), ClassHelper.makeCached(globalClass));
+        }
+    }
+
+
+    private static final Pattern extractNamePattern = Pattern.compile("^(?:.*\\$|)(.*)$");
+
+    public static String extractName(final String s) {
+        return extractNamePattern.matcher(s).replaceFirst("$1");
+    }
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
         this.source = source;
@@ -74,35 +122,106 @@ public class NewifyASTTransformation extends ClassCodeExpressionTransformer impl
             internalError("Transformation called from wrong annotation: " + node.getClassNode().getName());
         }
 
-        boolean autoFlag = determineAutoFlag(node.getMember("auto"));
-        Expression value = node.getMember("value");
+        final boolean autoFlag = determineAutoFlag(node.getMember("auto"));
+        final Expression classNames = node.getMember("value");
+        final Pattern cnPattern = determineClassNamePattern(node.getMember("pattern"));
 
         if (parent instanceof ClassNode) {
-            newifyClass((ClassNode) parent, autoFlag, determineClasses(value, false));
+            newifyClass((ClassNode) parent, autoFlag, determineClasses(classNames, false), cnPattern);
         } else if (parent instanceof MethodNode || parent instanceof FieldNode) {
-            newifyMethodOrField(parent, autoFlag, determineClasses(value, false));
+            newifyMethodOrField(parent, autoFlag, determineClasses(classNames, false), cnPattern);
         } else if (parent instanceof DeclarationExpression) {
-            newifyDeclaration((DeclarationExpression) parent, autoFlag, determineClasses(value, true));
+            newifyDeclaration((DeclarationExpression) parent, autoFlag, determineClasses(classNames, true), cnPattern);
+        }
+    }
+
+
+    private void newifyClass(ClassNode cNode, boolean autoFlag, ListExpression list, final Pattern cnPattern) {
+        String cName = cNode.getName();
+        if (cNode.isInterface()) {
+            addError("Error processing interface '" + cName + "'. @"
+                    + MY_NAME + " not allowed for interfaces.", cNode);
+        }
+
+        final ListExpression oldClassesToNewify = classesToNewify;
+        final boolean oldAuto = auto;
+        final Pattern oldCnPattern = classNamePattern;
+
+        classesToNewify = list;
+        auto = autoFlag;
+        classNamePattern = cnPattern;
+
+        super.visitClass(cNode);
+
+        classesToNewify = oldClassesToNewify;
+        auto = oldAuto;
+        classNamePattern = oldCnPattern;
+    }
+
+    private void newifyMethodOrField(AnnotatedNode parent, boolean autoFlag, ListExpression list, final Pattern cnPattern) {
+
+        final ListExpression oldClassesToNewify = classesToNewify;
+        final boolean oldAuto = auto;
+        final Pattern oldCnPattern = classNamePattern;
+
+        checkClassLevelClashes(list);
+        checkAutoClash(autoFlag, parent);
+
+        classesToNewify = list;
+        auto = autoFlag;
+        classNamePattern = cnPattern;
+
+        if (parent instanceof FieldNode) {
+            super.visitField((FieldNode) parent);
+        } else {
+            super.visitMethod((MethodNode) parent);
         }
+
+        classesToNewify = oldClassesToNewify;
+        auto = oldAuto;
+        classNamePattern = oldCnPattern;
     }
 
-    private void newifyDeclaration(DeclarationExpression de, boolean autoFlag, ListExpression list) {
+
+    private void newifyDeclaration(DeclarationExpression de, boolean autoFlag, ListExpression list, final Pattern cnPattern) {
         ClassNode cNode = de.getDeclaringClass();
         candidate = de;
         final ListExpression oldClassesToNewify = classesToNewify;
         final boolean oldAuto = auto;
+        final Pattern oldCnPattern = classNamePattern;
+
         classesToNewify = list;
         auto = autoFlag;
+        classNamePattern = cnPattern;
+
         super.visitClass(cNode);
+
         classesToNewify = oldClassesToNewify;
         auto = oldAuto;
+        classNamePattern = oldCnPattern;
     }
 
     private static boolean determineAutoFlag(Expression autoExpr) {
         return !(autoExpr instanceof ConstantExpression && ((ConstantExpression) autoExpr).getValue().equals(false));
     }
 
-    /** allow non-strict mode in scripts because parsing not complete at that point */
+    private Pattern determineClassNamePattern(Expression expr) {
+        if (!(expr instanceof ConstantExpression)) { return null; }
+        final ConstantExpression constExpr = (ConstantExpression) expr;
+        final String text = constExpr.getText();
+        if (constExpr.getValue() == null || text.equals("")) { return null; }
+        try {
+            final Pattern pattern = Pattern.compile(text);
+            return pattern;
+        } catch (PatternSyntaxException e) {
+            addError("Invalid class name pattern: " + e.getMessage(), expr);
+            return null;
+        }
+    }
+
+    /**
+     * allow non-strict mode in scripts because parsing not complete at that point
+     */
     private ListExpression determineClasses(Expression expr, boolean searchSourceUnit) {
         ListExpression list = new ListExpression();
         if (expr instanceof ClassExpression) {
@@ -196,44 +315,13 @@ public class NewifyASTTransformation extends ClassCodeExpressionTransformer impl
     }
 
     private boolean hasClassesToNewify() {
-        return classesToNewify != null && !classesToNewify.getExpressions().isEmpty();
+        return (classesToNewify != null && !classesToNewify.getExpressions().isEmpty()) || (classNamePattern != null);
     }
 
-    private void newifyClass(ClassNode cNode, boolean autoFlag, ListExpression list) {
-        String cName = cNode.getName();
-        if (cNode.isInterface()) {
-            addError("Error processing interface '" + cName + "'. @"
-                    + MY_NAME + " not allowed for interfaces.", cNode);
-        }
-        final ListExpression oldClassesToNewify = classesToNewify;
-        final boolean oldAuto = auto;
-        classesToNewify = list;
-        auto = autoFlag;
-        super.visitClass(cNode);
-        classesToNewify = oldClassesToNewify;
-        auto = oldAuto;
-    }
-
-    private void newifyMethodOrField(AnnotatedNode parent, boolean autoFlag, ListExpression list) {
-        final ListExpression oldClassesToNewify = classesToNewify;
-        final boolean oldAuto = auto;
-        checkClassLevelClashes(list);
-        checkAutoClash(autoFlag, parent);
-        classesToNewify = list;
-        auto = autoFlag;
-        if (parent instanceof FieldNode) {
-            super.visitField((FieldNode) parent);
-        } else {
-            super.visitMethod((MethodNode) parent);
-        }
-        classesToNewify = oldClassesToNewify;
-        auto = oldAuto;
-    }
 
     private void checkDuplicateNameClashes(ListExpression list) {
         final Set<String> seen = new HashSet<String>();
-        @SuppressWarnings("unchecked")
-        final List<ClassExpression> classes = (List)list.getExpressions();
+        @SuppressWarnings("unchecked") final List<ClassExpression> classes = (List) list.getExpressions();
         for (ClassExpression ce : classes) {
             final String name = ce.getType().getNameWithoutPackage();
             if (seen.contains(name)) {
@@ -251,8 +339,7 @@ public class NewifyASTTransformation extends ClassCodeExpressionTransformer impl
     }
 
     private void checkClassLevelClashes(ListExpression list) {
-        @SuppressWarnings("unchecked")
-        final List<ClassExpression> classes = (List)list.getExpressions();
+        @SuppressWarnings("unchecked") final List<ClassExpression> classes = (List) list.getExpressions();
         for (ClassExpression ce : classes) {
             final String name = ce.getType().getNameWithoutPackage();
             if (findClassWithMatchingBasename(name)) {
@@ -262,17 +349,6 @@ public class NewifyASTTransformation extends ClassCodeExpressionTransformer impl
         }
     }
 
-    private boolean findClassWithMatchingBasename(String nameWithoutPackage) {
-        if (classesToNewify == null) return false;
-        @SuppressWarnings("unchecked")
-        final List<ClassExpression> classes = (List)classesToNewify.getExpressions();
-        for (ClassExpression ce : classes) {
-            if (ce.getType().getNameWithoutPackage().equals(nameWithoutPackage)) {
-                return true;
-            }
-        }
-        return false;
-    }
 
     private boolean isNewifyCandidate(MethodCallExpression mce) {
         return mce.getObjectExpression() == VariableExpression.THIS_EXPRESSION
@@ -286,31 +362,114 @@ public class NewifyASTTransformation extends ClassCodeExpressionTransformer impl
                 && ((ConstantExpression) meth).getValue().equals("new"));
     }
 
-    private Expression transformMethodCall(MethodCallExpression mce, Expression args) {
+    private Expression transformMethodCall(MethodCallExpression mce, Expression argsExp) {
         ClassNode classType;
+
         if (isNewMethodStyle(mce)) {
             classType = mce.getObjectExpression().getType();
         } else {
             classType = findMatchingCandidateClass(mce);
         }
+
         if (classType != null) {
-            return new ConstructorCallExpression(classType, args);
+            Expression argsToUse = argsExp;
+            if (classType.getOuterClass() != null && ((classType.getModifiers() & org.objectweb.asm.Opcodes.ACC_STATIC) == 0)) {
+                if (!(argsExp instanceof ArgumentListExpression)) {
+                    addError("Non-static inner constructor arguments must be an argument list expression; pass 'this' pointer explicitely as first constructor argument otherwise.", mce);
+                    return mce;
+                }
+                final ArgumentListExpression argsListExp = (ArgumentListExpression) argsExp;
+                final List<Expression> argExpList = argsListExp.getExpressions();
+                final VariableExpression thisVarExp = new VariableExpression("this");
+
+                final List<Expression> expressionsWithThis = new ArrayList<Expression>(argExpList.size() + 1);
+                expressionsWithThis.add(thisVarExp);
+                expressionsWithThis.addAll(argExpList);
+
+                argsToUse = new ArgumentListExpression(expressionsWithThis);
+            }
+            return new ConstructorCallExpression(classType, argsToUse);
         }
+
         // set the args as they might have gotten Newify transformed GROOVY-3491
-        mce.setArguments(args);
+        mce.setArguments(argsExp);
         return mce;
     }
 
+
+    private boolean findClassWithMatchingBasename(String nameWithoutPackage) {
+        // For performance reasons test against classNamePattern first
+        if (classNamePattern != null && classNamePattern.matcher(nameWithoutPackage).matches()) {
+            return true;
+        }
+
+        if (classesToNewify != null) {
+            @SuppressWarnings("unchecked") final List<ClassExpression> classes = (List) classesToNewify.getExpressions();
+            for (ClassExpression ce : classes) {
+                if (ce.getType().getNameWithoutPackage().equals(nameWithoutPackage)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
     private ClassNode findMatchingCandidateClass(MethodCallExpression mce) {
-        if (classesToNewify == null) return null;
-        @SuppressWarnings("unchecked")
-        List<ClassExpression> classes = (List)classesToNewify.getExpressions();
-        for (ClassExpression ce : classes) {
-            final ClassNode type = ce.getType();
-            if (type.getNameWithoutPackage().equals(mce.getMethodAsString())) {
-                return type;
+        final String methodName = mce.getMethodAsString();
+
+        if (classesToNewify != null) {
+            @SuppressWarnings("unchecked")
+            List<ClassExpression> classes = (List) classesToNewify.getExpressions();
+            for (ClassExpression ce : classes) {
+                final ClassNode type = ce.getType();
+                if (type.getNameWithoutPackage().equals(methodName)) {
+                    return type;
+                }
             }
         }
+
+        if (classNamePattern != null && classNamePattern.matcher(methodName).matches()) {
+
+            // One-time-fill inner classes lookup map
+            if (nameToInnerClassesNodesMap == null) {
+                final List<ClassNode> innerClassNodes = source.getAST().getClasses();
+                nameToInnerClassesNodesMap = new HashMap<>(innerClassNodes.size());
+                for (ClassNode type : innerClassNodes) {
+                    final String pureClassName = extractName(type.getNameWithoutPackage());
+                    final NewifyClassData classData = nameToInnerClassesNodesMap.get(pureClassName);
+                    if (classData == null) {
+                        nameToInnerClassesNodesMap.put(pureClassName, new NewifyClassData(pureClassName, type));
+                    } else {
+                        // If class name is looked up below, additional types will be used in error message
+                        classData.addAdditionalType(type);
+                    }
+                }
+            }
+
+            // Inner classes
+            final NewifyClassData innerTypeClassData = nameToInnerClassesNodesMap.get(methodName);
+            if (innerTypeClassData != null) {
+                if (innerTypeClassData.types != null) {
+                    addError("Inner class name lookup is ambiguous between the following classes: " + DefaultGroovyMethods.join(innerTypeClassData.types, ", ") + ". Use new keyword and qualify name to break ambiguity.", mce);
+                    return null;
+                }
+                return innerTypeClassData.type;
+            }
+
+            // Imported classes
+            final ClassNode importedType = source.getAST().getImportType(methodName);
+            if (importedType != null) {
+                return importedType;
+            }
+
+            // Global classes
+            final ClassNode globalType = nameToGlobalClassesNodesMap.get(methodName);
+            if (globalType != null) {
+                return globalType;
+            }
+        }
+
         return null;
     }
 
@@ -321,4 +480,26 @@ public class NewifyASTTransformation extends ClassCodeExpressionTransformer impl
     protected SourceUnit getSourceUnit() {
         return source;
     }
+
+
+    private static class NewifyClassData {
+        final String name;
+        final ClassNode type;
+        List<ClassNode> types = null;
+
+        public NewifyClassData(final String name, final ClassNode type) {
+            this.name = name;
+            this.type = type;
+        }
+
+        public void addAdditionalType(final ClassNode additionalType) {
+            if (types == null) {
+                types = new LinkedList<>();
+                types.add(type);
+            }
+            types.add(additionalType);
+        }
+    }
+
+
 }
diff --git a/src/test/org/codehaus/groovy/transform/NewifyTransformBlackBoxTest.groovy b/src/test/org/codehaus/groovy/transform/NewifyTransformBlackBoxTest.groovy
new file mode 100644
index 0000000000..cecd4830c7
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/NewifyTransformBlackBoxTest.groovy
@@ -0,0 +1,593 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.transform
+
+import gls.CompilableTestSupport
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.JUnit4
+import java.util.Map.Entry
+
+/**
+ * Tests for the {@code @Newify} AST transform.
+ */
+@RunWith(JUnit4)
+class NewifyTransformBlackBoxTest extends CompilableTestSupport {
+
+  @Test
+  void testNewifyWithoutNamePattern() {
+    final String classPart = """  
+            final a = A('XyZ')
+            String foo(final x = null) { x?.toString() }
+        """
+    final script = newifyTestScript(true, [value: "[A]"], classPart, "final foo = new $newifyTestClassName(); foo.foo()")
+    println script
+    assert script.contains('@Newify')
+    assertScript(script)
+  }
+
+  @Test
+  void testNewifyWithoutNamePatternFails() {
+    final String classPart = classCode([
+        "final a = A('XyZ')",
+        "final ab0 = new AB('XyZ')",
+        "final ab1 = AB('XyZ')",
+        "String foo(final x = null) { x?.toString() }"
+    ])
+
+    final script0 = newifyTestScript(true, [value: "[A,AB]"], classPart, "final foo = new $newifyTestClassName(); foo.foo()")
+    final script1 = newifyTestScript(true, [value: "[A]"], classPart, "final foo = new $newifyTestClassName(); foo.foo()")
+
+    assertScript(script0)
+
+    final result = shouldNotCompile(script1)
+    assert result.contains("Cannot find matching method NewifyFoo#AB(java.lang.String)")
+  }
+
+
+  @Test
+  void testRegularClassNewifyWithNamePattern() {
+    final String script = """
+              import groovy.transform.Canonical
+              import groovy.transform.CompileStatic
+              import groovy.lang.Newify
+              import groovy.transform.ASTTest
+              import java.lang.StringBuilder
+              import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+  
+              @Canonical class TheClass { String classField }            
+   
+              @Newify(pattern=/[A-Z][A-Za-z0-9_]+/)
+              @CompileStatic
+              def newTheClassField() {
+                final sb = StringBuilder(13)
+                sb.append("abc"); sb.append("_")
+                sb.append("123"); sb.append("_")
+                sb.append(sb.capacity())
+                return sb
+              }
+              
+               newTheClassField()
+          """
+
+    println "script=|$script|"
+    final result = evalScript(script)
+    println "result=$result"
+    assert result instanceof java.lang.StringBuilder
+    assert result.toString() == 'abc_123_13'
+  }
+
+
+  @Test
+  void testInnerScriptClassNewifyWithNamePattern() {
+    final String script = """
+              import groovy.transform.Canonical
+              import groovy.transform.CompileStatic
+              import groovy.lang.Newify
+              import groovy.transform.ASTTest
+              import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+  
+              @Canonical class A { String a }            
+              @Canonical class AB { String a; String b }            
+              @Canonical class ABC { String a; String b; String c }            
+               
+              @Newify(pattern=/[A-Z].*/)
+              @CompileStatic
+              def createClassList() {
+                final l = [ A('2018-04-08'), AB("I am", "class AB"), ABC("A","B","C") ]
+                [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+              }
+              
+              createClassList()
+          """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    assert resultList[0] == ['A', 'AB', 'ABC']
+    assert resultList[1] == ['A(2018-04-08)', 'AB(I am, class AB)', 'ABC(A, B, C)']
+  }
+
+
+  @Test
+  void testInnerClassesNewifyWithNamePattern() {
+    final String script = """           
+        import groovy.transform.Canonical
+        import groovy.transform.CompileStatic
+        import groovy.lang.Newify
+        import groovy.transform.ASTTest
+        import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+  
+        @Newify(pattern=/[A-Z].*/)
+        class Foo {
+          @Canonical class A { String a }            
+          @Canonical class AB { String a; String b }            
+          @Canonical class ABC { String a; String b; String c }            
+           
+          List createClassList() {
+            final l = [ A('2018-04-08'), AB("I am", "class AB"), ABC("A","B","C") ]
+            //final l = [ A(this, '2018-04-08'), AB(this, "I am", "class AB"), ABC(this, "A","B","C") ]
+            [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+          }
+        }
+        
+        final Foo foo = new Foo()
+        foo.createClassList()
+      """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    assert resultList[0] == ['Foo.A', 'Foo.AB', 'Foo.ABC']
+    assert resultList[1] == ['Foo$A(2018-04-08)', 'Foo$AB(I am, class AB)', 'Foo$ABC(A, B, C)']
+  }
+
+
+  @Test
+  void testInnerStaticClassesNewifyWithNamePattern() {
+    final String script = """
+          import groovy.transform.Canonical
+          import groovy.transform.CompileStatic
+          import groovy.lang.Newify
+          import groovy.transform.ASTTest
+          import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+  
+          @Newify(pattern=/[A-Z].*/)
+          class Foo {
+            @Canonical static class A { String a }            
+            @Canonical static class AB { String a; String b }            
+            @Canonical static class ABC { String a; String b; String c }            
+             
+            List createClassList() {
+              final l = [ A('2018-04-08'), AB("I am", "class AB"), ABC("A","B","C") ]
+              [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+            }
+          }
+          
+          final Foo foo = new Foo()
+          foo.createClassList()
+      """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    assert resultList[0] == ['Foo.A', 'Foo.AB', 'Foo.ABC']
+    assert resultList[1] == ['Foo$A(2018-04-08)', 'Foo$AB(I am, class AB)', 'Foo$ABC(A, B, C)']
+  }
+
+
+  @Test
+  void testAmbiguousInnerStaticClassesNewifyWithNamePatternFails() {
+    final String script = """
+          import groovy.transform.CompileStatic
+          import groovy.lang.Newify
+          import groovy.transform.ASTTest
+          import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+  
+          @Newify(pattern=/[A-Z].*/)
+          class Foo {
+            static class Foo {
+              static class Foo { }
+            }
+            List createClassList() {
+              final l = [ new Foo(), new Foo.Foo.Foo(), Foo() ]
+              [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+            }
+          }
+          
+          final Foo foo = new Foo()
+          foo.createClassList()
+      """
+
+    println "script=|$script|"
+
+    final String result = shouldNotCompile(script)
+    assert result ==~ '(?s).*Inner class name lookup is ambiguous between the following classes: Foo, Foo\\$Foo, Foo\\$Foo\\$Foo\\..*'
+  }
+
+
+  @Test
+  void testImportedClassesNewifyWithNamePattern() {
+    final String script = """
+        import groovy.transform.Canonical
+        import groovy.transform.CompileStatic
+        import groovy.lang.Newify
+        import groovy.transform.ASTTest
+        import java.lang.StringBuilder
+        import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+
+        @Canonical class A { String a }            
+        @Canonical class AB { String a; String b }            
+        @Canonical class ABC { String a; String b; String c }            
+         
+        @Newify(pattern=/[A-Z][A-Za-z0-9_]*/)
+        @CompileStatic
+        def createClassList() {
+          final l = [ A('2018-04-08'), StringBuilder('*lol*'), AB("I am", "class AB"), ABC("A","B","C") ]
+          [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+        }
+        
+        createClassList()
+      """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    assert resultList[0] == ['A', 'java.lang.StringBuilder', 'AB', 'ABC']
+    assert resultList[1] == ['A(2018-04-08)', '*lol*', 'AB(I am, class AB)', 'ABC(A, B, C)']
+  }
+
+
+  @Test
+  void testAlwaysExistingClassesNewifyWithNamePattern() {
+    final String script = """
+              import groovy.transform.Canonical
+              import groovy.transform.CompileStatic
+              import groovy.lang.Newify
+              import groovy.transform.ASTTest
+              import java.lang.StringBuilder
+              import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+  
+              @Canonical class A { String a }            
+              @Canonical class AB { String a; String b }            
+              @Canonical class ABC { String a; String b; String c }            
+               
+              @Newify(pattern=/[A-Z][A-Za-z0-9_]*/)
+              @CompileStatic
+              def createClassList() {
+                final l = [ A('2018-04-08'), StringBuilder('*lol*'), AB("I am", "class AB"), ABC("A","B","C"), Object() ]
+                [ l.collect { it.getClass().getName() }, l.collect { it.toString().replaceAll(/@[a-f0-9]+\\b/,'') } ]
+              }
+              
+              createClassList()
+          """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    assert resultList[0] == ['A', 'java.lang.StringBuilder', 'AB', 'ABC', 'java.lang.Object']
+    assert resultList[1] == ['A(2018-04-08)', '*lol*', 'AB(I am, class AB)', 'ABC(A, B, C)', 'java.lang.Object']
+  }
+
+
+  @Test
+  void testNewifyWithNamePatternMixed() {
+    final String script = """
+              import groovy.transform.Canonical
+              import groovy.transform.CompileStatic
+              import groovy.lang.Newify
+              import groovy.transform.ASTTest
+              import java.lang.StringBuilder
+              import groovy.lang.Binding
+              import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+  
+              @Canonical class A { String a }            
+              @Canonical class AB { String a; String b }            
+              @Canonical class ABC { String a; String b; String c }            
+               
+              @Newify(pattern=/[A-Z][A-Za-z0-9_]*/)
+              @CompileStatic
+              def createClassList() {
+                final l = [ 
+                  A('2018-04-08'), StringBuilder('*lol*'), AB("I am", "class AB"), ABC("A","B","C"), Object(),
+                  Reference(), Binding(), Double(123.456d), Integer(987), BigInteger('987654321',10),
+                  BigDecimal('1234.5678')
+                ]
+                [ l.collect { it.getClass().getName() }, l.collect { it.toString().replaceAll(/@[a-f0-9]+\\b/,'') } ]
+              }
+              
+              createClassList()
+          """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    assert resultList[0] == [
+        'A', 'java.lang.StringBuilder', 'AB', 'ABC', 'java.lang.Object',
+        'groovy.lang.Reference', 'groovy.lang.Binding', 'java.lang.Double', 'java.lang.Integer', 'java.math.BigInteger',
+        'java.math.BigDecimal'
+    ]
+    assert resultList[1] == [
+        'A(2018-04-08)', '*lol*', 'AB(I am, class AB)', 'ABC(A, B, C)', 'java.lang.Object',
+        'groovy.lang.Reference', 'groovy.lang.Binding', '123.456', '987', '987654321',
+        '1234.5678'
+    ]
+  }
+
+
+  @Test
+  void testAliasImportedClassesNewifyWithNamePattern() {
+    final String script = """
+        import groovy.lang.Newify
+        import groovy.transform.ASTTest
+        import java.lang.StringBuilder as WobblyOneDimensionalObjectBuilda
+        import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+
+        @Newify(pattern=/[A-Z][A-Za-z0-9_]*/)
+        def createClassList() {
+          final l = [ WobblyOneDimensionalObjectBuilda('Discrete Reality') ]
+          [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+        }
+        
+        createClassList()
+      """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    assert resultList[0] == ['java.lang.StringBuilder']
+    assert resultList[1] == ['Discrete Reality']
+  }
+
+
+  @Test
+  void testAliasShadowededImportedClassesNewifyWithNamePatternFails() {
+    final String script = """   
+        import groovy.transform.CompileStatic
+        import groovy.lang.Newify
+        import groovy.transform.ASTTest
+        import java.lang.StringBuilder as WobblyOneDimensionalObjectBuilda
+        import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+
+        @CompileStatic
+        @Newify(pattern=/[A-Z][A-Za-z0-9_]*/)
+        def createClassList() {
+          final l = [ WobblyOneDimensionalObjectBuilda('Discrete Reality'), StringBuilder('Quantum Loops') ]
+          [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+        }
+        
+        createClassList()
+      """
+
+    println "script=|$script|"
+
+    final String result = shouldNotCompile(script)
+    assert result ==~ /(?s).*\[Static type checking] - Cannot find matching method TestScript[A-Za-z0-9]*#StringBuilder\(java\.lang\.String\).*/
+  }
+
+
+  @Test
+  void testInvalidNamePatternNewifyWithNamePatternFails() {
+    final String script = """   
+        import groovy.transform.CompileStatic
+        import groovy.lang.Newify
+        import groovy.transform.ASTTest
+        import java.lang.StringBuilder as WobblyOneDimensionalObjectBuilda
+        import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+
+        @CompileStatic
+        @Newify(pattern=/[A-/)
+        def createClassList() {
+          final l = [ WobblyOneDimensionalObjectBuilda('Discrete Reality'), StringBuilder('Quantum Loops') ]
+          [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+        }
+        
+        createClassList()
+      """
+
+    println "script=|$script|"
+
+    final String result = shouldNotCompile(script)
+    assert result ==~ /(?s).*Invalid class name pattern: Illegal character range near index 3.*/
+  }
+
+
+  @Test
+  void testStaticallyAndDynamicallyCompiledMixedClassesNewifyWithNamePattern() {
+    final List<Boolean> compileStaticFlags = [true]
+    assertMixedClassesNewifyWithNamePatternResult("@Newify(pattern=/[A-Z].*/)", compileStaticFlags,
+        ['Foo.A', 'Foo.AB', 'Foo.ABC'], ['Foo$A(2018-04-08)', 'Foo$AB(I am, class AB)', 'Foo$ABC(A, B, C)']
+    )
+  }
+
+  @Test
+  void testStaticallyCompiledMixedClassesNoNewify() {
+    assertMixedClassesNewifyWithNamePatternFails("", [true], standardCompileStaticErrorMsg)
+  }
+
+  @Test
+  void testStaticallyCompiledMixedClassesNewifyWithNamePattern() {
+    assertMixedClassesNewifyWithNamePatternFails("@Newify(pattern=/XXX/)", [true], standardCompileStaticErrorMsg)
+  }
+
+  @Test
+  void testDynmaicallyCompiledMixedClassesNoNewify() {
+    assertMixedClassesNewifyWithNamePatternFails("", [false], standardCompileDynamiccErrorMsg)
+  }
+
+  @Test
+  void testDynmaicallyCompiledMixedClassesNewifyWithNamePattern() {
+    assertMixedClassesNewifyWithNamePatternFails("@Newify(pattern=/XXX/)", [false], standardCompileDynamiccErrorMsg)
+  }
+
+
+  @Test
+  void testExtractName() {
+    ['', 'A', 'Bc', 'DEF'].each { String s ->
+      assertExtractName(s, s)
+      assertExtractName("\$$s", s)
+      assertExtractName("A\$$s", s)
+      assertExtractName("Foo\$$s", s)
+      assertExtractName("Foo\$Foo\$$s", s)
+      assertExtractName("A\$AB\$ABC\$$s", s)
+    }
+  }
+
+
+  String getStandardCompileDynamiccErrorMsg() {
+    "No signature of method: Foo.A() is applicable for argument types: (String) values: [2018-04-08]"
+  }
+
+  String getStandardCompileStaticErrorMsg() {
+    "[Static type checking] - Cannot find matching method Foo#A(java.lang.String)."
+  }
+
+  void assertMixedClassesNewifyWithNamePatternFails(
+      final String newifyAnnotation, final List<Boolean> compileStaticFlags, final String errorMsgStartsWith) {
+    try {
+      mixedClassesNewifyWithNamePattern(newifyAnnotation, compileStaticFlags)
+    }
+    catch(Exception e) {
+      assert e.message.contains(errorMsgStartsWith)
+    }
+  }
+
+  void assertMixedClassesNewifyWithNamePatternResult(
+      final String newifyAnnotation,
+      final List<Boolean> compileStaticFlags, final List<String> classNameList, final List<String> resultList) {
+    final List list = mixedClassesNewifyWithNamePattern(newifyAnnotation, compileStaticFlags)
+    assert list[0] == classNameList
+    assert list[1] == resultList
+  }
+
+  List mixedClassesNewifyWithNamePattern(final String newifyAnnotation, final List<Boolean> compileStaticFlags) {
+
+    int iCompileStaticOrDynamic = 0
+    final Closure<String> compileStaticOrDynamicCls = {
+      compileStaticFlags[iCompileStaticOrDynamic++] ? "@CompileStatic" : "@CompileDynamic"
+    }
+
+    final String script = """
+            import groovy.transform.Canonical
+            import groovy.transform.CompileStatic
+            import groovy.transform.CompileDynamic
+            import groovy.lang.Newify
+            import java.lang.StringBuilder
+            import groovy.lang.Binding
+            import groovy.transform.ASTTest
+            import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+    
+            $newifyAnnotation
+            ${compileStaticOrDynamicCls()}
+            class Foo {
+              @Canonical static class A { String a }            
+              @Canonical static class AB { String a; String b }            
+              @Canonical static class ABC { String a; String b; String c }            
+               
+              List createClassList() {
+                final l = [ A('2018-04-08'), AB("I am", "class AB"), ABC("A","B","C") ]
+                [ l.collect { it.getClass().getCanonicalName() }, l.collect { it.toString() } ]
+              }
+            }
+            
+            final Foo foo = new Foo()
+            foo.createClassList()
+        """
+
+    println "script=|$script|"
+    final List resultList = (List) evalScript(script)
+    println "result=$resultList"
+
+    return resultList
+  }
+
+
+  void assertExtractName(final String s, final String expected) {
+    final String result = NewifyASTTransformation.extractName(s)
+    println "|$s| -> |$result|"
+    assert result == expected
+  }
+
+
+  String classCode(final List<String> lines) { code(lines, 1) }
+
+  String scriptCode(final List<String> lines) { code(lines, 0) }
+
+  String code(final List<String> lines, final int indent = 0) {
+    lines.collect { "${'\t' * indent}${it};" }.join('\n')
+  }
+
+  String newifyTestScript(
+      final boolean hasAnnotation,
+      final Map<String, Object> annotationParameters,
+      final String classPart, final String scriptPart = '') {
+    assert !hasAnnotation || (annotationParameters != null); assert classPart
+    final String annotationParametersTerm = annotationParameters ? "(${annotationParameters.collect { final Entry<String, Object> e -> "$e.key=$e.value" }.join(', ')})" : ''
+    final String script = """
+            import groovy.transform.Canonical
+            import groovy.transform.CompileStatic
+            import groovy.lang.Newify
+            import groovy.transform.ASTTest
+            import static org.codehaus.groovy.control.CompilePhase.SEMANTIC_ANALYSIS
+
+            @Canonical class A { String a }            
+            @Canonical class AB { String a; String b }            
+            @Canonical class ABC { String a; String b; String c }            
+
+            @CompileStatic
+            ${hasAnnotation ? "@Newify${annotationParametersTerm}" : ''}
+            class $newifyTestClassName {
+                $classPart
+            } 
+
+            $scriptPart
+        """
+    return script
+  }
+
+  String getNewifyTestClassName() {
+    'NewifyFoo'
+  }
+
+
+  static def evalScript(final String script) throws Exception {
+    GroovyShell shell = new GroovyShell();
+    shell.evaluate(script);
+  }
+
+
+  static Throwable compileShouldThrow(final String script, final String testClassName) {
+    try {
+      final GroovyClassLoader gcl = new GroovyClassLoader()
+      gcl.parseClass(script, testClassName)
+    }
+    catch(Throwable throwable) {
+      return throwable
+    }
+    throw new Exception("Script was expected to throw here!")
+  }
+
+}

Commit:
b5ff40d8717d3a48cbf0f177bef4982520484166
danielsun1106
realbluesun@hotmail.com
2018-04-22 01:18:00 +0800
Revert "Bump gradle to 4.7"
diff --git a/gradle.properties b/gradle.properties
index 5a105f4516..2fff8ce341 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -17,7 +17,7 @@ groovyVersion = 3.0.0-SNAPSHOT
 # bundle version format: major('.'minor('.'micro('.'qualifier)?)?)? (first 3 only digits)
 groovyBundleVersion = 3.0.0.SNAPSHOT
 
-gradle_version=4.7
+gradle_version=4.6
 
 groovyJUnit_ms=512m
 groovyJUnit_mx=1g
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index f6b961fd5a..c44b679acd 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 16d28051c9..ea720f986f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.7-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-bin.zip

Commit:
906d96ab83a38aa26a98a6f9d057d888b1859e22
Paul King
paulk@asert.com.au
2018-04-20 00:58:57 +1000
GROOVY-8472: Final variable analysis doesn't account for early exit for try/catch/finally
diff --git a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
index 34c652a200..84c95465c3 100644
--- a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
+++ b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
@@ -21,6 +21,7 @@ package org.codehaus.groovy.classgen;
 import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.Variable;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.expr.DeclarationExpression;
@@ -34,17 +35,21 @@ import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.CatchStatement;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.IfStatement;
+import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.ast.stmt.TryCatchStatement;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 
 import java.lang.reflect.Modifier;
+import java.util.ArrayList;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
@@ -54,12 +59,14 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
     private final VariableNotFinalCallback callback;
 
     private Set<Variable> declaredFinalVariables = null;
-    private boolean inAssignment = false;
+    private boolean inAssignmentRHS = false;
+    private boolean inArgumentList = false;
 
     private enum VariableState {
         is_uninitialized(false),
         is_final(true),
-        is_var(false);
+        is_var(false),
+        is_ambiguous(false); // any further use of that variable can trigger uninitialized ot not final errors
 
         private final boolean isFinal;
 
@@ -136,6 +143,14 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
         declaredFinalVariables = old;
     }
 
+    @Override
+    public void visitArgumentlistExpression(ArgumentListExpression ale) {
+        boolean old = inArgumentList;
+        inArgumentList = true;
+        super.visitArgumentlistExpression(ale);
+        inArgumentList = old;
+    }
+
     @Override
     public void visitBinaryExpression(final BinaryExpression expression) {
         boolean assignment = StaticTypeCheckingSupport.isAssignment(expression.getOperation().getType());
@@ -146,9 +161,9 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
             recordFinalVars(leftExpression);
         }
         // visit RHS first for expressions like a = b = 0
-        inAssignment = assignment;
+        inAssignmentRHS = assignment;
         rightExpression.visit(this);
-        inAssignment = false;
+        inAssignmentRHS = false;
         leftExpression.visit(this);
         if (assignment) {
             recordAssignments(expression, isDeclaration, leftExpression, rightExpression);
@@ -188,13 +203,13 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
 
     @Override
     public void visitClosureExpression(final ClosureExpression expression) {
-        boolean old = inAssignment;
-        inAssignment = false;
+        boolean old = inAssignmentRHS;
+        inAssignmentRHS = false;
         Map<Variable, VariableState> origState = new StateMap();
         origState.putAll(getState());
         super.visitClosureExpression(expression);
         cleanLocalVars(origState, getState());
-        inAssignment = old;
+        inAssignmentRHS = old;
     }
 
     private void cleanLocalVars(Map<Variable, VariableState> origState, Map<Variable, VariableState> state) {
@@ -211,17 +226,17 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
 
     @Override
     public void visitPrefixExpression(final PrefixExpression expression) {
-        inAssignment = expression.getExpression() instanceof VariableExpression;
+        inAssignmentRHS = expression.getExpression() instanceof VariableExpression;
         super.visitPrefixExpression(expression);
-        inAssignment = false;
+        inAssignmentRHS = false;
         checkPrePostfixOperation(expression.getExpression(), expression);
     }
 
     @Override
     public void visitPostfixExpression(final PostfixExpression expression) {
-        inAssignment = expression.getExpression() instanceof VariableExpression;
+        inAssignmentRHS = expression.getExpression() instanceof VariableExpression;
         super.visitPostfixExpression(expression);
-        inAssignment = false;
+        inAssignmentRHS = false;
         checkPrePostfixOperation(expression.getExpression(), expression);
     }
 
@@ -248,7 +263,7 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
         }
         if (key != null && !key.isClosureSharedVariable() && callback != null) {
             VariableState variableState = state.get(key);
-            if (inAssignment && variableState == VariableState.is_uninitialized) {
+            if ((inAssignmentRHS || inArgumentList) && (variableState == VariableState.is_uninitialized || variableState == VariableState.is_ambiguous)) {
                 callback.variableNotAlwaysInitialized(expression);
             }
         }
@@ -263,13 +278,7 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
         popState();
         Statement elseBlock = ifElse.getElseBlock();
         Map<Variable, VariableState> elseState = pushState();
-        if (elseBlock instanceof EmptyStatement) {
-            // dispatching to EmptyStatement will not call back visitor,
-            // must call our visitEmptyStatement explicitly
-            visitEmptyStatement((EmptyStatement) elseBlock);
-        } else {
-            elseBlock.visit(this);
-        }
+        visitPossiblyEmptyStatement(elseBlock);
         popState();
 
         // merge if/else branches
@@ -284,44 +293,113 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
             VariableState elseValue = elseState.get(var);
             // merge if and else values
             VariableState mergedIfElse;
-            mergedIfElse = ifValue != null && ifValue.isFinal
-                    && elseValue != null && elseValue.isFinal ? VariableState.is_final : VariableState.is_var;
+            mergedIfElse = isFinal(ifValue) && isFinal(elseValue) ? VariableState.is_final : VariableState.is_var;
             if (beforeValue != null) {
                 curState.put(var, mergedIfElse);
             }
         }
     }
 
+    private void visitPossiblyEmptyStatement(Statement block) {
+        if (block instanceof EmptyStatement) {
+            // dispatching to EmptyStatement will not call back visitor,
+            // must call our visitEmptyStatement explicitly
+            visitEmptyStatement((EmptyStatement) block);
+        } else {
+            block.visit(this);
+        }
+    }
+
+    private boolean isFinal(VariableState value) {
+        return value != null && value.isFinal;
+    }
+
     @Override
     public void visitTryCatchFinally(final TryCatchStatement statement) {
         visitStatement(statement);
-        Map<Variable, VariableState> beforeTryCatch = new HashMap<Variable, VariableState>(getState());
-        statement.getTryStatement().visit(this);
+        Map<Variable, VariableState> beforeTryState = new HashMap<Variable, VariableState>(getState());
+        pushState();
+        Statement tryStatement = statement.getTryStatement();
+        tryStatement.visit(this);
+        Map<Variable, VariableState> afterTryState = new HashMap<Variable, VariableState>(getState());
+        Statement finallyStatement = statement.getFinallyStatement();
+        List<Map<Variable, VariableState>> afterStates = new ArrayList<>();
+        // the try finally case
+        visitPossiblyEmptyStatement(finallyStatement);
+        if (!returningBlock(tryStatement)) {
+            afterStates.add(new HashMap<Variable, VariableState>(getState()));
+        }
+        popState();
+        // now the finally only case but only if no catches
+        if (statement.getCatchStatements().isEmpty()) {
+            visitPossiblyEmptyStatement(finallyStatement);
+            if (!returningBlock(tryStatement)) {
+                afterStates.add(new HashMap<Variable, VariableState>(getState()));
+            }
+        }
         for (CatchStatement catchStatement : statement.getCatchStatements()) {
-            catchStatement.visit(this);
+            // We don't try to analyse which statement within the try block might have thrown an exception.
+            // We make a crude assumption that anywhere from none to all of the statements might have been executed.
+            // Run visitor for both scenarios so the eager checks will be performed for either of these cases.
+            visitCatchFinally(beforeTryState, afterStates, catchStatement, finallyStatement);
+            visitCatchFinally(afterTryState, afterStates, catchStatement, finallyStatement);
         }
-        Statement finallyStatement = statement.getFinallyStatement();
-        // we need to recall which final variables are unassigned so cloning the current state
-        Map<Variable, VariableState> afterTryCatchState = new HashMap<Variable, VariableState>(getState());
-        if (finallyStatement instanceof EmptyStatement) {
-            // dispatching to EmptyStatement will not call back visitor,
-            // must call our visitEmptyStatement explicitly
-            visitEmptyStatement((EmptyStatement) finallyStatement);
-        } else {
-            finallyStatement.visit(this);
-        }
-        // and now we must reset to uninitialized state variables which were only initialized during try/catch
-        Map<Variable, VariableState> afterFinally = new HashMap<Variable, VariableState>(getState());
-        for (Map.Entry<Variable, VariableState> entry : afterFinally.entrySet()) {
-            Variable var = entry.getKey();
-            VariableState afterFinallyState = entry.getValue();
-            VariableState beforeTryCatchState = beforeTryCatch.get(var);
-            if (afterFinallyState == VariableState.is_final
-                    && beforeTryCatchState != VariableState.is_final
-                    && afterTryCatchState.get(var) != beforeTryCatchState) {
-                getState().put(var, beforeTryCatchState == null ? VariableState.is_uninitialized : beforeTryCatchState);
+        // after states can only be empty if try and catch statements all return in which case nothing to do
+        if (afterStates.isEmpty()) return;
+        // now adjust the state variables - any early returns won't have gotten here
+        // but we need to check that the same status was observed by all paths
+        // and mark as ambiguous if needed
+        Map<Variable, VariableState> corrected = afterStates.remove(0);
+        for (Map<Variable, VariableState> nextState : afterStates) {
+            for (Map.Entry<Variable, VariableState> entry : corrected.entrySet()) {
+                Variable var = entry.getKey();
+                VariableState currentCorrectedState = entry.getValue();
+                VariableState candidateCorrectedState = nextState.get(var);
+                if (currentCorrectedState == VariableState.is_ambiguous) continue;
+                if (currentCorrectedState != candidateCorrectedState) {
+                    if (currentCorrectedState == VariableState.is_uninitialized || candidateCorrectedState == VariableState.is_uninitialized) {
+                        corrected.put(var, VariableState.is_ambiguous);
+                    } else {
+                        corrected.put(var, VariableState.is_var);
+                    }
+                }
             }
         }
+        getState().putAll(corrected);
+    }
+
+    private void visitCatchFinally(Map<Variable, VariableState> initialVarState, List<Map<Variable, VariableState>> afterTryCatchStates, CatchStatement catchStatement, Statement finallyStatement) {
+        pushState();
+//        getState().clear();
+        getState().putAll(initialVarState);
+        Statement code = catchStatement.getCode();
+        catchStatement.visit(this);
+        visitPossiblyEmptyStatement(finallyStatement);
+        if (code == null || !returningBlock(code)) {
+            afterTryCatchStates.add(new HashMap<Variable, VariableState>(getState()));
+        }
+        popState();
+    }
+
+    /**
+     * @return true if the block's last statement is a return
+     */
+    private boolean returningBlock(Statement block) {
+        if (block instanceof ReturnStatement) {
+            return true;
+        }
+        if (!(block instanceof BlockStatement)) {
+            return false;
+        }
+        BlockStatement bs = (BlockStatement) block;
+        if (bs.getStatements().size() == 0) {
+            return false;
+        }
+        Statement last = DefaultGroovyMethods.last(bs.getStatements());
+        if (last instanceof ReturnStatement) {
+            return true;
+        }
+        return false;
     }
 
     private void recordAssignment(
@@ -357,7 +435,7 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
             variableState = VariableState.is_var;
         }
         getState().put(var, variableState);
-        if (variableState == VariableState.is_var && callback != null) {
+        if ((variableState == VariableState.is_var || variableState == VariableState.is_ambiguous) && callback != null) {
             callback.variableNotFinal(var, expression);
         }
     }
diff --git a/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy b/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy
index b211ee472a..3f79f470ab 100644
--- a/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy
@@ -460,6 +460,49 @@ class FinalVariableAnalyzerTest extends GroovyTestCase {
         '''
     }
 
+    // GROOVY-8472
+    void testTryCatchWithReturnInTry() {
+        assertScript '''
+            def method(String foo) {
+                final str
+                try {
+                    return foo.trim()
+                }
+                catch(e) {
+                    str = '-1'
+                }
+                int exitCode = str.toInteger()
+                exitCode
+            }
+
+            assert method(null) == -1
+            assert method('  foo  ') == 'foo'
+        '''
+    }
+
+    // GROOVY-8472
+    void testTryCatchWithReturnInCatch() {
+        assertScript '''
+            def method(String foo) {
+                final str
+                try {
+                    str = foo.trim()
+                }
+                catch(RuntimeException re) {
+                    return re.message
+                }
+                catch(Throwable t) {
+                    return -1
+                }
+                int exitCode = str.isInteger() ? str.toInteger() : null
+                exitCode
+            }
+
+            assert method(null) == 'Cannot invoke method trim() on null object'
+            assert method('  42  ') == 42
+        '''
+    }
+
     @CompileStatic
     private static class AssertionFinalVariableAnalyzer extends FinalVariableAnalyzer {
 

Commit:
460a3e93a066a564e7f5c6076a43290f251923dd
sunlan
sunlan@apache.org
2018-04-19 16:14:59 +0800
Trivial refactoring: Unnecessary 'Arrays.asList' call
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovydoc.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovydoc.java
index d154aeb089..07de20205d 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovydoc.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovydoc.java
@@ -402,7 +402,7 @@ public class Groovydoc extends Task {
                     }
                 });
 
-                for (String filename : Arrays.asList(files)) {
+                for (String filename : files) {
                     sourceFilesToDoc.add(dir + File.separator + filename);
                 }
 

Commit:
065a1ed2d03c812578ed52c7d56f681724d63553
sunlan
sunlan@apache.org
2018-04-19 16:13:38 +0800
Trivial refactoring: 'StringBuilder' can be replaced with 'String'
diff --git a/src/main/groovy/groovy/lang/MetaMethod.java b/src/main/groovy/groovy/lang/MetaMethod.java
index 10815ed7a7..fcc001d186 100644
--- a/src/main/groovy/groovy/lang/MetaMethod.java
+++ b/src/main/groovy/groovy/lang/MetaMethod.java
@@ -281,9 +281,9 @@ public abstract class MetaMethod extends ParameterTypes implements Cloneable {
           String name = getName();
           CachedClass declaringClass = getDeclaringClass();
           if (Modifier.isPrivate(getModifiers()))
-            mopName = new StringBuilder("this$").append(declaringClass.getSuperClassDistance()).append("$").append(name).toString();
+            mopName = "this$" + declaringClass.getSuperClassDistance() + "$" + name;
           else 
-            mopName = new StringBuilder("super$").append(declaringClass.getSuperClassDistance()).append("$").append(name).toString();
+            mopName = "super$" + declaringClass.getSuperClassDistance() + "$" + name;
         }
         return mopName;
     }
diff --git a/src/main/groovy/groovy/util/ObjectGraphBuilder.java b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
index ce031c71e9..6dc166081b 100644
--- a/src/main/groovy/groovy/util/ObjectGraphBuilder.java
+++ b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
@@ -850,10 +850,10 @@ public class ObjectGraphBuilder extends FactoryBuilderSupport {
         }
 
         public String toString() {
-            return new StringBuilder().append("[parentName=").append(parentName)
-                    .append(", childName=").append(childName)
-                    .append(", refId=").append(refId)
-                    .append("]").toString();
+            return "[parentName=" + parentName +
+                    ", childName=" + childName +
+                    ", refId=" + refId +
+                    "]";
         }
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/indy/InvokeDynamicWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/indy/InvokeDynamicWriter.java
index 4e677d906e..1e53ec115c 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/indy/InvokeDynamicWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/indy/InvokeDynamicWriter.java
@@ -214,15 +214,14 @@ public class InvokeDynamicWriter extends InvocationWriter {
     }
 
     private void writeIndyCast(ClassNode sourceType, ClassNode targetType) {
-        StringBuilder sig = new StringBuilder();
-        sig.append('(');
-        sig.append(getTypeDescription(sourceType));
-        sig.append(')');
-        sig.append(getTypeDescription(targetType));
 
+        String sig = "(" +
+                getTypeDescription(sourceType) +
+                ')' +
+                getTypeDescription(targetType);
         controller.getMethodVisitor().visitInvokeDynamicInsn(
                 //TODO: maybe use a different bootstrap method since no arguments are needed here
-                CAST.getCallSiteName(), sig.toString(), BSM, "()", 0);
+                CAST.getCallSiteName(), sig, BSM, "()", 0);
         controller.getOperandStack().replace(targetType);
     }
 
diff --git a/src/main/java/org/codehaus/groovy/reflection/ReflectionCache.java b/src/main/java/org/codehaus/groovy/reflection/ReflectionCache.java
index efedc956f8..1ae2f27181 100644
--- a/src/main/java/org/codehaus/groovy/reflection/ReflectionCache.java
+++ b/src/main/java/org/codehaus/groovy/reflection/ReflectionCache.java
@@ -31,7 +31,7 @@ public class ReflectionCache {
     public static String getMOPMethodName(CachedClass declaringClass, String name, boolean useThis) {
         TripleKeyHashMap.Entry mopNameEntry = mopNames.getOrPut(declaringClass, name, Boolean.valueOf(useThis));
         if (mopNameEntry.value == null) {
-            mopNameEntry.value = new StringBuilder().append(useThis ? "this$" : "super$").append(declaringClass.getSuperClassDistance()).append("$").append(name).toString();
+            mopNameEntry.value = (useThis ? "this$" : "super$") + declaringClass.getSuperClassDistance() + "$" + name;
         }
         return (String) mopNameEntry.value;
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModule.java b/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModule.java
index 3d14aa49d4..0c30a3b385 100644
--- a/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModule.java
+++ b/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModule.java
@@ -52,10 +52,9 @@ public abstract class ExtensionModule {
 
     @Override
     public String toString() {
-        final StringBuilder sb = new StringBuilder("ExtensionModule{");
-        sb.append("name='").append(name).append('\'');
-        sb.append(", version='").append(version).append('\'');
-        sb.append('}');
-        return sb.toString();
+        String sb = "ExtensionModule{" + "name='" + name + '\'' +
+                ", version='" + version + '\'' +
+                '}';
+        return sb;
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index 56f6fbc66e..0add1d3516 100644
--- a/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -953,11 +953,9 @@ public class JavaStubGenerator {
         }
 
         for (String imp : imports) {
-            String s = new StringBuilder()
-                    .append("import ")
-                    .append(imp)
-                    .append((imp.charAt(imp.length() - 1) == '.') ? "*;" : ";")
-                    .toString()
+            String s = ("import " +
+                    imp +
+                    ((imp.charAt(imp.length() - 1) == '.') ? "*;" : ";"))
                     .replace('$', '.');
             out.println(s);
         }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java b/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java
index 49b09d63d5..ad934eed5c 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java
@@ -49,11 +49,10 @@ public class Receiver<T> {
 
     @Override
     public String toString() {
-        final StringBuilder sb = new StringBuilder();
-        sb.append("Receiver");
-        sb.append("{type=").append(type);
-        sb.append(", data=").append(data);
-        sb.append('}');
-        return sb.toString();
+        String sb = "Receiver" +
+                "{type=" + type +
+                ", data=" + data +
+                '}';
+        return sb;
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java b/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
index 4d0b0973e2..057403fbce 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
@@ -372,12 +372,11 @@ public class TypeCheckingContext {
 
         @Override
         public String toString() {
-            final StringBuilder sb = new StringBuilder();
-            sb.append("EnclosingClosure");
-            sb.append("{closureExpression=").append(closureExpression.getText());
-            sb.append(", returnTypes=").append(returnTypes);
-            sb.append('}');
-            return sb.toString();
+            String sb = "EnclosingClosure" +
+                    "{closureExpression=" + closureExpression.getText() +
+                    ", returnTypes=" + returnTypes +
+                    '}';
+            return sb;
         }
     }
 }
\ No newline at end of file
diff --git a/subprojects/groovy-servlet/src/main/java/groovy/servlet/TemplateServlet.java b/subprojects/groovy-servlet/src/main/java/groovy/servlet/TemplateServlet.java
index 3f640de4e1..d64378e7bf 100644
--- a/subprojects/groovy-servlet/src/main/java/groovy/servlet/TemplateServlet.java
+++ b/subprojects/groovy-servlet/src/main/java/groovy/servlet/TemplateServlet.java
@@ -483,13 +483,12 @@ public class TemplateServlet extends AbstractHttpServlet {
         makeMillis = System.currentTimeMillis() - makeMillis;
 
         if (generateBy) {
-            StringBuilder sb = new StringBuilder(100);
-            sb.append("\n<!-- Generated by Groovy TemplateServlet [create/get=");
-            sb.append(Long.toString(getMillis));
-            sb.append(" ms, make=");
-            sb.append(Long.toString(makeMillis));
-            sb.append(" ms] -->\n");
-            out.write(sb.toString());
+            String sb = "\n<!-- Generated by Groovy TemplateServlet [create/get=" +
+                    Long.toString(getMillis) +
+                    " ms, make=" +
+                    Long.toString(makeMillis) +
+                    " ms] -->\n";
+            out.write(sb);
         }
 
         //

Commit:
d19ccbabb0b32fcebd72606731b14cdf913e63fd
sunlan
sunlan@apache.org
2018-04-19 16:12:00 +0800
Trivial refactoring: Avoid string concatenation as argument to 'StringBuilder.append()' call
diff --git a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
index bfb70f7de9..476337b6ef 100644
--- a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -435,11 +435,11 @@ public class AsmClassGenerator extends ClassGenerator {
                     tracer.p.print(p);
                     p.flush();
                 }
-                StringBuilder outBuffer = new StringBuilder();
+                StringBuilder outBuffer = new StringBuilder(64);
                 outBuffer.append("ASM reporting processing error for ");
-                outBuffer.append(controller.getClassNode().toString() + "#" + node.getName());
-                outBuffer.append(" with signature " + node.getTypeDescriptor());
-                outBuffer.append(" in " + sourceFile + ":" + node.getLineNumber());
+                outBuffer.append(controller.getClassNode().toString()).append("#").append(node.getName());
+                outBuffer.append(" with signature ").append(node.getTypeDescriptor());
+                outBuffer.append(" in ").append(sourceFile).append(":").append(node.getLineNumber());
                 if (writer != null) {
                     outBuffer.append("\nLast known generated bytecode in last generated method or constructor:\n");
                     outBuffer.append(writer);

Commit:
20abd83126055a6210908fa6b6dc1c24c6c2b335
sunlan
sunlan@apache.org
2018-04-19 15:41:05 +0800
Trivial refactoring: remove redundant `contains` check
diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index ab8b6557ac..7be4264594 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -641,9 +641,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                     }
                 }
                 if (!skip) {
-                    if (!newGroovyMethodsSet.contains(method)) {
-                        newGroovyMethodsSet.add(method);
-                    }
+                    newGroovyMethodsSet.add(method);
                     addMetaMethodToIndex(method, mainClassMethodHeader);
                 }
             }

Commit:
923f788f81f0308458c6210121c5edd63073ba98
sunlan
sunlan@apache.org
2018-04-19 13:55:14 +0800
Minor refactoring: remove duplicated code of `Inspector`
diff --git a/src/main/groovy/groovy/inspect/Inspector.java b/src/main/groovy/groovy/inspect/Inspector.java
index b8ad561787..6fff2a129c 100644
--- a/src/main/groovy/groovy/inspect/Inspector.java
+++ b/src/main/groovy/groovy/inspect/Inspector.java
@@ -22,7 +22,6 @@ import groovy.lang.GroovyObject;
 import groovy.lang.MetaClass;
 import groovy.lang.MetaMethod;
 import groovy.lang.PropertyValue;
-import org.codehaus.groovy.reflection.CachedClass;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.InvokerHelper;
 
@@ -280,16 +279,7 @@ public class Inspector {
         result[MEMBER_DECLARER_IDX] = shortName(method.getDeclaringClass().getTheClass());
         result[MEMBER_TYPE_IDX] = shortName(method.getReturnType());
         result[MEMBER_NAME_IDX] = method.getName();
-        CachedClass[] params = method.getParameterTypes();
-
-        // TODO reuse `makeParamsInfo`
-        StringBuilder sb = new StringBuilder();
-        for (int j = 0; j < params.length; j++) {
-            sb.append(shortName(params[j].getTheClass()));
-            if (j < (params.length - 1)) sb.append(", ");
-        }
-
-        result[MEMBER_PARAMS_IDX] = sb.toString();
+        result[MEMBER_PARAMS_IDX] = makeParamsInfo(method.getNativeParameterTypes());
         result[MEMBER_EXCEPTIONS_IDX] = NOT_APPLICABLE; // no exception info for Groovy MetaMethods
         return withoutNulls(result);
     }

Commit:
cc6ff27d11e6431fb008909c250d125761b261a0
sunlan
sunlan@apache.org
2018-04-19 08:04:21 +0800
Exclude OpenJDK9 from travis CI build due to failing to download
diff --git a/.travis.yml b/.travis.yml
index 1fe0b3858c..e7a17d516e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -33,8 +33,8 @@ matrix:
       env: JDK_RELEASE='Oracle JDK 9' EXTRA_GRADLE_ARGS=''
       install: echo "Don't let Travis CI execute './gradlew assemble' by default"
 # Java 9 "OpenJDK"
-    - env: TRAVIS_JDK_VERSION='openjdk9' JDK_RELEASE='OpenJDK 9' EXTRA_GRADLE_ARGS=''
-      install: . ./src/install/install-jdk.sh -F 9 -L GPL
+#    - env: TRAVIS_JDK_VERSION='openjdk9' JDK_RELEASE='OpenJDK 9' EXTRA_GRADLE_ARGS=''
+#      install: . ./src/install/install-jdk.sh -F 9 -L GPL
 # Java 8 "Oracle JDK" (provided by Travis CI)
     - jdk: oraclejdk8
       env: JDK_RELEASE='Oracle JDK 8' EXTRA_GRADLE_ARGS=''

Commit:
2850721b23ffe8f4d985343d4ff70c2a69ca05d5
sunlan
sunlan@apache.org
2018-04-19 08:02:57 +0800
Bump gradle to 4.7
diff --git a/gradle.properties b/gradle.properties
index 2fff8ce341..5a105f4516 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -17,7 +17,7 @@ groovyVersion = 3.0.0-SNAPSHOT
 # bundle version format: major('.'minor('.'micro('.'qualifier)?)?)? (first 3 only digits)
 groovyBundleVersion = 3.0.0.SNAPSHOT
 
-gradle_version=4.6
+gradle_version=4.7
 
 groovyJUnit_ms=512m
 groovyJUnit_mx=1g
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index c44b679acd..f6b961fd5a 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ea720f986f..16d28051c9 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.7-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-bin.zip

Commit:
ca44609c4dfa33b17a974689fe7abcbc2dad8bcc
sunlan
sunlan@apache.org
2018-04-18 19:06:14 +0800
Minor refactoring: remove duplicated code of `Inspector`
diff --git a/src/main/groovy/groovy/inspect/Inspector.java b/src/main/groovy/groovy/inspect/Inspector.java
index f0c94a751e..b8ad561787 100644
--- a/src/main/groovy/groovy/inspect/Inspector.java
+++ b/src/main/groovy/groovy/inspect/Inspector.java
@@ -228,53 +228,47 @@ public class Inspector {
         return className;
     }
 
+    private static String makeTypesInfo(Class[] types) {
+        StringBuilder sb = new StringBuilder(32);
+        for (int k = 0; k < types.length; k++) {
+            sb.append(shortName(types[k]));
+            if (k < (types.length - 1)) sb.append(", ");
+        }
+
+        return sb.toString();
+    }
+
+    private static String makeParamsInfo(Class[] params) {
+        return makeTypesInfo(params);
+    }
+
+    private static String makeExceptionInfo(Class[] exceptions) {
+        return makeTypesInfo(exceptions);
+    }
+
     protected String[] methodInfo(Method method) {
         String[] result = new String[MEMBER_EXCEPTIONS_IDX + 1];
-        int mod = method.getModifiers();
         result[MEMBER_ORIGIN_IDX] = JAVA;
         result[MEMBER_DECLARER_IDX] = shortName(method.getDeclaringClass());
-        result[MEMBER_MODIFIER_IDX] = Modifier.toString(mod);
+        result[MEMBER_MODIFIER_IDX] = Modifier.toString(method.getModifiers());
         result[MEMBER_NAME_IDX] = method.getName();
         result[MEMBER_TYPE_IDX] = shortName(method.getReturnType());
-        Class[] params = method.getParameterTypes();
-        StringBuilder sb = new StringBuilder();
-        for (int j = 0; j < params.length; j++) {
-            sb.append(shortName(params[j]));
-            if (j < (params.length - 1)) sb.append(", ");
-        }
-        result[MEMBER_PARAMS_IDX] = sb.toString();
-        sb.setLength(0);
-        Class[] exceptions = method.getExceptionTypes();
-        for (int k = 0; k < exceptions.length; k++) {
-            sb.append(shortName(exceptions[k]));
-            if (k < (exceptions.length - 1)) sb.append(", ");
-        }
-        result[MEMBER_EXCEPTIONS_IDX] = sb.toString();
+        result[MEMBER_PARAMS_IDX] = makeParamsInfo(method.getParameterTypes());
+        result[MEMBER_EXCEPTIONS_IDX] = makeExceptionInfo(method.getExceptionTypes());
+
         return withoutNulls(result);
     }
 
     protected String[] methodInfo(Constructor ctor) {
         String[] result = new String[MEMBER_EXCEPTIONS_IDX + 1];
-        int mod = ctor.getModifiers();
         result[MEMBER_ORIGIN_IDX] = JAVA;
-        result[MEMBER_MODIFIER_IDX] = Modifier.toString(mod);
+        result[MEMBER_MODIFIER_IDX] = Modifier.toString(ctor.getModifiers());
         result[MEMBER_DECLARER_IDX] = shortName(ctor.getDeclaringClass());
         result[MEMBER_TYPE_IDX] = shortName(ctor.getDeclaringClass());
         result[MEMBER_NAME_IDX] = ctor.getName();
-        Class[] params = ctor.getParameterTypes();
-        StringBuilder sb = new StringBuilder();
-        for (int j = 0; j < params.length; j++) {
-            sb.append(shortName(params[j]));
-            if (j < (params.length - 1)) sb.append(", ");
-        }
-        result[MEMBER_PARAMS_IDX] = sb.toString();
-        sb.setLength(0);
-        Class[] exceptions = ctor.getExceptionTypes();
-        for (int k = 0; k < exceptions.length; k++) {
-            sb.append(shortName(exceptions[k]));
-            if (k < (exceptions.length - 1)) sb.append(", ");
-        }
-        result[MEMBER_EXCEPTIONS_IDX] = sb.toString();
+        result[MEMBER_PARAMS_IDX] = makeParamsInfo(ctor.getParameterTypes());
+        result[MEMBER_EXCEPTIONS_IDX] = makeExceptionInfo(ctor.getExceptionTypes());
+
         return withoutNulls(result);
     }
 
@@ -287,11 +281,14 @@ public class Inspector {
         result[MEMBER_TYPE_IDX] = shortName(method.getReturnType());
         result[MEMBER_NAME_IDX] = method.getName();
         CachedClass[] params = method.getParameterTypes();
+
+        // TODO reuse `makeParamsInfo`
         StringBuilder sb = new StringBuilder();
         for (int j = 0; j < params.length; j++) {
             sb.append(shortName(params[j].getTheClass()));
             if (j < (params.length - 1)) sb.append(", ");
         }
+
         result[MEMBER_PARAMS_IDX] = sb.toString();
         result[MEMBER_EXCEPTIONS_IDX] = NOT_APPLICABLE; // no exception info for Groovy MetaMethods
         return withoutNulls(result);

Commit:
264985f7f7ca75ba53511836d68ce7c1d99ca41a
Paul King
paulk@asert.com.au
2018-04-18 14:45:45 +1000
Add 'var' in the highlighted keyword for the Groovy Console (closes #685)
diff --git a/subprojects/groovy-console/src/main/groovy/groovy/ui/text/GroovyFilter.java b/subprojects/groovy-console/src/main/groovy/groovy/ui/text/GroovyFilter.java
index baa29e144b..11f799a1ab 100644
--- a/subprojects/groovy-console/src/main/groovy/groovy/ui/text/GroovyFilter.java
+++ b/subprojects/groovy-console/src/main/groovy/groovy/ui/text/GroovyFilter.java
@@ -121,6 +121,7 @@ public class GroovyFilter extends StructuredSyntaxDocumentFilter {
             "\\bgoto\\b",
             "\\bpackage\\b",
             "\\bdef\\b",
+            "\\bvar\\b",
             "\\bas\\b",
             "\\bin\\b",
             "\\bsynchronized\\b",

Commit:
4840d1fce2ccea5efaf30e30b8e569a833257023
sunlan
sunlan@apache.org
2018-04-17 11:20:02 +0800
Fix java.lang.ClassFormatError: Illegal method name "test IO stream/reader closed by the parser properly" when using Java9
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
index 1602fa79ec..fe74a08fb9 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
@@ -45,7 +45,8 @@ class GroovyParserTest extends GroovyTestCase {
         doTestAttachedComments()
     }
 
-    void "test IO stream/reader closed by the parser properly"() {
+    // java.lang.ClassFormatError: Illegal method name "test IO stream/reader closed by the parser properly" when using Java9
+    void "test IO reader closed by the parser properly"() {
         def f = File.createTempFile("Script${System.nanoTime()}", ".groovy")
         f.text = '''
             def a = 123
@@ -58,7 +59,8 @@ class GroovyParserTest extends GroovyTestCase {
         assert deleted: "Failed to delete file: ${f.getAbsolutePath()}"
     }
 
-    void "test IO stream/reader closed by the compiler properly"() {
+    // java.lang.ClassFormatError: Illegal method name "test IO stream/reader closed by the parser properly" when using Java9
+    void "test reader closed by the compiler properly"() {
         def f = File.createTempFile("Script${System.nanoTime()}", ".groovy")
         f.text = '''
             def a = 123

Commit:
e19a93242dcc204cd94e034242a348c113cc1130
sunlan
sunlan@apache.org
2018-04-17 10:22:09 +0800
GROOVY-8546: Parrot Parser: multiple Reader instances opened from SourceUnit; many left open
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/Antlr4ParserPlugin.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/Antlr4ParserPlugin.java
index 25131bfd1c..0f35f1daf6 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/Antlr4ParserPlugin.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/Antlr4ParserPlugin.java
@@ -30,6 +30,7 @@ import org.codehaus.groovy.syntax.ParserException;
 import org.codehaus.groovy.syntax.Reduction;
 
 import java.io.IOException;
+import java.io.Reader;
 
 /**
  * A parser plugin for the new parser
@@ -42,9 +43,10 @@ public class Antlr4ParserPlugin implements ParserPlugin {
 
     @Override
     public Reduction parseCST(SourceUnit sourceUnit, java.io.Reader reader) throws CompilationFailedException {
-        try {
-            ReaderSource readerSource = sourceUnit.getSource();
-            if (null != readerSource && null != readerSource.getReader()) {
+        ReaderSource readerSource = sourceUnit.getSource();
+
+        try (Reader sourceReader = null != readerSource ? readerSource.getReader() : null) {
+            if (null != readerSource && null != sourceReader) {
                 this.readerSource = readerSource;
             } else {
                 this.readerSource = new StringReaderSource(IOGroovyMethods.getText(reader), sourceUnit.getConfiguration());
@@ -58,9 +60,10 @@ public class Antlr4ParserPlugin implements ParserPlugin {
 
     @Override
     public ModuleNode buildAST(SourceUnit sourceUnit, ClassLoader classLoader, Reduction cst) throws ParserException {
-        try {
-            ReaderSource readerSource = sourceUnit.getSource();
-            if (null == readerSource || null == readerSource.getReader()) {
+        ReaderSource readerSource = sourceUnit.getSource();
+
+        try (Reader sourceReader = null != readerSource ? readerSource.getReader() : null) {
+            if (null == readerSource || null == sourceReader) {
                 sourceUnit.setSource(this.readerSource);
             }
         } catch (IOException e) {
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
index 8dae27e485..1602fa79ec 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
@@ -27,9 +27,9 @@ import org.codehaus.groovy.ast.stmt.AssertStatement
 import org.codehaus.groovy.ast.stmt.ExpressionStatement
 import org.codehaus.groovy.syntax.Token
 
-import static org.apache.groovy.parser.antlr4.TestUtils.doTest
-import static org.apache.groovy.parser.antlr4.TestUtils.doRunAndTestAntlr4
 import static org.apache.groovy.parser.antlr4.TestUtils.doRunAndTest
+import static org.apache.groovy.parser.antlr4.TestUtils.doRunAndTestAntlr4
+import static org.apache.groovy.parser.antlr4.TestUtils.doTest
 
 /**
  * Some basic test cases for the new parser
@@ -45,6 +45,31 @@ class GroovyParserTest extends GroovyTestCase {
         doTestAttachedComments()
     }
 
+    void "test IO stream/reader closed by the parser properly"() {
+        def f = File.createTempFile("Script${System.nanoTime()}", ".groovy")
+        f.text = '''
+            def a = 123
+        '''
+
+        def antlr4Parser = new org.apache.groovy.parser.Antlr4Parser()
+        antlr4Parser.parse(f)
+
+        boolean deleted = f.delete()
+        assert deleted: "Failed to delete file: ${f.getAbsolutePath()}"
+    }
+
+    void "test IO stream/reader closed by the compiler properly"() {
+        def f = File.createTempFile("Script${System.nanoTime()}", ".groovy")
+        f.text = '''
+            def a = 123
+        '''
+
+        TestUtils.createAntlr4Shell().evaluate(f)
+
+        boolean deleted = f.delete()
+        assert deleted: "Failed to delete file: ${f.getAbsolutePath()}"
+    }
+
     private static doTestAttachedComments() {
         def (newAST, oldAST) = doTest('core/Comments_02.groovy')
         List<ClassNode> classes = new ArrayList<>(newAST.classes).sort { c1, c2 -> c1.name <=> c2.name }

Commit:
c15b4c55d27c8c8cf949e03a0f81eab9aedc7a79
Paul King
paulk@asert.com.au
2018-04-16 21:42:46 +1000
typo
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 3ae2bd53a2..bc413a0054 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1764,7 +1764,7 @@ public abstract class StaticTypeCheckingSupport {
      * * For type !instanceof target a structural compare will be done
      * (for example Dummy&lt;T&gt; and List&lt;R&gt; to get T=R)
      * * If type equals target, a structural match is done as well
-     * (for example Colection&lt;U&gt; and Collection&lt;E&gt; to get U=E)
+     * (for example Collection&lt;U&gt; and Collection&lt;E&gt; to get U=E)
      * * otherwise we climb the hierarchy to find a case of type equals target
      * to then execute the structural match, while applying possibly existing
      * generics contexts on the way (for example for IntRange and Collection&lt;E&gt;

Commit:
66ada6915fedf9fad2c0723e6699e6fa6110fa6c
Paul King
paulk@asert.com.au
2018-04-16 15:34:35 +1000
GROOVY-8545: DGM#intersect(Set, Iterable) exception (minor refactor)
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy
index 67c9b22833..19a55dffd4 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy
@@ -104,13 +104,13 @@ class ImportsSyntaxCompletor implements IdentifierCompletor {
                 String className = importSpec.substring(staticPrefix.length(), lastDotIndex)
                 Class clazz = shell.interp.evaluate([className]) as Class
                 if (clazz != null) {
-                    List<String> clazzSymbols = ReflectionCompletor.getPublicFieldsAndMethods(clazz, '')*.value
+                    Set<String> clazzSymbols = ReflectionCompletor.getPublicFieldsAndMethods(clazz, '')*.value
                     Collection<String> importedSymbols
                     if (symbolName == '*') {
                         importedSymbols = clazzSymbols
                     } else {
                         Set<String> acceptableMatches = [symbolName, symbolName + '(', symbolName + '()']
-                        importedSymbols = (acceptableMatches as Collection).intersect(clazzSymbols)
+                        importedSymbols = acceptableMatches.intersect(clazzSymbols)
                     }
                     matches.addAll(importedSymbols)
                 }

Commit:
cc23c7be9213f1b73062858543a969705e011e2d
Paul King
paulk@asert.com.au
2018-04-16 13:59:10 +1000
GROOVY-8548: DGM#intersect should provide a variant with a comparator
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index a52abf96f5..4d4e3f6bd1 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -12212,24 +12212,51 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     /**
      * Create a Collection composed of the intersection of both collections.  Any
      * elements that exist in both collections are added to the resultant collection.
-     * For collection of custom objects; objects should implement java.lang.Comparable
+     * For collections of custom objects; the objects should implement java.lang.Comparable
      * <pre class="groovyTestCase">assert [4,5] == [1,2,3,4,5].intersect([4,5,6,7,8])</pre>
+     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an
+     * element exists in both collections.
      *
      * @param left  a Collection
      * @param right a Collection
      * @return a Collection as an intersection of both collections
+     * @see #intersect(Collection, Collection, Comparator)
      * @since 1.5.6
      */
     public static <T> Collection<T> intersect(Collection<T> left, Collection<T> right) {
+        return intersect(left, right, new NumberAwareComparator<>());
+    }
+
+    /**
+     * Create a Collection composed of the intersection of both collections.  Any
+     * elements that exist in both collections are added to the resultant collection.
+     * For collections of custom objects; the objects should implement java.lang.Comparable
+     * <pre class="groovyTestCase">
+     * assert [3,4] == [1,2,3,4].intersect([3,4,5,6], Comparator.naturalOrder())
+     * </pre>
+     * <pre class="groovyTestCase">
+     * def one = ['a', 'B', 'c', 'd']
+     * def two = ['b', 'C', 'd', 'e']
+     * def compareIgnoreCase = { a, b -> a.toLowerCase() <=> b.toLowerCase() }
+     * assert one.intersect(two) == ['d']
+     * assert two.intersect(one) == ['d']
+     * assert one.intersect(two, compareIgnoreCase) == ['b', 'C', 'd']
+     * assert two.intersect(one, compareIgnoreCase) == ['B', 'c', 'd']
+     * </pre>
+     *
+     * @param left  a Collection
+     * @param right a Collection
+     * @param comparator a Comparator
+     * @return a Collection as an intersection of both collections
+     * @since 2.5.0
+     */
+    public static <T> Collection<T> intersect(Collection<T> left, Collection<T> right, Comparator<T> comparator) {
         if (left.isEmpty() || right.isEmpty())
             return createSimilarCollection(left, 0);
 
-        // TODO optimise if same type?
-        // boolean nlgnSort = sameType(new Collection[]{left, right});
-
         Collection<T> result = createSimilarCollection(left, Math.min(left.size(), right.size()));
         //creates the collection to look for values.
-        Collection<T> pickFrom = new TreeSet<>(new NumberAwareComparator<>());
+        Collection<T> pickFrom = new TreeSet<T>(comparator);
         pickFrom.addAll(left);
 
         for (final T t : right) {
@@ -12242,60 +12269,133 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     /**
      * Create a Collection composed of the intersection of both iterables.  Any
      * elements that exist in both iterables are added to the resultant collection.
-     * For collection of custom objects; objects should implement java.lang.Comparable
+     * For iterables of custom objects; the objects should implement java.lang.Comparable
      * <pre class="groovyTestCase">assert [4,5] == [1,2,3,4,5].intersect([4,5,6,7,8])</pre>
+     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an
+     * element exists in both collections.
      *
      * @param left  an Iterable
      * @param right an Iterable
      * @return a Collection as an intersection of both iterables
+     * @see #intersect(Iterable, Iterable, Comparator)
      * @since 2.4.0
      */
     public static <T> Collection<T> intersect(Iterable<T> left, Iterable<T> right) {
         return intersect(asCollection(left), asCollection(right));
     }
 
+    /**
+     * Create a Collection composed of the intersection of both iterables.  Any
+     * elements that exist in both iterables are added to the resultant collection.
+     * For iterables of custom objects; the objects should implement java.lang.Comparable
+     * <pre class="groovyTestCase">assert [3,4] == [1,2,3,4].intersect([3,4,5,6], Comparator.naturalOrder())</pre>
+     *
+     * @param left  an Iterable
+     * @param right an Iterable
+     * @param comparator a Comparator
+     * @return a Collection as an intersection of both iterables
+     * @since 2.5.0
+     */
+    public static <T> Collection<T> intersect(Iterable<T> left, Iterable<T> right, Comparator<T> comparator) {
+        return intersect(asCollection(left), asCollection(right), comparator);
+    }
+
     /**
      * Create a List composed of the intersection of a List and an Iterable.  Any
      * elements that exist in both iterables are added to the resultant collection.
      * <pre class="groovyTestCase">assert [4,5] == [1,2,3,4,5].intersect([4,5,6,7,8])</pre>
+     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an
+     * element exists in both collections.
      *
      * @param left  a List
      * @param right an Iterable
      * @return a List as an intersection of a List and an Iterable
+     * @see #intersect(List, Iterable, Comparator)
      * @since 2.4.0
      */
     public static <T> List<T> intersect(List<T> left, Iterable<T> right) {
         return (List<T>) intersect((Collection<T>) left, asCollection(right));
     }
 
+    /**
+     * Create a List composed of the intersection of a List and an Iterable.  Any
+     * elements that exist in both iterables are added to the resultant collection.
+     * <pre class="groovyTestCase">assert [3,4] == [1,2,3,4].intersect([3,4,5,6])</pre>
+     *
+     * @param left  a List
+     * @param right an Iterable
+     * @param comparator a Comparator
+     * @return a List as an intersection of a List and an Iterable
+     * @since 2.5.0
+     */
+    public static <T> List<T> intersect(List<T> left, Iterable<T> right, Comparator<T> comparator) {
+        return (List<T>) intersect((Collection<T>) left, asCollection(right), comparator);
+    }
+
     /**
      * Create a Set composed of the intersection of a Set and an Iterable.  Any
      * elements that exist in both iterables are added to the resultant collection.
      * <pre class="groovyTestCase">assert [4,5] as Set == ([1,2,3,4,5] as Set).intersect([4,5,6,7,8])</pre>
+     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an
+     * element exists in both collections.
      *
      * @param left  a Set
      * @param right an Iterable
      * @return a Set as an intersection of a Set and an Iterable
+     * @see #intersect(Set, Iterable, Comparator)
      * @since 2.4.0
      */
     public static <T> Set<T> intersect(Set<T> left, Iterable<T> right) {
         return (Set<T>) intersect((Collection<T>) left, asCollection(right));
     }
 
+    /**
+     * Create a Set composed of the intersection of a Set and an Iterable.  Any
+     * elements that exist in both iterables are added to the resultant collection.
+     * <pre class="groovyTestCase">assert [3,4] as Set == ([1,2,3,4] as Set).intersect([3,4,5,6], Comparator.naturalOrder())</pre>
+     *
+     * @param left  a Set
+     * @param right an Iterable
+     * @param comparator a Comparator
+     * @return a Set as an intersection of a Set and an Iterable
+     * @since 2.5.0
+     */
+    public static <T> Set<T> intersect(Set<T> left, Iterable<T> right, Comparator<T> comparator) {
+        return (Set<T>) intersect((Collection<T>) left, asCollection(right), comparator);
+    }
+
     /**
      * Create a SortedSet composed of the intersection of a SortedSet and an Iterable.  Any
      * elements that exist in both iterables are added to the resultant collection.
      * <pre class="groovyTestCase">assert [4,5] as SortedSet == ([1,2,3,4,5] as SortedSet).intersect([4,5,6,7,8])</pre>
+     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an
+     * element exists in both collections.
      *
      * @param left  a SortedSet
      * @param right an Iterable
      * @return a Set as an intersection of a SortedSet and an Iterable
+     * @see #intersect(SortedSet, Iterable, Comparator)
      * @since 2.4.0
      */
     public static <T> SortedSet<T> intersect(SortedSet<T> left, Iterable<T> right) {
         return (SortedSet<T>) intersect((Collection<T>) left, asCollection(right));
     }
 
+    /**
+     * Create a SortedSet composed of the intersection of a SortedSet and an Iterable.  Any
+     * elements that exist in both iterables are added to the resultant collection.
+     * <pre class="groovyTestCase">assert [4,5] as SortedSet == ([1,2,3,4,5] as SortedSet).intersect([4,5,6,7,8])</pre>
+     *
+     * @param left  a SortedSet
+     * @param right an Iterable
+     * @param comparator a Comparator
+     * @return a Set as an intersection of a SortedSet and an Iterable
+     * @since 2.5.0
+     */
+    public static <T> SortedSet<T> intersect(SortedSet<T> left, Iterable<T> right, Comparator<T> comparator) {
+        return (SortedSet<T>) intersect((Collection<T>) left, asCollection(right), comparator);
+    }
+
     /**
      * Create a Map composed of the intersection of both maps.
      * Any entries that exist in both maps are added to the resultant map.

Commit:
86cb87b2a4192200e0b2cd2cd5886f107132bae3
Paul King
paulk@asert.com.au
2018-04-16 10:03:17 +1000
GROOVY-8545: DGM#intersect(Set, Iterable) throws ClassCastException if Iterable is larger than Set (closes #645)
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 07b7c25e54..a52abf96f5 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -12224,18 +12224,12 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         if (left.isEmpty() || right.isEmpty())
             return createSimilarCollection(left, 0);
 
-        if (left.size() < right.size()) {
-            Collection<T> swaptemp = left;
-            left = right;
-            right = swaptemp;
-        }
-
         // TODO optimise if same type?
         // boolean nlgnSort = sameType(new Collection[]{left, right});
 
-        Collection<T> result = createSimilarCollection(left, left.size());
+        Collection<T> result = createSimilarCollection(left, Math.min(left.size(), right.size()));
         //creates the collection to look for values.
-        Collection<T> pickFrom = new TreeSet<T>(new NumberAwareComparator<T>());
+        Collection<T> pickFrom = new TreeSet<>(new NumberAwareComparator<>());
         pickFrom.addAll(left);
 
         for (final T t : right) {
diff --git a/src/test/groovy/GroovyMethodsTest.groovy b/src/test/groovy/GroovyMethodsTest.groovy
index 7f550af357..903ea02c44 100644
--- a/src/test/groovy/GroovyMethodsTest.groovy
+++ b/src/test/groovy/GroovyMethodsTest.groovy
@@ -809,10 +809,10 @@ class GroovyMethodsTest extends GroovyTestCase {
     }
 
     void doIt(col) {
-        col.clear();
-        col.addAll(leftCol);
+        col.clear()
+        col.addAll(leftCol)
         // not really concerned about  correctness, rather that the method can be called, however..
-        assert col.intersect(rightCol) == ["2"]
+        assert col.intersect(rightCol) as List == ["2"]
     }
 
     void testFileWithReader() {
@@ -1565,6 +1565,15 @@ class GroovyMethodsTest extends GroovyTestCase {
         assert [4, 5] == iterableA.intersect(iterableB)
     }
 
+    void testIntersectForSets() {
+        assert [].toSet() == [].toSet().intersect([] as Iterable)
+        assert [].toSet() == [].toSet().intersect([1, 2, 3] as Iterable)
+        assert [].toSet() == [1, 2, 3].toSet().intersect([] as Iterable)
+        assert [2, 3].toSet() == [2, 3, 4].toSet().intersect([1, 2, 3] as Iterable)
+        assert [2, 3, 4].toSet() == [2, 3, 4].toSet().intersect([1, 2, 3, 4] as Iterable)
+        assert [2, 3].toSet() == [2, 3, 4, 5].toSet().intersect([1, 2, 3] as Iterable)
+    }
+
     void testIntersectForMaps() {
         // GROOVY-7602
         def list1 = [[language: 'Java'], [language: 'Groovy'], [language: 'Scala']]
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy
index cb446a6b4d..67c9b22833 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy
@@ -105,12 +105,12 @@ class ImportsSyntaxCompletor implements IdentifierCompletor {
                 Class clazz = shell.interp.evaluate([className]) as Class
                 if (clazz != null) {
                     List<String> clazzSymbols = ReflectionCompletor.getPublicFieldsAndMethods(clazz, '')*.value
-                    List<String> importedSymbols;
+                    Collection<String> importedSymbols
                     if (symbolName == '*') {
-                        importedSymbols = clazzSymbols;
+                        importedSymbols = clazzSymbols
                     } else {
                         Set<String> acceptableMatches = [symbolName, symbolName + '(', symbolName + '()']
-                        importedSymbols = acceptableMatches.intersect(clazzSymbols)
+                        importedSymbols = (acceptableMatches as Collection).intersect(clazzSymbols)
                     }
                     matches.addAll(importedSymbols)
                 }

Commit:
ebb1d1c19107658031422bd7a72a378928fba533
Paul King
paulk@asert.com.au
2018-04-15 18:09:10 +1000
Merge branch 'groovy-cli'
Commit:
a67f5fc3d3f2e10e2584d92f2d0e236db5680c17
Paul King
paulk@asert.com.au
2018-04-15 18:08:43 +1000
move commons-cli CliBuilder into its own subproject
diff --git a/gradle/binarycompatibility.gradle b/gradle/binarycompatibility.gradle
index aa0175ae4f..66b41c2516 100644
--- a/gradle/binarycompatibility.gradle
+++ b/gradle/binarycompatibility.gradle
@@ -35,7 +35,7 @@ task checkBinaryCompatibility {
 check.dependsOn(checkBinaryCompatibility)
 
 // for comparing between versions with different modules, set excludeModules to differing modules, e.g.
-def excludeModules = ['groovy-dateutil', 'groovy-datetime', 'performance', 'groovy-macro', 'tests-vm8', 'groovy-json-direct']
+def excludeModules = ['groovy-cli-commons', 'groovy-dateutil', 'groovy-datetime', 'performance', 'groovy-macro', 'tests-vm8', 'groovy-json-direct']
 //def excludeModules = []
 
 Set projectsToCheck = allprojects.findAll{ !(it.name in excludeModules) }
diff --git a/settings.gradle b/settings.gradle
index 271d33a04b..e1441f30aa 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -18,6 +18,7 @@
  */
 def subprojects = ['groovy-ant',
         'groovy-bsf',
+        'groovy-cli-commons',
         'groovy-console',
         'groovy-datetime',
         'groovy-dateutil',
diff --git a/subprojects/groovy-cli-commons/build.gradle b/subprojects/groovy-cli-commons/build.gradle
new file mode 100644
index 0000000000..c77cf10f5d
--- /dev/null
+++ b/subprojects/groovy-cli-commons/build.gradle
@@ -0,0 +1,24 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+dependencies {
+    compile rootProject
+    compile "commons-cli:commons-cli:$commonsCliVersion"
+    testCompile project(':groovy-test')
+    testCompile project(':groovy-dateutil')
+}
diff --git a/src/main/groovy/groovy/util/CliBuilder.groovy b/subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
similarity index 100%
rename from src/main/groovy/groovy/util/CliBuilder.groovy
rename to subprojects/groovy-cli-commons/src/main/groovy/groovy/util/CliBuilder.groovy
diff --git a/src/test/groovy/util/CliBuilderTest.groovy b/subprojects/groovy-cli-commons/src/test/groovy/groovy/util/CliBuilderTest.groovy
similarity index 99%
rename from src/test/groovy/util/CliBuilderTest.groovy
rename to subprojects/groovy-cli-commons/src/test/groovy/groovy/util/CliBuilderTest.groovy
index 175228b265..938c79aca1 100644
--- a/src/test/groovy/util/CliBuilderTest.groovy
+++ b/subprojects/groovy-cli-commons/src/test/groovy/groovy/util/CliBuilderTest.groovy
@@ -466,7 +466,7 @@ usage: groovy
         assert p1.remaining() == ['and', 'some', 'more']
     }
 
-    @ToString(includeFields=true, excludes='metaClass', includePackage=false)
+    @ToString(includeFields=true, includePackage=false)
     class PersonC {
         @Option String first
         private String last
diff --git a/subprojects/groovy-console/build.gradle b/subprojects/groovy-console/build.gradle
index b9209ab26e..dc488bb56b 100644
--- a/subprojects/groovy-console/build.gradle
+++ b/subprojects/groovy-console/build.gradle
@@ -20,6 +20,7 @@ evaluationDependsOn(':groovy-swing')
 
 dependencies {
     compile rootProject
+    compile project(':groovy-cli-commons')
     compile project(':groovy-swing')
     compile project(':groovy-templates')
     testCompile project(':groovy-test')
diff --git a/subprojects/groovy-docgenerator/build.gradle b/subprojects/groovy-docgenerator/build.gradle
index d6c88c3d8b..77d93f2e0a 100644
--- a/subprojects/groovy-docgenerator/build.gradle
+++ b/subprojects/groovy-docgenerator/build.gradle
@@ -18,6 +18,7 @@
  */
 dependencies {
     compile rootProject
+    compile project(':groovy-cli-commons')
     compile project(':groovy-templates')
     testCompile project(':groovy-test')
     compile "com.thoughtworks.qdox:qdox:$qdoxVersion"
diff --git a/subprojects/groovy-groovydoc/build.gradle b/subprojects/groovy-groovydoc/build.gradle
index f12a4d10ef..ef3e292824 100644
--- a/subprojects/groovy-groovydoc/build.gradle
+++ b/subprojects/groovy-groovydoc/build.gradle
@@ -19,10 +19,10 @@
 dependencies {
     compile rootProject
     testCompile rootProject.sourceSets.test.runtimeClasspath
+    compile project(':groovy-cli-commons')
     compile project(':groovy-templates')
     runtime project(':groovy-dateutil')
     testCompile project(':groovy-test')
-    testCompile project(':groovy-ant')
     testCompile "org.apache.ant:ant-testutil:$antVersion"
 }
 
diff --git a/subprojects/groovy-groovysh/build.gradle b/subprojects/groovy-groovysh/build.gradle
index bd2d96862f..e234781560 100644
--- a/subprojects/groovy-groovysh/build.gradle
+++ b/subprojects/groovy-groovysh/build.gradle
@@ -18,6 +18,7 @@
  */
 dependencies {
     compile rootProject
+    compile project(':groovy-cli-commons')
     compile project(':groovy-console')
     testCompile project(':groovy-test')
     compile("jline:jline:$jlineVersion") {
diff --git a/subprojects/groovy-test/build.gradle b/subprojects/groovy-test/build.gradle
index 8dfd6edb2c..9a68ebc2dd 100644
--- a/subprojects/groovy-test/build.gradle
+++ b/subprojects/groovy-test/build.gradle
@@ -19,7 +19,10 @@
 dependencies {
     compile rootProject
     compile 'junit:junit:4.12'
-    testRuntime project(':groovy-ant')
+    // groovy-ant needed for FileNameFinder used in AllTestSuite and JavadocAssertionTestSuite
+    testRuntime(project(':groovy-ant')) {
+        transitive = false
+    }
 }
 
-apply from: "${rootProject.projectDir}/gradle/jacoco/jacocofix.gradle"
\ No newline at end of file
+apply from: "${rootProject.projectDir}/gradle/jacoco/jacocofix.gradle"

Commit:
5830d0d4ba8d0547b61b871c3f1549acb946b6ea
danielsun1106
realbluesun@hotmail.com
2018-04-14 21:45:32 +0800
GROOVY-8544: The new parser Parrot does not support enum constants end with semicolon
diff --git a/src/antlr/GroovyParser.g4 b/src/antlr/GroovyParser.g4
index aef9289736..77867dab2f 100644
--- a/src/antlr/GroovyParser.g4
+++ b/src/antlr/GroovyParser.g4
@@ -251,7 +251,7 @@ classBody[int t]
         (
             /* Only enum can have enum constants */
             { 2 == $t }?
-            enumConstants? nls
+            enumConstants? sep?
         |
 
         )
diff --git a/subprojects/parser-antlr4/src/test/resources/core/EnumDeclaration_01.groovy b/subprojects/parser-antlr4/src/test/resources/core/EnumDeclaration_01.groovy
index ed0f67d5b7..3e733b6a83 100644
--- a/subprojects/parser-antlr4/src/test/resources/core/EnumDeclaration_01.groovy
+++ b/subprojects/parser-antlr4/src/test/resources/core/EnumDeclaration_01.groovy
@@ -23,6 +23,11 @@ public enum AAAA3 implements A {}
 public enum AAAA4 implements A,B {}
 enum BBBB {A}
 enum CCCC {A, B}
+enum CCCC2 {A, B
+}
+enum CCCC3 {
+    A, B
+}
 enum DDDD {A, B,}
 enum EEEE {
     A,
@@ -59,4 +64,11 @@ enum E3 {
 
 
 
-enum e {}
\ No newline at end of file
+enum e {}
+
+enum Enum1 {
+    A, B;
+}
+enum Enum2 {
+    A, B;}
+enum Enum3 {A, B;}

Commit:
5443e87882f9b88169876f6d043ed54b5ae9023b
danielsun1106
realbluesun@hotmail.com
2018-04-13 22:23:25 +0800
Trivial refactoring for `CompilerConfiguration`
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 95d4c03e47..a2164bb38d 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -940,51 +940,50 @@ public class CompilerConfiguration {
         return indyEnabled;
     }
 
-    private boolean compileStatic;
-    private void enableCompileStaticByDefault() {
-        if (compileStatic) {
-            return;
-        }
-        if (!Boolean.getBoolean("groovy.compile.static")) {
-            return;
+    {
+        // this object initializer assures that `enableCompileStaticByDefault` must be invoked no matter which constructor called.
+        if (Boolean.getBoolean("groovy.compile.static")) {
+            enableCompileStaticByDefault();
         }
-
+    }
+    private void enableCompileStaticByDefault() {
         compilationCustomizers.add(
             new CompilationCustomizer(CompilePhase.CONVERSION) {
                 @Override
                 public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {
                     for (ClassNode cn : source.getAST().getClasses()) {
-                        new ClassCodeVisitorSupport() {
-                            @Override
-                            public void visitClass(ClassNode node) {
-                                enableCompileStatic(node);
-                            }
+                        newClassCodeVisitor(source).visitClass(cn);
+                    }
+                }
 
-                            private void enableCompileStatic(ClassNode classNode) {
-                                if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
-                                    return;
-                                }
-                                if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
-                                    return;
-                                }
+                private ClassCodeVisitorSupport newClassCodeVisitor(SourceUnit source) {
+                    return new ClassCodeVisitorSupport() {
+                        @Override
+                        public void visitClass(ClassNode node) {
+                            enableCompileStatic(node);
+                        }
 
-                                classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)));
+                        private void enableCompileStatic(ClassNode classNode) {
+                            if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
+                                return;
                             }
-
-                            @Override
-                            protected SourceUnit getSourceUnit() {
-                                return source;
+                            if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
+                                return;
                             }
 
-                            private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
-                            private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
-                        }.visitClass(cn);
-                    }
+                            classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)));
+                        }
+
+                        @Override
+                        protected SourceUnit getSourceUnit() {
+                            return source;
+                        }
+
+                        private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
+                        private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
+                    };
                 }
             }
         );
-
-        compileStatic = true;
     }
-    { enableCompileStaticByDefault(); }
 }

Commit:
31c5dabf8a47b7854808ec96d565ca00611051d9
sunlan
sunlan@apache.org
2018-04-13 19:13:52 +0800
Refine "GROOVY-8543: Support setting compileStatic by default via system properties"
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 06a4b1fcdd..95d4c03e47 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -194,8 +194,6 @@ public class CompilerConfiguration {
 
     private final List<CompilationCustomizer> compilationCustomizers = new LinkedList<CompilationCustomizer>();
 
-    private static final boolean COMPILE_STATIC_BY_DEFAULT = Boolean.getBoolean("groovy.compile.static.by.default");
-
     /**
      * Sets a list of global AST transformations which should not be loaded even if they are
      * defined in META-INF/org.codehaus.groovy.transform.ASTTransformation files. By default,
@@ -942,47 +940,51 @@ public class CompilerConfiguration {
         return indyEnabled;
     }
 
+    private boolean compileStatic;
     private void enableCompileStaticByDefault() {
-        if (!COMPILE_STATIC_BY_DEFAULT) {
+        if (compileStatic) {
+            return;
+        }
+        if (!Boolean.getBoolean("groovy.compile.static")) {
             return;
         }
 
         compilationCustomizers.add(
-                new CompilationCustomizer(CompilePhase.CONVERSION) {
-                    @Override
-                    public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {
-                        for (ClassNode cn : source.getAST().getClasses()) {
-                            new ClassCodeVisitorSupport() {
-                                @Override
-                                public void visitClass(ClassNode node) {
-                                    enableCompileStatic(node);
+            new CompilationCustomizer(CompilePhase.CONVERSION) {
+                @Override
+                public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {
+                    for (ClassNode cn : source.getAST().getClasses()) {
+                        new ClassCodeVisitorSupport() {
+                            @Override
+                            public void visitClass(ClassNode node) {
+                                enableCompileStatic(node);
+                            }
+
+                            private void enableCompileStatic(ClassNode classNode) {
+                                if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
+                                    return;
                                 }
-
-                                private void enableCompileStatic(ClassNode classNode) {
-                                    if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
-                                        return;
-                                    }
-
-                                    if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
-                                        return;
-                                    }
-
-                                    classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)));
+                                if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
+                                    return;
                                 }
 
-                                @Override
-                                protected SourceUnit getSourceUnit() {
-                                    return source;
-                                }
+                                classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)));
+                            }
 
-                                private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
-                                private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
-                            }.visitClass(cn);
-                        }
+                            @Override
+                            protected SourceUnit getSourceUnit() {
+                                return source;
+                            }
+
+                            private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
+                            private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
+                        }.visitClass(cn);
                     }
                 }
+            }
         );
 
+        compileStatic = true;
     }
     { enableCompileStaticByDefault(); }
 }

Commit:
ae74e1d6270518144e45b54a5a8b892a3ce4781f
sunlan
sunlan@apache.org
2018-04-13 16:59:45 +0800
Refine "GROOVY-8543: Support setting compileStatic by default via system properties"
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index d2d0a38735..06a4b1fcdd 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -19,6 +19,11 @@
 package org.codehaus.groovy.control;
 
 import org.apache.groovy.util.Maps;
+import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.control.customizers.CompilationCustomizer;
 import org.codehaus.groovy.control.io.NullWriter;
 import org.codehaus.groovy.control.messages.WarningMessage;
@@ -189,6 +194,8 @@ public class CompilerConfiguration {
 
     private final List<CompilationCustomizer> compilationCustomizers = new LinkedList<CompilationCustomizer>();
 
+    private static final boolean COMPILE_STATIC_BY_DEFAULT = Boolean.getBoolean("groovy.compile.static.by.default");
+
     /**
      * Sets a list of global AST transformations which should not be loaded even if they are
      * defined in META-INF/org.codehaus.groovy.transform.ASTTransformation files. By default,
@@ -934,4 +941,48 @@ public class CompilerConfiguration {
 
         return indyEnabled;
     }
+
+    private void enableCompileStaticByDefault() {
+        if (!COMPILE_STATIC_BY_DEFAULT) {
+            return;
+        }
+
+        compilationCustomizers.add(
+                new CompilationCustomizer(CompilePhase.CONVERSION) {
+                    @Override
+                    public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {
+                        for (ClassNode cn : source.getAST().getClasses()) {
+                            new ClassCodeVisitorSupport() {
+                                @Override
+                                public void visitClass(ClassNode node) {
+                                    enableCompileStatic(node);
+                                }
+
+                                private void enableCompileStatic(ClassNode classNode) {
+                                    if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
+                                        return;
+                                    }
+
+                                    if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
+                                        return;
+                                    }
+
+                                    classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)));
+                                }
+
+                                @Override
+                                protected SourceUnit getSourceUnit() {
+                                    return source;
+                                }
+
+                                private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
+                                private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
+                            }.visitClass(cn);
+                        }
+                    }
+                }
+        );
+
+    }
+    { enableCompileStaticByDefault(); }
 }
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index b383f7b9f7..b530c20926 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -1187,8 +1187,6 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         classNode.putNodeMetaData(CLASS_NAME, className);
         classNode.setSyntheticPublic(syntheticPublic);
 
-        enableCompileStaticByDefault(classNode);
-
         if (asBoolean(ctx.TRAIT())) {
             attachTraitAnnotation(classNode);
         }
@@ -1259,26 +1257,6 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         return classNode;
     }
 
-    private void enableCompileStaticByDefault(ClassNode classNode) {
-        if (!COMPILE_STATIC_BY_DEFAULT) {
-            return;
-        }
-
-        if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
-            return;
-        }
-
-        if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
-            return;
-        }
-
-        attachCompileStaticAnnotation(classNode);
-    }
-
-    private void attachCompileStaticAnnotation(ClassNode classNode) {
-        attachAnnotation(classNode, GROOVY_TRANSFORM_COMPILE_STATIC);
-    }
-
     private void attachTraitAnnotation(ClassNode classNode) {
         attachAnnotation(classNode, GROOVY_TRANSFORM_TRAIT);
     }
@@ -4767,8 +4745,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
 
     private static final String PACKAGE_INFO = "package-info";
     private static final String PACKAGE_INFO_FILE_NAME = PACKAGE_INFO + ".groovy";
-    private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
-    private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
+
     private static final String GROOVY_TRANSFORM_TRAIT = "groovy.transform.Trait";
     private static final Set<String> PRIMITIVE_TYPE_SET = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("boolean", "char", "byte", "short", "int", "long", "float", "double")));
     private static final Logger LOGGER = Logger.getLogger(AstBuilder.class.getName());
@@ -4796,6 +4773,4 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
     private static final String ENCLOSING_INSTANCE_EXPRESSION = "_ENCLOSING_INSTANCE_EXPRESSION";
 
     private static final String CLASS_NAME = "_CLASS_NAME";
-
-    private static final boolean COMPILE_STATIC_BY_DEFAULT = Boolean.getBoolean("groovy.compile.static.by.default");
 }

Commit:
adf7e9219f92827996d17a0624db11d9406e4b11
sunlan
sunlan@apache.org
2018-04-13 15:24:55 +0800
Make Parrot test util classes compileStatic
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/TestUtils.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/TestUtils.groovy
index 791655f653..af2cb160a8 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/TestUtils.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/TestUtils.groovy
@@ -18,6 +18,8 @@
  */
 package org.apache.groovy.parser.antlr4
 
+import groovy.transform.CompileDynamic
+import groovy.transform.CompileStatic
 import groovy.util.logging.Log
 import org.apache.groovy.parser.AbstractParser
 import org.apache.groovy.parser.Antlr2Parser
@@ -25,8 +27,23 @@ import org.apache.groovy.parser.Antlr4Parser
 import org.apache.groovy.parser.antlr4.util.ASTComparatorCategory
 import org.apache.groovy.parser.antlr4.util.AstDumper
 import org.codehaus.groovy.antlr.AntlrParserPluginFactory
-import org.codehaus.groovy.ast.*
-import org.codehaus.groovy.ast.stmt.*
+import org.codehaus.groovy.ast.ConstructorNode
+import org.codehaus.groovy.ast.FieldNode
+import org.codehaus.groovy.ast.GenericsType
+import org.codehaus.groovy.ast.MethodNode
+import org.codehaus.groovy.ast.ModuleNode
+import org.codehaus.groovy.ast.PackageNode
+import org.codehaus.groovy.ast.Parameter
+import org.codehaus.groovy.ast.PropertyNode
+import org.codehaus.groovy.ast.stmt.AssertStatement
+import org.codehaus.groovy.ast.stmt.BreakStatement
+import org.codehaus.groovy.ast.stmt.ContinueStatement
+import org.codehaus.groovy.ast.stmt.ExpressionStatement
+import org.codehaus.groovy.ast.stmt.ForStatement
+import org.codehaus.groovy.ast.stmt.IfStatement
+import org.codehaus.groovy.ast.stmt.ReturnStatement
+import org.codehaus.groovy.ast.stmt.ThrowStatement
+import org.codehaus.groovy.ast.stmt.WhileStatement
 import org.codehaus.groovy.control.CompilerConfiguration
 import org.codehaus.groovy.syntax.Token
 
@@ -36,6 +53,8 @@ import java.util.zip.ZipFile
 /**
  * Utilities for test
  */
+
+@CompileStatic
 @Log
 class TestUtils {
     public static final String DEFAULT_RESOURCES_PATH = 'subprojects/parser-antlr4/src/test/resources';
@@ -49,6 +68,7 @@ class TestUtils {
         return doTest(path, addIgnore(ignoreClazzList, ASTComparatorCategory.LOCATION_IGNORE_LIST))
     }
 
+    @CompileDynamic
     static doTest(String path, conf) {
         AbstractParser antlr4Parser = new Antlr4Parser()
         AbstractParser antlr2Parser = new Antlr2Parser()
@@ -81,6 +101,7 @@ class TestUtils {
     }
     */
 
+    @CompileDynamic
     static unzipAndTest(String path, String entryName, conf, Map<String, String> replacementsMap=[:]) {
         AbstractParser antlr4Parser = new Antlr4Parser()
         AbstractParser antlr2Parser = new Antlr2Parser()
@@ -114,6 +135,7 @@ class TestUtils {
         shouldFail(path, addIgnore(ignoreClazzList, ASTComparatorCategory.LOCATION_IGNORE_LIST), toCheckNewParserOnly)
     }
 
+    @CompileDynamic
     static shouldFail(String path, conf, boolean toCheckNewParserOnly = false) {
         AbstractParser antlr4Parser = new Antlr4Parser()
         AbstractParser antlr2Parser = new Antlr2Parser()
@@ -136,6 +158,7 @@ class TestUtils {
         }
     }
 
+    @CompileDynamic
     static unzipAndFail(String path, String entryName, conf, Map<String, String> replacementsMap=[:], boolean toCheckNewParserOnly = false) {
         AbstractParser antlr4Parser = new Antlr4Parser()
         AbstractParser antlr2Parser = new Antlr2Parser()
@@ -164,8 +187,7 @@ class TestUtils {
         }
     }
 
-
-    static assertAST(ast1, ast2, conf) {
+    static assertAST(ModuleNode ast1, ModuleNode ast2, conf) {
         assert null != ast1 && null != ast2
 
         ASTComparatorCategory.apply(conf) {
@@ -187,14 +209,14 @@ class TestUtils {
         return [result, end - begin];
     }
 
-    static addIgnore(Class aClass, ArrayList<String> ignore, Map<Class, List<String>> c = null) {
-        c = c ?: ASTComparatorCategory.DEFAULT_CONFIGURATION.clone() as Map<Class, List<String>>;
+    static addIgnore(Class aClass, List<String> ignore, Map<Class, List<String>> c = null) {
+        c = c ?: new HashMap<>(ASTComparatorCategory.DEFAULT_CONFIGURATION) as Map<Class, List<String>>;
         c[aClass].addAll(ignore)
         return c
     }
 
-    static addIgnore(Collection<Class> aClass, ArrayList<String> ignore, Map<Class, List<String>> c = null) {
-        c = c ?: ASTComparatorCategory.DEFAULT_CONFIGURATION.clone() as Map<Class, List<String>>;
+    static addIgnore(Collection<Class> aClass, List<String> ignore, Map<Class, List<String>> c = null) {
+        c = c ?: new HashMap<>(ASTComparatorCategory.DEFAULT_CONFIGURATION) as Map<Class, List<String>>;
         aClass.each { c[it].addAll(ignore) }
         return c
     }
@@ -229,7 +251,7 @@ class TestUtils {
     }
 
     static doRunAndTestAntlr4(String path) {
-        assert executeScript(path)
+        assert executeScript(path);
     }
 
     static doRunAndTestAntlr2(String path) {
@@ -240,7 +262,7 @@ class TestUtils {
         executeScript(createAntlr4Shell(), "$RESOURCES_PATH/$path")
     }
 
-    static executeScript(gsh, String path) {
+    static executeScript(GroovyShell gsh, String path) {
         def file = new File(path);
         def content = file.text;
 
@@ -254,19 +276,19 @@ class TestUtils {
         }
     }
 
-    static createAntlr4Shell() {
+    static GroovyShell createAntlr4Shell() {
         CompilerConfiguration configuration = new CompilerConfiguration(CompilerConfiguration.DEFAULT)
         configuration.pluginFactory = new Antlr4PluginFactory()
 
         return new GroovyShell(configuration);
     }
 
-    static createAntlr2Shell() {
+    static GroovyShell createAntlr2Shell() {
         CompilerConfiguration configuration = new CompilerConfiguration(CompilerConfiguration.DEFAULT)
         configuration.pluginFactory = new AntlrParserPluginFactory()
 
         return new GroovyShell(configuration);
     }
 
-    public static final List COMMON_IGNORE_CLASS_LIST = Collections.unmodifiableList([AssertStatement, BreakStatement, ConstructorNode, ContinueStatement, ExpressionStatement, FieldNode, ForStatement, GenericsType, IfStatement, MethodNode, PackageNode, Parameter, PropertyNode, ReturnStatement, ThrowStatement, Token, WhileStatement]);
+    public static final List COMMON_IGNORE_CLASS_LIST = Collections.unmodifiableList([AssertStatement, BreakStatement, ConstructorNode, ContinueStatement, ExpressionStatement, FieldNode, ForStatement, GenericsType, IfStatement, MethodNode, PackageNode, Parameter, PropertyNode, ReturnStatement, ThrowStatement, Token, WhileStatement] as List);
 }
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy
index 19123f906c..0480004ddb 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy
@@ -18,14 +18,90 @@
  */
 package org.apache.groovy.parser.antlr4.util
 
+import groovy.transform.CompileDynamic
+import groovy.transform.CompileStatic
 import groovy.util.logging.Log
-import org.codehaus.groovy.ast.*
-import org.codehaus.groovy.ast.expr.*
-import org.codehaus.groovy.ast.stmt.*
+import org.codehaus.groovy.ast.AnnotationNode
+import org.codehaus.groovy.ast.ClassNode
+import org.codehaus.groovy.ast.CompileUnit
+import org.codehaus.groovy.ast.ConstructorNode
+import org.codehaus.groovy.ast.DynamicVariable
+import org.codehaus.groovy.ast.EnumConstantClassNode
+import org.codehaus.groovy.ast.FieldNode
+import org.codehaus.groovy.ast.GenericsType
+import org.codehaus.groovy.ast.ImportNode
+import org.codehaus.groovy.ast.InnerClassNode
+import org.codehaus.groovy.ast.InterfaceHelperClassNode
+import org.codehaus.groovy.ast.MethodNode
+import org.codehaus.groovy.ast.MixinNode
+import org.codehaus.groovy.ast.ModuleNode
+import org.codehaus.groovy.ast.PackageNode
+import org.codehaus.groovy.ast.Parameter
+import org.codehaus.groovy.ast.PropertyNode
+import org.codehaus.groovy.ast.Variable
+import org.codehaus.groovy.ast.VariableScope
+import org.codehaus.groovy.ast.expr.AnnotationConstantExpression
+import org.codehaus.groovy.ast.expr.ArgumentListExpression
+import org.codehaus.groovy.ast.expr.ArrayExpression
+import org.codehaus.groovy.ast.expr.AttributeExpression
+import org.codehaus.groovy.ast.expr.BinaryExpression
+import org.codehaus.groovy.ast.expr.BitwiseNegationExpression
+import org.codehaus.groovy.ast.expr.BooleanExpression
+import org.codehaus.groovy.ast.expr.CastExpression
+import org.codehaus.groovy.ast.expr.ClassExpression
+import org.codehaus.groovy.ast.expr.ClosureExpression
+import org.codehaus.groovy.ast.expr.ClosureListExpression
+import org.codehaus.groovy.ast.expr.ConstantExpression
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression
+import org.codehaus.groovy.ast.expr.DeclarationExpression
+import org.codehaus.groovy.ast.expr.ElvisOperatorExpression
+import org.codehaus.groovy.ast.expr.EmptyExpression
+import org.codehaus.groovy.ast.expr.ExpressionTransformer
+import org.codehaus.groovy.ast.expr.FieldExpression
+import org.codehaus.groovy.ast.expr.GStringExpression
+import org.codehaus.groovy.ast.expr.ListExpression
+import org.codehaus.groovy.ast.expr.MapEntryExpression
+import org.codehaus.groovy.ast.expr.MapExpression
+import org.codehaus.groovy.ast.expr.MethodCall
+import org.codehaus.groovy.ast.expr.MethodCallExpression
+import org.codehaus.groovy.ast.expr.MethodPointerExpression
+import org.codehaus.groovy.ast.expr.NamedArgumentListExpression
+import org.codehaus.groovy.ast.expr.NotExpression
+import org.codehaus.groovy.ast.expr.PostfixExpression
+import org.codehaus.groovy.ast.expr.PrefixExpression
+import org.codehaus.groovy.ast.expr.PropertyExpression
+import org.codehaus.groovy.ast.expr.RangeExpression
+import org.codehaus.groovy.ast.expr.SpreadExpression
+import org.codehaus.groovy.ast.expr.SpreadMapExpression
+import org.codehaus.groovy.ast.expr.StaticMethodCallExpression
+import org.codehaus.groovy.ast.expr.TernaryExpression
+import org.codehaus.groovy.ast.expr.TupleExpression
+import org.codehaus.groovy.ast.expr.UnaryMinusExpression
+import org.codehaus.groovy.ast.expr.UnaryPlusExpression
+import org.codehaus.groovy.ast.expr.VariableExpression
+import org.codehaus.groovy.ast.stmt.AssertStatement
+import org.codehaus.groovy.ast.stmt.BlockStatement
+import org.codehaus.groovy.ast.stmt.BreakStatement
+import org.codehaus.groovy.ast.stmt.CaseStatement
+import org.codehaus.groovy.ast.stmt.CatchStatement
+import org.codehaus.groovy.ast.stmt.ContinueStatement
+import org.codehaus.groovy.ast.stmt.DoWhileStatement
+import org.codehaus.groovy.ast.stmt.EmptyStatement
+import org.codehaus.groovy.ast.stmt.ExpressionStatement
+import org.codehaus.groovy.ast.stmt.ForStatement
+import org.codehaus.groovy.ast.stmt.IfStatement
+import org.codehaus.groovy.ast.stmt.LoopingStatement
+import org.codehaus.groovy.ast.stmt.ReturnStatement
+import org.codehaus.groovy.ast.stmt.SwitchStatement
+import org.codehaus.groovy.ast.stmt.SynchronizedStatement
+import org.codehaus.groovy.ast.stmt.ThrowStatement
+import org.codehaus.groovy.ast.stmt.TryCatchStatement
+import org.codehaus.groovy.ast.stmt.WhileStatement
 import org.codehaus.groovy.syntax.Token
 
 import java.util.logging.Level
 
+@CompileStatic
 @Log @SuppressWarnings("GroovyUnusedDeclaration")
 class ASTComparatorCategory {
     static { log.level = Level.WARNING }
@@ -36,94 +112,95 @@ class ASTComparatorCategory {
      *  Keeps all checked object pairs and their comparison result.
      *  Will be cleared at {@link #apply(groovy.lang.Closure)} method }
      */
-    static objects = [:] as Map<List<Object>, Boolean>
+    static Map<List<Object>, Boolean> objects = [:] as Map<List<Object>, Boolean>
     static String lastName
 
     static Map<Class, List<String>> DEFAULT_CONFIGURATION = [
-            (ClassNode): (['module', "declaredMethodsMap", "plainNodeReference", "typeClass", "allInterfaces", "orAddStaticConstructorNode", "allDeclaredMethods", "unresolvedSuperClass", "innerClasses" ] + LOCATION_IGNORE_LIST) as List<String>,
-            (ConstructorNode): ['declaringClass'],
-            (DynamicVariable): [],
-            (EnumConstantClassNode): ["typeClass"],
-            (FieldNode): ["owner", "declaringClass", "initialValueExpression", "assignToken"],
-            (GenericsType): [],
-            (ImportNode): LOCATION_IGNORE_LIST,
-            (InnerClassNode): (['module', "declaredMethodsMap", "plainNodeReference", "typeClass", "allInterfaces", "orAddStaticConstructorNode", "allDeclaredMethods", "unresolvedSuperClass", "innerClasses" ] + LOCATION_IGNORE_LIST) as List<String>,
-            (InterfaceHelperClassNode): [],
-            (MethodNode): ["text", "declaringClass"],
-            (MixinNode): [],
-            (ModuleNode): ["context"],
-            (PackageNode): [],
-            (Parameter): [],
-            (PropertyNode): ['declaringClass', 'initialValueExpression', "assignToken"],
-            (Variable): [],
-            (VariableScope): ["clazzScope", "parent", "declaredVariablesIterator"],
-            (Token): ["root", "startColumn"],
-            (AnnotationNode): (["text"] + LOCATION_IGNORE_LIST) as List<String>,
-            (AssertStatement): ["text"],
-            (BlockStatement): ["columnNumber", "lineNumber", "lastColumnNumber", "lastLineNumber", "text"],
-            (BreakStatement): ["text"],
-            (CaseStatement): ["text"],
-            (CatchStatement): (["text"] + LOCATION_IGNORE_LIST) as List<String>,
-            (ContinueStatement): ["text"],
-            (DoWhileStatement): ["text"],
-            (EmptyStatement): ["text"],
-            (ExpressionStatement): ["text"],
-            (ForStatement): ["text"],
-            (IfStatement): ["text"],
-            (LoopingStatement): ["text"],
-            (ReturnStatement): ["text"],
-            (SwitchStatement): ["columnNumber", "lineNumber", "lastColumnNumber", "lastLineNumber", "text"],
-            (SynchronizedStatement): ["text"],
-            (ThrowStatement): ["text"],
-            (TryCatchStatement): (["text"] + LOCATION_IGNORE_LIST) as List<String>,
-            (WhileStatement): ["text"],
+            (ClassNode)                   : (['module', "declaredMethodsMap", "plainNodeReference", "typeClass", "allInterfaces", "orAddStaticConstructorNode", "allDeclaredMethods", "unresolvedSuperClass", "innerClasses" ] + LOCATION_IGNORE_LIST) as List<String>,
+            (ConstructorNode)             : ['declaringClass'],
+            (DynamicVariable)             : [],
+            (EnumConstantClassNode)       : ["typeClass"],
+            (FieldNode)                   : ["owner", "declaringClass", "initialValueExpression", "assignToken"],
+            (GenericsType)                : [],
+            (ImportNode)                  : LOCATION_IGNORE_LIST,
+            (InnerClassNode)              : (['module', "declaredMethodsMap", "plainNodeReference", "typeClass", "allInterfaces", "orAddStaticConstructorNode", "allDeclaredMethods", "unresolvedSuperClass", "innerClasses" ] + LOCATION_IGNORE_LIST) as List<String>,
+            (InterfaceHelperClassNode)    : [],
+            (MethodNode)                  : ["text", "declaringClass"],
+            (MixinNode)                   : [],
+            (ModuleNode)                  : ["context"],
+            (PackageNode)                 : [],
+            (Parameter)                   : [],
+            (PropertyNode)                : ['declaringClass', 'initialValueExpression', "assignToken"],
+            (Variable)                    : [],
+            (VariableScope)               : ["clazzScope", "parent", "declaredVariablesIterator"],
+            (Token)                       : ["root", "startColumn"],
+            (AnnotationNode)              : (["text"] + LOCATION_IGNORE_LIST) as List<String>,
+            (AssertStatement)             : ["text"],
+            (BlockStatement)              : ["columnNumber", "lineNumber", "lastColumnNumber", "lastLineNumber", "text"],
+            (BreakStatement)              : ["text"],
+            (CaseStatement)               : ["text"],
+            (CatchStatement)              : (["text"] + LOCATION_IGNORE_LIST) as List<String>,
+            (ContinueStatement)           : ["text"],
+            (DoWhileStatement)            : ["text"],
+            (EmptyStatement)              : ["text"],
+            (ExpressionStatement)         : ["text"],
+            (ForStatement)                : ["text"],
+            (IfStatement)                 : ["text"],
+            (LoopingStatement)            : ["text"],
+            (ReturnStatement)             : ["text"],
+            (SwitchStatement)             : ["columnNumber", "lineNumber", "lastColumnNumber", "lastLineNumber", "text"],
+            (SynchronizedStatement)       : ["text"],
+            (ThrowStatement)              : ["text"],
+            (TryCatchStatement)           : (["text"] + LOCATION_IGNORE_LIST) as List<String>,
+            (WhileStatement)              : ["text"],
             (AnnotationConstantExpression): EXPRESSION_IGNORE_LIST,
-            (ArgumentListExpression): EXPRESSION_IGNORE_LIST,
-            (ArrayExpression): EXPRESSION_IGNORE_LIST,
-            (AttributeExpression): EXPRESSION_IGNORE_LIST,
-            (BinaryExpression): EXPRESSION_IGNORE_LIST,
-            (BitwiseNegationExpression): EXPRESSION_IGNORE_LIST,
-            (BooleanExpression): EXPRESSION_IGNORE_LIST,
-            (CastExpression): EXPRESSION_IGNORE_LIST,
-            (ClassExpression): EXPRESSION_IGNORE_LIST,
-            (ClosureExpression): EXPRESSION_IGNORE_LIST,
-            (ClosureListExpression): EXPRESSION_IGNORE_LIST,
-            (ConstantExpression): EXPRESSION_IGNORE_LIST,
-            (ConstructorCallExpression): EXPRESSION_IGNORE_LIST,
-            (DeclarationExpression): ["text", "columnNumber", "lineNumber", "lastColumnNumber", "lastLineNumber"],
-            (ElvisOperatorExpression): EXPRESSION_IGNORE_LIST,
-            (EmptyExpression): EXPRESSION_IGNORE_LIST,
-            (ExpressionTransformer): EXPRESSION_IGNORE_LIST,
-            (FieldExpression): EXPRESSION_IGNORE_LIST,
-            (GStringExpression): EXPRESSION_IGNORE_LIST,
-            (ListExpression): EXPRESSION_IGNORE_LIST,
-            (MapEntryExpression): EXPRESSION_IGNORE_LIST,
-            (MapExpression): EXPRESSION_IGNORE_LIST,
-            (MethodCall): EXPRESSION_IGNORE_LIST,
-            (MethodCallExpression): EXPRESSION_IGNORE_LIST,
-            (MethodPointerExpression): EXPRESSION_IGNORE_LIST,
-            (NamedArgumentListExpression): EXPRESSION_IGNORE_LIST,
-            (NotExpression): EXPRESSION_IGNORE_LIST,
-            (PostfixExpression): EXPRESSION_IGNORE_LIST,
-            (PrefixExpression): EXPRESSION_IGNORE_LIST,
-            (PropertyExpression): EXPRESSION_IGNORE_LIST,
-            (RangeExpression): EXPRESSION_IGNORE_LIST,
-            (SpreadExpression): EXPRESSION_IGNORE_LIST,
-            (SpreadMapExpression): EXPRESSION_IGNORE_LIST,
-            (StaticMethodCallExpression): EXPRESSION_IGNORE_LIST,
-            (TernaryExpression): EXPRESSION_IGNORE_LIST,
-            (TupleExpression): EXPRESSION_IGNORE_LIST,
-            (UnaryMinusExpression): EXPRESSION_IGNORE_LIST,
-            (UnaryPlusExpression): EXPRESSION_IGNORE_LIST,
-            (VariableExpression): EXPRESSION_IGNORE_LIST,
-    ];
+            (ArgumentListExpression)      : EXPRESSION_IGNORE_LIST,
+            (ArrayExpression)             : EXPRESSION_IGNORE_LIST,
+            (AttributeExpression)         : EXPRESSION_IGNORE_LIST,
+            (BinaryExpression)            : EXPRESSION_IGNORE_LIST,
+            (BitwiseNegationExpression)   : EXPRESSION_IGNORE_LIST,
+            (BooleanExpression)           : EXPRESSION_IGNORE_LIST,
+            (CastExpression)              : EXPRESSION_IGNORE_LIST,
+            (ClassExpression)             : EXPRESSION_IGNORE_LIST,
+            (ClosureExpression)           : EXPRESSION_IGNORE_LIST,
+            (ClosureListExpression)       : EXPRESSION_IGNORE_LIST,
+            (ConstantExpression)          : EXPRESSION_IGNORE_LIST,
+            (ConstructorCallExpression)   : EXPRESSION_IGNORE_LIST,
+            (DeclarationExpression)       : ["text", "columnNumber", "lineNumber", "lastColumnNumber", "lastLineNumber"],
+            (ElvisOperatorExpression)     : EXPRESSION_IGNORE_LIST,
+            (EmptyExpression)             : EXPRESSION_IGNORE_LIST,
+            (ExpressionTransformer)       : EXPRESSION_IGNORE_LIST,
+            (FieldExpression)             : EXPRESSION_IGNORE_LIST,
+            (GStringExpression)           : EXPRESSION_IGNORE_LIST,
+            (ListExpression)              : EXPRESSION_IGNORE_LIST,
+            (MapEntryExpression)          : EXPRESSION_IGNORE_LIST,
+            (MapExpression)               : EXPRESSION_IGNORE_LIST,
+            (MethodCall)                  : EXPRESSION_IGNORE_LIST,
+            (MethodCallExpression)        : EXPRESSION_IGNORE_LIST,
+            (MethodPointerExpression)     : EXPRESSION_IGNORE_LIST,
+            (NamedArgumentListExpression) : EXPRESSION_IGNORE_LIST,
+            (NotExpression)               : EXPRESSION_IGNORE_LIST,
+            (PostfixExpression)           : EXPRESSION_IGNORE_LIST,
+            (PrefixExpression)            : EXPRESSION_IGNORE_LIST,
+            (PropertyExpression)          : EXPRESSION_IGNORE_LIST,
+            (RangeExpression)             : EXPRESSION_IGNORE_LIST,
+            (SpreadExpression)            : EXPRESSION_IGNORE_LIST,
+            (SpreadMapExpression)         : EXPRESSION_IGNORE_LIST,
+            (StaticMethodCallExpression)  : EXPRESSION_IGNORE_LIST,
+            (TernaryExpression)           : EXPRESSION_IGNORE_LIST,
+            (TupleExpression)             : EXPRESSION_IGNORE_LIST,
+            (UnaryMinusExpression)        : EXPRESSION_IGNORE_LIST,
+            (UnaryPlusExpression)         : EXPRESSION_IGNORE_LIST,
+            (VariableExpression)          : EXPRESSION_IGNORE_LIST,
+    ] as Map<Class, List<String>>
 
     static Map<Class, List<String>> COLLECTION_PROPERTY_CONFIGURATION = [
             (ModuleNode): ["classes", "name"]
-    ]
+    ] as Map<Class, List<String>>
 
     static Map<Class, List<String>> configuration = DEFAULT_CONFIGURATION;
 
+    @CompileDynamic
     static void apply(config = DEFAULT_CONFIGURATION, Closure cl) {
         configuration = config
         objects.clear()
@@ -138,8 +215,8 @@ class ASTComparatorCategory {
      * @param b
      * @return
      */
+    @CompileDynamic
     static reflexiveEquals(a, b, ignore = []) {
-
         if (a.getClass() != b.getClass()) {
             log.warning(" !!!! DIFFERENCE WAS FOUND! ${a.getClass()} != ${b.getClass()}")
             return false;
@@ -161,7 +238,8 @@ class ASTComparatorCategory {
         if (a.is(b))
             return true
 
-        def difference = a.metaClass.properties.find { MetaBeanProperty p ->
+        def difference = a.metaClass.properties.find { MetaProperty mp  ->
+            MetaBeanProperty p = (MetaBeanProperty) mp
             if (!p.getter)
                 return false
 
@@ -194,7 +272,7 @@ class ASTComparatorCategory {
         }
 
         if (difference)
-            log.warning(" !!!! DIFFERENCE WAS FOUND! [${a.metaClass.hasProperty(a, 'text') ? a.text : '<NO TEXT>'}][${a.class}][${difference.name}]:: ${ a."$difference.name" } != ${ b."$difference.name" }")
+            log.warning(" !!!! DIFFERENCE WAS FOUND! [${extractText(a)}][${a.class}][${difference.name}]:: ${ a."$difference.name" } != ${ b."$difference.name" }")
         else
             log.info(" ==== Exit ${ a.getClass() } ${ a.hashCode() } ====== ")
 
@@ -204,6 +282,11 @@ class ASTComparatorCategory {
         res
     }
 
+    @CompileDynamic
+    static String extractText(obj) {
+        return obj.metaClass.hasProperty(obj, 'text') ? obj.text : '<NO TEXT>'
+    }
+
     ////////////////////////////////////////////////////////////////////////////////////////////////////
     // Just a bunch of copypasted methods. Maybe will wrote AST transformation for them.
     ////////////////////////////////////////////////////////////////////////////////////////////////////
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/AstDumper.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/AstDumper.groovy
index 72a64e5d98..0fa5ca9a3b 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/AstDumper.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/util/AstDumper.groovy
@@ -18,9 +18,77 @@
  */
 package org.apache.groovy.parser.antlr4.util
 
-import org.codehaus.groovy.ast.*
-import org.codehaus.groovy.ast.expr.*
-import org.codehaus.groovy.ast.stmt.*
+import groovy.transform.CompileStatic
+import org.codehaus.groovy.ast.ASTNode
+import org.codehaus.groovy.ast.AnnotationNode
+import org.codehaus.groovy.ast.ClassHelper
+import org.codehaus.groovy.ast.ClassNode
+import org.codehaus.groovy.ast.ConstructorNode
+import org.codehaus.groovy.ast.FieldNode
+import org.codehaus.groovy.ast.GenericsType
+import org.codehaus.groovy.ast.GroovyClassVisitor
+import org.codehaus.groovy.ast.GroovyCodeVisitor
+import org.codehaus.groovy.ast.ImportNode
+import org.codehaus.groovy.ast.MethodNode
+import org.codehaus.groovy.ast.ModuleNode
+import org.codehaus.groovy.ast.PackageNode
+import org.codehaus.groovy.ast.Parameter
+import org.codehaus.groovy.ast.PropertyNode
+import org.codehaus.groovy.ast.expr.ArgumentListExpression
+import org.codehaus.groovy.ast.expr.ArrayExpression
+import org.codehaus.groovy.ast.expr.AttributeExpression
+import org.codehaus.groovy.ast.expr.BinaryExpression
+import org.codehaus.groovy.ast.expr.BitwiseNegationExpression
+import org.codehaus.groovy.ast.expr.BooleanExpression
+import org.codehaus.groovy.ast.expr.CastExpression
+import org.codehaus.groovy.ast.expr.ClassExpression
+import org.codehaus.groovy.ast.expr.ClosureExpression
+import org.codehaus.groovy.ast.expr.ClosureListExpression
+import org.codehaus.groovy.ast.expr.ConstantExpression
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression
+import org.codehaus.groovy.ast.expr.DeclarationExpression
+import org.codehaus.groovy.ast.expr.ElvisOperatorExpression
+import org.codehaus.groovy.ast.expr.EmptyExpression
+import org.codehaus.groovy.ast.expr.Expression
+import org.codehaus.groovy.ast.expr.FieldExpression
+import org.codehaus.groovy.ast.expr.GStringExpression
+import org.codehaus.groovy.ast.expr.LambdaExpression
+import org.codehaus.groovy.ast.expr.ListExpression
+import org.codehaus.groovy.ast.expr.MapEntryExpression
+import org.codehaus.groovy.ast.expr.MapExpression
+import org.codehaus.groovy.ast.expr.MethodCallExpression
+import org.codehaus.groovy.ast.expr.MethodPointerExpression
+import org.codehaus.groovy.ast.expr.NotExpression
+import org.codehaus.groovy.ast.expr.PostfixExpression
+import org.codehaus.groovy.ast.expr.PrefixExpression
+import org.codehaus.groovy.ast.expr.PropertyExpression
+import org.codehaus.groovy.ast.expr.RangeExpression
+import org.codehaus.groovy.ast.expr.SpreadExpression
+import org.codehaus.groovy.ast.expr.SpreadMapExpression
+import org.codehaus.groovy.ast.expr.StaticMethodCallExpression
+import org.codehaus.groovy.ast.expr.TernaryExpression
+import org.codehaus.groovy.ast.expr.TupleExpression
+import org.codehaus.groovy.ast.expr.UnaryMinusExpression
+import org.codehaus.groovy.ast.expr.UnaryPlusExpression
+import org.codehaus.groovy.ast.expr.VariableExpression
+import org.codehaus.groovy.ast.stmt.AssertStatement
+import org.codehaus.groovy.ast.stmt.BlockStatement
+import org.codehaus.groovy.ast.stmt.BreakStatement
+import org.codehaus.groovy.ast.stmt.CaseStatement
+import org.codehaus.groovy.ast.stmt.CatchStatement
+import org.codehaus.groovy.ast.stmt.ContinueStatement
+import org.codehaus.groovy.ast.stmt.DoWhileStatement
+import org.codehaus.groovy.ast.stmt.EmptyStatement
+import org.codehaus.groovy.ast.stmt.ExpressionStatement
+import org.codehaus.groovy.ast.stmt.ForStatement
+import org.codehaus.groovy.ast.stmt.IfStatement
+import org.codehaus.groovy.ast.stmt.ReturnStatement
+import org.codehaus.groovy.ast.stmt.Statement
+import org.codehaus.groovy.ast.stmt.SwitchStatement
+import org.codehaus.groovy.ast.stmt.SynchronizedStatement
+import org.codehaus.groovy.ast.stmt.ThrowStatement
+import org.codehaus.groovy.ast.stmt.TryCatchStatement
+import org.codehaus.groovy.ast.stmt.WhileStatement
 import org.codehaus.groovy.classgen.BytecodeExpression
 import org.codehaus.groovy.classgen.GeneratorContext
 import org.codehaus.groovy.classgen.Verifier
@@ -37,6 +105,7 @@ import java.lang.reflect.Modifier
  * @author  <a href="mailto:realbluesun@hotmail.com">Daniel.Sun</a>
  * Created on    2016/08/16
  */
+@CompileStatic
 class AstDumper {
     private ModuleNode ast;
 
@@ -55,7 +124,7 @@ class AstDumper {
         try {
             AstNodeToScriptVisitor visitor = new AstNodeToScriptVisitor(out, true, true);
 
-            new LinkedList<ClassNode>(this.ast?.classes ?: []).sort { c1, c2 -> c1.name <=> c2.name }?.each {
+            new LinkedList<ClassNode>((List) this.ast?.classes ?: []).sort { c1, c2 -> c1.name <=> c2.name }?.each {
                 visitor.call(new SourceUnit((String) null, (ReaderSource) null, null, null, null) {
                     @Override
                     public ModuleNode getAST() {
@@ -82,6 +151,7 @@ class AstDumper {
  *
  * @author Hamlet D'Arcy
  */
+@CompileStatic
 class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation implements GroovyCodeVisitor, GroovyClassVisitor {
 
     private final Writer _out
@@ -233,7 +303,8 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
         }
 
         visitModifiers(node.modifiers)
-        print "class $node.name"
+        if (node.isInterface()) print node.name
+        else print "class $node.name"
         visitGenerics node?.genericsTypes
         boolean first = true
         node.unresolvedInterfaces?.each {
@@ -257,6 +328,8 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
             printDoubleBreak()
             node?.declaredConstructors?.each { visitConstructor(it) }
             printLineBreak()
+            visitObjectInitializerBlocks(node)
+            printLineBreak()
             node?.methods?.each { visitMethod(it) }
         }
         print '}'
@@ -264,6 +337,19 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
         classNameStack.pop()
     }
 
+    private void visitObjectInitializerBlocks(ClassNode node) {
+        for (Statement stmt : node.getObjectInitializerStatements()) {
+            print '{'
+            printLineBreak()
+            indented {
+                stmt.visit(this)
+            }
+            printLineBreak()
+            print '}'
+            printDoubleBreak()
+        }
+    }
+
     private void visitGenerics(GenericsType[] generics) {
 
         if (generics) {
@@ -368,40 +454,10 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
         printDoubleBreak()
     }
 
-    private def visitModifiers(int modifiers) {
-        if (Modifier.isAbstract(modifiers)) {
-            print 'abstract '
-        }
-        if (Modifier.isFinal(modifiers)) {
-            print 'final '
-        }
-        if (Modifier.isInterface(modifiers)) {
-            print 'interface '
-        }
-        if (Modifier.isNative(modifiers)) {
-            print 'native '
-        }
-        if (Modifier.isPrivate(modifiers)) {
-            print 'private '
-        }
-        if (Modifier.isProtected(modifiers)) {
-            print 'protected '
-        }
-        if (Modifier.isPublic(modifiers)) {
-            print 'public '
-        }
-        if (Modifier.isStatic(modifiers)) {
-            print 'static '
-        }
-        if (Modifier.isSynchronized(modifiers)) {
-            print 'synchronized '
-        }
-        if (Modifier.isTransient(modifiers)) {
-            print 'transient '
-        }
-        if (Modifier.isVolatile(modifiers)) {
-            print 'volatile '
-        }
+    private void visitModifiers(int modifiers) {
+        String mods = Modifier.toString(modifiers)
+        mods = mods ? mods + ' ' : mods
+        print mods
     }
 
     @Override
@@ -424,7 +480,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
             // GROOVY-5150: final constants may be initialized directly
             print ' = '
             if (ClassHelper.STRING_TYPE == type) {
-                print "'"+node.initialValueExpression.text.replaceAll("'", "\\\\'")+"'"
+                print "'" + node.initialValueExpression.text.replaceAll("'", "\\\\'") + "'"
             } else if (ClassHelper.char_TYPE == type) {
                 print "'${node.initialValueExpression.text}'"
             } else {
@@ -460,9 +516,22 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitBlockStatement(BlockStatement block) {
-        block?.statements?.each {
-            it.visit(this)
+        if (printStatementLabels(block)) {
+            print '{'
+            printLineBreak()
+            indented {
+                block?.statements?.each {
+                    it.visit(this)
+                    printLineBreak()
+                }
+            }
+            print '}'
             printLineBreak()
+        } else {
+            block?.statements?.each {
+                it.visit(this)
+                printLineBreak()
+            }
         }
         if (!_out.toString().endsWith('\n')) {
             printLineBreak()
@@ -471,7 +540,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitForLoop(ForStatement statement) {
-
+        printStatementLabels(statement)
         print 'for ('
         if (statement?.variable != ForStatement.FOR_LOOP_DUMMY) {
             visitParameters([statement.variable])
@@ -494,6 +563,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitIfElse(IfStatement ifElse) {
+        printStatementLabels(ifElse)
         print 'if ('
         ifElse?.booleanExpression?.visit this
         print ') {'
@@ -529,6 +599,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitSwitch(SwitchStatement statement) {
+        printStatementLabels(statement)
         print 'switch ('
         statement?.expression?.visit this
         print ') {'
@@ -561,12 +632,18 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
     @Override
     void visitBreakStatement(BreakStatement statement) {
         print 'break'
+        if (statement?.label) {
+            print ' ' + statement.label
+        }
         printLineBreak()
     }
 
     @Override
     void visitContinueStatement(ContinueStatement statement) {
         print 'continue'
+        if (statement?.label) {
+            print ' ' + statement.label
+        }
         printLineBreak()
     }
 
@@ -662,6 +739,11 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
         print '}'
     }
 
+    //@Override
+    void visitLambdaExpression(LambdaExpression expression) {
+        visitClosureExpression(expression)
+    }
+
     @Override
     void visitTupleExpression(TupleExpression expression) {
         print '('
@@ -688,7 +770,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
         }
         print '.'
         if (expression?.property instanceof ConstantExpression) {
-            visitConstantExpression(expression?.property, true)
+            visitConstantExpression((ConstantExpression) expression?.property, true)
         } else {
             expression?.property?.visit this
         }
@@ -733,7 +815,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
         // handle multiple assignment expressions
         if (expression?.leftExpression instanceof ArgumentListExpression) {
             print 'def '
-            visitArgumentlistExpression expression?.leftExpression, true
+            visitArgumentlistExpression((ArgumentListExpression) expression?.leftExpression, true)
             print " $expression.operation.text "
             expression.rightExpression.visit this
 
@@ -791,7 +873,6 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
     /**
      * Prints out the type, safely handling arrays.
      * @param classNode
-     *      classnode
      */
     void visitType(ClassNode classNode) {
         def name = classNode.name
@@ -832,14 +913,13 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
     }
 
 
-
     @Override
     void visitMapExpression(MapExpression expression) {
         print '['
         if (expression?.mapEntryExpressions?.size() == 0) {
             print ':'
         } else {
-            visitExpressionsAndCommaSeparate(expression?.mapEntryExpressions)
+            visitExpressionsAndCommaSeparate((List) expression?.mapEntryExpressions)
         }
         print ']'
     }
@@ -864,6 +944,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitTryCatchFinally(TryCatchStatement statement) {
+        printStatementLabels(statement)
         print 'try {'
         printLineBreak()
         indented {
@@ -893,6 +974,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitSynchronizedStatement(SynchronizedStatement statement) {
+        printStatementLabels(statement)
         print 'synchronized ('
         statement?.expression?.visit this
         print ') {'
@@ -924,6 +1006,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitWhileLoop(WhileStatement statement) {
+        printStatementLabels(statement)
         print 'while ('
         statement?.booleanExpression?.visit this
         print ') {'
@@ -938,6 +1021,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
 
     @Override
     void visitDoWhileLoop(DoWhileStatement statement) {
+        printStatementLabels(statement)
         print 'do {'
         printLineBreak()
         indented {
@@ -1012,7 +1096,7 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
                 print ', '
             }
             first = false
-            it.visit this
+            ((ASTNode) it).visit this
         }
     }
 
@@ -1021,5 +1105,24 @@ class AstNodeToScriptVisitor extends CompilationUnit.PrimaryClassNodeOperation i
         print '*:'
         expression?.expression?.visit this
     }
-}
 
+    /**
+     * Prints all labels for the given statement.  The labels will be printed on a single
+     * line and line break will be added.
+     *
+     * @param statement for which to print labels
+     * @return {@code true} if the statement had labels to print, else {@code false}
+     */
+    private boolean printStatementLabels(Statement statement) {
+        List<String> labels = statement?.statementLabels
+        if (labels == null || labels.isEmpty()) {
+            return false
+        }
+        for (String label : labels) {
+            print label + ':'
+            printLineBreak()
+        }
+        return true
+    }
+
+}
diff --git a/subprojects/parser-antlr4/src/test/resources/bugs/BUG-GROOVY-8426.groovy b/subprojects/parser-antlr4/src/test/resources/bugs/BUG-GROOVY-8426.groovy
index aa0e4d4333..917e8cb741 100644
--- a/subprojects/parser-antlr4/src/test/resources/bugs/BUG-GROOVY-8426.groovy
+++ b/subprojects/parser-antlr4/src/test/resources/bugs/BUG-GROOVY-8426.groovy
@@ -17,14 +17,16 @@
  *  under the License.
  */
 
+
+import groovy.transform.CompileDynamic
 import org.codehaus.groovy.ast.ClassNode
 import org.codehaus.groovy.ast.MethodNode
 import org.codehaus.groovy.ast.builder.AstBuilder
 import org.codehaus.groovy.ast.stmt.BlockStatement
 import static org.codehaus.groovy.control.CompilePhase.CONVERSION
 
-
- class Groovy8426Test {
+@CompileDynamic
+class Groovy8426Test {
     void testMethodBlockStatement() {
         def result = new AstBuilder().buildFromString CONVERSION, false, '''
             def method() {

Commit:
936295d8b152a4380b03bce3292735abc3816019
Paul King
paulk@asert.com.au
2018-04-13 17:02:37 +1000
typo and javadoc
diff --git a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
index 07fbdd36b9..d2d0a38735 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilerConfiguration.java
@@ -40,16 +40,11 @@ import java.util.StringTokenizer;
 
 /**
  * Compilation control flags and coordination stuff.
- *
- * @author <a href="mailto:cpoirier@dreaming.org">Chris Poirier</a>
- * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
- * @author <a href="mailto:jim@pagesmiths.com">Jim White</a>
- * @author <a href="mailto:cedric.champeau@gmail.com">Cedric Champeau</a>
  */
 
 public class CompilerConfiguration {
 
-    /** This (<code>"indy"</code>) is the Optimization Option value for enabling <code>invokedynamic</code> complilation. */
+    /** This (<code>"indy"</code>) is the Optimization Option value for enabling <code>invokedynamic</code> compilation. */
     public static final String INVOKEDYNAMIC = "indy";
 
     /** This (<code>"1.4"</code>) is the value for targetBytecode to compile for a JDK 1.4. **/

Commit:
4952a6359d59a79a1a95aa26d122a0cdf6d55c99
sunlan
sunlan@apache.org
2018-04-13 12:13:28 +0800
Refine "GROOVY-8543: Support setting compileStatic by default via system properties"
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index e548a0bf32..b383f7b9f7 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -1187,11 +1187,8 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         classNode.putNodeMetaData(CLASS_NAME, className);
         classNode.setSyntheticPublic(syntheticPublic);
 
-        if (COMPILE_STATIC_BY_DEFAULT) {
-            if (classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
-                attachCompileStaticAnnotation(classNode);
-            }
-        }
+        enableCompileStaticByDefault(classNode);
+
         if (asBoolean(ctx.TRAIT())) {
             attachTraitAnnotation(classNode);
         }
@@ -1262,6 +1259,22 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         return classNode;
     }
 
+    private void enableCompileStaticByDefault(ClassNode classNode) {
+        if (!COMPILE_STATIC_BY_DEFAULT) {
+            return;
+        }
+
+        if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_STATIC)).isEmpty()) {
+            return;
+        }
+
+        if (!classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
+            return;
+        }
+
+        attachCompileStaticAnnotation(classNode);
+    }
+
     private void attachCompileStaticAnnotation(ClassNode classNode) {
         attachAnnotation(classNode, GROOVY_TRANSFORM_COMPILE_STATIC);
     }

Commit:
39e4078c55d9f0824351310eebda260f2fb360ab
sunlan
sunlan@apache.org
2018-04-13 11:35:26 +0800
Refine "GROOVY-8543: Support setting compileStatic by default via system properties"
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 22c59d23b2..e548a0bf32 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -1188,7 +1188,9 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         classNode.setSyntheticPublic(syntheticPublic);
 
         if (COMPILE_STATIC_BY_DEFAULT) {
-            attachCompileStaticAnnotation(classNode);
+            if (classNode.getAnnotations(ClassHelper.make(GROOVY_TRANSFORM_COMPILE_DYNAMIC)).isEmpty()) {
+                attachCompileStaticAnnotation(classNode);
+            }
         }
         if (asBoolean(ctx.TRAIT())) {
             attachTraitAnnotation(classNode);
@@ -4753,6 +4755,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
     private static final String PACKAGE_INFO = "package-info";
     private static final String PACKAGE_INFO_FILE_NAME = PACKAGE_INFO + ".groovy";
     private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
+    private static final String GROOVY_TRANSFORM_COMPILE_DYNAMIC = "groovy.transform.CompileDynamic";
     private static final String GROOVY_TRANSFORM_TRAIT = "groovy.transform.Trait";
     private static final Set<String> PRIMITIVE_TYPE_SET = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("boolean", "char", "byte", "short", "int", "long", "float", "double")));
     private static final Logger LOGGER = Logger.getLogger(AstBuilder.class.getName());

Commit:
81ffc8099bb3916885d796b40d7d811350c67dff
sunlan
sunlan@apache.org
2018-04-13 07:56:00 +0800
GROOVY-8543: Support setting compileStatic by default via system properties
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 80988f61cc..22c59d23b2 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -1187,6 +1187,9 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         classNode.putNodeMetaData(CLASS_NAME, className);
         classNode.setSyntheticPublic(syntheticPublic);
 
+        if (COMPILE_STATIC_BY_DEFAULT) {
+            attachCompileStaticAnnotation(classNode);
+        }
         if (asBoolean(ctx.TRAIT())) {
             attachTraitAnnotation(classNode);
         }
@@ -1257,8 +1260,16 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
         return classNode;
     }
 
+    private void attachCompileStaticAnnotation(ClassNode classNode) {
+        attachAnnotation(classNode, GROOVY_TRANSFORM_COMPILE_STATIC);
+    }
+
     private void attachTraitAnnotation(ClassNode classNode) {
-        classNode.addAnnotation(new AnnotationNode(ClassHelper.make(GROOVY_TRANSFORM_TRAIT)));
+        attachAnnotation(classNode, GROOVY_TRANSFORM_TRAIT);
+    }
+
+    private void attachAnnotation(ClassNode classNode, String annotationClassName) {
+        classNode.addAnnotation(new AnnotationNode(ClassHelper.make(annotationClassName)));
     }
 
     @SuppressWarnings({"unchecked"})
@@ -4741,6 +4752,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
 
     private static final String PACKAGE_INFO = "package-info";
     private static final String PACKAGE_INFO_FILE_NAME = PACKAGE_INFO + ".groovy";
+    private static final String GROOVY_TRANSFORM_COMPILE_STATIC = "groovy.transform.CompileStatic";
     private static final String GROOVY_TRANSFORM_TRAIT = "groovy.transform.Trait";
     private static final Set<String> PRIMITIVE_TYPE_SET = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("boolean", "char", "byte", "short", "int", "long", "float", "double")));
     private static final Logger LOGGER = Logger.getLogger(AstBuilder.class.getName());
@@ -4768,4 +4780,6 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
     private static final String ENCLOSING_INSTANCE_EXPRESSION = "_ENCLOSING_INSTANCE_EXPRESSION";
 
     private static final String CLASS_NAME = "_CLASS_NAME";
+
+    private static final boolean COMPILE_STATIC_BY_DEFAULT = Boolean.getBoolean("groovy.compile.static.by.default");
 }

Commit:
e723618826dbd6cd5abec2bda65f58537aa3f09a
Paul King
paulk@asert.com.au
2018-04-13 03:28:19 +1000
GROOVY-8539: Groovy fails to compile assignment operators on boolean array (closes #683)
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/BinaryBooleanExpressionHelper.java b/src/main/java/org/codehaus/groovy/classgen/asm/BinaryBooleanExpressionHelper.java
index 18e3169c9e..def371b679 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/BinaryBooleanExpressionHelper.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/BinaryBooleanExpressionHelper.java
@@ -24,8 +24,10 @@ import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.runtime.BytecodeInterface8;
 import org.objectweb.asm.MethodVisitor;
 
+import static org.codehaus.groovy.syntax.Types.PLUS;
+
 /**
- * @author <a href="mailto:blackdrag@gmx.org">Jochen "blackdrag" Theodorou</a>
+ * Binary write operations specialised for Booleans
  */
 public class BinaryBooleanExpressionHelper extends BinaryIntExpressionHelper {
 
@@ -49,6 +51,8 @@ public class BinaryBooleanExpressionHelper extends BinaryIntExpressionHelper {
     
     @Override
     protected boolean writeStdOperators(int type, boolean simulate) {
+        type = type - PLUS;
+        if (type < 0 || type > 5 || type == 3 /*DIV*/) return false;
         if (simulate) return false;
         throw new GroovyBugError("should not reach here");
     }
@@ -58,10 +62,6 @@ public class BinaryBooleanExpressionHelper extends BinaryIntExpressionHelper {
         throw new GroovyBugError("should not reach here");
     }
 
-    protected int getBitwiseOperationBytecode(int type) {
-        return -1;
-    }
-    
     protected ClassNode getNormalOpResultType() {
         return ClassHelper.boolean_TYPE;
     }
diff --git a/src/test/groovy/operator/BooleanOperationsTest.groovy b/src/test/groovy/operator/BooleanOperationsTest.groovy
index e86493958d..d062e73413 100644
--- a/src/test/groovy/operator/BooleanOperationsTest.groovy
+++ b/src/test/groovy/operator/BooleanOperationsTest.groovy
@@ -141,4 +141,17 @@ class BooleanOperationsTest extends GroovyTestCase {
         assert z == false
     }
 
+    void testBooleanAssignArrayOps() {
+        boolean[] b = [true]
+        b[0] &= false
+        assert b == [false]
+        b[0] ^= true
+        assert b == [true]
+        b[0] ^= true
+        assert b == [false]
+        b[0] |= true
+        assert b == [true]
+        b[0] |= false
+        assert b == [true]
+    }
 }

Commit:
12d0f4431dcbe419e86cdd23ca7f71670fea4e6e
Paul King
paulk@asert.com.au
2018-04-13 03:25:33 +1000
GROOVY-8211: part two - check declaration expressions
diff --git a/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java b/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
index b4f38544aa..e623b18c50 100644
--- a/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
@@ -26,6 +26,9 @@ import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.DeclarationExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.TupleExpression;
 
 /**
  * Verify correct usage of generics.
@@ -86,6 +89,21 @@ public class GenericsVisitor extends ClassCodeVisitorSupport {
         super.visitMethod(node);
     }
 
+    @Override
+    public void visitDeclarationExpression(DeclarationExpression expression) {
+        if (expression.isMultipleAssignmentDeclaration()) {
+            TupleExpression tExpr = expression.getTupleExpression();
+            for (Expression nextExpr : tExpr.getExpressions()) {
+                ClassNode declType = nextExpr.getType();
+                checkGenericsUsage(declType, declType.redirect());
+            }
+        } else {
+            ClassNode declType = expression.getVariableExpression().getType();
+            checkGenericsUsage(declType, declType.redirect());
+        }
+        super.visitDeclarationExpression(expression);
+    }
+
     private boolean checkWildcard(ClassNode cn) {
         ClassNode sn = cn.getUnresolvedSuperClass(false);
         if (sn == null) return false;
diff --git a/src/test/gls/generics/GenericsTest.groovy b/src/test/gls/generics/GenericsTest.groovy
index 0f9e0ed80a..8a68145f4d 100644
--- a/src/test/gls/generics/GenericsTest.groovy
+++ b/src/test/gls/generics/GenericsTest.groovy
@@ -576,6 +576,12 @@ import java.util.concurrent.atomic.AtomicInteger
         shouldFailCompilationWithMessages '''
             class MyClass { Map<String, Map<String>> map }
         ''', ['(supplied with 1 type parameter)', 'which takes 2 parameters']
+        shouldFailCompilationWithMessages '''
+             def method() { Map<String> map }
+        ''', ['(supplied with 1 type parameter)', 'which takes 2 parameters']
+        shouldFailCompilationWithMessages '''
+             def method() { Map<String, Map<String>> map }
+        ''', ['(supplied with 1 type parameter)', 'which takes 2 parameters']
         assertScript '''
             List<String> ss = new LinkedList<>()
         '''
diff --git a/src/test/groovy/bugs/Groovy4190Bug.groovy b/src/test/groovy/bugs/Groovy4190Bug.groovy
index 1250a69828..8e0615802b 100644
--- a/src/test/groovy/bugs/Groovy4190Bug.groovy
+++ b/src/test/groovy/bugs/Groovy4190Bug.groovy
@@ -41,11 +41,11 @@ class Groovy4190Bug extends CompilableTestSupport {
     
     void testGenericsUsageInMethodCall2() {
         shouldCompile """
-            class Test4190V2<E> {
+            class Test4190V2<K,V> {
                 public static void main(String[] args) {
                     Test4190V2<Integer, String> t = Test4190V2.<Integer, String>create();
                 }
             }
         """
     }
-}
\ No newline at end of file
+}
diff --git a/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt b/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
index 825bb63a33..a40cb623d1 100644
--- a/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
+++ b/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
@@ -256,7 +256,7 @@ class Bean {
     public value
 }
 def bean = new Bean(value:42)
-def vlaue = bean.@value
+def value = bean.@value
 :::[AttributeExpression,(5:13),(5:24)][VariableExpression,(5:13),(5:17)][ConstantExpression,(5:19),(5:24)]
 
 ###AttributeExpression2:::
diff --git a/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr2.txt b/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr2.txt
index 54e707dd00..15ab366293 100644
--- a/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr2.txt
+++ b/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr2.txt
@@ -192,9 +192,9 @@ Collection<? super File> c
 [ClassNode,(1:20),(1:24)]
 
 ###typeArgumentsLowerAndUpperBound:::
-Collection<? extends String,? super File> c
-:::[ClassNode,(1:1),(1:11)][GenericsType,(1:12),(1:28)][ClassNode,(-1:-1),(-1:-1)][ClassNode,(1:22),(1:28)];
-[GenericsType,(1:29),(1:41)][ClassNode,(-1:-1),(-1:-1)][ClassNode,(1:37),(1:41)]
+Map<? extends String,? super File> m
+:::[ClassNode,(1:1),(1:4)][GenericsType,(1:5),(1:21)][ClassNode,(-1:-1),(-1:-1)][ClassNode,(1:15),(1:21)];
+[GenericsType,(1:22),(1:34)][ClassNode,(-1:-1),(-1:-1)][ClassNode,(1:30),(1:34)]
 
 ###typeArgumentNested:::
 class C<Y,T extends Map<String,Map<Y,Integer>>> {}
diff --git a/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr4.txt b/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr4.txt
index 4eb0cb8a0f..d7dec5b096 100644
--- a/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr4.txt
+++ b/src/test/org/codehaus/groovy/ast/LineColumnCheck_antlr4.txt
@@ -192,9 +192,9 @@ Collection<? super File> c
 [ClassNode,(1:20),(1:24)]
 
 ###typeArgumentsLowerAndUpperBound:::
-Collection<? extends String,? super File> c
-:::[ClassNode,(1:1),(1:42)][GenericsType,(1:12),(1:28)][ClassNode,(1:12),(1:13)][ClassNode,(1:22),(1:28)];
-[GenericsType,(1:29),(1:41)][ClassNode,(1:29),(1:30)][ClassNode,(1:37),(1:41)]
+Map<? extends String,? super File> m
+:::[ClassNode,(1:1),(1:35)][GenericsType,(1:5),(1:21)][ClassNode,(1:5),(1:6)][ClassNode,(1:15),(1:21)];
+[GenericsType,(1:22),(1:34)][ClassNode,(1:22),(1:23)][ClassNode,(1:30),(1:34)]
 
 ###typeArgumentNested:::
 class C<Y,T extends Map<String,Map<Y,Integer>>> {}

Commit:
a012487b53fccab125b3d9ca8d31eb979570a401
Paul King
paulk@asert.com.au
2018-04-13 03:25:32 +1000
GROOVY-8211: part one - also show nested type parameter arity mismatches
diff --git a/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java b/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
index 53885cf2dd..b4f38544aa 100644
--- a/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
@@ -28,8 +28,13 @@ import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 
 /**
- * class used to verify correct usage of generics in
- * class header (class and superclass declaration)
+ * Verify correct usage of generics.
+ * This includes:
+ * <ul>
+ * <li>class header (class and superclass declaration)</li>
+ * <li>arity of type parameters for fields, parameters, local variables</li>
+ * <li>invalid diamond &;t;&gt; usage</li>
+ * </ul>
  */
 public class GenericsVisitor extends ClassCodeVisitorSupport {
     private final SourceUnit source;
@@ -135,10 +140,12 @@ public class GenericsVisitor extends ClassCodeVisitorSupport {
             addError(message, n);
             return;
         }
-        // check bounds
         for (int i = 0; i < nTypes.length; i++) {
             ClassNode nType = nTypes[i].getType();
             ClassNode cnType = cnTypes[i].getType();
+            // check nested type parameters
+            checkGenericsUsage(nType, nType.redirect());
+            // check bounds
             if (!nType.isDerivedFrom(cnType)) {
                 if (cnType.isInterface() && nType.implementsInterface(cnType)) continue;
                 addError("The type " + nTypes[i].getName() +
diff --git a/src/test/gls/generics/GenericsTest.groovy b/src/test/gls/generics/GenericsTest.groovy
index 59fea06c11..0f9e0ed80a 100644
--- a/src/test/gls/generics/GenericsTest.groovy
+++ b/src/test/gls/generics/GenericsTest.groovy
@@ -564,6 +564,18 @@ import java.util.concurrent.atomic.AtomicInteger
         shouldFailCompilationWithMessages '''
             def now = new Date<Calendar>()
         ''', ['supplied with 1 type parameter', 'which takes no parameters']
+        shouldFailCompilationWithMessages '''
+            def method(Map<String> map) { map.toString() }
+        ''', ['(supplied with 1 type parameter)', 'which takes 2 parameters']
+        shouldFailCompilationWithMessages '''
+            def method(Map<String, Map<String>> map) { map.toString() }
+        ''', ['(supplied with 1 type parameter)', 'which takes 2 parameters']
+        shouldFailCompilationWithMessages '''
+            class MyClass { Map<String> map }
+        ''', ['(supplied with 1 type parameter)', 'which takes 2 parameters']
+        shouldFailCompilationWithMessages '''
+            class MyClass { Map<String, Map<String>> map }
+        ''', ['(supplied with 1 type parameter)', 'which takes 2 parameters']
         assertScript '''
             List<String> ss = new LinkedList<>()
         '''

Commit:
cb7db51e2c41a4ed5ca2c179dc3d0b2e7b6b5618
Paul King
paulk@asert.com.au
2018-04-13 03:25:30 +1000
formatting
diff --git a/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java b/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
index 36ef5ea725..53885cf2dd 100644
--- a/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/GenericsVisitor.java
@@ -30,8 +30,6 @@ import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 /**
  * class used to verify correct usage of generics in
  * class header (class and superclass declaration)
- *
- * @author Jochen Theodorou
  */
 public class GenericsVisitor extends ClassCodeVisitorSupport {
     private final SourceUnit source;
@@ -48,7 +46,7 @@ public class GenericsVisitor extends ClassCodeVisitorSupport {
     public void visitClass(ClassNode node) {
         boolean error = checkWildcard(node);
         if (error) return;
-        boolean isAnon = node instanceof InnerClassNode && ((InnerClassNode)node).isAnonymous();
+        boolean isAnon = node instanceof InnerClassNode && ((InnerClassNode) node).isAnonymous();
         checkGenericsUsage(node.getUnresolvedSuperClass(false), node.getSuperClass(), isAnon ? true : null);
         ClassNode[] interfaces = node.getInterfaces();
         for (ClassNode anInterface : interfaces) {
@@ -67,7 +65,7 @@ public class GenericsVisitor extends ClassCodeVisitorSupport {
     @Override
     public void visitConstructorCallExpression(ConstructorCallExpression call) {
         ClassNode type = call.getType();
-        boolean isAnon = type instanceof InnerClassNode && ((InnerClassNode)type).isAnonymous();
+        boolean isAnon = type instanceof InnerClassNode && ((InnerClassNode) type).isAnonymous();
         checkGenericsUsage(type, type.redirect(), isAnon);
     }
 

Commit:
322e862749e9f38ff6108b3b1a94cdb533832fd0
danielsun1106
realbluesun@hotmail.com
2018-04-12 22:19:58 +0800
Refine arguments validation and the test of GROOVY-8542
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 2372d44fbb..80988f61cc 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -2291,25 +2291,19 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
                     return configureAST(propertyExpression, ctx);
                 }
             }
-        }
-
-        if (asBoolean(ctx.creator())) {
+        } else if (asBoolean(ctx.creator())) {
             CreatorContext creatorContext = ctx.creator();
             creatorContext.putNodeMetaData(ENCLOSING_INSTANCE_EXPRESSION, baseExpr);
 
             return configureAST(this.visitCreator(creatorContext), ctx);
-        }
-
-        if (asBoolean(ctx.indexPropertyArgs())) { // e.g. list[1, 3, 5]
+        } else if (asBoolean(ctx.indexPropertyArgs())) { // e.g. list[1, 3, 5]
             Tuple2<Token, Expression> tuple = this.visitIndexPropertyArgs(ctx.indexPropertyArgs());
             boolean isSafeChain = isTrue(baseExpr, PATH_EXPRESSION_BASE_EXPR_SAFE_CHAIN);
 
             return configureAST(
                     new BinaryExpression(baseExpr, createGroovyToken(tuple.getFirst()), tuple.getSecond(), isSafeChain || asBoolean(ctx.indexPropertyArgs().QUESTION())),
                     ctx);
-        }
-
-        if (asBoolean(ctx.namedPropertyArgs())) { // this is a special way to new instance, e.g. Person(name: 'Daniel.Sun', location: 'Shanghai')
+        } else if (asBoolean(ctx.namedPropertyArgs())) { // this is a special way to new instance, e.g. Person(name: 'Daniel.Sun', location: 'Shanghai')
             List<MapEntryExpression> mapEntryExpressionList =
                     this.visitNamedPropertyArgs(ctx.namedPropertyArgs());
 
@@ -2346,9 +2340,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
             return configureAST(
                     new BinaryExpression(baseExpr, createGroovyToken(ctx.namedPropertyArgs().LBRACK().getSymbol()), right),
                     ctx);
-        }
-
-        if (asBoolean(ctx.arguments())) {
+        } else if (asBoolean(ctx.arguments())) {
             Expression argumentsExpr = this.visitArguments(ctx.arguments());
             configureAST(argumentsExpr, ctx);
 
@@ -2417,9 +2409,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
 
             // e.g. 1(), 1.1(), ((int) 1 / 2)(1, 2), {a, b -> a + b }(1, 2), m()()
             return configureAST(createCallMethodCallExpression(baseExpr, argumentsExpr), ctx);
-        }
-
-        if (asBoolean(ctx.closure())) {
+        } else if (asBoolean(ctx.closure())) {
             ClosureExpression closureExpression = this.visitClosure(ctx.closure());
 
             if (baseExpr instanceof MethodCallExpression) {
@@ -3162,8 +3152,12 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
             if (null != enclosingInstanceExpression) {
                 if (arguments instanceof ArgumentListExpression) {
                     ((ArgumentListExpression) arguments).getExpressions().add(0, enclosingInstanceExpression);
-                } else if (arguments instanceof TupleExpression || arguments instanceof NamedArgumentListExpression) {
+                } else if (arguments instanceof TupleExpression) {
                     throw createParsingFailedException("Creating instance of non-static class does not support named parameters", arguments);
+                } else if (arguments instanceof NamedArgumentListExpression) {
+                    throw createParsingFailedException("Unexpected arguments", arguments);
+                } else {
+                    throw createParsingFailedException("Unsupported arguments", arguments); // should never reach here
                 }
             }
 
diff --git a/subprojects/parser-antlr4/src/test/resources/core/NonStaticClass_01x.groovy b/subprojects/parser-antlr4/src/test/resources/core/NonStaticClass_01x.groovy
index 007978a4c4..4b70e29648 100644
--- a/subprojects/parser-antlr4/src/test/resources/core/NonStaticClass_01x.groovy
+++ b/subprojects/parser-antlr4/src/test/resources/core/NonStaticClass_01x.groovy
@@ -16,7 +16,6 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-
 public class Y {
     public class X {
         def name
@@ -47,13 +46,16 @@ public class Y {
                         new X('Daniel')
                                         .name
     }
-}
 
-def createY() {
-    return new Y()
+    public static String getXName3() {
+        return createY().
+                new X('Daniel')
+                                .getName()
+    }
 }
 
 assert 'Daniel' == Y.createX(new Y()).name
 assert 'Daniel' == Y.createX().name
 assert 'Daniel' == Y.getXName()
 assert 'Daniel' == Y.getXName2()
+assert 'Daniel' == Y.getXName3()

Commit:
3f35148f900b0743981b15f7fccc19f036bca1ec
Paul King
paulk@asert.com.au
2018-04-12 13:52:54 +1000
GROOVY-8211: pre-factor avoid AIOOBE with clearer message but real fix to come
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
index b562ab8df4..31f6c6e939 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -159,6 +159,11 @@ public class GenericsUtils {
         if (parameterized == null || parameterized.length == 0) return;
         GenericsType[] redirectGenericsTypes = node.redirect().getGenericsTypes();
         if (redirectGenericsTypes == null) redirectGenericsTypes = parameterized;
+        if (redirectGenericsTypes.length != parameterized.length) {
+            throw new GroovyBugError("Expected earlier checking to detect generics parameter arity mismatch" +
+                    "\nExpected: " + node.getName() + toGenericTypesString(redirectGenericsTypes) +
+                    "\nSupplied: " + node.getName() + toGenericTypesString(parameterized));
+        }
         for (int i = 0; i < redirectGenericsTypes.length; i++) {
             GenericsType redirectType = redirectGenericsTypes[i];
             if (redirectType.isPlaceholder()) {
@@ -185,6 +190,20 @@ public class GenericsUtils {
         }
     }
 
+    private static String toGenericTypesString(GenericsType[] genericsTypes) {
+        if (genericsTypes == null) return "";
+        StringBuilder sb = new StringBuilder("<");
+        for (int i = 0; i < genericsTypes.length; i++) {
+            final GenericsType genericsType = genericsTypes[i];
+            sb.append(genericsType.toString());
+            if (i < genericsTypes.length - 1) {
+                sb.append(",");
+            }
+        }
+        sb.append("> ");
+        return sb.toString();
+    }
+
     /**
      * Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()}
      * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type

Commit:
bc254b19f2d585da5430ea5fa81b72e0761efd31
sunlan
sunlan@apache.org
2018-04-12 08:40:48 +0800
Support creating instances of non-static inner classes of Java style
diff --git a/src/antlr/GroovyParser.g4 b/src/antlr/GroovyParser.g4
index 385fd11130..aef9289736 100644
--- a/src/antlr/GroovyParser.g4
+++ b/src/antlr/GroovyParser.g4
@@ -816,7 +816,7 @@ expression
         right=expression                                                                    #shiftExprAlt
 
     // boolean relational expressions (level 7)
-    |   left=expression nls op=(AS | INSTANCEOF | NOT_INSTANCEOF) nls type           #relationalExprAlt
+    |   left=expression nls op=(AS | INSTANCEOF | NOT_INSTANCEOF) nls type                  #relationalExprAlt
     |   left=expression nls op=(LE | GE | GT | LT | IN | NOT_IN)  nls right=expression      #relationalExprAlt
 
     // equality/inequality (==/!=) (level 8)
@@ -927,7 +927,7 @@ commandArgument
  *  (Compare to a C lvalue, or LeftHandSide in the JLS section 15.26.)
  *  General expressions are built up from path expressions, using operators like '+' and '='.
  *
- *  t   0: primary, 1: namePart, 2: arguments, 3: closure, 4: indexPropertyArgs, 5: namedPropertyArgs
+ *  t   0: primary, 1: namePart, 2: arguments, 3: closure, 4: indexPropertyArgs, 5: namedPropertyArgs, 6: non-static inner class creator
  */
 pathExpression returns [int t]
     :   primary (pathElement { $t = $pathElement.t; })*
@@ -950,7 +950,9 @@ pathElement returns [int t]
         )
         namePart
         { $t = 1; }
-
+    |
+        DOT nls NEW creator[1]
+        { $t = 6; }
     |   arguments
         { $t = 2; }
 
@@ -1021,7 +1023,7 @@ primary
         identifier typeArguments?                                                           #identifierPrmrAlt
     |   literal                                                                             #literalPrmrAlt
     |   gstring                                                                             #gstringPrmrAlt
-    |   NEW nls creator                                                                     #newPrmrAlt
+    |   NEW nls creator[0]                                                                  #newPrmrAlt
     |   THIS                                                                                #thisPrmrAlt
     |   SUPER                                                                               #superPrmrAlt
     |   parExpression                                                                       #parenPrmrAlt
@@ -1058,11 +1060,14 @@ mapEntryLabel
     |   primary
     ;
 
-creator
+/**
+ *  t 0: general creation; 1: non-static inner class creation
+ */
+creator[int t]
     :   createdName
-        (   nls arguments anonymousInnerClassDeclaration[0]?
-        |   (annotationsOpt LBRACK expression RBRACK)+ dimsOpt
-        |   dims nls arrayInitializer
+        (   {0 == $t || 1 == $t}? nls arguments anonymousInnerClassDeclaration[0]?
+        |   {0 == $t}?            (annotationsOpt LBRACK expression RBRACK)+ dimsOpt
+        |   {0 == $t}?            dims nls arrayInitializer
         )
     ;
 
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 0776856f4a..2372d44fbb 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -2293,6 +2293,13 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
             }
         }
 
+        if (asBoolean(ctx.creator())) {
+            CreatorContext creatorContext = ctx.creator();
+            creatorContext.putNodeMetaData(ENCLOSING_INSTANCE_EXPRESSION, baseExpr);
+
+            return configureAST(this.visitCreator(creatorContext), ctx);
+        }
+
         if (asBoolean(ctx.indexPropertyArgs())) { // e.g. list[1, 3, 5]
             Tuple2<Token, Expression> tuple = this.visitIndexPropertyArgs(ctx.indexPropertyArgs());
             boolean isSafeChain = isTrue(baseExpr, PATH_EXPRESSION_BASE_EXPR_SAFE_CHAIN);
@@ -3147,9 +3154,19 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
     @Override
     public Expression visitCreator(CreatorContext ctx) {
         ClassNode classNode = this.visitCreatedName(ctx.createdName());
-        Expression arguments = this.visitArguments(ctx.arguments());
 
         if (asBoolean(ctx.arguments())) { // create instance of class
+            Expression arguments = this.visitArguments(ctx.arguments());
+            Expression enclosingInstanceExpression = ctx.getNodeMetaData(ENCLOSING_INSTANCE_EXPRESSION);
+
+            if (null != enclosingInstanceExpression) {
+                if (arguments instanceof ArgumentListExpression) {
+                    ((ArgumentListExpression) arguments).getExpressions().add(0, enclosingInstanceExpression);
+                } else if (arguments instanceof TupleExpression || arguments instanceof NamedArgumentListExpression) {
+                    throw createParsingFailedException("Creating instance of non-static class does not support named parameters", arguments);
+                }
+            }
+
             if (asBoolean(ctx.anonymousInnerClassDeclaration())) {
                 ctx.anonymousInnerClassDeclaration().putNodeMetaData(ANONYMOUS_INNER_CLASS_SUPER_CLASS, classNode);
                 InnerClassNode anonymousInnerClassNode = this.visitAnonymousInnerClassDeclaration(ctx.anonymousInnerClassDeclaration());
@@ -4754,6 +4771,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
     private static final String ANONYMOUS_INNER_CLASS_SUPER_CLASS = "_ANONYMOUS_INNER_CLASS_SUPER_CLASS";
     private static final String INTEGER_LITERAL_TEXT = "_INTEGER_LITERAL_TEXT";
     private static final String FLOATING_POINT_LITERAL_TEXT = "_FLOATING_POINT_LITERAL_TEXT";
+    private static final String ENCLOSING_INSTANCE_EXPRESSION = "_ENCLOSING_INSTANCE_EXPRESSION";
 
     private static final String CLASS_NAME = "_CLASS_NAME";
 }
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
index 4701e77ef2..8dae27e485 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
@@ -383,6 +383,10 @@ class GroovyParserTest extends GroovyTestCase {
         doRunAndTestAntlr4('core/String_01x.groovy');
     }
 
+    void "test groovy core - NonStaticClass"() {
+        doRunAndTestAntlr4('core/NonStaticClass_01x.groovy');
+    }
+
     void "test groovy core - BUG"() {
         doRunAndTestAntlr4('bugs/BUG-GROOVY-4757.groovy')
         doRunAndTestAntlr4('bugs/BUG-GROOVY-5652.groovy')
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
index c23e8f4b9e..0fdef50c89 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
@@ -222,6 +222,10 @@ class SyntaxErrorTest extends GroovyTestCase {
         TestUtils.doRunAndShouldFail('fail/String_02x.groovy');
     }
 
+    void "test groovy core - NonStaticClass"() {
+        TestUtils.doRunAndShouldFail('fail/NonStaticClass_01x.groovy');
+    }
+
     /**************************************/
     static unzipScriptAndShouldFail(String entryName, List ignoreClazzList, Map<String, String> replacementsMap=[:], boolean toCheckNewParserOnly = false) {
         ignoreClazzList.addAll(TestUtils.COMMON_IGNORE_CLASS_LIST)
diff --git a/subprojects/parser-antlr4/src/test/resources/core/NonStaticClass_01x.groovy b/subprojects/parser-antlr4/src/test/resources/core/NonStaticClass_01x.groovy
new file mode 100644
index 0000000000..007978a4c4
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/core/NonStaticClass_01x.groovy
@@ -0,0 +1,59 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+public class Y {
+    public class X {
+        def name
+
+        public X(String name) {
+            this.name = name
+        }
+    }
+
+    public static Y createY() {
+        return new Y()
+    }
+
+    public static X createX(Y y) {
+        return y.new X('Daniel')
+    }
+
+    public static X createX() {
+        return createY().new X('Daniel')
+    }
+
+    public static String getXName() {
+        return createY().new X('Daniel').name
+    }
+
+    public static String getXName2() {
+        return createY().
+                        new X('Daniel')
+                                        .name
+    }
+}
+
+def createY() {
+    return new Y()
+}
+
+assert 'Daniel' == Y.createX(new Y()).name
+assert 'Daniel' == Y.createX().name
+assert 'Daniel' == Y.getXName()
+assert 'Daniel' == Y.getXName2()
diff --git a/subprojects/parser-antlr4/src/test/resources/fail/NonStaticClass_01x.groovy b/subprojects/parser-antlr4/src/test/resources/fail/NonStaticClass_01x.groovy
new file mode 100644
index 0000000000..5774e6edd3
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/fail/NonStaticClass_01x.groovy
@@ -0,0 +1,33 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+public class Y {
+    public class X {
+        def name
+
+        public X(String name) {
+            this.name = name
+        }
+    }
+
+    public static X createX(Y y) {
+        return y.new X(name:'Daniel')
+    }
+}
+assert 'Daniel' == Y.createX(new Y()).name

Commit:
d033d1ce591389f867698b49558621e899a91788
Paul King
paulk@asert.com.au
2018-04-12 10:12:09 +1000
formatting only
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 126ef424bd..b562ab8df4 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -52,9 +52,6 @@ import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.implem
 
 /**
  * Utility methods to deal with generic types.
- *
- * @author Cedric Champeau
- * @author Paul King
  */
 public class GenericsUtils {
     public static final GenericsType[] EMPTY_GENERICS_ARRAY = GenericsType.EMPTY_ARRAY;
@@ -65,28 +62,29 @@ public class GenericsUtils {
      * class uses generic type <pre>&lt;T,U,V&gt;</pre> (redirectGenericTypes), is used with actual type parameters
      * <pre>&lt;java.lang.String, U,V&gt;</pre>, then a class or interface using generic types <pre>&lt;T,V&gt;</pre>
      * will be aligned to <pre>&lt;java.lang.String,V&gt;</pre>
+     *
      * @param redirectGenericTypes the type arguments or the redirect class node
-     * @param parameterizedTypes the actual type arguments used on this class node
-     * @param alignmentTarget the generic type arguments to which we want to align to
+     * @param parameterizedTypes   the actual type arguments used on this class node
+     * @param alignmentTarget      the generic type arguments to which we want to align to
      * @return aligned type arguments
      * @deprecated You shouldn't call this method because it is inherently unreliable
      */
     @Deprecated
     public static GenericsType[] alignGenericTypes(final GenericsType[] redirectGenericTypes, final GenericsType[] parameterizedTypes, final GenericsType[] alignmentTarget) {
-        if (alignmentTarget==null) return EMPTY_GENERICS_ARRAY;
-        if (parameterizedTypes==null || parameterizedTypes.length==0) return alignmentTarget;
+        if (alignmentTarget == null) return EMPTY_GENERICS_ARRAY;
+        if (parameterizedTypes == null || parameterizedTypes.length == 0) return alignmentTarget;
         GenericsType[] generics = new GenericsType[alignmentTarget.length];
         for (int i = 0, scgtLength = alignmentTarget.length; i < scgtLength; i++) {
             final GenericsType currentTarget = alignmentTarget[i];
             GenericsType match = null;
-            if (redirectGenericTypes!=null) {
+            if (redirectGenericTypes != null) {
                 for (int j = 0; j < redirectGenericTypes.length && match == null; j++) {
                     GenericsType redirectGenericType = redirectGenericTypes[j];
                     if (redirectGenericType.isCompatibleWith(currentTarget.getType())) {
                         if (currentTarget.isPlaceholder() && redirectGenericType.isPlaceholder() && !currentTarget.getName().equals(redirectGenericType.getName())) {
                             // check if there's a potential better match
                             boolean skip = false;
-                            for (int k=j+1; k<redirectGenericTypes.length && !skip; k++) {
+                            for (int k = j + 1; k < redirectGenericTypes.length && !skip; k++) {
                                 GenericsType ogt = redirectGenericTypes[k];
                                 if (ogt.isPlaceholder() && ogt.isCompatibleWith(currentTarget.getType()) && ogt.getName().equals(currentTarget.getName())) {
                                     skip = true;
@@ -99,12 +97,12 @@ public class GenericsUtils {
                             // if alignment target is a wildcard type
                             // then we must make best effort to return a parameterized
                             // wildcard
-                            ClassNode lower = currentTarget.getLowerBound()!=null?match.getType():null;
+                            ClassNode lower = currentTarget.getLowerBound() != null ? match.getType() : null;
                             ClassNode[] currentUpper = currentTarget.getUpperBounds();
-                            ClassNode[] upper = currentUpper !=null?new ClassNode[currentUpper.length]:null;
-                            if (upper!=null) {
+                            ClassNode[] upper = currentUpper != null ? new ClassNode[currentUpper.length] : null;
+                            if (upper != null) {
                                 for (int k = 0; k < upper.length; k++) {
-                                    upper[k] = currentUpper[k].isGenericsPlaceHolder()?match.getType():currentUpper[k];
+                                    upper[k] = currentUpper[k].isGenericsPlaceHolder() ? match.getType() : currentUpper[k];
                                 }
                             }
                             match = new GenericsType(ClassHelper.makeWithoutCaching("?"), upper, lower);
@@ -116,7 +114,7 @@ public class GenericsUtils {
             if (match == null) {
                 match = currentTarget;
             }
-            generics[i]=match;
+            generics[i] = match;
         }
         return generics;
     }
@@ -124,6 +122,7 @@ public class GenericsUtils {
     /**
      * Generates a wildcard generic type in order to be used for checks against class nodes.
      * See {@link GenericsType#isCompatibleWith(org.codehaus.groovy.ast.ClassNode)}.
+     *
      * @param types the type to be used as the wildcard upper bound
      * @return a wildcard generics type
      */
@@ -143,8 +142,9 @@ public class GenericsUtils {
     /**
      * For a given classnode, fills in the supplied map with the parameterized
      * types it defines.
-     * @param node
-     * @param map
+     *
+     * @param node the class node to check
+     * @param map the generics type information collector
      */
     public static void extractPlaceholders(ClassNode node, Map<String, GenericsType> map) {
         if (node == null) return;
@@ -158,7 +158,7 @@ public class GenericsUtils {
         GenericsType[] parameterized = node.getGenericsTypes();
         if (parameterized == null || parameterized.length == 0) return;
         GenericsType[] redirectGenericsTypes = node.redirect().getGenericsTypes();
-        if (redirectGenericsTypes==null) redirectGenericsTypes = parameterized;
+        if (redirectGenericsTypes == null) redirectGenericsTypes = parameterized;
         for (int i = 0; i < redirectGenericsTypes.length; i++) {
             GenericsType redirectType = redirectGenericsTypes[i];
             if (redirectType.isPlaceholder()) {
@@ -168,11 +168,11 @@ public class GenericsUtils {
                     map.put(name, value);
                     if (value.isWildcard()) {
                         ClassNode lowerBound = value.getLowerBound();
-                        if (lowerBound!=null) {
+                        if (lowerBound != null) {
                             extractPlaceholders(lowerBound, map);
                         }
                         ClassNode[] upperBounds = value.getUpperBounds();
-                        if (upperBounds!=null) {
+                        if (upperBounds != null) {
                             for (ClassNode upperBound : upperBounds) {
                                 extractPlaceholders(upperBound, map);
                             }
@@ -190,7 +190,8 @@ public class GenericsUtils {
      * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type
      * arguments. This method allows returning a parameterized interface given the parameterized class
      * node which implements this interface.
-     * @param hint the class node where generics types are parameterized
+     *
+     * @param hint   the class node where generics types are parameterized
      * @param target the interface we want to parameterize generics types
      * @return a parameterized interface class node
      * @deprecated Use #parameterizeType instead
@@ -205,7 +206,8 @@ public class GenericsUtils {
      * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type
      * arguments. This method allows returning a parameterized interface given the parameterized class
      * node which implements this interface.
-     * @param hint the class node where generics types are parameterized
+     *
+     * @param hint   the class node where generics types are parameterized
      * @param target the interface we want to parameterize generics types
      * @return a parameterized interface class node
      */
@@ -282,7 +284,7 @@ public class GenericsUtils {
         return makeClassSafe0(type, gtypes);
     }
 
-    public static MethodNode correctToGenericsSpec(Map<String,ClassNode> genericsSpec, MethodNode mn) {
+    public static MethodNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, MethodNode mn) {
         ClassNode correctedType = correctToGenericsSpecRecurse(genericsSpec, mn.getReturnType());
         Parameter[] origParameters = mn.getParameters();
         Parameter[] newParameters = new Parameter[origParameters.length];
@@ -293,26 +295,26 @@ public class GenericsUtils {
         return new MethodNode(mn.getName(), mn.getModifiers(), correctedType, newParameters, mn.getExceptions(), mn.getCode());
     }
 
-    public static ClassNode correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode type) {
+    public static ClassNode correctToGenericsSpecRecurse(Map<String, ClassNode> genericsSpec, ClassNode type) {
         return correctToGenericsSpecRecurse(genericsSpec, type, new ArrayList<String>());
     }
 
     /**
      * @since 2.4.1
      */
-    public static ClassNode[] correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode[] types) {
-        if (types==null || types.length==1) return types;
+    public static ClassNode[] correctToGenericsSpecRecurse(Map<String, ClassNode> genericsSpec, ClassNode[] types) {
+        if (types == null || types.length == 1) return types;
         ClassNode[] newTypes = new ClassNode[types.length];
         boolean modified = false;
-        for (int i=0; i<types.length; i++) {
+        for (int i = 0; i < types.length; i++) {
             newTypes[i] = correctToGenericsSpecRecurse(genericsSpec, types[i], new ArrayList<String>());
-            modified = modified || (types[i]!=newTypes[i]);
+            modified = modified || (types[i] != newTypes[i]);
         }
         if (!modified) return types;
         return newTypes;
     }
 
-    public static ClassNode correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode type, List<String> exclusions) {
+    public static ClassNode correctToGenericsSpecRecurse(Map<String, ClassNode> genericsSpec, ClassNode type, List<String> exclusions) {
         if (type.isArray()) {
             return correctToGenericsSpecRecurse(genericsSpec, type.getComponentType(), exclusions).makeArray();
         }
@@ -332,21 +334,21 @@ public class GenericsUtils {
             newgTypes = new GenericsType[oldgTypes.length];
             for (int i = 0; i < newgTypes.length; i++) {
                 GenericsType oldgType = oldgTypes[i];
-                if (oldgType.isPlaceholder() ) {
-                    if (genericsSpec.get(oldgType.getName())!=null) {
+                if (oldgType.isPlaceholder()) {
+                    if (genericsSpec.get(oldgType.getName()) != null) {
                         newgTypes[i] = new GenericsType(genericsSpec.get(oldgType.getName()));
                     } else {
                         newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);
                     }
                 } else if (oldgType.isWildcard()) {
                     ClassNode oldLower = oldgType.getLowerBound();
-                    ClassNode lower = oldLower!=null?correctToGenericsSpecRecurse(genericsSpec, oldLower, exclusions):null;
+                    ClassNode lower = oldLower != null ? correctToGenericsSpecRecurse(genericsSpec, oldLower, exclusions) : null;
                     ClassNode[] oldUpper = oldgType.getUpperBounds();
                     ClassNode[] upper = null;
-                    if (oldUpper!=null) {
+                    if (oldUpper != null) {
                         upper = new ClassNode[oldUpper.length];
                         for (int j = 0; j < oldUpper.length; j++) {
-                            upper[j] = correctToGenericsSpecRecurse(genericsSpec,oldUpper[j], exclusions);
+                            upper[j] = correctToGenericsSpecRecurse(genericsSpec, oldUpper[j], exclusions);
                         }
                     }
                     GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);
@@ -354,7 +356,7 @@ public class GenericsUtils {
                     fixed.setWildcard(true);
                     newgTypes[i] = fixed;
                 } else {
-                    newgTypes[i] = new GenericsType(correctToGenericsSpecRecurse(genericsSpec,correctToGenericsSpec(genericsSpec, oldgType), exclusions));
+                    newgTypes[i] = new GenericsType(correctToGenericsSpecRecurse(genericsSpec, correctToGenericsSpec(genericsSpec, oldgType), exclusions));
                 }
             }
         }
@@ -371,7 +373,7 @@ public class GenericsUtils {
         return ret;
     }
 
-    public static ClassNode correctToGenericsSpec(Map<String,ClassNode> genericsSpec, ClassNode type) {
+    public static ClassNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, ClassNode type) {
         if (type.isArray()) {
             return correctToGenericsSpec(genericsSpec, type.getComponentType()).makeArray();
         }
@@ -384,12 +386,12 @@ public class GenericsUtils {
     }
 
     @SuppressWarnings("unchecked")
-    public static Map<String,ClassNode> createGenericsSpec(ClassNode current) {
+    public static Map<String, ClassNode> createGenericsSpec(ClassNode current) {
         return createGenericsSpec(current, Collections.EMPTY_MAP);
     }
 
-    public static Map<String,ClassNode> createGenericsSpec(ClassNode current, Map<String,ClassNode> oldSpec) {
-        Map<String,ClassNode> ret = new HashMap<String,ClassNode>(oldSpec);
+    public static Map<String, ClassNode> createGenericsSpec(ClassNode current, Map<String, ClassNode> oldSpec) {
+        Map<String, ClassNode> ret = new HashMap<String, ClassNode>(oldSpec);
         // ret contains the type specs, what we now need is the type spec for the
         // current class. To get that we first apply the type parameters to the
         // current class and then use the type names of the current class to reset
@@ -416,8 +418,8 @@ public class GenericsUtils {
         return ret;
     }
 
-    public static Map<String,ClassNode> addMethodGenerics(MethodNode current, Map<String,ClassNode> oldSpec) {
-        Map<String,ClassNode> ret = new HashMap<String,ClassNode>(oldSpec);
+    public static Map<String, ClassNode> addMethodGenerics(MethodNode current, Map<String, ClassNode> oldSpec) {
+        Map<String, ClassNode> ret = new HashMap<String, ClassNode>(oldSpec);
         // ret starts with the original type specs, now add gts for the current method if any
         GenericsType[] sgts = current.getGenericsTypes();
         if (sgts != null) {
@@ -471,16 +473,16 @@ public class GenericsUtils {
 
     private static void extractSuperClassGenerics(GenericsType[] usage, GenericsType[] declaration, Map<String, ClassNode> spec) {
         // if declaration does not provide generics, there is no connection to make 
-        if (usage==null || declaration==null || declaration.length==0) return;
-        if (usage.length!=declaration.length) return;
+        if (usage == null || declaration == null || declaration.length == 0) return;
+        if (usage.length != declaration.length) return;
 
         // both have generics
-        for (int i=0; i<usage.length; i++) {
+        for (int i = 0; i < usage.length; i++) {
             GenericsType ui = usage[i];
             GenericsType di = declaration[i];
             if (di.isPlaceholder()) {
                 spec.put(di.getName(), ui.getType());
-            } else if (di.isWildcard()){
+            } else if (di.isWildcard()) {
                 if (ui.isWildcard()) {
                     extractSuperClassGenerics(ui.getLowerBound(), di.getLowerBound(), spec);
                     extractSuperClassGenerics(ui.getUpperBounds(), di.getUpperBounds(), spec);
@@ -488,7 +490,7 @@ public class GenericsUtils {
                     ClassNode cu = ui.getType();
                     extractSuperClassGenerics(cu, di.getLowerBound(), spec);
                     ClassNode[] upperBounds = di.getUpperBounds();
-                    if (upperBounds!=null) {
+                    if (upperBounds != null) {
                         for (ClassNode cn : upperBounds) {
                             extractSuperClassGenerics(cu, cn, spec);
                         }
@@ -501,14 +503,14 @@ public class GenericsUtils {
     }
 
     private static void extractSuperClassGenerics(ClassNode[] usage, ClassNode[] declaration, Map<String, ClassNode> spec) {
-        if (usage==null || declaration==null || declaration.length==0) return;
+        if (usage == null || declaration == null || declaration.length == 0) return;
         // both have generics
-        for (int i=0; i<usage.length; i++) {
+        for (int i = 0; i < usage.length; i++) {
             ClassNode ui = usage[i];
             ClassNode di = declaration[i];
             if (di.isGenericsPlaceHolder()) {
                 spec.put(di.getGenericsTypes()[0].getName(), di);
-            } else if (di.isUsingGenerics()){
+            } else if (di.isUsingGenerics()) {
                 extractSuperClassGenerics(ui.getGenericsTypes(), di.getGenericsTypes(), spec);
             }
         }
@@ -556,7 +558,7 @@ public class GenericsUtils {
     }
 
     private static ClassNode resolveClassNode(final SourceUnit sourceUnit, final CompilationUnit compilationUnit, final MethodNode mn, final ASTNode usage, final ClassNode parsedNode) {
-        ClassNode dummyClass = new ClassNode("dummy",0, ClassHelper.OBJECT_TYPE);
+        ClassNode dummyClass = new ClassNode("dummy", 0, ClassHelper.OBJECT_TYPE);
         dummyClass.setModule(new ModuleNode(sourceUnit));
         dummyClass.setGenericsTypes(mn.getDeclaringClass().getGenericsTypes());
         MethodNode dummyMN = new MethodNode(
@@ -583,19 +585,21 @@ public class GenericsUtils {
      * transforms generics types from an old context to a new context using the given spec. This method assumes
      * all generics types will be placeholders. WARNING: The resulting generics types may or may not be placeholders
      * after the transformation.
-     * @param genericsSpec the generics context information spec
+     *
+     * @param genericsSpec    the generics context information spec
      * @param oldPlaceHolders the old placeholders
      * @return the new generics types
      */
     public static GenericsType[] applyGenericsContextToPlaceHolders(Map<String, ClassNode> genericsSpec, GenericsType[] oldPlaceHolders) {
-        if (oldPlaceHolders==null || oldPlaceHolders.length==0) return oldPlaceHolders;
+        if (oldPlaceHolders == null || oldPlaceHolders.length == 0) return oldPlaceHolders;
         if (genericsSpec.isEmpty()) return oldPlaceHolders;
         GenericsType[] newTypes = new GenericsType[oldPlaceHolders.length];
-        for (int i=0; i<oldPlaceHolders.length; i++) {
+        for (int i = 0; i < oldPlaceHolders.length; i++) {
             GenericsType old = oldPlaceHolders[i];
-            if (!old.isPlaceholder()) throw new GroovyBugError("Given generics type "+old+" must be a placeholder!");
+            if (!old.isPlaceholder())
+                throw new GroovyBugError("Given generics type " + old + " must be a placeholder!");
             ClassNode fromSpec = genericsSpec.get(old.getName());
-            if (fromSpec!=null) {
+            if (fromSpec != null) {
                 if (fromSpec.isGenericsPlaceHolder()) {
                     ClassNode[] upper = new ClassNode[]{fromSpec.redirect()};
                     newTypes[i] = new GenericsType(fromSpec, upper, null);
@@ -605,16 +609,16 @@ public class GenericsUtils {
             } else {
                 ClassNode[] upper = old.getUpperBounds();
                 ClassNode[] newUpper = upper;
-                if (upper!=null && upper.length>0) {
+                if (upper != null && upper.length > 0) {
                     ClassNode[] upperCorrected = new ClassNode[upper.length];
-                    for (int j=0;j<upper.length;j++) {
-                        upperCorrected[i] = correctToGenericsSpecRecurse(genericsSpec,upper[j]);
+                    for (int j = 0; j < upper.length; j++) {
+                        upperCorrected[i] = correctToGenericsSpecRecurse(genericsSpec, upper[j]);
                     }
                     upper = upperCorrected;
                 }
                 ClassNode lower = old.getLowerBound();
-                ClassNode newLower = correctToGenericsSpecRecurse(genericsSpec,lower);
-                if (lower==newLower && upper==newUpper) {
+                ClassNode newLower = correctToGenericsSpecRecurse(genericsSpec, lower);
+                if (lower == newLower && upper == newUpper) {
                     newTypes[i] = oldPlaceHolders[i];
                 } else {
                     ClassNode newPlaceHolder = ClassHelper.make(old.getName());
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index afb91d1a8b..3ae2bd53a2 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -169,38 +169,40 @@ public abstract class StaticTypeCheckingSupport {
                 private static final long serialVersionUID = 8841951852732042766L;
 
                 {
-                put(byte_TYPE, 0);
-                put(Byte_TYPE, 0);
-                put(short_TYPE, 1);
-                put(Short_TYPE, 1);
-                put(int_TYPE, 2);
-                put(Integer_TYPE, 2);
-                put(Long_TYPE, 3);
-                put(long_TYPE, 3);
-                put(float_TYPE, 4);
-                put(Float_TYPE, 4);
-                put(double_TYPE, 5);
-                put(Double_TYPE, 5);
-            }});
+                    put(byte_TYPE, 0);
+                    put(Byte_TYPE, 0);
+                    put(short_TYPE, 1);
+                    put(Short_TYPE, 1);
+                    put(int_TYPE, 2);
+                    put(Integer_TYPE, 2);
+                    put(Long_TYPE, 3);
+                    put(long_TYPE, 3);
+                    put(float_TYPE, 4);
+                    put(Float_TYPE, 4);
+                    put(double_TYPE, 5);
+                    put(Double_TYPE, 5);
+                }
+            });
 
     protected static final Map<String, Integer> NUMBER_OPS = Collections.unmodifiableMap(
             new HashMap<String, Integer>() {
                 private static final long serialVersionUID = 6951856193525808411L;
 
                 {
-                put("plus", PLUS);
-                put("minus", MINUS);
-                put("multiply", MULTIPLY);
-                put("div", DIVIDE);
-                put("or", BITWISE_OR);
-                put("and", BITWISE_AND);
-                put("xor", BITWISE_XOR);
-                put("mod", MOD);
-                put("intdiv", INTDIV);
-                put("leftShift", LEFT_SHIFT);
-                put("rightShift", RIGHT_SHIFT);
-                put("rightShiftUnsigned", RIGHT_SHIFT_UNSIGNED);
-            }});
+                    put("plus", PLUS);
+                    put("minus", MINUS);
+                    put("multiply", MULTIPLY);
+                    put("div", DIVIDE);
+                    put("or", BITWISE_OR);
+                    put("and", BITWISE_AND);
+                    put("xor", BITWISE_XOR);
+                    put("mod", MOD);
+                    put("intdiv", INTDIV);
+                    put("leftShift", LEFT_SHIFT);
+                    put("rightShift", RIGHT_SHIFT);
+                    put("rightShiftUnsigned", RIGHT_SHIFT_UNSIGNED);
+                }
+            });
 
     protected static final ClassNode GSTRING_STRING_CLASSNODE = WideningCategories.lowestUpperBound(
             STRING_TYPE,
@@ -246,6 +248,7 @@ public abstract class StaticTypeCheckingSupport {
 
     /**
      * Returns true for expressions of the form x[...]
+     *
      * @param expression an expression
      * @return true for array access expressions
      */
@@ -256,7 +259,8 @@ public abstract class StaticTypeCheckingSupport {
     /**
      * Called on method call checks in order to determine if a method call corresponds to the
      * idiomatic o.with { ... } structure
-     * @param name name of the method called
+     *
+     * @param name          name of the method called
      * @param callArguments arguments of the method
      * @return true if the name is "with" and arguments consist of a single closure
      */
@@ -272,6 +276,7 @@ public abstract class StaticTypeCheckingSupport {
 
     /**
      * Given a variable expression, returns the ultimately accessed variable.
+     *
      * @param ve a variable expression
      * @return the target variable
      */
@@ -286,11 +291,11 @@ public abstract class StaticTypeCheckingSupport {
 
 
     /**
-     * @deprecated Use {@link #findDGMMethodsForClassNode(ClassLoader, ClassNode,String)} instead
+     * @deprecated Use {@link #findDGMMethodsForClassNode(ClassLoader, ClassNode, String)} instead
      */
     @Deprecated
     protected static Set<MethodNode> findDGMMethodsForClassNode(ClassNode clazz, String name) {
-        return findDGMMethodsForClassNode(MetaClassRegistryImpl.class.getClassLoader(), clazz,  name);
+        return findDGMMethodsForClassNode(MetaClassRegistryImpl.class.getClassLoader(), clazz, name);
     }
 
     protected static Set<MethodNode> findDGMMethodsForClassNode(final ClassLoader loader, ClassNode clazz, String name) {
@@ -337,24 +342,25 @@ public abstract class StaticTypeCheckingSupport {
 
     /**
      * Checks that arguments and parameter types match.
+     *
      * @param params method parameters
-     * @param args type arguments
+     * @param args   type arguments
      * @return -1 if arguments do not match, 0 if arguments are of the exact type and >0 when one or more argument is
      * not of the exact type but still match
      */
     public static int allParametersAndArgumentsMatch(Parameter[] params, ClassNode[] args) {
-        if (params==null) {
+        if (params == null) {
             params = Parameter.EMPTY_ARRAY;
         }
         int dist = 0;
-        if (args.length<params.length) return -1;
+        if (args.length < params.length) return -1;
         // we already know there are at least params.length elements in both arrays
         for (int i = 0; i < params.length; i++) {
             ClassNode paramType = params[i].getType();
             ClassNode argType = args[i];
             if (!isAssignableTo(argType, paramType)) return -1;
             else {
-                if (!paramType.equals(argType)) dist+=getDistance(argType, paramType);
+                if (!paramType.equals(argType)) dist += getDistance(argType, paramType);
             }
         }
         return dist;
@@ -363,8 +369,9 @@ public abstract class StaticTypeCheckingSupport {
     /**
      * Checks that arguments and parameter types match, expecting that the number of parameters is strictly greater
      * than the number of arguments, allowing possible inclusion of default parameters.
+     *
      * @param params method parameters
-     * @param args type arguments
+     * @param args   type arguments
      * @return -1 if arguments do not match, 0 if arguments are of the exact type and >0 when one or more argument is
      * not of the exact type but still match
      */
@@ -372,19 +379,19 @@ public abstract class StaticTypeCheckingSupport {
         int dist = 0;
         ClassNode ptype = null;
         // we already know the lengths are equal
-        for (int i = 0, j=0; i < params.length; i++) {
+        for (int i = 0, j = 0; i < params.length; i++) {
             Parameter param = params[i];
             ClassNode paramType = param.getType();
-            ClassNode arg = j>=args.length?null:args[j];
-            if (arg==null || !isAssignableTo(arg, paramType)){
-                if (!param.hasInitialExpression() && (ptype==null || !ptype.equals(paramType))) {
+            ClassNode arg = j >= args.length ? null : args[j];
+            if (arg == null || !isAssignableTo(arg, paramType)) {
+                if (!param.hasInitialExpression() && (ptype == null || !ptype.equals(paramType))) {
                     return -1; // no default value
                 }
                 // a default value exists, we can skip this param
                 ptype = null;
             } else {
                 j++;
-                if (!paramType.equals(arg)) dist+=getDistance(arg, paramType);
+                if (!paramType.equals(arg)) dist += getDistance(arg, paramType);
                 if (param.hasInitialExpression()) {
                     ptype = arg;
                 } else {
@@ -397,6 +404,7 @@ public abstract class StaticTypeCheckingSupport {
 
     /**
      * Checks that excess arguments match the vararg signature parameter.
+     *
      * @param params
      * @param args
      * @return -1 if no match, 0 if all arguments matches the vararg type and >0 if one or more vararg argument is
@@ -409,7 +417,7 @@ public abstract class StaticTypeCheckingSupport {
         int dist = 0;
         ClassNode vargsBase = params[params.length - 1].getType().getComponentType();
         for (int i = params.length; i < args.length; i++) {
-            if (!isAssignableTo(args[i],vargsBase)) return -1;
+            if (!isAssignableTo(args[i], vargsBase)) return -1;
             else dist += getClassDistance(vargsBase, args[i]);
         }
         return dist;
@@ -417,6 +425,7 @@ public abstract class StaticTypeCheckingSupport {
 
     /**
      * Checks if the last argument matches the vararg type.
+     *
      * @param params
      * @param args
      * @return -1 if no match, 0 if the last argument is exactly the vararg type and 1 if of an assignable type
@@ -432,19 +441,20 @@ public abstract class StaticTypeCheckingSupport {
         ClassNode ptype = lastParamType.getComponentType();
         ClassNode arg = args[args.length - 1];
         if (isNumberType(ptype) && isNumberType(arg) && !ptype.equals(arg)) return -1;
-        return isAssignableTo(arg, ptype)?Math.min(getDistance(arg, lastParamType), getDistance(arg, ptype)):-1;
+        return isAssignableTo(arg, ptype) ? Math.min(getDistance(arg, lastParamType), getDistance(arg, ptype)) : -1;
     }
 
     /**
      * Checks if a class node is assignable to another. This is used for example in
      * assignment checks where you want to verify that the assignment is valid.
+     *
      * @param type
      * @param toBeAssignedTo
      * @return true if the class node is assignable to the other class node, false otherwise
      */
     static boolean isAssignableTo(ClassNode type, ClassNode toBeAssignedTo) {
-        if (UNKNOWN_PARAMETER_TYPE==type) return true;
-        if (type==toBeAssignedTo) return true;
+        if (UNKNOWN_PARAMETER_TYPE == type) return true;
+        if (type == toBeAssignedTo) return true;
         if (toBeAssignedTo.redirect() == STRING_TYPE && type.redirect() == GSTRING_TYPE) {
             return true;
         }
@@ -454,7 +464,7 @@ public abstract class StaticTypeCheckingSupport {
             return NUMBER_TYPES.get(type.redirect()) <= NUMBER_TYPES.get(toBeAssignedTo.redirect());
         }
         if (type.isArray() && toBeAssignedTo.isArray()) {
-            return isAssignableTo(type.getComponentType(),toBeAssignedTo.getComponentType());
+            return isAssignableTo(type.getComponentType(), toBeAssignedTo.getComponentType());
         }
         if (type.isDerivedFrom(GSTRING_TYPE) && STRING_TYPE.equals(toBeAssignedTo)) {
             return true;
@@ -666,29 +676,29 @@ public abstract class StaticTypeCheckingSupport {
     public static boolean checkCompatibleAssignmentTypes(ClassNode left, ClassNode right, Expression rightExpression, boolean allowConstructorCoercion) {
         ClassNode leftRedirect = left.redirect();
         ClassNode rightRedirect = right.redirect();
-        if (leftRedirect==rightRedirect) return true;
+        if (leftRedirect == rightRedirect) return true;
 
         if (leftRedirect.isArray() && rightRedirect.isArray()) {
             return checkCompatibleAssignmentTypes(leftRedirect.getComponentType(), rightRedirect.getComponentType(), rightExpression, false);
         }
 
-        if (right==VOID_TYPE||right==void_WRAPPER_TYPE) {
-            return left==VOID_TYPE||left==void_WRAPPER_TYPE;
+        if (right == VOID_TYPE || right == void_WRAPPER_TYPE) {
+            return left == VOID_TYPE || left == void_WRAPPER_TYPE;
         }
 
-        if ((isNumberType(rightRedirect)|| WideningCategories.isNumberCategory(rightRedirect))) {
-           if (BigDecimal_TYPE==leftRedirect) {
-               // any number can be assigned to a big decimal
-               return true;
-           }
-            if (BigInteger_TYPE==leftRedirect) {
+        if ((isNumberType(rightRedirect) || WideningCategories.isNumberCategory(rightRedirect))) {
+            if (BigDecimal_TYPE == leftRedirect) {
+                // any number can be assigned to a big decimal
+                return true;
+            }
+            if (BigInteger_TYPE == leftRedirect) {
                 return WideningCategories.isBigIntCategory(getUnwrapper(rightRedirect)) ||
                         rightRedirect.isDerivedFrom(BigInteger_TYPE);
             }
         }
 
         // if rightExpression is null and leftExpression is not a primitive type, it's ok
-        boolean rightExpressionIsNull = rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null;
+        boolean rightExpressionIsNull = rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue() == null;
         if (rightExpressionIsNull && !isPrimitiveType(left)) {
             return true;
         }
@@ -701,14 +711,14 @@ public abstract class StaticTypeCheckingSupport {
                 && !(boolean_TYPE.equals(left) && rightExpressionIsNull)) return true;
 
         // char as left expression
-        if (leftRedirect == char_TYPE && rightRedirect==STRING_TYPE) {
+        if (leftRedirect == char_TYPE && rightRedirect == STRING_TYPE) {
             if (rightExpression instanceof ConstantExpression) {
                 String value = rightExpression.getText();
-                return value.length()==1;
+                return value.length() == 1;
             }
         }
-        if (leftRedirect == Character_TYPE && (rightRedirect==STRING_TYPE||rightExpressionIsNull)) {
-            return rightExpressionIsNull || (rightExpression instanceof ConstantExpression && rightExpression.getText().length()==1);
+        if (leftRedirect == Character_TYPE && (rightRedirect == STRING_TYPE || rightExpressionIsNull)) {
+            return rightExpressionIsNull || (rightExpression instanceof ConstantExpression && rightExpression.getText().length() == 1);
         }
 
         // if left is Enum and right is String or GString we do valueOf
@@ -748,7 +758,7 @@ public abstract class StaticTypeCheckingSupport {
         if (left.isGenericsPlaceHolder()) {
             // GROOVY-7307
             GenericsType[] genericsTypes = left.getGenericsTypes();
-            if (genericsTypes!=null && genericsTypes.length==1) {
+            if (genericsTypes != null && genericsTypes.length == 1) {
                 // should always be the case, but safe guard is better
                 return genericsTypes[0].isCompatibleWith(right);
             }
@@ -768,15 +778,16 @@ public abstract class StaticTypeCheckingSupport {
     /**
      * Tells if a class is one of the "accept all" classes as the left hand side of an
      * assignment.
+     *
      * @param node the classnode to test
      * @return true if it's an Object, String, boolean, Boolean or Class.
      */
     public static boolean isWildcardLeftHandSide(final ClassNode node) {
         if (OBJECT_TYPE.equals(node) ||
-            STRING_TYPE.equals(node) ||
-            boolean_TYPE.equals(node) ||
-            Boolean_TYPE.equals(node) ||
-            CLASS_Type.equals(node)) {
+                STRING_TYPE.equals(node) ||
+                boolean_TYPE.equals(node) ||
+                Boolean_TYPE.equals(node) ||
+                CLASS_Type.equals(node)) {
             return true;
         }
         return false;
@@ -875,7 +886,7 @@ public abstract class StaticTypeCheckingSupport {
 
     static String prettyPrintType(ClassNode type) {
         if (type.isArray()) {
-            return prettyPrintType(type.getComponentType())+"[]";
+            return prettyPrintType(type.getComponentType()) + "[]";
         }
         return type.toString(false);
     }
@@ -926,13 +937,13 @@ public abstract class StaticTypeCheckingSupport {
         ClassNode unwrapCompare = getUnwrapper(compare);
         if (isPrimitiveType(unwrapReceiver)
                 && isPrimitiveType(unwrapCompare)
-                && unwrapReceiver!=unwrapCompare) {
+                && unwrapReceiver != unwrapCompare) {
             dist = getPrimitiveDistance(unwrapReceiver, unwrapCompare);
         }
         // Add a penalty against boxing or unboxing, to get a resolution similar to JLS 15.12.2
         // (http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2).
         if (isPrimitiveType(receiver) ^ isPrimitiveType(compare)) {
-            dist = (dist+1)<<1;
+            dist = (dist + 1) << 1;
         }
         if (unwrapCompare.equals(unwrapReceiver)) return dist;
         if (receiver.isArray() && !compare.isArray()) {
@@ -945,7 +956,7 @@ public abstract class StaticTypeCheckingSupport {
         }
 
         ClassNode ref = receiver;
-        while (ref!=null) {
+        while (ref != null) {
             if (compare.equals(ref)) {
                 break;
             }
@@ -955,8 +966,8 @@ public abstract class StaticTypeCheckingSupport {
             }
             ref = ref.getSuperClass();
             dist++;
-            if (ref == null) dist++ ;
-            dist = (dist+1)<<1;
+            if (ref == null) dist++;
+            dist = (dist + 1) << 1;
         }
         return dist;
     }
@@ -976,7 +987,7 @@ public abstract class StaticTypeCheckingSupport {
             // we want to add one, because there is an interface between
             // the interface we search for and the interface we are in.
             if (sub != -1) {
-                sub+=1;
+                sub += 1;
             }
             // we are interested in the longest path only
             max = Math.max(max, sub);
@@ -1019,6 +1030,7 @@ public abstract class StaticTypeCheckingSupport {
      * Returns true if the provided class node, when considered as a receiver of a message or as a parameter,
      * is using a placeholder in its generics type. In this case, we're facing unchecked generics and type
      * checking is limited (ex: void foo(Set s) { s.keySet() }
+     *
      * @param node the node to test
      * @return true if it is using any placeholder in generics types
      */
@@ -1026,7 +1038,7 @@ public abstract class StaticTypeCheckingSupport {
         if (node.isArray()) return isUsingUncheckedGenerics(node.getComponentType());
         if (node.isUsingGenerics()) {
             GenericsType[] genericsTypes = node.getGenericsTypes();
-            if (genericsTypes!=null) {
+            if (genericsTypes != null) {
                 for (GenericsType genericsType : genericsTypes) {
                     if (genericsType.isPlaceholder()) {
                         return true;
@@ -1047,8 +1059,8 @@ public abstract class StaticTypeCheckingSupport {
      * Given a list of candidate methods, returns the one which best matches the argument types
      *
      * @param receiver
-     * @param methods candidate methods
-     * @param args argument types
+     * @param methods  candidate methods
+     * @param args     argument types
      * @return the list of methods which best matches the argument types. It is still possible that multiple
      * methods match the argument types.
      */
@@ -1068,7 +1080,7 @@ public abstract class StaticTypeCheckingSupport {
             ClassNode[] safeArgs = args;
             boolean isExtensionMethodNode = candidateNode instanceof ExtensionMethodNode;
             if (isExtensionMethodNode) {
-                safeArgs = new ClassNode[args.length+1];
+                safeArgs = new ClassNode[args.length + 1];
                 System.arraycopy(args, 0, safeArgs, 1, args.length);
                 safeArgs[0] = receiver;
                 safeNode = ((ExtensionMethodNode) candidateNode).getExtensionMethodNode();
@@ -1099,7 +1111,7 @@ public abstract class StaticTypeCheckingSupport {
                 }
             }
         }
-        if (bestChoices.size()>1) {
+        if (bestChoices.size() > 1) {
             // GROOVY-6849: prefer extension methods in case of ambiguity
             List<MethodNode> onlyExtensionMethods = new LinkedList<MethodNode>();
             for (MethodNode choice : bestChoices) {
@@ -1107,7 +1119,7 @@ public abstract class StaticTypeCheckingSupport {
                     onlyExtensionMethods.add(choice);
                 }
             }
-            if (onlyExtensionMethods.size()==1) {
+            if (onlyExtensionMethods.size() == 1) {
                 return onlyExtensionMethods;
             }
         }
@@ -1177,9 +1189,9 @@ public abstract class StaticTypeCheckingSupport {
 
     private static Parameter[] makeRawTypes(Parameter[] params) {
         Parameter[] newParam = new Parameter[params.length];
-        for (int i=0; i<params.length; i++) {
+        for (int i = 0; i < params.length; i++) {
             Parameter oldP = params[i];
-            Parameter newP = new Parameter(makeRawType(oldP.getType()),oldP.getName());
+            Parameter newP = new Parameter(makeRawType(oldP.getType()), oldP.getName());
             newParam[i] = newP;
         }
         return newParam;
@@ -1206,7 +1218,7 @@ public abstract class StaticTypeCheckingSupport {
                 MethodNode two = list.get(j);
                 if (toBeRemoved.contains(two)) continue;
                 if (one.getParameters().length == two.getParameters().length) {
-                    if (areOverloadMethodsInSameClass(one,two)) {
+                    if (areOverloadMethodsInSameClass(one, two)) {
                         if (ParameterUtils.parametersEqual(one.getParameters(), two.getParameters())) {
                             removeMethodWithSuperReturnType(toBeRemoved, one, two);
                         } else {
@@ -1279,7 +1291,7 @@ public abstract class StaticTypeCheckingSupport {
      * available generic type information.
      *
      * @param receiver the class
-     * @param m the method
+     * @param m        the method
      * @return the parameterized arguments
      */
     public static Parameter[] parameterizeArguments(final ClassNode receiver, final MethodNode m) {
@@ -1297,14 +1309,15 @@ public abstract class StaticTypeCheckingSupport {
 
     /**
      * Given a parameter, builds a new parameter for which the known generics placeholders are resolved.
-     * @param genericFromReceiver resolved generics from the receiver of the message
+     *
+     * @param genericFromReceiver      resolved generics from the receiver of the message
      * @param placeholdersFromContext, resolved generics from the method context
-     * @param methodParameter the method parameter for which we want to resolve generic types
-     * @param paramType the (unresolved) type of the method parameter
+     * @param methodParameter          the method parameter for which we want to resolve generic types
+     * @param paramType                the (unresolved) type of the method parameter
      * @return a new parameter with the same name and type as the original one, but with resolved generic types
      */
     private static Parameter buildParameter(final Map<String, GenericsType> genericFromReceiver, final Map<String, GenericsType> placeholdersFromContext, final Parameter methodParameter, final ClassNode paramType) {
-        if (genericFromReceiver.isEmpty() && (placeholdersFromContext==null||placeholdersFromContext.isEmpty())) {
+        if (genericFromReceiver.isEmpty() && (placeholdersFromContext == null || placeholdersFromContext.isEmpty())) {
             return methodParameter;
         }
         if (paramType.isArray()) {
@@ -1321,6 +1334,7 @@ public abstract class StaticTypeCheckingSupport {
     /**
      * Returns true if a class node makes use of generic types. If the class node represents an
      * array type, then checks if the component type is using generics.
+     *
      * @param cn a class node for which to check if it is using generics
      * @return true if the type (or component type) is using generics
      */
@@ -1328,7 +1342,7 @@ public abstract class StaticTypeCheckingSupport {
         if (cn.isArray()) {
             return isUsingGenericsOrIsArrayUsingGenerics(cn.getComponentType());
         }
-        return (cn.isUsingGenerics() && cn.getGenericsTypes()!=null);
+        return (cn.isUsingGenerics() && cn.getGenericsTypes() != null);
     }
 
     /**
@@ -1337,7 +1351,7 @@ public abstract class StaticTypeCheckingSupport {
      */
     protected static GenericsType fullyResolve(GenericsType gt, Map<String, GenericsType> placeholders) {
         GenericsType fromMap = placeholders.get(gt.getName());
-        if (gt.isPlaceholder() && fromMap!=null) {
+        if (gt.isPlaceholder() && fromMap != null) {
             gt = fromMap;
         }
 
@@ -1478,7 +1492,7 @@ public abstract class StaticTypeCheckingSupport {
         } else {
             classGTs = GenericsUtils.extractPlaceholders(receiver);
         }
-        if (parameters.length > arguments.length || parameters.length==0) {
+        if (parameters.length > arguments.length || parameters.length == 0) {
             // this is a limitation that must be removed in a future version
             // we cannot check generic type arguments if there are default parameters!
             return true;
@@ -1490,12 +1504,12 @@ public abstract class StaticTypeCheckingSupport {
         // the non-hidden ones.
         Map<String, GenericsType> resolvedMethodGenerics = new HashMap<String, GenericsType>();
         if (!skipBecauseOfInnerClassNotReceiver) {
-            addMethodLevelDeclaredGenerics(candidateMethod,resolvedMethodGenerics);
+            addMethodLevelDeclaredGenerics(candidateMethod, resolvedMethodGenerics);
         }
         // so first we remove hidden generics
-        for (String key: resolvedMethodGenerics.keySet()) classGTs.remove(key);
+        for (String key : resolvedMethodGenerics.keySet()) classGTs.remove(key);
         // then we use the remaining information to refine the given generics
-        applyGenericsConnections(classGTs,resolvedMethodGenerics);
+        applyGenericsConnections(classGTs, resolvedMethodGenerics);
         // and then start our checks with the receiver
         if (!skipBecauseOfInnerClassNotReceiver) {
             failure |= inferenceCheck(Collections.EMPTY_SET, resolvedMethodGenerics, candidateMethod.getDeclaringClass(), receiver, false);
@@ -1512,16 +1526,17 @@ public abstract class StaticTypeCheckingSupport {
             ClassNode wrappedArgument = arguments[i];
             ClassNode type = parameters[pindex].getOriginType();
 
-            failure |= inferenceCheck(fixedGenericsPlaceHolders, resolvedMethodGenerics, type, wrappedArgument,i >= parameters.length - 1);
+            failure |= inferenceCheck(fixedGenericsPlaceHolders, resolvedMethodGenerics, type, wrappedArgument, i >= parameters.length - 1);
 
             // set real fixed generics for extension methods
-            if (isExtensionMethod && i==0) fixedGenericsPlaceHolders = extractResolvedPlaceHolders(resolvedMethodGenerics);
+            if (isExtensionMethod && i == 0)
+                fixedGenericsPlaceHolders = extractResolvedPlaceHolders(resolvedMethodGenerics);
         }
         return !failure;
     }
 
     private static boolean isOuterClassOf(ClassNode receiver, ClassNode type) {
-        if (implementsInterfaceOrIsSubclassOf(receiver,type)) return false;
+        if (implementsInterfaceOrIsSubclassOf(receiver, type)) return false;
         return true;
     }
 
@@ -1572,25 +1587,23 @@ public abstract class StaticTypeCheckingSupport {
         return gt;
     }
 
-    private static boolean compatibleConnections(Map<String, GenericsType> connections, Map<String, GenericsType> resolvedMethodGenerics, Set<String> fixedGenericsPlaceHolders)
-    {
+    private static boolean compatibleConnections(Map<String, GenericsType> connections, Map<String, GenericsType> resolvedMethodGenerics, Set<String> fixedGenericsPlaceHolders) {
         for (Entry<String, GenericsType> entry : connections.entrySet()) {
             GenericsType resolved = resolvedMethodGenerics.get(entry.getKey());
-            if (resolved==null) continue;
+            if (resolved == null) continue;
             GenericsType connection = entry.getValue();
             if (connection.isPlaceholder() && !hasNonTrivialBounds(connection)) {
                 continue;
             }
-            if (!compatibleConnection(resolved,connection)) {
-                if (    !(resolved.isPlaceholder() || resolved.isWildcard()) &&
+            if (!compatibleConnection(resolved, connection)) {
+                if (!(resolved.isPlaceholder() || resolved.isWildcard()) &&
                         !fixedGenericsPlaceHolders.contains(entry.getKey()) &&
-                        compatibleConnection(connection,resolved))
-                {
+                        compatibleConnection(connection, resolved)) {
                     // we did for example find T=String and now check against
                     // T=Object, which fails the first compatibleConnection check
                     // but since T=Object works for both, the second one will pass
                     // and we need to change the type for T to the more general one
-                    resolvedMethodGenerics.put(entry.getKey(),connection);
+                    resolvedMethodGenerics.put(entry.getKey(), connection);
                 } else {
                     return false;
                 }
@@ -1602,10 +1615,9 @@ public abstract class StaticTypeCheckingSupport {
     private static boolean compatibleConnection(GenericsType resolved, GenericsType connection) {
         GenericsType gt = connection;
         if (!connection.isWildcard()) gt = buildWildcardType(connection);
-        if (    resolved.isPlaceholder() && resolved.getUpperBounds()!=null &&
-                resolved.getUpperBounds().length==1 && !resolved.getUpperBounds()[0].isGenericsPlaceHolder() &&
-                resolved.getUpperBounds()[0].getName().equals("java.lang.Object"))
-        {
+        if (resolved.isPlaceholder() && resolved.getUpperBounds() != null &&
+                resolved.getUpperBounds().length == 1 && !resolved.getUpperBounds()[0].isGenericsPlaceHolder() &&
+                resolved.getUpperBounds()[0].getName().equals("java.lang.Object")) {
             return true;
         }
         ClassNode compareNode;
@@ -1627,7 +1639,7 @@ public abstract class StaticTypeCheckingSupport {
             if (resolved.containsKey(entry.getKey())) continue;
             GenericsType gt = entry.getValue();
             ClassNode cn = gt.getType();
-            if (cn.redirect()==UNKNOWN_PARAMETER_TYPE) continue;
+            if (cn.redirect() == UNKNOWN_PARAMETER_TYPE) continue;
             resolved.put(entry.getKey(), gt);
         }
     }
@@ -1635,10 +1647,10 @@ public abstract class StaticTypeCheckingSupport {
     public static ClassNode resolveClassNodeGenerics(Map<String, GenericsType> resolvedPlaceholders, final Map<String, GenericsType> placeholdersFromContext, ClassNode currentType) {
         ClassNode target = currentType.redirect();
         resolvedPlaceholders = new HashMap<String, GenericsType>(resolvedPlaceholders);
-        applyContextGenerics(resolvedPlaceholders,placeholdersFromContext);
+        applyContextGenerics(resolvedPlaceholders, placeholdersFromContext);
 
-        Map<String, GenericsType> connections  = new HashMap<String, GenericsType>();
-        extractGenericsConnections(connections, currentType,target);
+        Map<String, GenericsType> connections = new HashMap<String, GenericsType>();
+        extractGenericsConnections(connections, currentType, target);
         applyGenericsConnections(connections, resolvedPlaceholders);
         currentType = applyGenericsContext(resolvedPlaceholders, currentType);
         return currentType;
@@ -1648,19 +1660,19 @@ public abstract class StaticTypeCheckingSupport {
             Map<String, GenericsType> connections,
             Map<String, GenericsType> resolvedPlaceholders
     ) {
-        if (connections==null) return;
+        if (connections == null) return;
         int count = 0;
-        while (count<10000) {
+        while (count < 10000) {
             count++;
-            boolean checkForMorePlaceHolders=false;
-            for (Entry<String, GenericsType> entry: resolvedPlaceholders.entrySet()){
+            boolean checkForMorePlaceHolders = false;
+            for (Entry<String, GenericsType> entry : resolvedPlaceholders.entrySet()) {
                 String name = entry.getKey();
                 GenericsType replacement = connections.get(name);
-                if (replacement==null) {
+                if (replacement == null) {
                     GenericsType value = entry.getValue();
                     GenericsType newValue = applyGenericsContext(connections, value);
                     entry.setValue(newValue);
-                    checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(value,newValue);
+                    checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(value, newValue);
                     continue;
                 }
                 GenericsType original = entry.getValue();
@@ -1670,7 +1682,7 @@ public abstract class StaticTypeCheckingSupport {
                 boolean placeholderReplacement = replacement.isPlaceholder();
                 if (placeholderReplacement) {
                     GenericsType connectedType = resolvedPlaceholders.get(replacement.getName());
-                    if (replacement==connectedType) continue;
+                    if (replacement == connectedType) continue;
                 }
                 // GROOVY-6787: Don't override the original if the replacement placeholder doesn't respect the bounds,
                 // otherwise the original bounds are lost which can result in accepting an incompatible type as an
@@ -1679,13 +1691,14 @@ public abstract class StaticTypeCheckingSupport {
                 if (original.isCompatibleWith(replacementType)) {
                     entry.setValue(replacement);
                     if (placeholderReplacement) {
-                        checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(original,replacement);
+                        checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(original, replacement);
                     }
                 }
             }
             if (!checkForMorePlaceHolders) break;
         }
-        if  (count>=10000) throw new GroovyBugError("unable to handle generics in "+resolvedPlaceholders+" with connections "+connections);
+        if (count >= 10000)
+            throw new GroovyBugError("unable to handle generics in " + resolvedPlaceholders + " with connections " + connections);
     }
 
     private static ClassNode extractType(GenericsType gt) {
@@ -1707,13 +1720,13 @@ public abstract class StaticTypeCheckingSupport {
     }
 
     private static boolean equalIncludingGenerics(GenericsType orig, GenericsType copy) {
-        if (orig==copy) return true;
-        if (orig.isPlaceholder()!=copy.isPlaceholder()) return false;
-        if (orig.isWildcard()!=copy.isWildcard()) return false;
+        if (orig == copy) return true;
+        if (orig.isPlaceholder() != copy.isPlaceholder()) return false;
+        if (orig.isWildcard() != copy.isWildcard()) return false;
         if (!equalIncludingGenerics(orig.getType(), copy.getType())) return false;
         ClassNode lower1 = orig.getLowerBound();
         ClassNode lower2 = copy.getLowerBound();
-        if ((lower1 == null) ^ (lower2 ==null)) return false;
+        if ((lower1 == null) ^ (lower2 == null)) return false;
         if (lower1 != lower2) {
             if (!equalIncludingGenerics(lower1, lower2)) return false;
         }
@@ -1730,12 +1743,12 @@ public abstract class StaticTypeCheckingSupport {
     }
 
     private static boolean equalIncludingGenerics(ClassNode orig, ClassNode copy) {
-        if (orig==copy) return true;
-        if (orig.isGenericsPlaceHolder()!=copy.isGenericsPlaceHolder()) return false;
+        if (orig == copy) return true;
+        if (orig.isGenericsPlaceHolder() != copy.isGenericsPlaceHolder()) return false;
         if (!orig.equals(copy)) return false;
         GenericsType[] gt1 = orig.getGenericsTypes();
         GenericsType[] gt2 = orig.getGenericsTypes();
-        if ((gt1==null) ^ (gt2==null)) return false;
+        if ((gt1 == null) ^ (gt2 == null)) return false;
         if (gt1 != gt2) {
             if (gt1.length != gt2.length) return false;
             for (int i = 0; i < gt1.length; i++) {
@@ -1749,13 +1762,13 @@ public abstract class StaticTypeCheckingSupport {
      * use supplied type to make a connection from usage to declaration
      * The method operates in two modes.
      * * For type !instanceof target a structural compare will be done
-     *   (for example Dummy&lt;T&gt; and List&lt;R&gt; to get T=R)
+     * (for example Dummy&lt;T&gt; and List&lt;R&gt; to get T=R)
      * * If type equals target, a structural match is done as well
-     *   (for example Colection&lt;U&gt; and Collection&lt;E&gt; to get U=E)
+     * (for example Colection&lt;U&gt; and Collection&lt;E&gt; to get U=E)
      * * otherwise we climb the hierarchy to find a case of type equals target
-     *   to then execute the structural match, while applying possibly existing
-     *   generics contexts on the way (for example for IntRange and Collection&lt;E&gt;
-     *   to get E=Integer, since IntRange is an AbstractList&lt;Integer&gt;)
+     * to then execute the structural match, while applying possibly existing
+     * generics contexts on the way (for example for IntRange and Collection&lt;E&gt;
+     * to get E=Integer, since IntRange is an AbstractList&lt;Integer&gt;)
      * Should the target not have any generics this method does nothing.
      */
     static void extractGenericsConnections(Map<String, GenericsType> connections, ClassNode type, ClassNode target) {
@@ -1796,16 +1809,16 @@ public abstract class StaticTypeCheckingSupport {
 
     private static void extractGenericsConnections(Map<String, GenericsType> connections, GenericsType[] usage, GenericsType[] declaration) {
         // if declaration does not provide generics, there is no connection to make 
-        if (usage==null || declaration==null || declaration.length==0) return;
-        if (usage.length!=declaration.length) return;
+        if (usage == null || declaration == null || declaration.length == 0) return;
+        if (usage.length != declaration.length) return;
 
         // both have generics
-        for (int i=0; i<usage.length; i++) {
+        for (int i = 0; i < usage.length; i++) {
             GenericsType ui = usage[i];
             GenericsType di = declaration[i];
             if (di.isPlaceholder()) {
                 connections.put(di.getName(), ui);
-            } else if (di.isWildcard()){
+            } else if (di.isWildcard()) {
                 if (ui.isWildcard()) {
                     extractGenericsConnections(connections, ui.getLowerBound(), di.getLowerBound());
                     extractGenericsConnections(connections, ui.getUpperBounds(), di.getUpperBounds());
@@ -1813,7 +1826,7 @@ public abstract class StaticTypeCheckingSupport {
                     ClassNode cu = ui.getType();
                     extractGenericsConnections(connections, cu, di.getLowerBound());
                     ClassNode[] upperBounds = di.getUpperBounds();
-                    if (upperBounds!=null) {
+                    if (upperBounds != null) {
                         for (ClassNode cn : upperBounds) {
                             extractGenericsConnections(connections, cu, cn);
                         }
@@ -1826,16 +1839,16 @@ public abstract class StaticTypeCheckingSupport {
     }
 
     private static void extractGenericsConnections(Map<String, GenericsType> connections, ClassNode[] usage, ClassNode[] declaration) {
-        if (usage==null || declaration==null || declaration.length==0) return;
+        if (usage == null || declaration == null || declaration.length == 0) return;
         // both have generics
-        for (int i=0; i<usage.length; i++) {
+        for (int i = 0; i < usage.length; i++) {
             ClassNode ui = usage[i];
             ClassNode di = declaration[i];
             if (di.isGenericsPlaceHolder()) {
                 GenericsType gt = new GenericsType(di);
                 gt.setPlaceholder(di.isGenericsPlaceHolder());
                 connections.put(di.getGenericsTypes()[0].getName(), gt);
-            } else if (di.isUsingGenerics()){
+            } else if (di.isUsingGenerics()) {
                 extractGenericsConnections(connections, ui.getGenericsTypes(), di.getGenericsTypes());
             }
         }
@@ -1850,7 +1863,7 @@ public abstract class StaticTypeCheckingSupport {
             Map<String, GenericsType> spec, ClassNode parameterUsage
     ) {
         GenericsType[] gts = parameterUsage.getGenericsTypes();
-        if (gts==null) return Collections.EMPTY_MAP;
+        if (gts == null) return Collections.EMPTY_MAP;
 
         GenericsType[] newGTs = applyGenericsContext(spec, gts);
         ClassNode newTarget = parameterUsage.redirect().getPlainNodeReference();
@@ -1861,9 +1874,9 @@ public abstract class StaticTypeCheckingSupport {
     private static GenericsType[] applyGenericsContext(
             Map<String, GenericsType> spec, GenericsType[] gts
     ) {
-        if (gts==null) return null;
+        if (gts == null) return null;
         GenericsType[] newGTs = new GenericsType[gts.length];
-        for (int i=0; i<gts.length; i++) {
+        for (int i = 0; i < gts.length; i++) {
             GenericsType gt = gts[i];
             newGTs[i] = applyGenericsContext(spec, gt);
         }
@@ -1874,7 +1887,7 @@ public abstract class StaticTypeCheckingSupport {
         if (gt.isPlaceholder()) {
             String name = gt.getName();
             GenericsType specType = spec.get(name);
-            if (specType!=null) return specType;
+            if (specType != null) return specType;
             if (hasNonTrivialBounds(gt)) {
                 GenericsType newGT = new GenericsType(gt.getType(), applyGenericsContext(spec, gt.getUpperBounds()), applyGenericsContext(spec, gt.getLowerBound()));
                 newGT.setPlaceholder(true);
@@ -1887,7 +1900,7 @@ public abstract class StaticTypeCheckingSupport {
             return newGT;
         }
         ClassNode type = gt.getType();
-        if (type.getGenericsTypes()==null) return gt;
+        if (type.getGenericsTypes() == null) return gt;
         ClassNode newType = type.getPlainNodeReference();
         newType.setGenericsPlaceHolder(type.isGenericsPlaceHolder());
         newType.setGenericsTypes(applyGenericsContext(spec, type.getGenericsTypes()));
@@ -1907,10 +1920,10 @@ public abstract class StaticTypeCheckingSupport {
     private static ClassNode[] applyGenericsContext(
             Map<String, GenericsType> spec, ClassNode[] bounds
     ) {
-        if (bounds==null) return null;
+        if (bounds == null) return null;
         ClassNode[] newBounds = new ClassNode[bounds.length];
-        for(int i=0; i<bounds.length; i++) {
-            newBounds[i] = applyGenericsContext(spec,bounds[i]);
+        for (int i = 0; i < bounds.length; i++) {
+            newBounds[i] = applyGenericsContext(spec, bounds[i]);
         }
         return newBounds;
     }
@@ -1918,15 +1931,15 @@ public abstract class StaticTypeCheckingSupport {
     static ClassNode applyGenericsContext(
             Map<String, GenericsType> spec, ClassNode bound
     ) {
-        if (bound==null) return null;
+        if (bound == null) return null;
         if (bound.isArray()) {
-            return applyGenericsContext(spec,bound.getComponentType()).makeArray();
+            return applyGenericsContext(spec, bound.getComponentType()).makeArray();
         }
         if (!bound.isUsingGenerics()) return bound;
         ClassNode newBound = bound.getPlainNodeReference();
         newBound.setGenericsTypes(applyGenericsContext(spec, bound.getGenericsTypes()));
         if (bound.isGenericsPlaceHolder()) {
-            GenericsType[] gt= newBound.getGenericsTypes();
+            GenericsType[] gt = newBound.getGenericsTypes();
             boolean hasBounds = hasNonTrivialBounds(gt[0]);
             if (hasBounds || !gt[0].isPlaceholder()) return getCombinedBoundType(gt[0]);
             String placeHolderName = newBound.getGenericsTypes()[0].getName();
@@ -1947,31 +1960,31 @@ public abstract class StaticTypeCheckingSupport {
         // representing the combination of all bounds. The code here, just picks
         // something out to be able to proceed and is not actually correct
         if (hasNonTrivialBounds(genericsType)) {
-            if (genericsType.getLowerBound()!=null) return genericsType.getLowerBound();
-            if (genericsType.getUpperBounds()!=null) return genericsType.getUpperBounds()[0];
+            if (genericsType.getLowerBound() != null) return genericsType.getLowerBound();
+            if (genericsType.getUpperBounds() != null) return genericsType.getUpperBounds()[0];
         }
         return genericsType.getType();
     }
 
     private static void applyContextGenerics(Map<String, GenericsType> resolvedPlaceholders, Map<String, GenericsType> placeholdersFromContext) {
-        if (placeholdersFromContext==null) return;
+        if (placeholdersFromContext == null) return;
         for (Entry<String, GenericsType> entry : resolvedPlaceholders.entrySet()) {
             GenericsType gt = entry.getValue();
             if (gt.isPlaceholder()) {
                 String name = gt.getName();
                 GenericsType outer = placeholdersFromContext.get(name);
-                if (outer==null) continue;
+                if (outer == null) continue;
                 entry.setValue(outer);
             }
         }
     }
 
     private static Map<String, GenericsType> getGenericsParameterMapOfThis(ClassNode cn) {
-        if (cn==null) return null;
+        if (cn == null) return null;
         Map<String, GenericsType> map = null;
-        if (cn.getEnclosingMethod()!=null) {
+        if (cn.getEnclosingMethod() != null) {
             map = extractGenericsParameterMapOfThis(cn.getEnclosingMethod());
-        } else if (cn.getOuterClass()!=null) {
+        } else if (cn.getOuterClass() != null) {
             map = getGenericsParameterMapOfThis(cn.getOuterClass());
         }
         map = mergeGenerics(map, cn.getGenericsTypes());
@@ -2041,7 +2054,7 @@ public abstract class StaticTypeCheckingSupport {
 
     private static Map<String, GenericsType> mergeGenerics(Map<String, GenericsType> current, GenericsType[] newGenerics) {
         if (newGenerics == null || newGenerics.length == 0) return current;
-        if (current==null) current = new HashMap<String, GenericsType>();
+        if (current == null) current = new HashMap<String, GenericsType>();
         for (GenericsType gt : newGenerics) {
             if (!gt.isPlaceholder()) continue;
             String name = gt.getName();
@@ -2058,7 +2071,8 @@ public abstract class StaticTypeCheckingSupport {
         public static <T> T getAt(T[] arr, int index) {
             return null == arr ? null : arr[index];
         }
-        public static <T,U extends T> void putAt(T[] arr, int index, U object) {
+
+        public static <T, U extends T> void putAt(T[] arr, int index, U object) {
             if (null == arr) {
                 return;
             }
@@ -2071,6 +2085,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Boolean getAt(boolean[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(boolean[] arr, int index, boolean object) {
             if (null == arr) {
                 return;
@@ -2084,6 +2099,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Character getAt(char[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(char[] arr, int index, char object) {
             if (null == arr) {
                 return;
@@ -2097,6 +2113,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Byte getAt(byte[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(byte[] arr, int index, byte object) {
             if (null == arr) {
                 return;
@@ -2110,6 +2127,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Short getAt(short[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(short[] arr, int index, short object) {
             if (null == arr) {
                 return;
@@ -2123,6 +2141,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Integer getAt(int[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(int[] arr, int index, int object) {
             if (null == arr) {
                 return;
@@ -2136,6 +2155,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Long getAt(long[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(long[] arr, int index, long object) {
             if (null == arr) {
                 return;
@@ -2149,6 +2169,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Float getAt(float[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(float[] arr, int index, float object) {
             if (null == arr) {
                 return;
@@ -2162,6 +2183,7 @@ public abstract class StaticTypeCheckingSupport {
         public static Double getAt(double[] arr, int index) {
             return null == arr ? null : arr[index];
         }
+
         public static void putAt(double[] arr, int index, double object) {
             if (null == arr) {
                 return;
@@ -2215,12 +2237,13 @@ public abstract class StaticTypeCheckingSupport {
          * Returns a map which contains, as the key, the name of a class. The value
          * consists of a list of MethodNode, one for each default groovy method found
          * which is applicable for this class.
-         * @return
+         *
          * @param modules
+         * @return
          */
         private static Map<String, List<MethodNode>> getDGMMethods(List<ExtensionModule> modules) {
-           Set<Class> instanceExtClasses = new LinkedHashSet<Class>();
-           Set<Class> staticExtClasses = new LinkedHashSet<Class>();
+            Set<Class> instanceExtClasses = new LinkedHashSet<Class>();
+            Set<Class> staticExtClasses = new LinkedHashSet<Class>();
             for (ExtensionModule module : modules) {
                 if (module instanceof MetaInfExtensionModule) {
                     MetaInfExtensionModule extensionModule = (MetaInfExtensionModule) module;
@@ -2253,7 +2276,7 @@ public abstract class StaticTypeCheckingSupport {
         }
 
         private static void scanClassesForDGMMethods(Map<String, List<MethodNode>> accumulator,
-                                                    Iterable<Class> allClasses, boolean isStatic) {
+                                                     Iterable<Class> allClasses, boolean isStatic) {
             for (Class dgmLikeClass : allClasses) {
                 ClassNode cn = makeWithoutCaching(dgmLikeClass, true);
                 for (MethodNode metaMethod : cn.getMethods()) {
@@ -2303,7 +2326,7 @@ public abstract class StaticTypeCheckingSupport {
         if (node.isArray()) return isParameterizedWithGStringOrGStringString(node.getComponentType());
         if (node.isUsingGenerics()) {
             GenericsType[] genericsTypes = node.getGenericsTypes();
-            if (genericsTypes!=null) {
+            if (genericsTypes != null) {
                 for (GenericsType genericsType : genericsTypes) {
                     if (isGStringOrGStringStringLUB(genericsType.getType())) return true;
                 }
@@ -2320,7 +2343,7 @@ public abstract class StaticTypeCheckingSupport {
         if (node.isArray()) return isParameterizedWithString(node.getComponentType());
         if (node.isUsingGenerics()) {
             GenericsType[] genericsTypes = node.getGenericsTypes();
-            if (genericsTypes!=null) {
+            if (genericsTypes != null) {
                 for (GenericsType genericsType : genericsTypes) {
                     if (STRING_TYPE.equals(genericsType.getType())) return true;
                 }
@@ -2333,8 +2356,8 @@ public abstract class StaticTypeCheckingSupport {
         if (cn.isArray()) return missesGenericsTypes(cn.getComponentType());
         GenericsType[] cnTypes = cn.getGenericsTypes();
         GenericsType[] rnTypes = cn.redirect().getGenericsTypes();
-        if (rnTypes!=null && cnTypes==null) return true;
-        if (cnTypes!=null) {
+        if (rnTypes != null && cnTypes == null) return true;
+        if (cnTypes != null) {
             for (GenericsType genericsType : cnTypes) {
                 if (genericsType.isPlaceholder()) return true;
             }
@@ -2346,10 +2369,10 @@ public abstract class StaticTypeCheckingSupport {
      * A helper method that can be used to evaluate expressions as found in annotation
      * parameters. For example, it will evaluate a constant, be it referenced directly as
      * an integer or as a reference to a field.
-     *
+     * <p>
      * If this method throws an exception, then the expression cannot be evaluated on its own.
      *
-     * @param expr the expression to be evaluated
+     * @param expr   the expression to be evaluated
      * @param config the compiler configuration
      * @return the result of the expression
      */
@@ -2357,13 +2380,13 @@ public abstract class StaticTypeCheckingSupport {
         String className = "Expression$" + UUID.randomUUID().toString().replace('-', '$');
         ClassNode node = new ClassNode(className, Opcodes.ACC_PUBLIC, OBJECT_TYPE);
         ReturnStatement code = new ReturnStatement(expr);
-        node.addMethod(new MethodNode("eval", Opcodes.ACC_PUBLIC+ Opcodes.ACC_STATIC, OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, code));
+        node.addMethod(new MethodNode("eval", Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, code));
         CompilerConfiguration copyConf = new CompilerConfiguration(config);
         CompilationUnit cu = new CompilationUnit(copyConf);
         cu.addClassNode(node);
         cu.compile(Phases.CLASS_GENERATION);
         @SuppressWarnings("unchecked")
-        List<GroovyClass> classes = (List<GroovyClass>)cu.getClasses();
+        List<GroovyClass> classes = (List<GroovyClass>) cu.getClasses();
         Class aClass = cu.getClassLoader().defineClass(className, classes.get(0).getBytes());
         try {
             return aClass.getMethod("eval").invoke(null);
@@ -2379,6 +2402,7 @@ public abstract class StaticTypeCheckingSupport {
     /**
      * Collects all interfaces of a class node, including those defined by the
      * super class.
+     *
      * @param node a class for which we want to retrieve all interfaces
      * @return a set of interfaces implemented by this class node
      */
@@ -2391,11 +2415,12 @@ public abstract class StaticTypeCheckingSupport {
     /**
      * Collects all interfaces of a class node, including those defined by the
      * super class.
+     *
      * @param node a class for which we want to retrieve all interfaces
-     * @param out the set where to collect interfaces
+     * @param out  the set where to collect interfaces
      */
     private static void collectAllInterfaces(final ClassNode node, final Set<ClassNode> out) {
-        if (node==null) return;
+        if (node == null) return;
         Set<ClassNode> allInterfaces = node.getAllInterfaces();
         out.addAll(allInterfaces);
         collectAllInterfaces(node.getSuperClass(), out);
@@ -2406,6 +2431,7 @@ public abstract class StaticTypeCheckingSupport {
      * and if the parametrized type is a neither a placeholder or a wildcard. For example,
      * the class node Class&lt;Foo&gt; where Foo is a class would return true, but the class
      * node for Class&lt;?&gt; would return false.
+     *
      * @param classNode a class node to be tested
      * @return true if it is the class node for Class and its generic type is a real class
      */
@@ -2413,7 +2439,7 @@ public abstract class StaticTypeCheckingSupport {
         GenericsType[] genericsTypes = classNode.getGenericsTypes();
         return CLASS_Type.equals(classNode)
                 && classNode.isUsingGenerics()
-                && genericsTypes!=null
+                && genericsTypes != null
                 && !genericsTypes[0].isPlaceholder()
                 && !genericsTypes[0].isWildcard();
     }
@@ -2422,15 +2448,15 @@ public abstract class StaticTypeCheckingSupport {
         List<MethodNode> result = null;
         for (MethodNode method : cn.getDeclaredMethods(setterName)) {
             if (setterName.equals(method.getName())
-                    && (!voidOnly || VOID_TYPE==method.getReturnType())
+                    && (!voidOnly || VOID_TYPE == method.getReturnType())
                     && method.getParameters().length == 1) {
-                if (result==null) {
+                if (result == null) {
                     result = new LinkedList<MethodNode>();
                 }
                 result.add(method);
             }
         }
-        if (result==null) {
+        if (result == null) {
             ClassNode parent = cn.getSuperClass();
             if (parent != null) {
                 return findSetters(parent, setterName, voidOnly);
@@ -2443,7 +2469,7 @@ public abstract class StaticTypeCheckingSupport {
     public static ClassNode isTraitSelf(VariableExpression vexp) {
         if (Traits.THIS_OBJECT.equals(vexp.getName())) {
             Variable accessedVariable = vexp.getAccessedVariable();
-            ClassNode type = accessedVariable!=null?accessedVariable.getType():null;
+            ClassNode type = accessedVariable != null ? accessedVariable.getType() : null;
             if (accessedVariable instanceof Parameter
                     && Traits.isTrait(type)) {
                 return type;
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index c8e79bb6a4..a6067c27ae 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -304,13 +304,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (returnStatement.getExpression() == ConstantExpression.NULL) return;
             if (isNullConstant(returnStatement.getExpression())) return;
             checkReturnType(returnStatement);
-            if (typeCheckingContext.getEnclosingClosure()!=null) {
+            if (typeCheckingContext.getEnclosingClosure() != null) {
                 addClosureReturnType(getType(returnStatement.getExpression()));
             } else if (typeCheckingContext.getEnclosingMethod() != null) {
             } else {
                 throw new GroovyBugError("Unexpected return statement at "
-                        + returnStatement.getLineNumber()+":"+returnStatement.getColumnNumber()
-                        + " "+returnStatement.getText());
+                        + returnStatement.getLineNumber() + ":" + returnStatement.getColumnNumber()
+                        + " " + returnStatement.getText());
             }
         }
     };
@@ -445,6 +445,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     /**
      * Test if a node is an inner class node, and if it is, then checks if the enclosing method is skipped.
+     *
      * @param node
      * @return true if the inner class node should be skipped
      */
@@ -466,7 +467,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     @SuppressWarnings("unchecked")
     private static void addPrivateFieldOrMethodAccess(Expression source, ClassNode cn, StaticTypesMarker type, ASTNode accessedMember) {
         Set<ASTNode> set = (Set<ASTNode>) cn.getNodeMetaData(type);
-        if (set==null) {
+        if (set == null) {
             set = new LinkedHashSet<ASTNode>();
             cn.putNodeMetaData(type, set);
         }
@@ -478,9 +479,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * Given a field node, checks if we are accessing or setting a private field from an inner class.
      */
     private void checkOrMarkPrivateAccess(Expression source, FieldNode fn, boolean lhsOfAssignment) {
-        if (fn!=null && Modifier.isPrivate(fn.getModifiers()) &&
-            (fn.getDeclaringClass() != typeCheckingContext.getEnclosingClassNode() || typeCheckingContext.getEnclosingClosure()!=null) &&
-            fn.getDeclaringClass().getModule() == typeCheckingContext.getEnclosingClassNode().getModule()) {
+        if (fn != null && Modifier.isPrivate(fn.getModifiers()) &&
+                (fn.getDeclaringClass() != typeCheckingContext.getEnclosingClassNode() || typeCheckingContext.getEnclosingClosure() != null) &&
+                fn.getDeclaringClass().getModule() == typeCheckingContext.getEnclosingClassNode().getModule()) {
             StaticTypesMarker marker = lhsOfAssignment ? StaticTypesMarker.PV_FIELDS_MUTATION : StaticTypesMarker.PV_FIELDS_ACCESS;
             addPrivateFieldOrMethodAccess(source, fn.getDeclaringClass(), marker, fn);
         }
@@ -490,7 +491,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * Given a method node, checks if we are calling a private method from an inner class.
      */
     private void checkOrMarkPrivateAccess(Expression source, MethodNode mn) {
-        if (mn==null) {
+        if (mn == null) {
             return;
         }
         ClassNode declaringClass = mn.getDeclaringClass();
@@ -499,7 +500,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             int mods = mn.getModifiers();
             boolean sameModule = declaringClass.getModule() == enclosingClassNode.getModule();
             String packageName = declaringClass.getPackageName();
-            if (packageName==null) {
+            if (packageName == null) {
                 packageName = "";
             }
             if ((Modifier.isPrivate(mods) && sameModule)) {
@@ -519,7 +520,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private void checkSuperCallFromClosure(Expression call, MethodNode directCallTarget) {
         if (call instanceof MethodCallExpression && typeCheckingContext.getEnclosingClosure() != null) {
-            Expression objectExpression = ((MethodCallExpression)call).getObjectExpression();
+            Expression objectExpression = ((MethodCallExpression) call).getObjectExpression();
             if (objectExpression instanceof VariableExpression) {
                 VariableExpression var = (VariableExpression) objectExpression;
                 if (var.isSuperExpression()) {
@@ -542,7 +543,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     private static ClassNode makeType(ClassNode cn, boolean usingClass) {
         if (usingClass) {
             ClassNode clazzType = CLASS_Type.getPlainNodeReference();
-            clazzType.setGenericsTypes(new GenericsType[] {new GenericsType(cn)});
+            clazzType.setGenericsTypes(new GenericsType[]{new GenericsType(cn)});
             return clazzType;
         } else {
             return cn;
@@ -600,7 +601,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             } else if ("delegate".equals(name)) {
                 DelegationMetadata md = getDelegationMetadata(enclosingClosure.getClosureExpression());
                 ClassNode type = typeCheckingContext.getEnclosingClassNode();
-                if (md!=null) type = md.getType();
+                if (md != null) type = md.getType();
                 storeType(vexp, type);
                 return;
             }
@@ -647,9 +648,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             vexp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, previousIt);
             storeType(vexp, getType(pe));
             Object val = pe.getNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);
-            if (val!=null) vexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY,val);
+            if (val != null) vexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, val);
             val = pe.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);
-            if (val!=null) vexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER,val);
+            if (val != null) vexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, val);
             return true;
         }
         return false;
@@ -661,7 +662,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     @Override
     public void visitPropertyExpression(final PropertyExpression pexp) {
-        if (visitPropertyExpressionSilent(pexp,pexp)) return;
+        if (visitPropertyExpressionSilent(pexp, pexp)) return;
 
         if (!extension.handleUnresolvedProperty(pexp)) {
             Expression objectExpression = pexp.getObjectExpression();
@@ -694,8 +695,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             storeType(expression, ClassHelper.make(IntRange.class));
         } else {
             ClassNode rangeType = ClassHelper.make(Range.class).getPlainNodeReference();
-            rangeType.setGenericsTypes(new GenericsType[] { new GenericsType(WideningCategories.lowestUpperBound(fromType, toType))});
-            storeType(expression,  rangeType);
+            rangeType.setGenericsTypes(new GenericsType[]{new GenericsType(WideningCategories.lowestUpperBound(fromType, toType))});
+            storeType(expression, rangeType);
         }
     }
 
@@ -724,16 +725,16 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     rType = UNKNOWN_PARAMETER_TYPE; // primitive types should be ignored as they will result in another failure
             }
             BinaryExpression reversedBinaryExpression = binX(rightExpression, expression.getOperation(), leftExpression);
-            ClassNode resultType = (op==KEYWORD_IN || op==COMPARE_NOT_IN)
-                    ?getResultType(rType,op,lType,reversedBinaryExpression)
-                    :getResultType(lType, op, rType, expression);
-            if (op==KEYWORD_IN || op==COMPARE_NOT_IN) {
+            ClassNode resultType = (op == KEYWORD_IN || op == COMPARE_NOT_IN)
+                    ? getResultType(rType, op, lType, reversedBinaryExpression)
+                    : getResultType(lType, op, rType, expression);
+            if (op == KEYWORD_IN || op == COMPARE_NOT_IN) {
                 // in case of the "in" operator, the receiver and the arguments are reversed
                 // so we use the reversedExpression and get the target method from it
                 storeTargetMethod(expression, (MethodNode) reversedBinaryExpression.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
             } else if (op == LEFT_SQUARE_BRACKET
                     && leftExpression instanceof VariableExpression
-                    && leftExpression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE)==null) {
+                    && leftExpression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE) == null) {
                 storeType(leftExpression, lType);
             }
             if (resultType == null) {
@@ -831,13 +832,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();
                         leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);
                     } else if (rightExpression instanceof VariableExpression &&
-                            ((VariableExpression)rightExpression).getAccessedVariable() instanceof Expression &&
-                            ((Expression)((VariableExpression)rightExpression).getAccessedVariable()).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS)!=null) {
-                        Variable targetVariable = findTargetVariable((VariableExpression)leftExpression);
+                            ((VariableExpression) rightExpression).getAccessedVariable() instanceof Expression &&
+                            ((Expression) ((VariableExpression) rightExpression).getAccessedVariable()).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS) != null) {
+                        Variable targetVariable = findTargetVariable((VariableExpression) leftExpression);
                         if (targetVariable instanceof ASTNode) {
-                            ((ASTNode)targetVariable).putNodeMetaData(
-                                StaticTypesMarker.CLOSURE_ARGUMENTS,
-                                ((Expression)((VariableExpression)rightExpression).getAccessedVariable()).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS));
+                            ((ASTNode) targetVariable).putNodeMetaData(
+                                    StaticTypesMarker.CLOSURE_ARGUMENTS,
+                                    ((Expression) ((VariableExpression) rightExpression).getAccessedVariable()).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS));
                         }
                     }
                 }
@@ -857,10 +858,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     /**
      * Given a binary expression corresponding to an assignment, will check that the type of the RHS matches one
      * of the possible setters and if not, throw a type checking error.
-     * @param expression the assignment expression
-     * @param leftExpression left expression of the assignment
+     *
+     * @param expression      the assignment expression
+     * @param leftExpression  left expression of the assignment
      * @param rightExpression right expression of the assignment
-     * @param setterInfo possible setters
+     * @param setterInfo      possible setters
      * @return true if type checking passed
      */
     private boolean ensureValidSetter(final Expression expression, final Expression leftExpression, final Expression rightExpression, final SetterInfo setterInfo) {
@@ -877,7 +879,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         call.setImplicitThis(false);
         visitMethodCallExpression(call);
         MethodNode directSetterCandidate = call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
-        if (directSetterCandidate==null) {
+        if (directSetterCandidate == null) {
             // this may happen if there's a setter of type boolean/String/Class, and that we are using the property
             // notation AND that the RHS is not a boolean/String/Class
             for (MethodNode setter : setterInfo.setters) {
@@ -887,7 +889,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     call.setImplicitThis(false);
                     visitMethodCallExpression(call);
                     directSetterCandidate = call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
-                    if (directSetterCandidate!=null) {
+                    if (directSetterCandidate != null) {
                         break;
                     }
                 }
@@ -1080,8 +1082,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     private void addListAssignmentConstructorErrors(
             ClassNode leftRedirect, ClassNode leftExpressionType,
             ClassNode inferredRightExpressionType, Expression rightExpression,
-            Expression assignmentExpression)
-    {
+            Expression assignmentExpression) {
         // if left type is not a list but right type is a list, then we're in the case of a groovy
         // constructor type : Dimension d = [100,200]
         // In that case, more checks can be performed
@@ -1089,15 +1090,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             ArgumentListExpression argList = args(((ListExpression) rightExpression).getExpressions());
             ClassNode[] args = getArgumentTypes(argList);
             MethodNode methodNode = checkGroovyStyleConstructor(leftRedirect, args, assignmentExpression);
-            if (methodNode!=null) {
+            if (methodNode != null) {
                 rightExpression.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, methodNode);
             }
         } else if (!implementsInterfaceOrIsSubclassOf(inferredRightExpressionType, leftRedirect)
                 && implementsInterfaceOrIsSubclassOf(inferredRightExpressionType, LIST_TYPE)
                 && !isWildcardLeftHandSide(leftExpressionType)) {
-                if (!extension.handleIncompatibleAssignment(leftExpressionType, inferredRightExpressionType, assignmentExpression)) {
-                    addAssignmentError(leftExpressionType, inferredRightExpressionType, assignmentExpression);
-                }
+            if (!extension.handleIncompatibleAssignment(leftExpressionType, inferredRightExpressionType, assignmentExpression)) {
+                addAssignmentError(leftExpressionType, inferredRightExpressionType, assignmentExpression);
+            }
         }
     }
 
@@ -1125,7 +1126,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (hasRHSIncompleteGenericTypeInfo(wrappedRHS)) return;
 
         GenericsType gt = GenericsUtils.buildWildcardType(leftExpressionType);
-        if (    UNKNOWN_PARAMETER_TYPE.equals(wrappedRHS) ||
+        if (UNKNOWN_PARAMETER_TYPE.equals(wrappedRHS) ||
                 gt.isCompatibleWith(wrappedRHS) ||
                 isNullConstant(rightExpression)) return;
 
@@ -1148,8 +1149,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             final Expression leftExpression,
             final ClassNode leftExpressionType,
             final Expression rightExpression,
-            final ClassNode inferredRightExpressionTypeOrig)
-    {
+            final ClassNode inferredRightExpressionTypeOrig) {
         ClassNode inferredRightExpressionType = inferredRightExpressionTypeOrig;
         if (!typeCheckMultipleAssignmentAndContinue(leftExpression, rightExpression)) return;
 
@@ -1256,7 +1256,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
         List<MethodNode> constructorList = findMethod(node, "<init>", arguments);
         if (constructorList.isEmpty()) {
-            if (isBeingCompiled(node) && arguments.length==1 && LINKEDHASHMAP_CLASSNODE.equals(arguments[0])) {
+            if (isBeingCompiled(node) && arguments.length == 1 && LINKEDHASHMAP_CLASSNODE.equals(arguments[0])) {
                 // there will be a default hash map constructor added later
                 ConstructorNode cn = new ConstructorNode(Opcodes.ACC_PUBLIC, new Parameter[]{
                         new Parameter(LINKEDHASHMAP_CLASSNODE, "args")
@@ -1266,7 +1266,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 addStaticTypeError("No matching constructor found: " + node + toMethodParametersString("<init>", arguments), source);
                 return null;
             }
-        } else if (constructorList.size()>1) {
+        } else if (constructorList.size() > 1) {
             addStaticTypeError("Ambiguous constructor call " + node + toMethodParametersString("<init>", arguments), source);
             return null;
         }
@@ -1293,7 +1293,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * @param expr the expression for which an unknown field has been found
      * @param type the type of the expression (used as fallback type)
      * @return if temporary information is available and there's only one type, returns the temporary type class
-     *         otherwise falls back to the provided type class.
+     * otherwise falls back to the provided type class.
      */
     protected ClassNode findCurrentInstanceOfClass(final Expression expr, final ClassNode type) {
         if (!typeCheckingContext.temporaryIfBranchTypeInformation.empty()) {
@@ -1311,9 +1311,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the
      * temporary type information table)
      *
-     * @param pexp             a property expression
-     * @param readMode         if true, look for property read, else for property set
-     * @param visitor          if not null, when the property node is found, visit it with the provided visitor
+     * @param pexp     a property expression
+     * @param readMode if true, look for property read, else for property set
+     * @param visitor  if not null, when the property node is found, visit it with the provided visitor
      * @return true if the property is defined in any of the possible receiver classes
      */
     protected boolean existsProperty(final PropertyExpression pexp, final boolean readMode, final ClassCodeVisitorSupport visitor) {
@@ -1389,7 +1389,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                 FieldNode field = current.getDeclaredField(propertyName);
                 field = allowStaticAccessToMember(field, staticOnly);
-                if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData(), !readMode)) return true;
+                if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData(), !readMode))
+                    return true;
 
                 boolean isThisExpression = objectExpression instanceof VariableExpression
                         && ((VariableExpression) objectExpression).isThisExpression()
@@ -1469,7 +1470,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             List<ClassNode> dgmReceivers = new ArrayList<ClassNode>(2);
             dgmReceivers.add(testClass);
             if (isPrimitiveType(testClass)) dgmReceivers.add(getWrapper(testClass));
-            for (ClassNode dgmReceiver: dgmReceivers) {
+            for (ClassNode dgmReceiver : dgmReceivers) {
                 List<MethodNode> methods = findDGMMethodsByNameAndArguments(getTransformLoader(), dgmReceiver, "get" + capName, ClassNode.EMPTY_ARRAY);
                 for (MethodNode m : findDGMMethodsByNameAndArguments(getTransformLoader(), dgmReceiver, "is" + capName, ClassNode.EMPTY_ARRAY)) {
                     if (Boolean_TYPE.equals(getWrapper(m.getReturnType()))) methods.add(m);
@@ -1493,10 +1494,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         for (Receiver<String> receiver : receivers) {
             ClassNode testClass = receiver.getType();
             ClassNode propertyType = getTypeForMapPropertyExpression(testClass, objectExpressionType, pexp);
-            if (propertyType==null) propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);
-            if (propertyType==null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);
-            if (propertyType==null) continue;
-            if (visitor!=null) {
+            if (propertyType == null)
+                propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);
+            if (propertyType == null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);
+            if (propertyType == null) continue;
+            if (visitor != null) {
                 // todo : type inference on maps and lists, if possible
                 PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, receiver.getType(), null, null, null);
                 node.setDeclaringClass(receiver.getType());
@@ -1504,7 +1506,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
             storeType(pexp, propertyType);
             String delegationData = receiver.getData();
-            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);
+            if (delegationData != null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);
             return true;
         }
         return foundGetterOrSetter;
@@ -1527,12 +1529,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (!implementsInterfaceOrIsSubclassOf(callType, Iterator_TYPE)) return null;
         GenericsType[] types = callType.getGenericsTypes();
         ClassNode contentType = OBJECT_TYPE;
-        if (types!=null && types.length==1) contentType = types[0].getType();
+        if (types != null && types.length == 1) contentType = types[0].getType();
         PropertyExpression subExp = new PropertyExpression(varX("{}", contentType), pexp.getPropertyAsString());
         AtomicReference<ClassNode> result = new AtomicReference<ClassNode>();
         if (existsProperty(subExp, true, new PropertyLookupVisitor(result))) {
             ClassNode intf = LIST_TYPE.getPlainNodeReference();
-            intf.setGenericsTypes(new GenericsType[] { new GenericsType(getWrapper(result.get()))});
+            intf.setGenericsTypes(new GenericsType[]{new GenericsType(getWrapper(result.get()))});
             return intf;
         }
         return null;
@@ -1542,14 +1544,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (!implementsInterfaceOrIsSubclassOf(testClass, LIST_TYPE)) return null;
         ClassNode intf = GenericsUtils.parameterizeType(objectExpressionType, LIST_TYPE.getPlainNodeReference());
         GenericsType[] types = intf.getGenericsTypes();
-        if (types==null || types.length!=1) return OBJECT_TYPE;
+        if (types == null || types.length != 1) return OBJECT_TYPE;
 
         PropertyExpression subExp = new PropertyExpression(varX("{}", types[0].getType()), pexp.getPropertyAsString());
         AtomicReference<ClassNode> result = new AtomicReference<ClassNode>();
         if (existsProperty(subExp, true, new PropertyLookupVisitor(result))) {
             intf = LIST_TYPE.getPlainNodeReference();
             ClassNode itemType = result.get();
-            intf.setGenericsTypes(new GenericsType[] { new GenericsType(wrapTypeIfNecessary(itemType))});
+            intf.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(itemType))});
             return intf;
         }
         return null;
@@ -1558,7 +1560,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     private ClassNode getTypeForMapPropertyExpression(ClassNode testClass, ClassNode objectExpressionType, PropertyExpression pexp) {
         if (!implementsInterfaceOrIsSubclassOf(testClass, MAP_TYPE)) return null;
         ClassNode intf;
-        if (objectExpressionType.getGenericsTypes()!=null) {
+        if (objectExpressionType.getGenericsTypes() != null) {
             intf = GenericsUtils.parameterizeType(objectExpressionType, MAP_TYPE.getPlainNodeReference());
         } else {
             intf = MAP_TYPE.getPlainNodeReference();
@@ -1590,7 +1592,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     /**
      * This method is used to filter search results in which null means "no match",
      * to filter out illegal access to instance members from a static context.
-     *
+     * <p>
      * Return null if the given member is not static, but we want to access in
      * a static way (staticOnly=true). If we want to access in a non-static way
      * we always return the member, since then access to static members and
@@ -1604,9 +1606,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (member instanceof Variable) {
             Variable v = (Variable) member;
             isStatic = Modifier.isStatic(v.getModifiers());
-        } else if (member instanceof List)  {
+        } else if (member instanceof List) {
             List<MethodNode> list = (List<MethodNode>) member;
-            if (list.size()==1) {
+            if (list.size() == 1) {
                 return (T) Collections.singletonList(allowStaticAccessToMember(list.get(0), staticOnly));
             }
             return (T) Collections.emptyList();
@@ -1620,7 +1622,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private void storeWithResolve(ClassNode typeToResolve, ClassNode receiver, ClassNode declaringClass, boolean isStatic, PropertyExpression expressionToStoreOn) {
         ClassNode type = typeToResolve;
-        if (getGenericsWithoutArray(type)!=null) {
+        if (getGenericsWithoutArray(type) != null) {
             Map<String, GenericsType> resolvedPlaceholders = resolvePlaceHoldersFromDeclaration(receiver, declaringClass, null, isStatic);
             type = resolveGenericsWithContext(resolvedPlaceholders, type);
         }
@@ -1629,11 +1631,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     private boolean storeField(FieldNode field, boolean returnTrueIfFieldExists, PropertyExpression expressionToStoreOn, ClassNode receiver, ClassCodeVisitorSupport visitor, String delegationData, boolean lhsOfAssignment) {
-        if (field==null || !returnTrueIfFieldExists) return false;
+        if (field == null || !returnTrueIfFieldExists) return false;
         if (visitor != null) visitor.visitField(field);
         storeWithResolve(field.getOriginType(), receiver, field.getDeclaringClass(), field.isStatic(), expressionToStoreOn);
         checkOrMarkPrivateAccess(expressionToStoreOn, field, lhsOfAssignment);
-        if (delegationData!=null) {
+        if (delegationData != null) {
             expressionToStoreOn.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);
         }
         return true;
@@ -1643,7 +1645,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (propertyNode == null) return false;
         if (visitor != null) visitor.visitProperty(propertyNode);
         storeWithResolve(propertyNode.getOriginType(), receiver, propertyNode.getDeclaringClass(), propertyNode.isStatic(), expressionToStoreOn);
-        if (delegationData!=null) {
+        if (delegationData != null) {
             expressionToStoreOn.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);
         }
         return true;
@@ -1652,7 +1654,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected void storeInferredTypeForPropertyExpression(final PropertyExpression pexp, final ClassNode flatInferredType) {
         if (pexp.isSpreadSafe()) {
             ClassNode list = LIST_TYPE.getPlainNodeReference();
-            list.setGenericsTypes(new GenericsType[] {
+            list.setGenericsTypes(new GenericsType[]{
                     new GenericsType(flatInferredType)
             });
             storeType(pexp, list);
@@ -1674,7 +1676,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         String capName = MetaClassHelper.capitalize(propertyName);
         boolean isAttributeExpression = pexp instanceof AttributeExpression;
 
-        for (Receiver<String> receiver: receivers) {
+        for (Receiver<String> receiver : receivers) {
             ClassNode testClass = receiver.getType();
             LinkedList<ClassNode> queue = new LinkedList<ClassNode>();
             queue.add(testClass);
@@ -1851,7 +1853,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             resultType = PATTERN_TYPE;
         } else {
             MethodNode mn = findMethodOrFail(expression, type, "bitwiseNegate");
-            if (mn!=null) {
+            if (mn != null) {
                 resultType = mn.getReturnType();
             } else {
                 resultType = OBJECT_TYPE;
@@ -1911,7 +1913,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     if (node != null) {
                         storeTargetMethod(origin, node);
                         storeType(origin,
-                                isPostfix?exprType:getMathWideningClassNode(exprType));
+                                isPostfix ? exprType : getMathWideningClassNode(exprType));
                         return;
                     }
                 }
@@ -1937,7 +1939,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         MethodNode node = findMethodOrFail(innerExpression, exprType, name);
         if (node != null) {
             storeTargetMethod(origin, node);
-            storeType(origin,  isPostfix?exprType:inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
+            storeType(origin, isPostfix ? exprType : inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
         }
     }
 
@@ -1981,7 +1983,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected ClassNode checkReturnType(final ReturnStatement statement) {
         Expression expression = statement.getExpression();
         ClassNode type = getType(expression);
-        if (typeCheckingContext.getEnclosingClosure()!=null) {
+        if (typeCheckingContext.getEnclosingClosure() != null) {
             return type;
         }
         // handle instanceof cases
@@ -1989,7 +1991,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             type = expression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
         }
         MethodNode enclosingMethod = typeCheckingContext.getEnclosingMethod();
-        if (enclosingMethod != null && typeCheckingContext.getEnclosingClosure()==null) {
+        if (enclosingMethod != null && typeCheckingContext.getEnclosingClosure() == null) {
             if (!enclosingMethod.isVoidMethod()
                     && !type.equals(void_WRAPPER_TYPE)
                     && !type.equals(VOID_TYPE)
@@ -2044,14 +2046,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         checkForbiddenSpreadArgument(argumentList);
 
         ClassNode[] args = getArgumentTypes(argumentList);
-        if (    args.length>0 &&
-                typeCheckingContext.getEnclosingClosure()!=null &&
+        if (args.length > 0 &&
+                typeCheckingContext.getEnclosingClosure() != null &&
                 argumentList.getExpression(0) instanceof VariableExpression &&
                 ((VariableExpression) argumentList.getExpression(0)).isThisExpression() &&
                 call.getType() instanceof InnerClassNode &&
                 call.getType().getOuterClass().equals(args[0]) &&
-                !call.getType().isStaticClass())
-        {
+                !call.getType().isStaticClass()) {
             args[0] = CLOSURE_TYPE;
         }
 
@@ -2117,11 +2118,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         ClassNode[] ret = new ClassNode[arglist.size()];
         for (int i = 0; i < arglist.size(); i++) {
             Expression exp = arglist.get(i);
-                if (isNullConstant(exp)) {
-                    ret[i] = UNKNOWN_PARAMETER_TYPE;
-                } else {
-                    ret[i] = getInferredTypeFromTempInfo(exp, getType(exp));
-                }
+            if (isNullConstant(exp)) {
+                ret[i] = UNKNOWN_PARAMETER_TYPE;
+            } else {
+                ret[i] = getInferredTypeFromTempInfo(exp, getType(exp));
+            }
         }
         return ret;
     }
@@ -2144,7 +2145,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
                 if (arr.isEmpty()) {
                     result = ClassHelper.OBJECT_TYPE.getPlainNodeReference();
-                } else if (arr.size()==1) {
+                } else if (arr.size() == 1) {
                     result = arr.get(0);
                 } else {
                     result = new UnionTypeClassNode(arr.toArray(ClassNode.EMPTY_ARRAY));
@@ -2178,7 +2179,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         // perform visit
         typeCheckingContext.pushEnclosingClosureExpression(expression);
         DelegationMetadata dmd = getDelegationMetadata(expression);
-        if (dmd ==null) {
+        if (dmd == null) {
             typeCheckingContext.delegationMetadata = new DelegationMetadata(
                     typeCheckingContext.getEnclosingClassNode(), Closure.OWNER_FIRST, typeCheckingContext.delegationMetadata
             );
@@ -2211,7 +2212,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         restoreVariableExpressionMetadata(typesBeforeVisit);
         typeCheckingContext.isInStaticContext = oldStaticContext;
         Parameter[] parameters = expression.getParameters();
-        if (parameters!=null) {
+        if (parameters != null) {
             for (Parameter parameter : parameters) {
                 typeCheckingContext.controlStructureVariables.remove(parameter);
             }
@@ -2292,7 +2293,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return;
         }
         for (Parameter parameter : node.getParameters()) {
-            if (parameter.getInitialExpression()!=null) {
+            if (parameter.getInitialExpression() != null) {
                 parameter.getInitialExpression().visit(this);
             }
         }
@@ -2307,7 +2308,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         // we must not visit a method which used dynamic dispatch.
         // We do not check for an annotation because some other AST transformations
         // may use this visitor without the annotation being explicitly set
-        if (!typeCheckingContext.methodsToBeVisited.isEmpty() && !typeCheckingContext.methodsToBeVisited.contains(node)) return;
+        if (!typeCheckingContext.methodsToBeVisited.isEmpty() && !typeCheckingContext.methodsToBeVisited.contains(node))
+            return;
 
         // alreadyVisitedMethods prevents from visiting the same method multiple times
         // and prevents from infinite loops
@@ -2321,7 +2323,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             typeCheckingContext.isInStaticContext = node.isStatic();
             super.visitMethod(node);
             for (Parameter parameter : node.getParameters()) {
-                if (parameter.getInitialExpression()!=null) {
+                if (parameter.getInitialExpression() != null) {
                     parameter.getInitialExpression().visit(this);
                 }
             }
@@ -2399,7 +2401,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             for (Receiver<String> currentReceiver : receivers) {
                 mn = findMethod(currentReceiver.getType(), name, args);
                 if (!mn.isEmpty()) {
-                    if (mn.size() == 1) typeCheckMethodsWithGenericsOrFail(currentReceiver.getType(), args, mn.get(0), call);
+                    if (mn.size() == 1)
+                        typeCheckMethodsWithGenericsOrFail(currentReceiver.getType(), args, mn.get(0), call);
                     chosenReceiver = currentReceiver;
                     break;
                 }
@@ -2428,7 +2431,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     addAmbiguousErrorMessage(mn, name, args, call);
                 }
                 if (!callArgsVisited) {
-                    visitMethodCallArguments(receiver, argumentList, true, (MethodNode)call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
+                    visitMethodCallArguments(receiver, argumentList, true, (MethodNode) call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
                 }
             }
         } finally {
@@ -2437,9 +2440,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     /**
-     * @deprecated this method is unused, replaced with {@link DelegatesTo} inference.
      * @param callArguments
      * @param receiver
+     * @deprecated this method is unused, replaced with {@link DelegatesTo} inference.
      */
     @Deprecated
     protected void checkClosureParameters(final Expression callArguments, final ClassNode receiver) {
@@ -2474,7 +2477,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     protected void visitMethodCallArguments(final ClassNode receiver, ArgumentListExpression arguments, boolean visitClosures, final MethodNode selectedMethod) {
-        Parameter[] params = selectedMethod!=null?selectedMethod.getParameters(): Parameter.EMPTY_ARRAY;
+        Parameter[] params = selectedMethod != null ? selectedMethod.getParameters() : Parameter.EMPTY_ARRAY;
         List<Expression> expressions = new LinkedList<Expression>(arguments.getExpressions());
         if (selectedMethod instanceof ExtensionMethodNode) {
             params = ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode().getParameters();
@@ -2486,19 +2489,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             final Expression expression = expressions.get(i);
             if (visitClosures && expression instanceof ClosureExpression
                     || !visitClosures && !(expression instanceof ClosureExpression)) {
-                if (i<params.length && visitClosures) {
+                if (i < params.length && visitClosures) {
                     Parameter param = params[i];
-                    checkClosureWithDelegatesTo(receiver, selectedMethod, newArgs,params , expression, param);
+                    checkClosureWithDelegatesTo(receiver, selectedMethod, newArgs, params, expression, param);
                     if (selectedMethod instanceof ExtensionMethodNode) {
-                        if (i>0) {
-                            inferClosureParameterTypes(receiver, arguments, (ClosureExpression)expression, param, selectedMethod);
+                        if (i > 0) {
+                            inferClosureParameterTypes(receiver, arguments, (ClosureExpression) expression, param, selectedMethod);
                         }
                     } else {
                         inferClosureParameterTypes(receiver, newArgs, (ClosureExpression) expression, param, selectedMethod);
                     }
                 }
                 expression.visit(this);
-                if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA)!=null) {
+                if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA) != null) {
                     expression.removeNodeMetaData(StaticTypesMarker.DELEGATION_METADATA);
                 }
             }
@@ -2514,13 +2517,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      *
      * @param receiver
      * @param arguments
-     * @param expression a closure expression for which the argument types should be inferred
-     * @param param the parameter where to look for a {@link groovy.transform.stc.ClosureParams} annotation.
+     * @param expression     a closure expression for which the argument types should be inferred
+     * @param param          the parameter where to look for a {@link groovy.transform.stc.ClosureParams} annotation.
      * @param selectedMethod the method accepting a closure
      */
     protected void inferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final Parameter param, final MethodNode selectedMethod) {
         List<AnnotationNode> annotations = param.getAnnotations(CLOSUREPARAMS_CLASSNODE);
-        if (annotations!=null && !annotations.isEmpty()) {
+        if (annotations != null && !annotations.isEmpty()) {
             for (AnnotationNode annotation : annotations) {
                 Expression hintClass = annotation.getMember("value");
                 Expression options = annotation.getMember("options");
@@ -2550,7 +2553,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // First we try to get as much information about the declaration
         // class through the receiver
-        Map<String,GenericsType> targetMethodDeclarationClassConnections = new HashMap<String,GenericsType>();
+        Map<String, GenericsType> targetMethodDeclarationClassConnections = new HashMap<String, GenericsType>();
         extractGenericsConnections(targetMethodDeclarationClassConnections, receiver, receiver.redirect());
         // then we use the method with the SAM parameter to get more information about the declaration
         Parameter[] parametersOfMethodContainingSAM = methodWithSAMParameter.getParameters();
@@ -2571,7 +2574,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         // to replace the generics in the SAM type parameter of the target
         // method and than that to make the connections to the SAM type generics
         ClassNode paramTypeWithReceiverInformation = applyGenericsContext(targetMethodDeclarationClassConnections, param.getOriginType());
-        Map<String,GenericsType> SAMTypeConnections = new HashMap<String,GenericsType>();
+        Map<String, GenericsType> SAMTypeConnections = new HashMap<String, GenericsType>();
         ClassNode classForSAM = paramTypeWithReceiverInformation.redirect();
         extractGenericsConnections(SAMTypeConnections, paramTypeWithReceiverInformation, classForSAM);
 
@@ -2580,12 +2583,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         MethodNode methodForSAM = findSAM(classForSAM);
         ClassNode[] parameterTypesForSAM = extractTypesFromParameters(methodForSAM.getParameters());
         ClassNode[] blockParameterTypes = (ClassNode[]) openBlock.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
-        if (blockParameterTypes==null) {
+        if (blockParameterTypes == null) {
             Parameter[] p = openBlock.getParameters();
             if (p == null) {
                 // zero parameter closure e.g. { -> println 'no args' }
                 blockParameterTypes = ClassNode.EMPTY_ARRAY;
-            } else if (p.length==0 && parameterTypesForSAM.length!=0) {
+            } else if (p.length == 0 && parameterTypesForSAM.length != 0) {
                 // implicit it
                 blockParameterTypes = parameterTypesForSAM;
             } else {
@@ -2599,13 +2602,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
         }
-        for (int i=0; i<blockParameterTypes.length; i++) {
+        for (int i = 0; i < blockParameterTypes.length; i++) {
             extractGenericsConnections(SAMTypeConnections, blockParameterTypes[i], typeOrNull(parameterTypesForSAM, i));
         }
 
         // and finally we apply the generics information to the parameters and
         // store the type of parameter and block type as meta information
-        for (int i=0; i<blockParameterTypes.length; i++) {
+        for (int i = 0; i < blockParameterTypes.length; i++) {
             ClassNode resolvedParameter =
                     applyGenericsContext(SAMTypeConnections, typeOrNull(parameterTypesForSAM, i));
             blockParameterTypes[i] = resolvedParameter;
@@ -2626,7 +2629,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             Class<? extends ClosureSignatureHint> hint = (Class<? extends ClosureSignatureHint>) transformLoader.loadClass(hintClass.getText());
             ClosureSignatureHint hintInstance = hint.newInstance();
             closureSignatures = hintInstance.getClosureSignatures(
-                    selectedMethod instanceof ExtensionMethodNode ?((ExtensionMethodNode) selectedMethod).getExtensionMethodNode():selectedMethod,
+                    selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod,
                     typeCheckingContext.source,
                     typeCheckingContext.compilationUnit,
                     convertToStringArray(options), expression);
@@ -2667,7 +2670,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private ClassLoader getTransformLoader() {
         CompilationUnit compilationUnit = typeCheckingContext.getCompilationUnit();
-        return compilationUnit!=null?compilationUnit.getTransformLoader():getSourceUnit().getClassLoader();
+        return compilationUnit != null ? compilationUnit.getTransformLoader() : getSourceUnit().getClassLoader();
     }
 
     private void doInferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, Expression resolverClass, final Expression options) {
@@ -2688,7 +2691,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 candidates.add(inferred);
             }
         }
-        if (candidates.size()>1) {
+        if (candidates.size() > 1) {
             Iterator<ClassNode[]> candIt = candidates.iterator();
             while (candIt.hasNext()) {
                 ClassNode[] inferred = candIt.next();
@@ -2697,10 +2700,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     Parameter closureParam = closureParams[i];
                     final ClassNode originType = closureParam.getOriginType();
                     ClassNode inferredType;
-                    if (i<inferred.length-1 || inferred.length==closureParams.length) {
+                    if (i < inferred.length - 1 || inferred.length == closureParams.length) {
                         inferredType = inferred[i];
                     } else { // vargs?
-                        ClassNode lastArgInferred = inferred[inferred.length-1];
+                        ClassNode lastArgInferred = inferred[inferred.length - 1];
                         if (lastArgInferred.isArray()) {
                             inferredType = lastArgInferred.getComponentType();
                         } else {
@@ -2708,7 +2711,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             continue;
                         }
                     }
-                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {
+                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i == length - 1)) {
                         candIt.remove();
                     }
                 }
@@ -2716,13 +2719,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (candidates.size() > 1 && resolverClass instanceof ClassExpression) {
                 candidates = resolveWithResolver(candidates, receiver, arguments, expression, selectedMethod, resolverClass, options);
             }
-            if (candidates.size()>1) {
+            if (candidates.size() > 1) {
                 addError("Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.", expression);
             }
         }
-        if (candidates.size()==1) {
+        if (candidates.size() == 1) {
             ClassNode[] inferred = candidates.get(0);
-            if (closureParams.length==0 && inferred.length==1) {
+            if (closureParams.length == 0 && inferred.length == 1) {
                 expression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, inferred);
             } else {
                 final int length = closureParams.length;
@@ -2730,15 +2733,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     Parameter closureParam = closureParams[i];
                     final ClassNode originType = closureParam.getOriginType();
                     ClassNode inferredType = OBJECT_TYPE;
-                    if (i<inferred.length-1 || inferred.length==closureParams.length) {
+                    if (i < inferred.length - 1 || inferred.length == closureParams.length) {
                         inferredType = inferred[i];
                     } else { // vargs?
-                            ClassNode lastArgInferred = inferred[inferred.length-1];
-                            if (lastArgInferred.isArray()) {
-                                inferredType = lastArgInferred.getComponentType();
-                            } else {
-                                addError("Incorrect number of parameters. Expected "+inferred.length+" but found "+closureParams.length, expression);
-                            }
+                        ClassNode lastArgInferred = inferred[inferred.length - 1];
+                        if (lastArgInferred.isArray()) {
+                            inferredType = lastArgInferred.getComponentType();
+                        } else {
+                            addError("Incorrect number of parameters. Expected " + inferred.length + " but found " + closureParams.length, expression);
+                        }
                     }
                     boolean lastArg = i == length - 1;
 
@@ -2747,7 +2750,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             inferredType = originType;
                         }
                     } else if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, lastArg)) {
-                        addError("Expected parameter of type "+ inferredType.toString(false)+" but got "+originType.toString(false), closureParam.getType());
+                        addError("Expected parameter of type " + inferredType.toString(false) + " but got " + originType.toString(false), closureParam.getType());
                     }
 
                     typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);
@@ -2771,7 +2774,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 dummyMN.getParameters(),
                 dummyMN.getExceptions(),
                 EmptyStatement.INSTANCE
-                );
+        );
         dummyMN.setDeclaringClass(selectedMethod.getDeclaringClass());
         dummyMN.setGenericsTypes(selectedMethod.getGenericsTypes());
         if (selectedMethod instanceof ExtensionMethodNode) {
@@ -2785,7 +2788,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     orig.getExceptions(),
                     EmptyStatement.INSTANCE,
                     orig.isStaticExtension()
-                    );
+            );
             dummyMN.setDeclaringClass(orig.getDeclaringClass());
             dummyMN.setGenericsTypes(orig.getGenericsTypes());
         }
@@ -2801,6 +2804,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     /**
      * Given a GenericsType instance, returns a ClassNode which can be used as an inferred type.
+     *
      * @param genericsType a {@link org.codehaus.groovy.ast.GenericsType} representing either a type, a placeholder or a wildcard
      * @return a class node usable as an inferred type
      */
@@ -2810,11 +2814,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             value = OBJECT_TYPE;
         }
         ClassNode lowerBound = genericsType.getLowerBound();
-        if (lowerBound !=null) {
+        if (lowerBound != null) {
             value = lowerBound;
         } else {
             ClassNode[] upperBounds = genericsType.getUpperBounds();
-            if (upperBounds !=null) {
+            if (upperBounds != null) {
                 value = WideningCategories.lowestUpperBound(Arrays.asList(upperBounds));
             }
         }
@@ -2822,11 +2826,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     private static String[] convertToStringArray(final Expression options) {
-        if (options==null) {
+        if (options == null) {
             return EMPTY_STRING_ARRAY;
         }
         if (options instanceof ConstantExpression) {
-            return new String[] { options.getText() };
+            return new String[]{options.getText()};
         }
         if (options instanceof ListExpression) {
             List<Expression> list = ((ListExpression) options).getExpressions();
@@ -2836,7 +2840,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
             return result.toArray(new String[0]);
         }
-        throw new IllegalArgumentException("Unexpected options for @ClosureParams:"+options);
+        throw new IllegalArgumentException("Unexpected options for @ClosureParams:" + options);
     }
 
     private void checkClosureWithDelegatesTo(final ClassNode receiver,
@@ -2846,7 +2850,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                                              final Expression expression,
                                              final Parameter param) {
         List<AnnotationNode> annotations = param.getAnnotations(DELEGATES_TO);
-        if (annotations!=null && !annotations.isEmpty()) {
+        if (annotations != null && !annotations.isEmpty()) {
             for (AnnotationNode annotation : annotations) {
                 // in theory, there can only be one annotation of that type
                 Expression value = annotation.getMember("value");
@@ -2854,17 +2858,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 Expression genericTypeIndex = annotation.getMember("genericTypeIndex");
                 Expression type = annotation.getMember("type");
                 Integer stInt = Closure.OWNER_FIRST;
-                if (strategy!=null) {
-                    stInt = (Integer) evaluateExpression(castX(ClassHelper.Integer_TYPE,strategy), typeCheckingContext.source.getConfiguration());
+                if (strategy != null) {
+                    stInt = (Integer) evaluateExpression(castX(ClassHelper.Integer_TYPE, strategy), typeCheckingContext.source.getConfiguration());
                 }
                 if (value instanceof ClassExpression && !value.getType().equals(DELEGATES_TO_TARGET)) {
-                    if (genericTypeIndex!=null) {
-                        addStaticTypeError("Cannot use @DelegatesTo(genericTypeIndex="+genericTypeIndex.getText()
-                                +") without @DelegatesTo.Target because generic argument types are not available at runtime", value);
+                    if (genericTypeIndex != null) {
+                        addStaticTypeError("Cannot use @DelegatesTo(genericTypeIndex=" + genericTypeIndex.getText()
+                                + ") without @DelegatesTo.Target because generic argument types are not available at runtime", value);
                     }
                     // temporarily store the delegation strategy and the delegate type
                     expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(value.getType(), stInt, typeCheckingContext.delegationMetadata));
-                } else if (type!=null && !"".equals(type.getText()) && type instanceof ConstantExpression) {
+                } else if (type != null && !"".equals(type.getText()) && type instanceof ConstantExpression) {
                     String typeString = type.getText();
                     ClassNode[] resolved = GenericsUtils.parseClassNodesFromString(
                             typeString,
@@ -2873,9 +2877,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             mn,
                             type
                     );
-                    if (resolved!=null) {
-                        if (resolved.length==1) {
-                            resolved = resolveGenericsFromTypeHint(receiver, arguments, mn, resolved );
+                    if (resolved != null) {
+                        if (resolved.length == 1) {
+                            resolved = resolveGenericsFromTypeHint(receiver, arguments, mn, resolved);
                             expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(resolved[0], stInt, typeCheckingContext.delegationMetadata));
                         } else {
                             addStaticTypeError("Incorrect type hint found in method " + (mn), type);
@@ -2885,7 +2889,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     final List<Expression> expressions = arguments.getExpressions();
                     final int expressionsSize = expressions.size();
                     Expression parameter = annotation.getMember("target");
-                    String parameterName = parameter instanceof ConstantExpression ?parameter.getText():"";
+                    String parameterName = parameter instanceof ConstantExpression ? parameter.getText() : "";
                     // todo: handle vargs!
                     for (int j = 0, paramsLength = params.length; j < paramsLength; j++) {
                         final Parameter methodParam = params[j];
@@ -2902,19 +2906,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                                         int gti = Integer.parseInt(genericTypeIndex.getText());
                                         ClassNode paramType = methodParam.getType(); // type annotated with @DelegatesTo.Target
                                         GenericsType[] genericsTypes = paramType.getGenericsTypes();
-                                        if (genericsTypes==null) {
-                                            addStaticTypeError("Cannot use @DelegatesTo(genericTypeIndex="+genericTypeIndex.getText()
-                                                + ") with a type that doesn't use generics", methodParam);
-                                        } else if (gti<0 || gti>=genericsTypes.length) {
-                                            addStaticTypeError("Index of generic type @DelegatesTo(genericTypeIndex="+genericTypeIndex.getText()
-                                                    + ") "+(gti<0?"lower":"greater")+" than those of the selected type", methodParam);
+                                        if (genericsTypes == null) {
+                                            addStaticTypeError("Cannot use @DelegatesTo(genericTypeIndex=" + genericTypeIndex.getText()
+                                                    + ") with a type that doesn't use generics", methodParam);
+                                        } else if (gti < 0 || gti >= genericsTypes.length) {
+                                            addStaticTypeError("Index of generic type @DelegatesTo(genericTypeIndex=" + genericTypeIndex.getText()
+                                                    + ") " + (gti < 0 ? "lower" : "greater") + " than those of the selected type", methodParam);
                                         } else {
                                             ClassNode pType = GenericsUtils.parameterizeType(actualType, paramType);
                                             GenericsType[] pTypeGenerics = pType.getGenericsTypes();
-                                            if (pTypeGenerics!=null && pTypeGenerics.length>gti) {
+                                            if (pTypeGenerics != null && pTypeGenerics.length > gti) {
                                                 actualType = pTypeGenerics[gti].getType();
                                             } else {
-                                                addStaticTypeError("Unable to map actual type ["+actualType.toString(false)+"] onto "+paramType.toString(false), methodParam);
+                                                addStaticTypeError("Unable to map actual type [" + actualType.toString(false) + "] onto " + paramType.toString(false), methodParam);
                                             }
                                         }
                                     }
@@ -2924,7 +2928,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             }
                         }
                     }
-                    if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA)==null) {
+                    if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA) == null) {
                         addError("Not enough arguments found for a @DelegatesTo method call. Please check that you either use an explicit class or @DelegatesTo.Target with a correct id", arguments);
                     }
                 }
@@ -2937,9 +2941,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     protected void addReceivers(final List<Receiver<String>> receivers,
-                              final Collection<Receiver<String>> owners,
-                              final boolean implicitThis) {
-        if (typeCheckingContext.delegationMetadata ==null || !implicitThis) {
+                                final Collection<Receiver<String>> owners,
+                                final boolean implicitThis) {
+        if (typeCheckingContext.delegationMetadata == null || !implicitThis) {
             receivers.addAll(owners);
             return;
         }
@@ -3067,7 +3071,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             typeCheckClosureCall(callArguments, args, parameters);
                         }
                         ClassNode type = getType(((ASTNode) variable));
-                        if (type!=null && type.equals(CLOSURE_TYPE)) {
+                        if (type != null && type.equals(CLOSURE_TYPE)) {
                             GenericsType[] genericsTypes = type.getGenericsTypes();
                             type = OBJECT_TYPE;
                             if (genericsTypes != null) {
@@ -3170,7 +3174,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     if (areCategoryMethodCalls(mn, name, args)) {
                         addCategoryMethodCallError(call);
                     }
-                    mn = disambiguateMethods(mn, chosenReceiver!=null?chosenReceiver.getType():null, args, call);
+                    mn = disambiguateMethods(mn, chosenReceiver != null ? chosenReceiver.getType() : null, args, call);
 
 
                     if (mn.size() == 1) {
@@ -3181,7 +3185,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             ClassNode owner = directMethodCallCandidate.getDeclaringClass();
                             addStaticTypeError("Non static method " + owner.getName() + "#" + directMethodCallCandidate.getName() + " cannot be called from static context", call);
                         }
-                        if (chosenReceiver==null) {
+                        if (chosenReceiver == null) {
                             chosenReceiver = Receiver.make(directMethodCallCandidate.getDeclaringClass());
                         }
 
@@ -3197,15 +3201,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             returnType = irtg != null && implementsInterfaceOrIsSubclassOf(irtg, returnType) ? irtg : returnType;
                             callArgsVisited = true;
                         }
-                        if (directMethodCallCandidate==GET_DELEGATE && typeCheckingContext.getEnclosingClosure()!=null) {
+                        if (directMethodCallCandidate == GET_DELEGATE && typeCheckingContext.getEnclosingClosure() != null) {
                             DelegationMetadata md = getDelegationMetadata(typeCheckingContext.getEnclosingClosure().getClosureExpression());
                             returnType = typeCheckingContext.getEnclosingClassNode();
-                            if (md!=null) {
+                            if (md != null) {
                                 returnType = md.getType();
                             }
                         }
                         if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, mn.get(0), call)) {
-                            returnType = adjustWithTraits(directMethodCallCandidate,chosenReceiver.getType(), args, returnType);
+                            returnType = adjustWithTraits(directMethodCallCandidate, chosenReceiver.getType(), args, returnType);
                             storeType(call, returnType);
                             storeTargetMethod(call, directMethodCallCandidate);
                             String data = chosenReceiver.getData();
@@ -3246,19 +3250,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 MethodNode mn = (MethodNode) call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
                 visitMethodCallArguments(receiver, argumentList, true, mn);
                 // GROOVY-6219
-                if (mn!=null) {
+                if (mn != null) {
                     List<Expression> argExpressions = argumentList.getExpressions();
                     Parameter[] parameters = mn.getParameters();
-                    for (int i = 0; i < argExpressions.size() && i< parameters.length; i++) {
-                          Expression arg = argExpressions.get(i);
-                          ClassNode pType = parameters[i].getType();
-                          ClassNode aType = getType(arg);
-                          if (CLOSURE_TYPE.equals(pType) && CLOSURE_TYPE.equals(aType)) {
-                              if (!isAssignableTo(aType, pType)) {
-                                  addNoMatchingMethodError(receiver, name, getArgumentTypes(argumentList), call);
-                                  call.removeNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
-                              }
-                          }
+                    for (int i = 0; i < argExpressions.size() && i < parameters.length; i++) {
+                        Expression arg = argExpressions.get(i);
+                        ClassNode pType = parameters[i].getType();
+                        ClassNode aType = getType(arg);
+                        if (CLOSURE_TYPE.equals(pType) && CLOSURE_TYPE.equals(aType)) {
+                            if (!isAssignableTo(aType, pType)) {
+                                addNoMatchingMethodError(receiver, name, getArgumentTypes(argumentList), call);
+                                call.removeNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
+                            }
+                        }
                     }
                 }
             }
@@ -3274,9 +3278,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * is created representing the list of trait interfaces.
      *
      * @param directMethodCallCandidate a method selected by the type checker
-     * @param receiver the receiver of the method call
-     * @param args the arguments of the method call
-     * @param returnType the original return type, as inferred by the type checker
+     * @param receiver                  the receiver of the method call
+     * @param args                      the arguments of the method call
+     * @param returnType                the original return type, as inferred by the type checker
      * @return fixed return type if the selected method is {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#withTraits(Object, Class[]) withTraits}
      */
     private static ClassNode adjustWithTraits(final MethodNode directMethodCallCandidate, final ClassNode receiver, final ClassNode[] args, final ClassNode returnType) {
@@ -3292,7 +3296,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         nodes.add(arg);
                     }
                 }
-                return new LowestUpperBoundClassNode(returnType.getName()+"Composed", OBJECT_TYPE, nodes.toArray(ClassNode.EMPTY_ARRAY));
+                return new LowestUpperBoundClassNode(returnType.getName() + "Composed", OBJECT_TYPE, nodes.toArray(ClassNode.EMPTY_ARRAY));
             }
         }
         return returnType;
@@ -3300,20 +3304,21 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     /**
      * add various getAt and setAt methods for primitive arrays
+     *
      * @param receiver the receiver class
-     * @param name  the name of the method
-     * @param args the argument classes
+     * @param name     the name of the method
+     * @param args     the argument classes
      */
     private static void addArrayMethods(List<MethodNode> methods, ClassNode receiver, String name, ClassNode[] args) {
-        if (args.length!=1) return;
+        if (args.length != 1) return;
         if (!receiver.isArray()) return;
         if (!isIntCategory(getUnwrapper(args[0]))) return;
         if ("getAt".equals(name)) {
-            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, receiver.getComponentType(), new Parameter[]{new Parameter(args[0],"arg")}, null, null);
+            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, receiver.getComponentType(), new Parameter[]{new Parameter(args[0], "arg")}, null, null);
             node.setDeclaringClass(receiver.redirect());
             methods.add(node);
         } else if ("setAt".equals(name)) {
-            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, VOID_TYPE, new Parameter[]{new Parameter(args[0],"arg")}, null, null);
+            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, VOID_TYPE, new Parameter[]{new Parameter(args[0], "arg")}, null, null);
             node.setDeclaringClass(receiver.redirect());
             methods.add(node);
         }
@@ -3334,7 +3339,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         visitClosureExpression(closure);
 
-        if (getInferredReturnType(closure) != null)  {
+        if (getInferredReturnType(closure) != null) {
             return getInferredReturnType(closure);
         }
 
@@ -3343,6 +3348,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     /**
      * Given an object expression (a receiver expression), generate the list of potential receiver types.
+     *
      * @param objectExpression the receiver expression
      * @return the list of types the receiver may be
      */
@@ -3411,7 +3417,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     protected boolean isClosureCall(final String name, final Expression objectExpression, final Expression arguments) {
-        if (objectExpression instanceof ClosureExpression && (CALL.equals(name)||"doCall".equals(name))) return true;
+        if (objectExpression instanceof ClosureExpression && (CALL.equals(name) || "doCall".equals(name))) return true;
         if (objectExpression == VariableExpression.THIS_EXPRESSION) {
             FieldNode fieldNode = typeCheckingContext.getEnclosingClassNode().getDeclaredField(name);
             if (fieldNode != null) {
@@ -3473,7 +3479,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             instanceOfExpression = findNotInstanceOfReturnExpression(ifElse);
         }
         if (instanceOfExpression != null) {
-            if(typeCheckingContext.enclosingBlocks.size()>0) {
+            if (typeCheckingContext.enclosingBlocks.size() > 0) {
                 visitInstanceofNot(instanceOfExpression);
             }
         }
@@ -3520,10 +3526,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * Check IfStatement matched pattern :
      * Object var1;
      * if (!(var1 instanceOf Runnable)) {
-     *   return
+     * return
      * }
      * // Here var1 instance of Runnable
-     *
+     * <p>
      * Return expression , which contains instanceOf (without not)
      * Return null, if not found
      */
@@ -3556,10 +3562,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * Check IfStatement matched pattern :
      * Object var1;
      * if (var1 !instanceOf Runnable) {
-     *   return
+     * return
      * }
      * // Here var1 instance of Runnable
-     *
+     * <p>
      * Return expression , which contains instanceOf (without not)
      * Return null, if not found
      */
@@ -3633,7 +3639,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 // GROOVY-6099: First element of the list may be null, if no assignment was made before the branch
                 List<ClassNode> nonNullValues = new ArrayList<ClassNode>(allValues.size());
                 for (ClassNode value : allValues) {
-                    if (value!=null) nonNullValues.add(value);
+                    if (value != null) nonNullValues.add(value);
                 }
                 ClassNode cn = lowestUpperBound(nonNullValues);
                 storeType(key, cn);
@@ -3666,7 +3672,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     private boolean isDelegateOrOwnerInClosure(Expression exp) {
-        return typeCheckingContext.getEnclosingClosure()!=null &&
+        return typeCheckingContext.getEnclosingClosure() != null &&
                 exp instanceof VariableExpression &&
                 (("delegate".equals(((VariableExpression) exp).getName())) || ("owner".equals(((VariableExpression) exp).getName())));
     }
@@ -3690,9 +3696,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             // char c = (char) ...
         } else if (sourceIsNull && isPrimitiveType(targetType) && !boolean_TYPE.equals(targetType)) {
             return false;
-        } else if ((expressionType.getModifiers()& Opcodes.ACC_FINAL)==0 && targetType.isInterface()) {
+        } else if ((expressionType.getModifiers() & Opcodes.ACC_FINAL) == 0 && targetType.isInterface()) {
             return true;
-        } else if ((targetType.getModifiers()& Opcodes.ACC_FINAL)==0 && expressionType.isInterface()) {
+        } else if ((targetType.getModifiers() & Opcodes.ACC_FINAL) == 0 && expressionType.isInterface()) {
             return true;
         } else if (!isAssignableTo(targetType, expressionType) && !implementsInterfaceOrIsSubclassOf(expressionType, targetType)) {
             return false;
@@ -3728,7 +3734,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         typeOfTrue = checkForTargetType(trueExpression, typeOfTrue);
         if (isNullConstant(trueExpression) || isNullConstant(falseExpression)) {
             BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();
-            if (enclosingBinaryExpression != null && enclosingBinaryExpression.getRightExpression()==expression) {
+            if (enclosingBinaryExpression != null && enclosingBinaryExpression.getRightExpression() == expression) {
                 resultType = getType(enclosingBinaryExpression.getLeftExpression());
             } else if (isNullConstant(trueExpression) && isNullConstant(falseExpression)) {
                 resultType = OBJECT_TYPE;
@@ -3777,7 +3783,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private static boolean isEmptyCollection(Expression expr) {
         return (expr instanceof ListExpression && ((ListExpression) expr).getExpressions().size() == 0) ||
-        (expr instanceof MapExpression && ((MapExpression) expr).getMapEntryExpressions().size() == 0);
+                (expr instanceof MapExpression && ((MapExpression) expr).getMapEntryExpressions().size() == 0);
     }
 
     private static boolean hasInferredReturnType(Expression expression) {
@@ -3828,9 +3834,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration
             ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);
             if (oldDIT != null) {
-                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn==null?oldDIT : lowestUpperBound(oldDIT, cn));
+                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn == null ? oldDIT : lowestUpperBound(oldDIT, cn));
             } else {
-                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn==null?null : lowestUpperBound(oldValue, cn));
+                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn == null ? null : lowestUpperBound(oldValue, cn));
             }
         }
         if (exp instanceof VariableExpression) {
@@ -3842,7 +3848,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (accessedVariable instanceof Parameter) {
                 ((Parameter) accessedVariable).putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);
             }
-            if (var.isClosureSharedVariable() && cn!=null) {
+            if (var.isClosureSharedVariable() && cn != null) {
                 List<ClassNode> assignedTypes = typeCheckingContext.closureSharedVariablesAssignmentTypes.get(var);
                 if (assignedTypes == null) {
                     assignedTypes = new LinkedList<ClassNode>();
@@ -3868,7 +3874,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         Expression leftExpression = expr.getLeftExpression();
         Expression rightExpression = expr.getRightExpression();
         if (op == ASSIGN || op == ASSIGNMENT_OPERATOR || op == ELVIS_EQUAL) {
-            if (leftRedirect.isArray() && implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE)) return leftRedirect;
+            if (leftRedirect.isArray() && implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE))
+                return leftRedirect;
             if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {
                 // because of type inference, we must perform an additional check if the right expression
                 // is an empty list expression ([]). In that case and only in that case, the inferred type
@@ -3884,7 +3891,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 return right;
             }
             if (rightRedirect.isDerivedFrom(CLOSURE_TYPE) && isSAMType(leftRedirect) && rightExpression instanceof ClosureExpression) {
-                return inferSAMTypeGenericsInAssignment(left, findSAM(left),right,(ClosureExpression) rightExpression);
+                return inferSAMTypeGenericsInAssignment(left, findSAM(left), right, (ClosureExpression) rightExpression);
             }
 
             if (leftExpression instanceof VariableExpression) {
@@ -3893,7 +3900,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     return getWrapper(right);
                 }
 
-                if (isPrimitiveType(initialType) && rightRedirect.isDerivedFrom(Number_TYPE))  {
+                if (isPrimitiveType(initialType) && rightRedirect.isDerivedFrom(Number_TYPE)) {
                     return getUnwrapper(right);
                 }
 
@@ -3916,10 +3923,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             BinaryExpression newExpr = binX(expr.getLeftExpression(), expr.getOperation(), rightExpression);
             newExpr.setSourcePosition(expr);
             MethodNode method = findMethodOrFail(newExpr, left.getPlainNodeReference(), "getAt", right.getPlainNodeReference());
-            if (method!=null && implementsInterfaceOrIsSubclassOf(right, RANGE_TYPE)) {
+            if (method != null && implementsInterfaceOrIsSubclassOf(right, RANGE_TYPE)) {
                 return inferReturnTypeGenerics(left, method, rightExpression);
             }
-            return method!=null?inferComponentType(left, right):null;
+            return method != null ? inferComponentType(left, right) : null;
         }
         if (op == FIND_REGEX) {
             // this case always succeeds the result is a Matcher
@@ -3962,9 +3969,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             } else if (isPowerOperator(op)) {
                 return Number_TYPE;
             } else if (isBitOperator(op) || op == INTDIV || op == INTDIV_EQUAL) {
-                if (isIntCategory(getUnwrapper(leftRedirect)) && isIntCategory(getUnwrapper(rightRedirect))) return int_TYPE;
-                if (isLongCategory(getUnwrapper(leftRedirect)) && isLongCategory(getUnwrapper(rightRedirect))) return long_TYPE;
-                if (isBigIntCategory(getUnwrapper(leftRedirect)) && isBigIntCategory(getUnwrapper(rightRedirect))) return BigInteger_TYPE;
+                if (isIntCategory(getUnwrapper(leftRedirect)) && isIntCategory(getUnwrapper(rightRedirect)))
+                    return int_TYPE;
+                if (isLongCategory(getUnwrapper(leftRedirect)) && isLongCategory(getUnwrapper(rightRedirect)))
+                    return long_TYPE;
+                if (isBigIntCategory(getUnwrapper(leftRedirect)) && isBigIntCategory(getUnwrapper(rightRedirect)))
+                    return BigInteger_TYPE;
             } else if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {
                 return boolean_TYPE;
             }
@@ -4007,21 +4017,21 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         // we cannot infer anything, thus we simply return the provided samUsage
         GenericsType[] samGt = samUsage.getGenericsTypes();
         GenericsType[] closureGt = closureType.getGenericsTypes();
-        if (samGt==null || closureGt==null) return samUsage;
+        if (samGt == null || closureGt == null) return samUsage;
 
         // extract the generics from the return type
-        Map<String,GenericsType> connections = new HashMap<String,GenericsType>();
-        extractGenericsConnections(connections, getInferredReturnType(closureExpression),sam.getReturnType());
+        Map<String, GenericsType> connections = new HashMap<String, GenericsType>();
+        extractGenericsConnections(connections, getInferredReturnType(closureExpression), sam.getReturnType());
 
         // next we get the block parameter types and set the generics
         // information just like before
         // TODO: add vargs handling
         Parameter[] closureParams = closureExpression.getParameters();
         Parameter[] methodParams = sam.getParameters();
-        for (int i=0; i<closureParams.length; i++) {
+        for (int i = 0; i < closureParams.length; i++) {
             ClassNode fromClosure = closureParams[i].getType();
             ClassNode fromMethod = methodParams[i].getType();
-            extractGenericsConnections(connections,fromClosure,fromMethod);
+            extractGenericsConnections(connections, fromClosure, fromMethod);
         }
         ClassNode result = applyGenericsContext(connections, samUsage.redirect());
         return result;
@@ -4096,14 +4106,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     private List<MethodNode> disambiguateMethods(List<MethodNode> methods, ClassNode receiver, ClassNode[] argTypes, final Expression call) {
-        if (methods.size()>1 && receiver!=null && argTypes!=null) {
+        if (methods.size() > 1 && receiver != null && argTypes != null) {
             List<MethodNode> filteredWithGenerics = new LinkedList<MethodNode>();
             for (MethodNode methodNode : methods) {
                 if (typeCheckMethodsWithGenerics(receiver, argTypes, methodNode)) {
                     filteredWithGenerics.add(methodNode);
                 }
             }
-            if (filteredWithGenerics.size()==1) {
+            if (filteredWithGenerics.size() == 1) {
                 return filteredWithGenerics;
             }
             methods = extension.handleAmbiguousMethods(methods, call);
@@ -4138,7 +4148,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             sb.append(node.getDeclaringClass().toString(false));
             sb.append("#");
             sb.append(toMethodParametersString(node.getName(), extractTypesFromParameters(node.getParameters())));
-            if (i<nodesSize-1) sb.append(", ");
+            if (i < nodesSize - 1) sb.append(", ");
         }
         sb.append("]");
         return sb.toString();
@@ -4163,8 +4173,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * are defined on the specified receiver, but it will also add "non existing" methods
      * that will be generated afterwards by the compiler, for example if a method is using
      * default values and that the specified class node isn't compiled yet.
+     *
      * @param receiver the receiver where to find methods
-     * @param name the name of the methods to return
+     * @param name     the name of the methods to return
      * @return the methods that are defined on the receiver completed with stubs for future methods
      */
     protected List<MethodNode> findMethodsWithGenerated(ClassNode receiver, String name) {
@@ -4206,7 +4217,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
                 MethodNode stubbed;
                 if ("<init>".equals(method.getName())) {
-                    stubbed= new ConstructorNode(
+                    stubbed = new ConstructorNode(
                             method.getModifiers(),
                             newParams,
                             method.getExceptions(),
@@ -4214,7 +4225,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     );
 
                 } else {
-                    stubbed= new MethodNode(
+                    stubbed = new MethodNode(
                             method.getName(),
                             method.getModifiers(),
                             method.getReturnType(),
@@ -4236,7 +4247,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (isPrimitiveType(receiver)) receiver = getWrapper(receiver);
         List<MethodNode> methods;
         if (!receiver.isInterface() && "<init>".equals(name)) {
-            methods = addGeneratedMethods(receiver,new ArrayList<MethodNode>(receiver.getDeclaredConstructors()));
+            methods = addGeneratedMethods(receiver, new ArrayList<MethodNode>(receiver.getDeclaredConstructors()));
             if (methods.isEmpty()) {
                 MethodNode node = new ConstructorNode(Opcodes.ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, GENERATED_EMPTY_STATEMENT);
                 node.setDeclaringClass(receiver);
@@ -4249,7 +4260,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
         } else {
-            methods = findMethodsWithGenerated(receiver,name);
+            methods = findMethodsWithGenerated(receiver, name);
             if (receiver.isInterface()) {
                 collectAllInterfaceMethodsByName(receiver, name, methods);
                 methods.addAll(OBJECT_TYPE.getMethods(name));
@@ -4271,7 +4282,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 ClassNode parent = receiver;
                 while (parent instanceof InnerClassNode && !parent.isStaticClass()) {
                     parent = parent.getOuterClass();
-                    methods.addAll(findMethodsWithGenerated(parent,name));
+                    methods.addAll(findMethodsWithGenerated(parent, name));
                 }
             }
             if (methods.isEmpty()) {
@@ -4280,7 +4291,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (methods.isEmpty() && (args == null || args.length == 0)) {
                 // check if it's a property
                 String pname = extractPropertyNameFromMethodName("get", name);
-                if (pname==null) {
+                if (pname == null) {
                     pname = extractPropertyNameFromMethodName("is", name);
                 }
                 if (pname != null) {
@@ -4290,10 +4301,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     while (property == null && curNode != null) {
                         property = curNode.getProperty(pname);
                         ClassNode svCur = curNode;
-                        while (property==null && svCur instanceof InnerClassNode && !svCur.isStaticClass()) {
+                        while (property == null && svCur instanceof InnerClassNode && !svCur.isStaticClass()) {
                             svCur = svCur.getOuterClass();
                             property = svCur.getProperty(pname);
-                            if (property!=null) {
+                            if (property != null) {
                                 receiver = svCur;
                                 break;
                             }
@@ -4314,7 +4325,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             } else if (methods.isEmpty() && args != null && args.length == 1) {
                 // maybe we are looking for a setter ?
                 String pname = extractPropertyNameFromMethodName("set", name);
-                if (pname!=null) {
+                if (pname != null) {
                     ClassNode curNode = receiver;
                     PropertyNode property = null;
                     while (property == null && curNode != null) {
@@ -4377,13 +4388,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * following the java beans rules. For example, "getName" would return "name", while
      * "getFullName" would return "fullName".
      * If the prefix is not found, returns null.
-     * @param prefix the method name prefix ("get", "is", "set", ...)
+     *
+     * @param prefix     the method name prefix ("get", "is", "set", ...)
      * @param methodName the method name
      * @return a property name if the prefix is found and the method matches the java beans rules, null otherwise
      */
     public static String extractPropertyNameFromMethodName(String prefix, String methodName) {
-        if (prefix==null || methodName==null) return null;
-        if (methodName.startsWith(prefix) && prefix.length()<methodName.length()) {
+        if (prefix == null || methodName == null) return null;
+        if (methodName.startsWith(prefix) && prefix.length() < methodName.length()) {
             String result = methodName.substring(prefix.length());
             String propertyName = java.beans.Introspector.decapitalize(result);
             if (result.equals(MetaClassHelper.capitalize(propertyName))) return propertyName;
@@ -4548,7 +4560,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     /**
      * resolves a Field or Property node generics by using the current class and
      * the declaring class to extract the right meaning of the generics symbols
-     * @param an a FieldNode or PropertyNode
+     *
+     * @param an   a FieldNode or PropertyNode
      * @param type the origin type
      * @return the new ClassNode with corrected generics
      */
@@ -4557,7 +4570,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         Map<String, GenericsType> connections = new HashMap<String, GenericsType>();
         //TODO: inner classes mean a different this-type. This is ignored here!
         extractGenericsConnections(connections, typeCheckingContext.getEnclosingClassNode(), an.getDeclaringClass());
-        type= applyGenericsContext(connections, type);
+        type = applyGenericsContext(connections, type);
         return type;
     }
 
@@ -4605,7 +4618,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      */
     protected ClassNode storeInferredReturnType(final ASTNode node, final ClassNode type) {
         if (!(node instanceof ClosureExpression)) {
-            throw new IllegalArgumentException("Storing inferred return type is only allowed on closures but found "+node.getClass());
+            throw new IllegalArgumentException("Storing inferred return type is only allowed on closures but found " + node.getClass());
         }
         return (ClassNode) node.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, type);
     }
@@ -4613,6 +4626,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     /**
      * Returns the inferred return type of a closure or a method, if stored on the AST node. This method
      * doesn't perform any type inference by itself.
+     *
      * @param exp a {@link ClosureExpression} or {@link MethodNode}
      * @return the inferred type, as stored on node metadata.
      */
@@ -4682,7 +4696,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return mapType;
     }
 
-    private static class ExtensionMethodDeclaringClass{}
+    private static class ExtensionMethodDeclaringClass {
+    }
 
     /**
      * If a method call returns a parameterized type, then we can perform additional inference on the
@@ -4704,8 +4719,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * Arrays.asList(T...) is generified with type T which can be deduced from actual type
      * arguments.
      *
-     * @param method    the method node
-     * @param arguments the method call arguments
+     * @param method            the method node
+     * @param arguments         the method call arguments
      * @param explicitTypeHints explicit type hints as found for example in Collections.&lt;String&gt;emptyList()
      * @return parameterized, infered, class node
      */
@@ -4736,7 +4751,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return inferReturnTypeGenerics(receiver, dgmMethod, argList);
         }
         if (!isUsingGenericsOrIsArrayUsingGenerics(returnType)) return returnType;
-        if (getGenericsWithoutArray(returnType)==null) return returnType;
+        if (getGenericsWithoutArray(returnType) == null) return returnType;
         Map<String, GenericsType> resolvedPlaceholders = resolvePlaceHoldersFromDeclaration(receiver, getDeclaringClass(method, arguments), method, method.isStatic());
         if (!receiver.isGenericsPlaceHolder()) {
             GenericsUtils.extractPlaceholders(receiver, resolvedPlaceholders);
@@ -4746,7 +4761,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return boundUnboundedWildcards(returnType);
         }
         Map<String, GenericsType> placeholdersFromContext = extractGenericsParameterMapOfThis(typeCheckingContext.getEnclosingMethod());
-        applyGenericsConnections(placeholdersFromContext,resolvedPlaceholders);
+        applyGenericsConnections(placeholdersFromContext, resolvedPlaceholders);
 
         // then resolve receivers from method arguments
         Parameter[] parameters = method.getParameters();
@@ -4767,7 +4782,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     if (implementsInterfaceOrIsSubclassOf(actualType, CLOSURE_TYPE) &&
                             isSAMType(type)) {
                         // implicit closure coercion in action!
-                        Map<String,GenericsType> pholders = applyGenericsContextToParameterClass(resolvedPlaceholders, type);
+                        Map<String, GenericsType> pholders = applyGenericsContextToParameterClass(resolvedPlaceholders, type);
                         actualType = convertClosureTypeToSAMType(expressions.get(i), actualType, type, pholders);
                     }
                     if (isVargs && lastArg && actualType.isArray()) {
@@ -4778,8 +4793,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                     actualType = wrapTypeIfNecessary(actualType);
 
-                    Map<String, GenericsType> connections  = new HashMap<String, GenericsType>();
-                    extractGenericsConnections(connections, actualType,type);
+                    Map<String, GenericsType> connections = new HashMap<String, GenericsType>();
+                    extractGenericsConnections(connections, actualType, type);
                     extractGenericsConnectionsForSuperClassAndInterfaces(resolvedPlaceholders, connections);
                     applyGenericsConnections(connections, resolvedPlaceholders);
                 }
@@ -4790,9 +4805,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     private static void resolvePlaceholdersFromExplicitTypeHints(final MethodNode method, final GenericsType[] explicitTypeHints, final Map<String, GenericsType> resolvedPlaceholders) {
-        if (explicitTypeHints!=null) {
+        if (explicitTypeHints != null) {
             GenericsType[] methodGenericTypes = method.getGenericsTypes();
-            if (methodGenericTypes!=null && methodGenericTypes.length==explicitTypeHints.length) {
+            if (methodGenericTypes != null && methodGenericTypes.length == explicitTypeHints.length) {
                 for (int i = 0; i < explicitTypeHints.length; i++) {
                     GenericsType methodGenericType = methodGenericTypes[i];
                     GenericsType explicitTypeHint = explicitTypeHints[i];
@@ -4808,7 +4823,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 ClassNode valueType = value.getType();
                 List<ClassNode> deepNodes = new LinkedList<ClassNode>();
                 ClassNode unresolvedSuperClass = valueType.getUnresolvedSuperClass();
-                if (unresolvedSuperClass!=null && unresolvedSuperClass.isUsingGenerics()) {
+                if (unresolvedSuperClass != null && unresolvedSuperClass.isUsingGenerics()) {
                     deepNodes.add(unresolvedSuperClass);
                 }
                 for (ClassNode node : valueType.getUnresolvedInterfaces()) {
@@ -4847,73 +4862,73 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * to infer return type generics.
      *
      * @param closureType the inferred type of a closure (Closure&lt;ClosureReturnType&gt;)
-     * @param samType the type into which the closure is coerced into
+     * @param samType     the type into which the closure is coerced into
      * @return same SAM type, but completed with information from the closure node
      */
-    private static ClassNode convertClosureTypeToSAMType(final Expression expression, final ClassNode closureType, final ClassNode samType, final Map<String,GenericsType> placeholders) {
+    private static ClassNode convertClosureTypeToSAMType(final Expression expression, final ClassNode closureType, final ClassNode samType, final Map<String, GenericsType> placeholders) {
         if (!samType.isUsingGenerics()) return samType;
 
         // use the generics information from the Closure to further specify the type
         MethodNode sam = findSAM(samType);
-        if (closureType.isUsingGenerics() && sam!=null) {
-           //correct SAM type for generics
-           //sam = applyGenericsContext(placeholders, sam);
-
-           // the return type of the SAM method exactly corresponds to the inferred return type
-           ClassNode samReturnType = sam.getReturnType();
-           ClassNode closureReturnType = expression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
-           if (closureReturnType!=null && closureReturnType.isUsingGenerics()) {
-               ClassNode unwrapped = closureReturnType.getGenericsTypes()[0].getType();
-               extractGenericsConnections(placeholders, unwrapped, samReturnType);
-           } else if (samReturnType.isGenericsPlaceHolder()) {
-               placeholders.put(samReturnType.getGenericsTypes()[0].getName(), closureType.getGenericsTypes()[0]);
-           }
-
-           // now repeat the same for each parameter given in the ClosureExpression
-           if (expression instanceof ClosureExpression && sam.getParameters().length > 0) {
-               List<ClassNode[]> genericsToConnect = new LinkedList<ClassNode[]>();
-               Parameter[] closureParams = ((ClosureExpression) expression).getParameters();
-               ClassNode[] closureParamTypes = extractTypesFromParameters(closureParams);
-               if (expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS)!=null) {
-                   closureParamTypes = expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
-               }
-               final Parameter[] parameters = sam.getParameters();
-               for (int i = 0; i < parameters.length; i++) {
-                   final Parameter parameter = parameters[i];
-                   if (parameter.getOriginType().isUsingGenerics() && closureParamTypes.length>i) {
-                       genericsToConnect.add(new ClassNode[]{closureParamTypes[i], parameter.getOriginType()});
-                   }
-               }
-               for (ClassNode[] classNodes : genericsToConnect) {
-                   ClassNode found = classNodes[0];
-                   ClassNode expected = classNodes[1];
-                   if (!isAssignableTo(found, expected)) {
-                       // probably facing a type mismatch
-                       continue;
-                   }
-                   ClassNode generifiedType = GenericsUtils.parameterizeType(found, expected);
-                   while (expected.isArray()) {
-                       expected = expected.getComponentType();
-                       generifiedType = generifiedType.getComponentType();
-                   }
-                   if (expected.isGenericsPlaceHolder()) {
-                       placeholders.put(expected.getGenericsTypes()[0].getName(), new GenericsType(generifiedType));
-                   } else {
-                       GenericsType[] expectedGenericsTypes = expected.getGenericsTypes();
-                       GenericsType[] foundGenericsTypes = generifiedType.getGenericsTypes();
-
-                       for (int i = 0; i < expectedGenericsTypes.length; i++) {
-                           final GenericsType type = expectedGenericsTypes[i];
-                           if (type.isPlaceholder()) {
-                               String name = type.getName();
-                               placeholders.put(name, foundGenericsTypes[i]);
-                           }
-                       }
-                   }
-               }
-           }
-        }
-        ClassNode result = applyGenericsContext(placeholders,samType.redirect());
+        if (closureType.isUsingGenerics() && sam != null) {
+            //correct SAM type for generics
+            //sam = applyGenericsContext(placeholders, sam);
+
+            // the return type of the SAM method exactly corresponds to the inferred return type
+            ClassNode samReturnType = sam.getReturnType();
+            ClassNode closureReturnType = expression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+            if (closureReturnType != null && closureReturnType.isUsingGenerics()) {
+                ClassNode unwrapped = closureReturnType.getGenericsTypes()[0].getType();
+                extractGenericsConnections(placeholders, unwrapped, samReturnType);
+            } else if (samReturnType.isGenericsPlaceHolder()) {
+                placeholders.put(samReturnType.getGenericsTypes()[0].getName(), closureType.getGenericsTypes()[0]);
+            }
+
+            // now repeat the same for each parameter given in the ClosureExpression
+            if (expression instanceof ClosureExpression && sam.getParameters().length > 0) {
+                List<ClassNode[]> genericsToConnect = new LinkedList<ClassNode[]>();
+                Parameter[] closureParams = ((ClosureExpression) expression).getParameters();
+                ClassNode[] closureParamTypes = extractTypesFromParameters(closureParams);
+                if (expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS) != null) {
+                    closureParamTypes = expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
+                }
+                final Parameter[] parameters = sam.getParameters();
+                for (int i = 0; i < parameters.length; i++) {
+                    final Parameter parameter = parameters[i];
+                    if (parameter.getOriginType().isUsingGenerics() && closureParamTypes.length > i) {
+                        genericsToConnect.add(new ClassNode[]{closureParamTypes[i], parameter.getOriginType()});
+                    }
+                }
+                for (ClassNode[] classNodes : genericsToConnect) {
+                    ClassNode found = classNodes[0];
+                    ClassNode expected = classNodes[1];
+                    if (!isAssignableTo(found, expected)) {
+                        // probably facing a type mismatch
+                        continue;
+                    }
+                    ClassNode generifiedType = GenericsUtils.parameterizeType(found, expected);
+                    while (expected.isArray()) {
+                        expected = expected.getComponentType();
+                        generifiedType = generifiedType.getComponentType();
+                    }
+                    if (expected.isGenericsPlaceHolder()) {
+                        placeholders.put(expected.getGenericsTypes()[0].getName(), new GenericsType(generifiedType));
+                    } else {
+                        GenericsType[] expectedGenericsTypes = expected.getGenericsTypes();
+                        GenericsType[] foundGenericsTypes = generifiedType.getGenericsTypes();
+
+                        for (int i = 0; i < expectedGenericsTypes.length; i++) {
+                            final GenericsType type = expectedGenericsTypes[i];
+                            if (type.isPlaceholder()) {
+                                String name = type.getName();
+                                placeholders.put(name, foundGenericsTypes[i]);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        ClassNode result = applyGenericsContext(placeholders, samType.redirect());
         return result;
     }
 
@@ -4932,18 +4947,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (list.isEmpty()) return declaringClass;
             Expression exp = list.get(0);
             ClassNode cn = exp.getNodeMetaData(ExtensionMethodDeclaringClass.class);
-            if (cn!=null) return cn;
+            if (cn != null) return cn;
         }
         return declaringClass;
     }
 
     private Map<String, GenericsType> resolvePlaceHoldersFromDeclaration(ClassNode receiver, ClassNode declaration, MethodNode method, boolean isStaticTarget) {
         Map<String, GenericsType> resolvedPlaceholders;
-        if (    isStaticTarget && CLASS_Type.equals(receiver) &&
+        if (isStaticTarget && CLASS_Type.equals(receiver) &&
                 receiver.isUsingGenerics() &&
-                receiver.getGenericsTypes().length>0 &&
-                !OBJECT_TYPE.equals(receiver.getGenericsTypes()[0].getType()))
-        {
+                receiver.getGenericsTypes().length > 0 &&
+                !OBJECT_TYPE.equals(receiver.getGenericsTypes()[0].getType())) {
             return resolvePlaceHoldersFromDeclaration(receiver.getGenericsTypes()[0].getType(), declaration, method, isStaticTarget);
         } else {
             resolvedPlaceholders = extractPlaceHolders(method, receiver, declaration);
@@ -4960,7 +4974,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     private static Map<String, GenericsType> extractPlaceHolders(MethodNode method, ClassNode receiver, ClassNode declaringClass) {
         if (declaringClass.equals(OBJECT_TYPE)) {
             Map<String, GenericsType> resolvedPlaceholders = new HashMap<String, GenericsType>();
-            if (method!=null) addMethodLevelDeclaredGenerics(method, resolvedPlaceholders);
+            if (method != null) addMethodLevelDeclaredGenerics(method, resolvedPlaceholders);
             return resolvedPlaceholders;
         }
 
@@ -4976,26 +4990,26 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
         for (ClassNode item : queue) {
             ClassNode current = item;
-            while (current!=null) {
+            while (current != null) {
                 boolean continueLoop = true;
                 //extract the place holders
                 Map<String, GenericsType> currentPlaceHolders = new HashMap<String, GenericsType>();
                 if (isGenericsPlaceHolderOrArrayOf(declaringClass) || declaringClass.equals(current)) {
                     extractGenericsConnections(currentPlaceHolders, current, declaringClass);
-                    if (method!=null) addMethodLevelDeclaredGenerics(method, currentPlaceHolders);
+                    if (method != null) addMethodLevelDeclaredGenerics(method, currentPlaceHolders);
                     continueLoop = false;
                 } else {
                     GenericsUtils.extractPlaceholders(current, currentPlaceHolders);
                 }
 
-                if (resolvedPlaceholders!=null) {
+                if (resolvedPlaceholders != null) {
                     // merge maps
-                    Set<Map.Entry<String,GenericsType>> entries = currentPlaceHolders.entrySet();
-                    for (Map.Entry<String,GenericsType> entry : entries) {
+                    Set<Map.Entry<String, GenericsType>> entries = currentPlaceHolders.entrySet();
+                    for (Map.Entry<String, GenericsType> entry : entries) {
                         GenericsType gt = entry.getValue();
                         if (!gt.isPlaceholder()) continue;
                         GenericsType referenced = resolvedPlaceholders.get(gt.getName());
-                        if (referenced==null) continue;
+                        if (referenced == null) continue;
                         entry.setValue(referenced);
                     }
                 }
@@ -5005,20 +5019,20 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (!continueLoop) break;
 
                 current = getNextSuperClass(current, declaringClass);
-                if (current==null && CLASS_Type.equals(declaringClass)) {
+                if (current == null && CLASS_Type.equals(declaringClass)) {
                     // this can happen if the receiver is Class<Foo>, then
                     // the actual receiver is Foo and declaringClass is Class
                     current = declaringClass;
                 }
             }
         }
-        if (resolvedPlaceholders==null) {
+        if (resolvedPlaceholders == null) {
             String descriptor = "<>";
-            if (method!=null) descriptor = method.getTypeDescriptor();
+            if (method != null) descriptor = method.getTypeDescriptor();
             throw new GroovyBugError(
                     "Declaring class for method call to '" +
                             descriptor + "' declared in " + declaringClass.getName() +
-                            " was not matched with found receiver "+ receiver.getName() + "." +
+                            " was not matched with found receiver " + receiver.getName() + "." +
                             " This should not have happened!");
         }
         return resolvedPlaceholders;
@@ -5044,12 +5058,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private static String toMethodGenericTypesString(MethodNode node) {
         GenericsType[] genericsTypes = node.getGenericsTypes();
-        if (genericsTypes ==null) return "";
+        if (genericsTypes == null) return "";
         StringBuilder sb = new StringBuilder("<");
         for (int i = 0; i < genericsTypes.length; i++) {
             final GenericsType genericsType = genericsTypes[i];
             sb.append(genericsType.toString());
-            if (i<genericsTypes.length-1) {
+            if (i < genericsTypes.length - 1) {
                 sb.append(",");
             }
         }
@@ -5058,7 +5072,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     protected static String formatArgumentList(ClassNode[] nodes) {
-        if (nodes == null || nodes.length==0) return "[]";
+        if (nodes == null || nodes.length == 0) return "[]";
         StringBuilder sb = new StringBuilder(24 * nodes.length);
         sb.append("[");
         for (ClassNode node : nodes) {
@@ -5077,7 +5091,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private static SetterInfo removeSetterInfo(Expression exp) {
         Object nodeMetaData = exp.getNodeMetaData(SetterInfo.class);
-        if (nodeMetaData!=null) {
+        if (nodeMetaData != null) {
             exp.removeNodeMetaData(SetterInfo.class);
             return (SetterInfo) nodeMetaData;
         }
@@ -5087,7 +5101,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     @Override
     public void addError(final String msg, final ASTNode expr) {
         Long err = ((long) expr.getLineNumber()) << 16 + expr.getColumnNumber();
-        if ((DEBUG_GENERATED_CODE && expr.getLineNumber()<0) || !typeCheckingContext.reportedErrors.contains(err)) {
+        if ((DEBUG_GENERATED_CODE && expr.getLineNumber() < 0) || !typeCheckingContext.reportedErrors.contains(err)) {
             typeCheckingContext.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
                     new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(), expr.getLastLineNumber(), expr.getLastColumnNumber()),
                     typeCheckingContext.source)
@@ -5101,7 +5115,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             addError(StaticTypesTransformation.STATIC_ERROR_PREFIX + msg, expr);
         } else {
             if (DEBUG_GENERATED_CODE) {
-                addError(StaticTypesTransformation.STATIC_ERROR_PREFIX + "Error in generated code ["+expr.getText()+"] - "+ msg, expr);
+                addError(StaticTypesTransformation.STATIC_ERROR_PREFIX + "Error in generated code [" + expr.getText() + "] - " + msg, expr);
             }
             // ignore errors which are related to unknown source locations
             // because they are likely related to generated code
@@ -5129,9 +5143,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     protected void addUnsupportedPreOrPostfixExpressionError(final Expression expression) {
         if (expression instanceof PostfixExpression) {
-            addStaticTypeError("Unsupported postfix operation type [" + ((PostfixExpression)expression).getOperation() + "]", expression);
+            addStaticTypeError("Unsupported postfix operation type [" + ((PostfixExpression) expression).getOperation() + "]", expression);
         } else if (expression instanceof PrefixExpression) {
-            addStaticTypeError("Unsupported prefix operation type [" + ((PrefixExpression)expression).getOperation() + "]", expression);
+            addStaticTypeError("Unsupported prefix operation type [" + ((PrefixExpression) expression).getOperation() + "]", expression);
         } else {
             throw new IllegalArgumentException("Method should be called with a PostfixExpression or a PrefixExpression");
         }
@@ -5156,7 +5170,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (classNodes != null && classNodes.size() > 1) {
                             ClassNode lub = lowestUpperBound(classNodes);
                             String message = getOperationName(((BinaryExpression) expression).getOperation().getType());
-                            if (message!=null) {
+                            if (message != null) {
                                 List<MethodNode> method = findMethod(lub, message, getType(((BinaryExpression) expression).getRightExpression()));
                                 if (method.isEmpty()) {
                                     addStaticTypeError("A closure shared variable [" + target.getName() + "] has been assigned with various types and the method" +
@@ -5260,8 +5274,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     public static class SignatureCodecFactory {
         public static SignatureCodec getCodec(int version, final ClassLoader classLoader) {
             switch (version) {
-                case 1:  return new SignatureCodecVersion1(classLoader);
-                default: return null;
+                case 1:
+                    return new SignatureCodecVersion1(classLoader);
+                default:
+                    return null;
             }
         }
     }
@@ -5283,7 +5299,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     /**
      * Wrapper for a Parameter so it can be treated like a VariableExpression
      * and tracked in the ifElseForWhileAssignmentTracker.
-     *
+     * <p>
      * This class purposely does not adhere to the normal equals and hashCode
      * contract on the Object class and delegates those calls to the wrapped
      * variable.

Commit:
4ada9e66c93cee4d5b688521047279bd80daf21b
Paul King
paulk@asert.com.au
2018-04-11 22:53:24 +1000
fix serializable incompatibility with 2_4_X
diff --git a/src/main/groovy/groovy/lang/GroovyObjectSupport.java b/src/main/groovy/groovy/lang/GroovyObjectSupport.java
index cf7a77fb1f..d08ecd6945 100644
--- a/src/main/groovy/groovy/lang/GroovyObjectSupport.java
+++ b/src/main/groovy/groovy/lang/GroovyObjectSupport.java
@@ -22,8 +22,6 @@ import org.codehaus.groovy.runtime.InvokerHelper;
 
 /**
  * A useful base class for Java objects wishing to be Groovy objects
- *
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
 public abstract class GroovyObjectSupport implements GroovyObject {
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java b/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
index 56ba50afd4..52f52cb1ed 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
@@ -57,7 +57,7 @@ import java.util.List;
  */
 public final class ComposedClosure<V> extends Closure<V> {
 
-    private static final long serialVersionUID = 1290542293376731831L;
+    private static final long serialVersionUID = -4816724431590921285L;
     private Closure first;
     private Closure<V> second;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
index 9bc71fa138..c0c98127dd 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
@@ -26,12 +26,10 @@ import java.util.Map;
 /**
  * This class is a general adapter to adapt a map of closures to
  * any Java interface.
- *
- * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  */
 public class ConvertedMap extends ConversionHandler {
 
-    private static final long serialVersionUID = -8131432558241254137L;
+    private static final long serialVersionUID = 8535543126684786030L;
 
     /**
      * to create a ConvertedMap object.
diff --git a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
index 1db103760a..e9365bea36 100644
--- a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
@@ -46,7 +46,7 @@ import groovy.lang.Closure;
  */
 public final class CurriedClosure<V> extends Closure<V> {
 
-    private static final long serialVersionUID = -1018388175778192754L;
+    private static final long serialVersionUID = 2077643745780234126L;
     private final Object[] curriedParams;
     private final int minParamsExpected;
     private int index;
diff --git a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
index 05ce6b0f95..8843f11f34 100644
--- a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
+++ b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
@@ -38,16 +38,14 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- * @author sam
- * @author Paul King
- * @author Alex Tkachman
+ * Support methods for Groovy category usage
  */
 public class GroovyCategorySupport {
 
     private static int categoriesInUse = 0;
 
     public static class CategoryMethodList extends ArrayList<CategoryMethod> {
-        private static final long serialVersionUID = 1569020062006842141L;
+        private static final long serialVersionUID = 1631799972200881802L;
         public final int level;
         final CategoryMethodList previous;
         final AtomicInteger usage;
@@ -73,7 +71,7 @@ public class GroovyCategorySupport {
     public static class ThreadCategoryInfo extends HashMap<String, CategoryMethodList>{
 
         private static final Object LOCK = new Object();
-        private static final long serialVersionUID = 2609120843123833410L;
+        private static final long serialVersionUID = 1348443374952726263L;
 
         int level;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
index da85b6b8a5..8fb5572383 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
@@ -24,12 +24,10 @@ import java.lang.reflect.InvocationTargetException;
 
 /**
  * An exception thrown if a method is called and an exception occurred
- * 
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
 public class InvokerInvocationException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = 5870532233180451709L;
+    private static final long serialVersionUID = 1337849572129640775L;
 
     public InvokerInvocationException(InvocationTargetException e) {
         super(e.getTargetException());
diff --git a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
index 7f098d7013..ea08d2f775 100644
--- a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
@@ -27,12 +27,10 @@ import java.util.List;
 /**
  * A closure which stores calls in a List so that method calls 
  * can be iterated over in a 'yield' style way
- * 
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
 public class IteratorClosureAdapter<T> extends Closure {
 
-    private static final long serialVersionUID = -3193812539363103534L;
+    private static final long serialVersionUID = -7485077849389539770L;
     private final List<T> list = new ArrayList<T>();
     private MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
     
diff --git a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
index 938347b858..7314c1e913 100644
--- a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
@@ -35,7 +35,7 @@ public class MethodClosure extends Closure {
     public static final String NEW = "new";
     public static final String ANY_INSTANCE_METHOD_EXISTS = "anyInstanceMethodExists";
 
-    private static final long serialVersionUID = 5316055624606528584L;
+    private static final long serialVersionUID = -2491254866810955844L;
     public static boolean ALLOW_RESOLVE = false;
 
     private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
index 2d501b3a94..ef7da8fc36 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
@@ -167,7 +167,7 @@ public class ConcurrentReaderHashMap
 
   /** A Serializable class for barrier lock **/
   protected static class BarrierLock implements java.io.Serializable {
-      private static final long serialVersionUID = -5403150101810674636L;
+      private static final long serialVersionUID = -2159505361622844863L;
   }
 
   /**
@@ -178,7 +178,6 @@ public class ConcurrentReaderHashMap
   /**
    * field written to only to guarantee lock ordering.
    **/
-
   protected transient Object lastWrite;
 
   /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
index 4f0cc4cb96..06272ed1c7 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
@@ -32,12 +32,11 @@ import java.lang.reflect.Modifier;
  * <p>
  * <b>Note:</b> This exception as for internal use only!
  * 
- * @author Jochen Theodorou
  * @since Groovy 1.1
  */
 public class MethodSelectionException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = 6260193948973669540L;
+    private static final long serialVersionUID = 8126246630023758333L;
     private final String methodName;
     private final FastArray methods;
     private final Class[] arguments;
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
index 80836c78e4..954dc6b1ec 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
@@ -22,7 +22,7 @@ import groovy.lang.MissingMethodException;
 
 public class MissingMethodExceptionNoStack extends MissingMethodException {
 
-    private static final long serialVersionUID = 7075950754138801519L;
+    private static final long serialVersionUID = -4567395518573062216L;
 
     public MissingMethodExceptionNoStack(String method, Class type, Object[] arguments) {
         this(method,type,arguments,false);
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
index 557176dcb6..b2bd6bcc37 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
@@ -20,11 +20,11 @@ package org.codehaus.groovy.runtime.metaclass;
 
 /**
  * A stack less exception used to indicate, that the execution of a missingMethod
- * method failed with a MissingMethodException. This is used to preven a call to
+ * method failed with a MissingMethodException. This is used to prevent a call to
  * invokeMethod for GroovyObject implementing classes.
  */
 public class MissingMethodExecutionFailed extends MissingMethodExceptionNoStack {
-    private static final long serialVersionUID = -6551412223364004284L;
+    private static final long serialVersionUID = -7894095278952483769L;
     private Throwable cause;
     public MissingMethodExecutionFailed(String method, Class type, Object[] arguments, boolean isStatic, Throwable cause) {
         super(method, type, arguments, isStatic);
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
index a177eaba7d..3f7926e6a2 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
@@ -22,7 +22,7 @@ import groovy.lang.MissingPropertyException;
 
 public class MissingPropertyExceptionNoStack extends MissingPropertyException {
 
-    private static final long serialVersionUID = -7734212543734003079L;
+    private static final long serialVersionUID = 8993570436675442348L;
 
     public MissingPropertyExceptionNoStack(String propertyName, Class theClass) {
         super(propertyName, theClass);
diff --git a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
index b79f0d75ba..498f1fa7dd 100644
--- a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
+++ b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
@@ -20,11 +20,9 @@ package org.codehaus.groovy.runtime.powerassert;
 
 /**
  * Indicates that a power assertion has failed.
- *
- * @author Peter Niederwieser
  */
 public class PowerAssertionError extends java.lang.AssertionError {
-    private static final long serialVersionUID = 186840762256433109L;
+    private static final long serialVersionUID = -2204531294530022591L;
 
     public PowerAssertionError(String msg) {
         super(msg);
diff --git a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
index 4d5117d59a..fe2b7ad846 100644
--- a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
+++ b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
@@ -25,7 +25,7 @@ import java.util.TreeSet;
 
 public class StringSetMap extends LinkedHashMap<String,Set<String>> {
 
-    private static final long serialVersionUID = 4230491822783819152L;
+    private static final long serialVersionUID = -8603734698633884431L;
 
     public StringSetMap() {
         super();
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
index 349c9306ba..c34132637a 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
@@ -50,7 +50,7 @@ public abstract class AbstractConcurrentMap<K, V> extends AbstractConcurrentMapB
 
     public abstract static class Segment<K,V> extends AbstractConcurrentMapBase.Segment {
 
-        private static final long serialVersionUID = 5192533863182570468L;
+        private static final long serialVersionUID = -2392526467736920612L;
 
         protected Segment(int initialCapacity) {
             super(initialCapacity);
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
index 2cfc82a99f..f0625f6126 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
@@ -154,7 +154,7 @@ public abstract class AbstractConcurrentMapBase {
     }
 
     public static class Segment extends LockableObject {
-        private static final long serialVersionUID = -1071886855389945760L;
+        private static final long serialVersionUID = -4128828550135386431L;
         volatile int count;
 
         int threshold;
diff --git a/src/main/java/org/codehaus/groovy/util/FastArray.java b/src/main/java/org/codehaus/groovy/util/FastArray.java
index 8881af2848..17e6f6df3f 100644
--- a/src/main/java/org/codehaus/groovy/util/FastArray.java
+++ b/src/main/java/org/codehaus/groovy/util/FastArray.java
@@ -18,12 +18,14 @@
  */
 package org.codehaus.groovy.util;
 
+import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
-public class FastArray implements Cloneable {
+public class FastArray implements Cloneable, Serializable {
+    private static final long serialVersionUID = -9143440116071577249L;
     private Object[] data;
     public int size;
     public static final FastArray EMPTY_LIST = new FastArray(0);
diff --git a/src/main/java/org/codehaus/groovy/util/LazyReference.java b/src/main/java/org/codehaus/groovy/util/LazyReference.java
index 54e0ab2e78..a8abc15480 100644
--- a/src/main/java/org/codehaus/groovy/util/LazyReference.java
+++ b/src/main/java/org/codehaus/groovy/util/LazyReference.java
@@ -24,7 +24,7 @@ package org.codehaus.groovy.util;
 public abstract class LazyReference<T> extends LockableObject {
     private static final ManagedReference INIT = new ManagedReference(ReferenceType.HARD,null,null){};
     private static final ManagedReference NULL_REFERENCE = new ManagedReference(ReferenceType.HARD,null,null){};
-    private static final long serialVersionUID = 3160238516132794621L;
+    private static final long serialVersionUID = -828564509716680325L;
     private ManagedReference<T> reference = INIT;
     private final ReferenceBundle bundle;
     
diff --git a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
index da06275840..d1cf760108 100644
--- a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
@@ -33,7 +33,7 @@ public class ManagedConcurrentMap<K,V> extends AbstractConcurrentMap<K,V> {
     }
 
     public static class Segment<K,V> extends AbstractConcurrentMap.Segment<K,V>{
-        private static final long serialVersionUID = -2157582627873688747L;
+        private static final long serialVersionUID = 2742952509311037869L;
         protected final ReferenceBundle bundle;
         public Segment(ReferenceBundle bundle, int cap) {
             super(cap);

Commit:
e6a0efdbf2c8ec836949f01a208a569fc325fafc
Paul King
paulk@asert.com.au
2018-04-11 16:38:41 +1000
GROOVY-8537: GroovyCollections.combinations should return an empty list if one of the source collections is empty (closes #682)
diff --git a/src/main/groovy/groovy/util/GroovyCollections.java b/src/main/groovy/groovy/util/GroovyCollections.java
index 3f637ef785..19bef50b00 100644
--- a/src/main/groovy/groovy/util/GroovyCollections.java
+++ b/src/main/groovy/groovy/util/GroovyCollections.java
@@ -91,6 +91,7 @@ public class GroovyCollections {
      * is <code>[['a', 1], ['b', 1], ['a', 2], ['b', 2], ['a', 3], ['b', 3]]</code>.
      * If a non-collection item is given, it is treated as a singleton collection,
      * i.e. <code>combinations([[1, 2], 'x'])</code> is <code>[[1, 'x'], [2, 'x']]</code>.
+     * If an empty collection is found within the given collections, the result will be an empty list.
      *
      * @param collections the Iterable of given collections
      * @return a List of the combinations found

Commit:
93ecc0ad47b613e76c47689afc7b93afea6a371b
Paul King
paulk@asert.com.au
2018-04-11 16:24:07 +1000
Fixes issue GROOVY-8537
diff --git a/src/main/groovy/groovy/util/GroovyCollections.java b/src/main/groovy/groovy/util/GroovyCollections.java
index dff062db6a..3f637ef785 100644
--- a/src/main/groovy/groovy/util/GroovyCollections.java
+++ b/src/main/groovy/groovy/util/GroovyCollections.java
@@ -118,6 +118,9 @@ public class GroovyCollections {
                 }
                 collectedCombos = newCombos;
             }
+
+            if (collectedCombos.isEmpty()) 
+                break;
         }
         return collectedCombos;
     }
diff --git a/src/test/groovy/util/GroovyCollectionsTest.groovy b/src/test/groovy/util/GroovyCollectionsTest.groovy
index d605e2036c..1678f5b7ec 100644
--- a/src/test/groovy/util/GroovyCollectionsTest.groovy
+++ b/src/test/groovy/util/GroovyCollectionsTest.groovy
@@ -50,6 +50,11 @@ public class GroovyCollectionsTest extends GroovyTestCase {
         // collection versions should match Collection
         assert GroovyCollections.combinations(input) as Set == expected
         assert combinations(input) as Set == expected
+
+        // an empty iterable should result in no combination
+        assert combinations([[]] + input).isEmpty()
+        assert combinations(input + [[]]).isEmpty()
+        assert combinations(input + [[]] + input).isEmpty()
     }
 
     void testTranspose() {
@@ -114,4 +119,4 @@ public class GroovyCollectionsTest extends GroovyTestCase {
     void testHashCodeCollisionInMinus() {
         assert ([[1:2],[2:3]]-[["b":"a"]]) == [[1:2],[2:3]]
     }
-}
\ No newline at end of file
+}

Commit:
2971892891602c196822389362798ef35e8d6eed
sunlan
sunlan@apache.org
2018-04-11 07:49:40 +0800
Revert "Refine `sep` rule of parser"
diff --git a/src/antlr/GroovyParser.g4 b/src/antlr/GroovyParser.g4
index fa9b6751f8..385fd11130 100644
--- a/src/antlr/GroovyParser.g4
+++ b/src/antlr/GroovyParser.g4
@@ -1215,6 +1215,5 @@ nls
     :   NL*
     ;
 
-sep :   SEMI NL*
-    |   NL+ (SEMI NL*)*
+sep :   (NL | SEMI)+
     ;

Commit:
ebd835d561da98098cb2f502ed705884e068b99d
Paul King
paulk@asert.com.au
2018-04-10 22:54:55 +1000
GROOVY-8541: Incorrect packaging in groovy-all pom
diff --git a/gradle/upload.gradle b/gradle/upload.gradle
index 7413d8c1f5..246df83391 100644
--- a/gradle/upload.gradle
+++ b/gradle/upload.gradle
@@ -251,7 +251,7 @@ ext.pomAll = {
         def dependencyClass = p.dependencies[0].getClass()
         p.dependencies.clear()
         // defer setting packaging until here otherwise gets overwritten
-        p.packaging - 'pom'
+        p.packaging = 'pom'
         allprojects {
             if (it.name.startsWith('groovy')) {
                 def dep = dependencyClass.newInstance()

Commit:
9e3580768473287b7e6f82508b476ae6d0d1c675
sunlan
sunlan@apache.org
2018-04-10 12:33:55 +0800
Refine `sep` rule of parser
diff --git a/src/antlr/GroovyParser.g4 b/src/antlr/GroovyParser.g4
index 385fd11130..fa9b6751f8 100644
--- a/src/antlr/GroovyParser.g4
+++ b/src/antlr/GroovyParser.g4
@@ -1215,5 +1215,6 @@ nls
     :   NL*
     ;
 
-sep :   (NL | SEMI)+
+sep :   SEMI NL*
+    |   NL+ (SEMI NL*)*
     ;

Commit:
c1bf7b56a9b4c9ccfd86a49e8546eef969bcbb9e
sunlan
sunlan@apache.org
2018-04-10 08:52:13 +0800
Bump antlr to 4.7.1
diff --git a/build.gradle b/build.gradle
index 5aa112e2de..32e3bd8a89 100644
--- a/build.gradle
+++ b/build.gradle
@@ -168,7 +168,7 @@ ext {
     xmlunitVersion = '1.6'
     xstreamVersion = '1.4.10'
     spockVersion = '1.2-groovy-2.4-SNAPSHOT' // supports 3.0
-    antlr4Version = '4.7'
+    antlr4Version = '4.7.1'
     jsr305Version = '3.0.2'
 }
 

Commit:
5846b24901c686a8391b00bf6e7cde2e3109a23b
Paul King
paulk@asert.com.au
2018-04-08 21:33:22 +1000
add license header to fix rat violation
diff --git a/src/test-resources/groovy/bugs/groovy4585/groovy4585.xml b/src/test-resources/groovy/bugs/groovy4585/groovy4585.xml
index 5d8e83ce2a..6dcf2bb190 100644
--- a/src/test-resources/groovy/bugs/groovy4585/groovy4585.xml
+++ b/src/test-resources/groovy/bugs/groovy4585/groovy4585.xml
@@ -1,4 +1,24 @@
 <?xml version="1.0" encoding="GB2312"?>
+<!--
+
+     Licensed to the Apache Software Foundation (ASF) under one
+     or more contributor license agreements.  See the NOTICE file
+     distributed with this work for additional information
+     regarding copyright ownership.  The ASF licenses this file
+     to you under the Apache License, Version 2.0 (the
+     "License"); you may not use this file except in compliance
+     with the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing,
+     software distributed under the License is distributed on an
+     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+     KIND, either express or implied.  See the License for the
+     specific language governing permissions and limitations
+     under the License.
+
+-->
 <project name="projBuild" default="projBuild" basedir=".">
     <property name="drive" value="d:\" />
 

Commit:
099089ea4888ba0fa143706630c04a7f11e4db2b
danielsun1106
realbluesun@hotmail.com
2018-04-07 02:09:03 +0800
Refine `SimpleTemplateEngine` API to support escaping backslashes
diff --git a/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy b/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
index 17f912028e..0dc274c9e3 100644
--- a/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
+++ b/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
@@ -20,7 +20,8 @@ package groovy.bugs.groovy4585
 
 class Groovy4585Bug extends GroovyTestCase {
     void test() {
-        def engineForBuildXml = new groovy.text.SimpleTemplateEngine(false, true)
+        def engineForBuildXml = new groovy.text.SimpleTemplateEngine(false)
+        engineForBuildXml.setEscapeBackslash(true)
         def templateForBuildXml = engineForBuildXml.createTemplate(this.getClass().getResource("/groovy/bugs/groovy4585/groovy4585.xml").text)
         String buildXmlContent = templateForBuildXml.make([names:['a', 'b', 'c']]).toString()
 
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
index 2c541f09c1..1893bd154a 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
@@ -105,13 +105,8 @@ public class SimpleTemplateEngine extends TemplateEngine {
     }
 
     public SimpleTemplateEngine(boolean verbose) {
-        this(verbose, false);
-    }
-
-    public SimpleTemplateEngine(boolean verbose, boolean escapeBackslash) {
         this(GroovyShell.class.getClassLoader());
         setVerbose(verbose);
-        this.escapeBackslash = escapeBackslash;
     }
 
     public SimpleTemplateEngine(ClassLoader parentLoader) {
@@ -365,6 +360,13 @@ public class SimpleTemplateEngine extends TemplateEngine {
             }
             sw.write(";\nout.print(\"\"\"");
         }
+    }
 
+    public boolean isEscapeBackslash() {
+        return escapeBackslash;
+    }
+
+    public void setEscapeBackslash(boolean escapeBackslash) {
+        this.escapeBackslash = escapeBackslash;
     }
 }

Commit:
d8e35f637ddc24563cc98970b2423ef806383de2
danielsun1106
realbluesun@hotmail.com
2018-04-07 00:00:44 +0800
Trivial refactoring for `AstStringCompiler`
diff --git a/src/main/groovy/org/codehaus/groovy/ast/builder/AstStringCompiler.groovy b/src/main/groovy/org/codehaus/groovy/ast/builder/AstStringCompiler.groovy
index ec18993000..6089c0c042 100644
--- a/src/main/groovy/org/codehaus/groovy/ast/builder/AstStringCompiler.groovy
+++ b/src/main/groovy/org/codehaus/groovy/ast/builder/AstStringCompiler.groovy
@@ -44,17 +44,16 @@ import org.codehaus.groovy.control.CompilerConfiguration
      * @param statementsOnly
      */
     List<ASTNode> compile(String script, CompilePhase compilePhase, boolean statementsOnly) {
-        def scriptClassName = "script" + System.currentTimeMillis()
-        GroovyClassLoader classLoader = new GroovyClassLoader()
-        GroovyCodeSource codeSource = new GroovyCodeSource(script, scriptClassName + ".groovy", "/groovy/script")
-        CompilationUnit cu = new CompilationUnit(CompilerConfiguration.DEFAULT, codeSource.codeSource, classLoader)
-        cu.addSource(codeSource.getName(), script);
+        final scriptClassName = makeScriptClassName()
+        GroovyCodeSource codeSource = new GroovyCodeSource(script, "${scriptClassName}.groovy", "/groovy/script")
+        CompilationUnit cu = new CompilationUnit(CompilerConfiguration.DEFAULT, codeSource.codeSource, new GroovyClassLoader())
+        cu.addSource(codeSource.getName(), script)
         cu.compile(compilePhase.getPhaseNumber())
         // collect all the ASTNodes into the result, possibly ignoring the script body if desired
-        return (List<ASTNode>) cu.getAST().modules.inject([]) {List acc, ModuleNode node ->
+        return (List<ASTNode>) cu.getAST().modules.inject([]) { List acc, ModuleNode node ->
             if (node.statementBlock) acc.add(node.statementBlock)
             node.classes?.each {
-                if (!(it.name == scriptClassName && statementsOnly)) {
+                if (!(statementsOnly && it.name == scriptClassName)) {
                     acc << it
                 }
             }
@@ -62,4 +61,7 @@ import org.codehaus.groovy.control.CompilerConfiguration
         }
     }
 
-}
\ No newline at end of file
+    private static String makeScriptClassName() {
+        return "Script${System.nanoTime()}"
+    }
+}

Commit:
697136d31177f2ef5bcbfe5348f3d9389d06e7d8
danielsun1106
realbluesun@hotmail.com
2018-04-06 22:49:46 +0800
Simplify the test for "GROOVY-4585: backslash can not be escaped by `SimpleTemplateEngine`"
diff --git a/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy b/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
index fed604ebe1..17f912028e 100644
--- a/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
+++ b/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
@@ -20,14 +20,11 @@ package groovy.bugs.groovy4585
 
 class Groovy4585Bug extends GroovyTestCase {
     void test() {
-        assertScript '''
-            package groovy.bugs.groovy4585
-            def engineForBuildXml = new groovy.text.SimpleTemplateEngine(false, true)
-            def templateForBuildXml = engineForBuildXml.createTemplate(this.getClass().getResource("/groovy/bugs/groovy4585/groovy4585.xml").text)
-            String buildXmlContent = templateForBuildXml.make([names:['a', 'b', 'c']]).toString()
-    
-            assert buildXmlContent.contains('<property name="drive" value="d:\\\\" />')
-            assert buildXmlContent.contains('<exec dir="${drive}" executable="echo">')
-        '''
+        def engineForBuildXml = new groovy.text.SimpleTemplateEngine(false, true)
+        def templateForBuildXml = engineForBuildXml.createTemplate(this.getClass().getResource("/groovy/bugs/groovy4585/groovy4585.xml").text)
+        String buildXmlContent = templateForBuildXml.make([names:['a', 'b', 'c']]).toString()
+
+        assert buildXmlContent.contains('<property name="drive" value="d:\\" />')
+        assert buildXmlContent.contains('<exec dir="${drive}" executable="echo">')
     }
 }

Commit:
49aaa28959234a86d02b8ecacf5be5fa9b8a1bdf
danielsun1106
realbluesun@hotmail.com
2018-04-06 22:22:56 +0800
GROOVY-4585: backslash can not be escaped by `SimpleTemplateEngine` (closes #681)
diff --git a/src/test-resources/groovy/bugs/groovy4585/groovy4585.xml b/src/test-resources/groovy/bugs/groovy4585/groovy4585.xml
new file mode 100644
index 0000000000..5d8e83ce2a
--- /dev/null
+++ b/src/test-resources/groovy/bugs/groovy4585/groovy4585.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="GB2312"?>
+<project name="projBuild" default="projBuild" basedir=".">
+    <property name="drive" value="d:\" />
+
+    <target name="projBuild">
+        <%for (int i = 0; i < names.size(); i++) {%>
+            <exec dir="\${drive}" executable="echo">
+                  <arg line="${names[i]}"/>
+            </exec>
+        <%}%>
+    </target>
+</project>
diff --git a/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy b/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
new file mode 100644
index 0000000000..fed604ebe1
--- /dev/null
+++ b/src/test/groovy/bugs/groovy4585/Groovy4585Bug.groovy
@@ -0,0 +1,33 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs.groovy4585
+
+class Groovy4585Bug extends GroovyTestCase {
+    void test() {
+        assertScript '''
+            package groovy.bugs.groovy4585
+            def engineForBuildXml = new groovy.text.SimpleTemplateEngine(false, true)
+            def templateForBuildXml = engineForBuildXml.createTemplate(this.getClass().getResource("/groovy/bugs/groovy4585/groovy4585.xml").text)
+            String buildXmlContent = templateForBuildXml.make([names:['a', 'b', 'c']]).toString()
+    
+            assert buildXmlContent.contains('<property name="drive" value="d:\\\\" />')
+            assert buildXmlContent.contains('<exec dir="${drive}" executable="echo">')
+        '''
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
index e4776aba5c..2c541f09c1 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
@@ -97,16 +97,21 @@ import java.util.Map;
 public class SimpleTemplateEngine extends TemplateEngine {
     private boolean verbose;
     private static int counter = 1;
-
     private GroovyShell groovyShell;
+    private boolean escapeBackslash;
 
     public SimpleTemplateEngine() {
         this(GroovyShell.class.getClassLoader());
     }
 
     public SimpleTemplateEngine(boolean verbose) {
+        this(verbose, false);
+    }
+
+    public SimpleTemplateEngine(boolean verbose, boolean escapeBackslash) {
         this(GroovyShell.class.getClassLoader());
         setVerbose(verbose);
+        this.escapeBackslash = escapeBackslash;
     }
 
     public SimpleTemplateEngine(ClassLoader parentLoader) {
@@ -118,7 +123,7 @@ public class SimpleTemplateEngine extends TemplateEngine {
     }
 
     public Template createTemplate(Reader reader) throws CompilationFailedException, IOException {
-        SimpleTemplate template = new SimpleTemplate();
+        SimpleTemplate template = new SimpleTemplate(escapeBackslash);
         String script = template.parse(reader);
         if (verbose) {
             System.out.println("\n-- script source --");
@@ -147,6 +152,16 @@ public class SimpleTemplateEngine extends TemplateEngine {
     private static class SimpleTemplate implements Template {
 
         protected Script script;
+        private boolean escapeBackslash;
+
+        public SimpleTemplate() {
+            this(false);
+        }
+
+        public SimpleTemplate(boolean escapeBackslash) {
+            this.escapeBackslash = escapeBackslash;
+        }
+
 
         public Writable make() {
             return make(null);
@@ -236,6 +251,25 @@ public class SimpleTemplateEngine extends TemplateEngine {
                 if (c == '\"') {
                     sw.write('\\');
                 }
+
+                /*
+                 *  GROOVY-4585
+                 *  Handle backslash characters.
+                 */
+                if (escapeBackslash) {
+                    if (c == '\\') {
+                        reader.mark(1);
+                        c = reader.read();
+                        if (c != '$') {
+                            sw.write("\\\\");
+                            reader.reset();
+                        } else {
+                            sw.write("\\$");
+                        }
+
+                        continue;
+                    }
+                }
                 /*
                  * Handle raw new line characters.
                  */

Commit:
ff4ce31ae445da1c433de486f496f00d15f202a9
danielsun1106
realbluesun@hotmail.com
2018-04-06 18:06:21 +0800
Bump jline to 2.14.6
diff --git a/build.gradle b/build.gradle
index 719eaad4cb..5aa112e2de 100644
--- a/build.gradle
+++ b/build.gradle
@@ -155,7 +155,7 @@ ext {
     ivyVersion = '2.4.0'
     jansiVersion = '1.17'
     jarjarVersion = '1.6.5'
-    jlineVersion = '2.14.5'
+    jlineVersion = '2.14.6'
     jmockVersion = '1.2.0'
     logbackVersion = '1.1.7'
     log4jVersion = '1.2.17'

Commit:
ab4583d660973e414d102d5779d0266a443a3f3f
danielsun1106
realbluesun@hotmail.com
2018-04-06 17:52:48 +0800
Bump jansi to 1.17
diff --git a/build.gradle b/build.gradle
index 387526fe68..719eaad4cb 100644
--- a/build.gradle
+++ b/build.gradle
@@ -153,7 +153,7 @@ ext {
     eclipseOsgiVersion = '3.9.1-v20140110-1610'
     gparsVersion = '1.2.1'
     ivyVersion = '2.4.0'
-    jansiVersion = '1.13'
+    jansiVersion = '1.17'
     jarjarVersion = '1.6.5'
     jlineVersion = '2.14.5'
     jmockVersion = '1.2.0'

Commit:
f02e72ca8513b581902598f3733970f286d47521
danielsun1106
realbluesun@hotmail.com
2018-04-06 17:41:51 +0800
Bump ant to 1.10.3
diff --git a/build.gradle b/build.gradle
index f32120c2f0..387526fe68 100644
--- a/build.gradle
+++ b/build.gradle
@@ -143,7 +143,7 @@ configurations {
 }
 
 ext {
-    antVersion = '1.10.1'
+    antVersion = '1.10.3'
     asmVersion = '6.1.1'
     antlrVersion = '2.7.7'
     bridgerVersion = '1.1.Final'

Commit:
3282a5153860cd998122fb8f0b2a80813df66a52
danielsun1106
realbluesun@hotmail.com
2018-04-06 16:22:47 +0800
Trivial refactoring: reuse the helper method `replaceLastPointWithDollar`
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 20d4f8f7e1..1bdf9b86e2 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -270,7 +270,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         genericParameterNames = oldPNames;
     }
 
-    private boolean resolveToInner (ClassNode type) {
+    private boolean resolveToInner(ClassNode type) {
         // we do not do our name mangling to find an inner class
         // if the type is a ConstructedClassWithPackage, because in this case we
         // are resolving the name at a different place already
@@ -279,9 +279,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         String name = type.getName();
         String saved = name;
         while (true) {
-            int len = name.lastIndexOf('.');
-            if (len == -1) break;
-            name = name.substring(0,len) + "$" + name.substring(len+1);
+            if (-1 == name.lastIndexOf('.')) break;
+            name = replaceLastPointWithDollar(name);
             type.setName(name);
             if (resolve(type)) return true;
         }
@@ -315,8 +314,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 return true;
             }
         }
-        return false;
 
+        return false;
     }
 
     private boolean checkInnerTypeVisibility(ClassNode enclosingType, ClassNode innerClassNode) {
@@ -458,12 +457,10 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         return false;
     }
 
-    private static String replaceLastPoint(String name) {
-        int lastPoint = name.lastIndexOf('.');
-        name = name.substring(0, lastPoint) +
-                "$" +
-                name.substring(lastPoint + 1);
-        return name;
+    private static String replaceLastPointWithDollar(String name) {
+        int lastPointIndex = name.lastIndexOf('.');
+
+        return name.substring(0, lastPointIndex) + "$" + name.substring(lastPointIndex + 1);
     }
 
     private boolean resolveFromStaticInnerClasses(ClassNode type, boolean testStaticInnerClasses) {
@@ -483,7 +480,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 // the package is really a class is handled elsewhere
                 ConstructedClassWithPackage tmp = (ConstructedClassWithPackage) type;
                 String savedName = tmp.className;
-                tmp.className = replaceLastPoint(savedName);
+                tmp.className = replaceLastPointWithDollar(savedName);
                 if (resolve(tmp, false, true, true)) {
                     type.setRedirect(tmp.redirect());
                     return true;
@@ -491,7 +488,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 tmp.className = savedName;
             }   else {
                 String savedName = type.getName();
-                String replacedPointType = replaceLastPoint(savedName);
+                String replacedPointType = replaceLastPointWithDollar(savedName);
                 type.setName(replacedPointType);
                 if (resolve(type, false, true, true)) return true;
                 type.setName(savedName);

Commit:
1b19f68879fe58b09e0684e332f2cbf060fd28ff
danielsun1106
realbluesun@hotmail.com
2018-04-06 15:04:50 +0800
Refine the test for GROOVY-8531
diff --git a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
index 72dd08bc63..2369d884c5 100644
--- a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
+++ b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
@@ -25,6 +25,14 @@ class Groovy8531Bug extends GroovyTestCase {
             class Example extends Reducer {
                 public void reduce(PublicContext context) {}
                 public void reduce2(ProtectedContext context) {}
+                public void reduce3(PublicStaticContext context) {}
+                public void reduce4(ProtectedStaticContext context) {}
+                
+                public void reduce5(PublicBaseContext context) {}
+                public void reduce6(ProtectedBaseContext context) {}
+                public void reduce7(PublicStaticBaseContext context) {}
+                public void reduce8(ProtectedStaticBaseContext context) {}
+                
                 public boolean isDynamic(Type type) {
                     return Type.DYNAMIC == type
                 }
@@ -32,6 +40,14 @@ class Groovy8531Bug extends GroovyTestCase {
             
             new Example().reduce(null)
             new Example().reduce2(null)
+            new Example().reduce3(null)
+            new Example().reduce4(null)
+            
+            new Example().reduce5(null)
+            new Example().reduce6(null)
+            new Example().reduce7(null)
+            new Example().reduce8(null)
+            
             assert new Example().isDynamic(Reducer.Type.DYNAMIC)
         '''
     }
@@ -43,6 +59,16 @@ class Groovy8531Bug extends GroovyTestCase {
                 public void reduce3(PrivateContext context) {}
             }
         '''
-        assert errMsg.contains('unable to resolve class')
+        assert errMsg.contains('unable to resolve class PrivateContext')
+    }
+
+    void testPrivateInnerType2() {
+        def errMsg = shouldFail '''
+            package groovy.bugs.groovy8531
+            class Example extends Reducer {
+                public void reduce3(PrivateBaseContext context) {}
+            }
+        '''
+        assert errMsg.contains('unable to resolve class PrivateBaseContext')
     }
 }
diff --git a/src/test/groovy/bugs/groovy8531/Reducer.java b/src/test/groovy/bugs/groovy8531/Reducer.java
index 95b5b241fc..6cf865fe02 100644
--- a/src/test/groovy/bugs/groovy8531/Reducer.java
+++ b/src/test/groovy/bugs/groovy8531/Reducer.java
@@ -18,9 +18,19 @@
  */
 package groovy.bugs.groovy8531;
 
-public class Reducer {
+class BaseReducer {
+    public abstract class PublicBaseContext {}
+    protected abstract class ProtectedBaseContext {}
+    public static abstract class PublicStaticBaseContext {}
+    protected static abstract class ProtectedStaticBaseContext {}
+    private abstract class PrivateBaseContext {}
+}
+
+public class Reducer extends BaseReducer {
     public abstract class PublicContext {}
     protected abstract class ProtectedContext {}
+    public static abstract class PublicStaticContext {}
+    protected static abstract class ProtectedStaticContext {}
     private abstract class PrivateContext {}
 
     public enum Type {

Commit:
79d90ec1f148ae623c85ce61d6b46cf37b6fbc45
danielsun1106
realbluesun@hotmail.com
2018-04-06 14:49:28 +0800
Trivial refactoring: avoid unnecessary `StringBuffer` usage
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index bc3630f6e0..20d4f8f7e1 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -460,11 +460,9 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
 
     private static String replaceLastPoint(String name) {
         int lastPoint = name.lastIndexOf('.');
-        name = new StringBuffer()
-                .append(name.substring(0, lastPoint))
-                .append("$")
-                .append(name.substring(lastPoint + 1))
-                .toString();
+        name = name.substring(0, lastPoint) +
+                "$" +
+                name.substring(lastPoint + 1);
         return name;
     }
 

Commit:
ebdfa19389e75066154c433e272a0083350a15cf
danielsun1106
realbluesun@hotmail.com
2018-04-06 14:46:13 +0800
Trivial refactoring: extract variable
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 6065a6d172..bc3630f6e0 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -368,15 +368,17 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         // test if vanilla name is current class name
         if (currentClass == type) return true;
 
-        if (genericParameterNames.get(type.getName()) != null) {
-            GenericsType gt = genericParameterNames.get(type.getName());
+        String typeName = type.getName();
+
+        if (genericParameterNames.get(typeName) != null) {
+            GenericsType gt = genericParameterNames.get(typeName);
             type.setRedirect(gt.getType());
-            type.setGenericsTypes(new GenericsType[]{gt});
+            type.setGenericsTypes(new GenericsType[]{ gt });
             type.setGenericsPlaceHolder(true);
             return true;
         }
 
-        if (currentClass.getNameWithoutPackage().equals(type.getName())) {
+        if (currentClass.getNameWithoutPackage().equals(typeName)) {
             type.setRedirect(currentClass);
             return true;
         }

Commit:
2b918f8e6e5e2735fc5835b7c68f1e859de540b0
danielsun1106
realbluesun@hotmail.com
2018-04-06 14:38:38 +0800
Trivial refactoring: extract constants
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 653e11c055..6065a6d172 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -87,9 +87,12 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.isDefaultVisibility;
  * Note: the method to start the resolving is  startResolving(ClassNode, SourceUnit).
  */
 public class ResolveVisitor extends ClassCodeExpressionTransformer {
-    private ClassNode currentClass;
     // note: BigInteger and BigDecimal are also imported by default
     public static final String[] DEFAULT_IMPORTS = {"java.lang.", "java.io.", "java.net.", "java.util.", "groovy.lang.", "groovy.util."};
+    private static final String BIGINTEGER_STR = "BigInteger";
+    private static final String BIGDECIMAL_STR = "BigDecimal";
+
+    private ClassNode currentClass;
     private final CompilationUnit compilationUnit;
     private SourceUnit source;
     private VariableScope currentScope;
@@ -497,34 +500,34 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         return false;
     }
 
-    private boolean resolveFromDefaultImports(ClassNode type, boolean testDefaultImports) {
+    private boolean resolveFromDefaultImports(final ClassNode type, boolean testDefaultImports) {
         // test default imports
         testDefaultImports &= !type.hasPackageName();
         // we do not resolve a vanilla name starting with a lower case letter
         // try to resolve against a default import, because we know that the
         // default packages do not contain classes like these
         testDefaultImports &= !(type instanceof LowerCaseClass);
+        final String typeName = type.getName();
+
         if (testDefaultImports) {
-            for (int i = 0, size = DEFAULT_IMPORTS.length; i < size; i++) {
-                String packagePrefix = DEFAULT_IMPORTS[i];
-                String name = type.getName();
+            for (String packagePrefix : DEFAULT_IMPORTS) {
                 // We limit the inner class lookups here by using ConstructedClassWithPackage.
                 // This way only the name will change, the packagePrefix will
                 // not be included in the lookup. The case where the
                 // packagePrefix is really a class is handled elsewhere.
                 // WARNING: This code does not expect a class that has a static
                 //          inner class in DEFAULT_IMPORTS
-                ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(packagePrefix,name);
+                ConstructedClassWithPackage tmp = new ConstructedClassWithPackage(packagePrefix, typeName);
                 if (resolve(tmp, false, false, false)) {
                     type.setRedirect(tmp.redirect());
                     return true;
                 }
             }
-            String name = type.getName();
-            if (name.equals("BigInteger")) {
+
+            if (BIGINTEGER_STR.equals(typeName)) {
                 type.setRedirect(ClassHelper.BigInteger_TYPE);
                 return true;
-            } else if (name.equals("BigDecimal")) {
+            } else if (BIGDECIMAL_STR.equals(typeName)) {
                 type.setRedirect(ClassHelper.BigDecimal_TYPE);
                 return true;
             }

Commit:
10cdf235de9ac654844b6641fbcc7a5b0ba524b3
danielsun1106
realbluesun@hotmail.com
2018-04-06 13:48:11 +0800
Bump build-scan plugin to 1.12.1 and bump buildscan-recipes to 0.2.3
diff --git a/build.gradle b/build.gradle
index a194a74e4e..f32120c2f0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -50,8 +50,8 @@ buildscript {
 }
 
 plugins {
-    id 'com.gradle.build-scan' version '1.10.2'
-    id 'me.champeau.buildscan-recipes' version '0.2.0'
+    id 'com.gradle.build-scan' version '1.12.1'
+    id 'me.champeau.buildscan-recipes' version '0.2.3'
 }
 
 buildScan {

Commit:
0c7c6b112a01387c6acb56b359ead60501f299de
danielsun1106
realbluesun@hotmail.com
2018-04-06 13:24:54 +0800
Fix "Minor refactoring: remove duplicated code of `ResolveVisitor`"
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 2f82009b4e..653e11c055 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -18,6 +18,7 @@
  */
 package org.codehaus.groovy.control;
 
+import groovy.lang.Tuple2;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotatedNode;
@@ -790,8 +791,10 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                     return null;
                 }
                 String varName = ve.getName();
-                name = getClassName(doInitialClassTest, name, varName);
-                if (name == null) return null;
+                Tuple2<StringBuilder, Boolean> classNameInfo = makeClassName(doInitialClassTest, name, varName);
+                name = classNameInfo.getFirst();
+                doInitialClassTest = classNameInfo.getSecond();
+
                 break;
             }
             // anything other than PropertyExpressions or
@@ -805,7 +808,9 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 if (propertyPart == null || propertyPart.equals("class")) {
                     return null;
                 }
-                name = getClassName(doInitialClassTest, name, propertyPart);
+                Tuple2<StringBuilder, Boolean> classNameInfo = makeClassName(doInitialClassTest, name, propertyPart);
+                name = classNameInfo.getFirst();
+                doInitialClassTest = classNameInfo.getSecond();
             }
         }
 
@@ -814,7 +819,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         return name.toString();
     }
 
-    private static StringBuilder getClassName(boolean doInitialClassTest, StringBuilder name, String varName) {
+    private static Tuple2<StringBuilder, Boolean> makeClassName(boolean doInitialClassTest, StringBuilder name, String varName) {
         if (doInitialClassTest) {
             // we are at the first name part. This is the right most part.
             // If this part is in lower case, then we do not need a class
@@ -822,13 +827,17 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             // by a different method call to this method, so foo.Bar.bar
             // can still be resolved to the class foo.Bar and the static
             // field bar.
-            if (!testVanillaNameForClass(varName)) return null;
-            doInitialClassTest = false;
-            name = new StringBuilder(varName);
+            if (!testVanillaNameForClass(varName)) {
+                name = null;
+            } else {
+                doInitialClassTest = false;
+                name = new StringBuilder(varName);
+            }
         } else {
             name.insert(0, varName + ".");
         }
-        return name;
+
+        return new Tuple2<StringBuilder, Boolean>(name, doInitialClassTest);
     }
 
     // iterate from the inner most to the outer and check for classes

Commit:
24114e01f8a1fc44b776c9a64c2df50ebc8f7fe9
danielsun1106
realbluesun@hotmail.com
2018-04-06 12:54:59 +0800
Minor refactoring: remove duplicated code of `ResolveVisitor`
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 43a1dc1a9a..2f82009b4e 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -790,19 +790,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                     return null;
                 }
                 String varName = ve.getName();
-                if (doInitialClassTest) {
-                    // we are at the first name part. This is the right most part.
-                    // If this part is in lower case, then we do not need a class
-                    // check. other parts of the property expression will be tested
-                    // by a different method call to this method, so foo.Bar.bar
-                    // can still be resolved to the class foo.Bar and the static
-                    // field bar.
-                    if (!testVanillaNameForClass(varName)) return null;
-                    doInitialClassTest = false;
-                    name = new StringBuilder(varName);
-                } else {
-                    name.insert(0, varName + ".");
-                }
+                name = getClassName(doInitialClassTest, name, varName);
+                if (name == null) return null;
                 break;
             }
             // anything other than PropertyExpressions or
@@ -816,25 +805,32 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 if (propertyPart == null || propertyPart.equals("class")) {
                     return null;
                 }
-                if (doInitialClassTest) {
-                    // we are at the first name part. This is the right most part.
-                    // If this part is in lower case, then we do not need a class
-                    // check. other parts of the property expression will be tested
-                    // by a different method call to this method, so foo.Bar.bar
-                    // can still be resolved to the class foo.Bar and the static
-                    // field bar.
-                    if (!testVanillaNameForClass(propertyPart)) return null;
-                    doInitialClassTest= false;
-                    name = new StringBuilder(propertyPart);
-                } else {
-                    name.insert(0, propertyPart + ".");
-                }
+                name = getClassName(doInitialClassTest, name, propertyPart);
             }
         }
-        if (name.length() == 0) return null;
+
+        if (null == name || name.length() == 0) return null;
+
         return name.toString();
     }
 
+    private static StringBuilder getClassName(boolean doInitialClassTest, StringBuilder name, String varName) {
+        if (doInitialClassTest) {
+            // we are at the first name part. This is the right most part.
+            // If this part is in lower case, then we do not need a class
+            // check. other parts of the property expression will be tested
+            // by a different method call to this method, so foo.Bar.bar
+            // can still be resolved to the class foo.Bar and the static
+            // field bar.
+            if (!testVanillaNameForClass(varName)) return null;
+            doInitialClassTest = false;
+            name = new StringBuilder(varName);
+        } else {
+            name.insert(0, varName + ".");
+        }
+        return name;
+    }
+
     // iterate from the inner most to the outer and check for classes
     // this check will ignore a .class property, for Example Integer.class will be
     // a PropertyExpression with the ClassExpression of Integer as objectExpression

Commit:
742770d0421b1036f629d186dd76cfed76017b65
danielsun1106
realbluesun@hotmail.com
2018-04-06 03:07:51 +0800
Fix failing test: "Groovy6841Bug.testShouldNotThrowNPEduringCompilation" on 2_4_X
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 6cfd9be648..43a1dc1a9a 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -290,7 +290,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
 
     private boolean resolveToNestedOfCurrentClassAndSuperClasses(ClassNode type) {
         // GROOVY-8531: Fail to resolve type defined in super class written in Java
-        for (ClassNode enclosingClassNode = currentClass; ClassHelper.OBJECT_TYPE != enclosingClassNode; enclosingClassNode = enclosingClassNode.getSuperClass()) {
+        for (ClassNode enclosingClassNode = currentClass; ClassHelper.OBJECT_TYPE != enclosingClassNode && null != enclosingClassNode; enclosingClassNode = enclosingClassNode.getSuperClass()) {
             if(resolveToNested(enclosingClassNode, type)) return true;
         }
 

Commit:
418162659040e80164bc89f1623f110069c05cab
danielsun1106
realbluesun@hotmail.com
2018-04-06 01:38:33 +0800
Refine "GROOVY-8531: Fail to resolve type defined in super class written in Java"
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index a48d516d12..6cfd9be648 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -282,7 +282,6 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             if (resolve(type)) return true;
         }
 
-        // GROOVY-8531: Fail to resolve type defined in super class written in Java
         if (resolveToNestedOfCurrentClassAndSuperClasses(type)) return true;
 
         type.setName(saved);
@@ -290,6 +289,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     }
 
     private boolean resolveToNestedOfCurrentClassAndSuperClasses(ClassNode type) {
+        // GROOVY-8531: Fail to resolve type defined in super class written in Java
         for (ClassNode enclosingClassNode = currentClass; ClassHelper.OBJECT_TYPE != enclosingClassNode; enclosingClassNode = enclosingClassNode.getSuperClass()) {
             if(resolveToNested(enclosingClassNode, type)) return true;
         }
@@ -305,6 +305,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         if (enclosingType != type && !name.contains(".") && type.getClass().equals(ClassNode.class)) {
             ClassNode tmp = new ConstructedNestedClass(enclosingType,name);
             if (resolve(tmp)) {
+                if (!checkInnerTypeVisibility(enclosingType, tmp)) return false;
+
                 type.setRedirect(tmp);
                 return true;
             }
@@ -313,6 +315,19 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
 
     }
 
+    private boolean checkInnerTypeVisibility(ClassNode enclosingType, ClassNode innerClassNode) {
+        if (currentClass == enclosingType) {
+            return true;
+        }
+
+        int modifiers = innerClassNode.getModifiers();
+        if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {
+            return true;
+        }
+
+        return false;
+    }
+
     private void resolveOrFail(ClassNode type, String msg, ASTNode node) {
         if (resolve(type)) return;
         if (resolveToInner(type)) return;
diff --git a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
index b7ee0d2a10..72dd08bc63 100644
--- a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
+++ b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
@@ -19,18 +19,30 @@
 package groovy.bugs.groovy8531
 
 class Groovy8531Bug extends GroovyTestCase {
-    void test() {
+    void testPublicAndProtectedInnerType() {
         assertScript '''
             package groovy.bugs.groovy8531
             class Example extends Reducer {
-                public void reduce(Context context) {}
+                public void reduce(PublicContext context) {}
+                public void reduce2(ProtectedContext context) {}
                 public boolean isDynamic(Type type) {
                     return Type.DYNAMIC == type
                 }
             }
             
             new Example().reduce(null)
+            new Example().reduce2(null)
             assert new Example().isDynamic(Reducer.Type.DYNAMIC)
         '''
     }
+
+    void testPrivateInnerType() {
+        def errMsg = shouldFail '''
+            package groovy.bugs.groovy8531
+            class Example extends Reducer {
+                public void reduce3(PrivateContext context) {}
+            }
+        '''
+        assert errMsg.contains('unable to resolve class')
+    }
 }
diff --git a/src/test/groovy/bugs/groovy8531/Reducer.java b/src/test/groovy/bugs/groovy8531/Reducer.java
index c9b78bf5ca..95b5b241fc 100644
--- a/src/test/groovy/bugs/groovy8531/Reducer.java
+++ b/src/test/groovy/bugs/groovy8531/Reducer.java
@@ -19,7 +19,9 @@
 package groovy.bugs.groovy8531;
 
 public class Reducer {
-    public abstract class Context {}
+    public abstract class PublicContext {}
+    protected abstract class ProtectedContext {}
+    private abstract class PrivateContext {}
 
     public enum Type {
         DYNAMIC, STATIC

Commit:
fdaef2004ab30d79c3dd7e53beddc742ba456ed2
danielsun1106
realbluesun@hotmail.com
2018-04-06 00:51:29 +0800
Refine "GROOVY-8531: Fail to resolve type defined in super class written in Java"
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 615af7f23b..a48d516d12 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -283,16 +283,18 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         }
 
         // GROOVY-8531: Fail to resolve type defined in super class written in Java
-        for (ClassNode enclosingClassNode = currentClass; ClassHelper.OBJECT_TYPE != enclosingClassNode; enclosingClassNode = enclosingClassNode.getSuperClass()) {
-            if(resolveToNested(enclosingClassNode, type)) return true;
-        }
+        if (resolveToNestedOfCurrentClassAndSuperClasses(type)) return true;
 
         type.setName(saved);
         return false;
     }
 
-    private boolean resolveToNestedOfCurrent(ClassNode type) {
-        return resolveToNested(currentClass, type);
+    private boolean resolveToNestedOfCurrentClassAndSuperClasses(ClassNode type) {
+        for (ClassNode enclosingClassNode = currentClass; ClassHelper.OBJECT_TYPE != enclosingClassNode; enclosingClassNode = enclosingClassNode.getSuperClass()) {
+            if(resolveToNested(enclosingClassNode, type)) return true;
+        }
+
+        return false;
     }
 
     private boolean resolveToNested(ClassNode enclosingType, ClassNode type) {
@@ -983,7 +985,9 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                   t = new LowerCaseClass(name);
                 }
                 isClass = resolve(t);
-                if(!isClass) isClass = resolveToNestedOfCurrent(t);
+                if(!isClass) {
+                    isClass = resolveToNestedOfCurrentClassAndSuperClasses(t);
+                }
             }
             if (isClass) {
                 // the name is a type so remove it from the scoping
diff --git a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
index a8a21bce78..b7ee0d2a10 100644
--- a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
+++ b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
@@ -24,9 +24,13 @@ class Groovy8531Bug extends GroovyTestCase {
             package groovy.bugs.groovy8531
             class Example extends Reducer {
                 public void reduce(Context context) {}
+                public boolean isDynamic(Type type) {
+                    return Type.DYNAMIC == type
+                }
             }
             
             new Example().reduce(null)
+            assert new Example().isDynamic(Reducer.Type.DYNAMIC)
         '''
     }
 }
diff --git a/src/test/groovy/bugs/groovy8531/Reducer.java b/src/test/groovy/bugs/groovy8531/Reducer.java
index 7fde1313b8..c9b78bf5ca 100644
--- a/src/test/groovy/bugs/groovy8531/Reducer.java
+++ b/src/test/groovy/bugs/groovy8531/Reducer.java
@@ -20,4 +20,8 @@ package groovy.bugs.groovy8531;
 
 public class Reducer {
     public abstract class Context {}
+
+    public enum Type {
+        DYNAMIC, STATIC
+    }
 }

Commit:
1032854c9ee63c89f3347042d912918551bac96b
danielsun1106
realbluesun@hotmail.com
2018-04-06 00:00:50 +0800
GROOVY-8531: Fail to resolve type defined in super class written in Java
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index a06ad997e7..615af7f23b 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -281,25 +281,34 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             type.setName(name);
             if (resolve(type)) return true;
         }
-        if(resolveToNestedOfCurrent(type)) return true;
-        
+
+        // GROOVY-8531: Fail to resolve type defined in super class written in Java
+        for (ClassNode enclosingClassNode = currentClass; ClassHelper.OBJECT_TYPE != enclosingClassNode; enclosingClassNode = enclosingClassNode.getSuperClass()) {
+            if(resolveToNested(enclosingClassNode, type)) return true;
+        }
+
         type.setName(saved);
         return false;
     }
 
     private boolean resolveToNestedOfCurrent(ClassNode type) {
+        return resolveToNested(currentClass, type);
+    }
+
+    private boolean resolveToNested(ClassNode enclosingType, ClassNode type) {
         if (type instanceof ConstructedNestedClass) return false;
         // GROOVY-3110: It may be an inner enum defined by this class itself, in which case it does not need to be
         // explicitly qualified by the currentClass name
         String name = type.getName();
-        if (currentClass != type && !name.contains(".") && type.getClass().equals(ClassNode.class)) {
-            ClassNode tmp = new ConstructedNestedClass(currentClass,name);
+        if (enclosingType != type && !name.contains(".") && type.getClass().equals(ClassNode.class)) {
+            ClassNode tmp = new ConstructedNestedClass(enclosingType,name);
             if (resolve(tmp)) {
                 type.setRedirect(tmp);
                 return true;
             }
         }
         return false;
+
     }
 
     private void resolveOrFail(ClassNode type, String msg, ASTNode node) {
diff --git a/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
new file mode 100644
index 0000000000..a8a21bce78
--- /dev/null
+++ b/src/test/groovy/bugs/groovy8531/Groovy8531Bug.groovy
@@ -0,0 +1,32 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs.groovy8531
+
+class Groovy8531Bug extends GroovyTestCase {
+    void test() {
+        assertScript '''
+            package groovy.bugs.groovy8531
+            class Example extends Reducer {
+                public void reduce(Context context) {}
+            }
+            
+            new Example().reduce(null)
+        '''
+    }
+}
diff --git a/src/test/groovy/bugs/groovy8531/Reducer.java b/src/test/groovy/bugs/groovy8531/Reducer.java
new file mode 100644
index 0000000000..7fde1313b8
--- /dev/null
+++ b/src/test/groovy/bugs/groovy8531/Reducer.java
@@ -0,0 +1,23 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs.groovy8531;
+
+public class Reducer {
+    public abstract class Context {}
+}

Commit:
9061e93d6d63cd0f7fe0ddd36066db8ebdcd627e
Paul King
paulk@asert.com.au
2018-04-05 14:20:51 +1000
GROOVY-8515: groovy.g no longer included in sources jars
diff --git a/build.gradle b/build.gradle
index 0ea74ed8e9..a194a74e4e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -126,14 +126,6 @@ task(copyTestResources, type: Copy)
         .include('**/*.txt', '**/*.xml', '**/*.properties', '**/*.png', '**/*.html', '**/*.gif', '**/*.ico', '**/*.css')
 test.dependsOn(copyTestResources)
 
-allprojects {
-    task sourceJar(type: Jar) {
-        classifier = 'sources'
-        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
-        from sourceSets.main.allSource
-    }
-}
-
 repositories {
     // todo Some repos are needed only for some configs. Declare them just for the configuration once Gradle allows this.
     maven { url 'http://repository.jboss.org/nexus/content/groups/m2-release-proxy' } // examples, tools
@@ -285,6 +277,11 @@ sourceSets {
             srcDirs = ['src/resources']
         }
     }
+    antlr2 {
+        resources {
+            srcDirs = ['src/main/antlr2']
+        }
+    }
     test {
         groovy {
             srcDirs = ['src/test']
@@ -312,6 +309,21 @@ sourceSets {
     }
 }
 
+task sourceJar(type: Jar) {
+    classifier = 'sources'
+    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
+    from sourceSets.main.allSource
+    from sourceSets.antlr2.allSource
+}
+
+subprojects {
+    task sourceJar(type: Jar) {
+        classifier = 'sources'
+        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
+        from sourceSets.main.allSource
+    }
+}
+
 apply from: 'subprojects/parser-antlr4/build.gradle'
 
 // make sure examples can be compiled, even if we don't run them

Commit:
4f508a47e2e81970f3b4573804e3b787c07dbd96
Paul King
paulk@asert.com.au
2018-04-05 14:20:29 +1000
Merge branch 'master' of http://git-wip-us.apache.org/repos/asf/groovy
Commit:
8a9491581d0c9184eae8c4e45bfac2016b6d623f
Paul King
paulk@asert.com.au
2018-04-05 08:28:28 +1000
GROOVY-8529: InvocationWriter also needs fix for calling static interface methods
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index 6ab3fd942b..899d5cb47f 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -225,7 +225,7 @@ public class InvocationWriter {
         loadArguments(args.getExpressions(), target.getParameters());
 
         String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());
-        mv.visitMethodInsn(opcode, owner, methodName, desc, opcode == INVOKEINTERFACE);
+        mv.visitMethodInsn(opcode, owner, methodName, desc, declaringClass.isInterface());
         ClassNode ret = target.getReturnType().redirect();
         if (ret==ClassHelper.VOID_TYPE) {
             ret = ClassHelper.OBJECT_TYPE;
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/MopWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/MopWriter.java
index 6d06742559..8d1c429772 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/MopWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/MopWriter.java
@@ -208,7 +208,7 @@ public class MopWriter {
             // JDK 8 support for default methods in interfaces
             // this should probably be strenghtened when we support the A.super.foo() syntax
             int opcode = declaringClass.isInterface()?INVOKEINTERFACE:INVOKESPECIAL;
-            mv.visitMethodInsn(opcode, BytecodeHelper.getClassInternalName(declaringClass), method.getName(), methodDescriptor, opcode == INVOKEINTERFACE);
+            mv.visitMethodInsn(opcode, BytecodeHelper.getClassInternalName(declaringClass), method.getName(), methodDescriptor, declaringClass.isInterface());
             BytecodeHelper.doReturn(mv, method.getReturnType());
             mv.visitMaxs(0, 0);
             mv.visitEnd();

Commit:
f535e8935e0d67e1a8b40de28c0f47679a847c07
sunlan
sunlan@apache.org
2018-04-04 17:33:52 +0800
Trivial refactoring: extract common variable
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
index 59e9df61a7..45cc5095fb 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
@@ -95,14 +95,15 @@ public class StaticTypesLambdaWriter extends LambdaWriter {
     @Override
     public void writeLambda(LambdaExpression expression) {
         ClassNode lambdaType = getLambdaType(expression);
+        ClassNode redirect = lambdaType.redirect();
 
-        if (null == lambdaType || !ClassHelper.isFunctionalInterface(lambdaType.redirect())) {
+        if (null == lambdaType || !ClassHelper.isFunctionalInterface(redirect)) {
             // if the parameter type is not real FunctionInterface or failed to be inferred, generate the default bytecode, which is actually a closure
             super.writeLambda(expression);
             return;
         }
 
-        MethodNode abstractMethodNode = ClassHelper.findSAM(lambdaType.redirect());
+        MethodNode abstractMethodNode = ClassHelper.findSAM(redirect);
         String abstractMethodDesc = createMethodDescriptor(abstractMethodNode);
 
         ClassNode classNode = controller.getClassNode();
@@ -124,7 +125,7 @@ public class StaticTypesLambdaWriter extends LambdaWriter {
                 createBootstrapMethod(isInterface),
                 createBootstrapMethodArguments(abstractMethodDesc, lambdaWrapperClassNode, syntheticLambdaMethodNode)
         );
-        operandStack.replace(lambdaType.redirect(), 2);
+        operandStack.replace(redirect, 2);
 
         if (null != expression.getNodeMetaData(INFERRED_LAMBDA_TYPE)) {
             // FIXME declaring variable whose initial value is a lambda, e.g. `Function<Integer, String> f = (Integer e) -> 'a' + e`

Commit:
600e08b09c46f1a18fa856ee9d46de7abcead2dc
sunlan
sunlan@apache.org
2018-04-04 15:13:41 +0800
Revert "'new String()' is redundant"
diff --git a/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java b/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java
index a2ed84a40c..0d7d4add75 100644
--- a/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java
+++ b/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java
@@ -37,7 +37,7 @@ public class DirectFastStringService implements FastStringService {
     @Override
     public String noCopyStringFromChars(char[] chars) {
         if (WRITE_TO_FINAL_FIELDS) {
-            String string = "";
+            String string = new String();
             UNSAFE.putObject(string, STRING_VALUE_FIELD_OFFSET, chars);
             return string;
         } else {

Commit:
08b98ddbb0b39dfb6f52da7a487680c843177f70
sunlan
sunlan@apache.org
2018-04-04 10:31:46 +0800
Close inputstream
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java b/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java
index 75ebcbb6f1..c128c49b0a 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java
@@ -77,11 +77,9 @@ public abstract class AsmDecompiler {
         ClassStub stub = ref == null ? null : ref.get();
         if (stub == null) {
             DecompilingVisitor visitor = new DecompilingVisitor();
-            InputStream stream = url.openStream();
-            try {
-                new ClassReader(new BufferedInputStream(stream)).accept(visitor, ClassReader.SKIP_FRAMES);
-            } finally {
-                stream.close();
+
+            try (InputStream stream = new BufferedInputStream(url.openStream())) {
+                new ClassReader(stream).accept(visitor, ClassReader.SKIP_FRAMES);
             }
             stub = visitor.result;
             StubCache.map.put(uri, new SoftReference<ClassStub>(stub));

Commit:
02e0f2aac6491b24cdbffee65f3171db6c6fa20b
sunlan
sunlan@apache.org
2018-04-04 08:09:36 +0800
Optimize imports
diff --git a/subprojects/groovy-json/src/main/java/org/apache/groovy/json/internal/MapItemValue.java b/subprojects/groovy-json/src/main/java/org/apache/groovy/json/internal/MapItemValue.java
index d57568ecd4..325214f3bb 100644
--- a/subprojects/groovy-json/src/main/java/org/apache/groovy/json/internal/MapItemValue.java
+++ b/subprojects/groovy-json/src/main/java/org/apache/groovy/json/internal/MapItemValue.java
@@ -21,8 +21,6 @@ package org.apache.groovy.json.internal;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
-import static org.apache.groovy.json.internal.Exceptions.die;
-
 /**
  * This holds a mapping from value key to value value to maximize laziness.
  *
diff --git a/subprojects/groovy-xml/src/main/java/groovy/xml/streamingmarkupsupport/Builder.java b/subprojects/groovy-xml/src/main/java/groovy/xml/streamingmarkupsupport/Builder.java
index a48ac7a86a..6b38498e4a 100644
--- a/subprojects/groovy-xml/src/main/java/groovy/xml/streamingmarkupsupport/Builder.java
+++ b/subprojects/groovy-xml/src/main/java/groovy/xml/streamingmarkupsupport/Builder.java
@@ -22,7 +22,6 @@ import groovy.lang.Closure;
 import groovy.lang.GroovyObjectSupport;
 
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 

Commit:
97554095dc1883afeda0b69ff85f68e8cb6733ff
sunlan
sunlan@apache.org
2018-04-04 08:08:06 +0800
Unnecessary 'contains' check
diff --git a/subprojects/groovy-json/src/main/java/groovy/json/JsonGenerator.java b/subprojects/groovy-json/src/main/java/groovy/json/JsonGenerator.java
index f6b27f1119..be61d67eb6 100644
--- a/subprojects/groovy-json/src/main/java/groovy/json/JsonGenerator.java
+++ b/subprojects/groovy-json/src/main/java/groovy/json/JsonGenerator.java
@@ -255,9 +255,7 @@ public interface JsonGenerator {
                                         Closure<?> closure)
         {
             Converter converter = new DefaultJsonGenerator.ClosureConverter(type, closure);
-            if (converters.contains(converter)) {
-                converters.remove(converter);
-            }
+            converters.remove(converter);
             return addConverter(converter);
         }
 

Commit:
6d0e2f657528a1b012533a3f7282fa7bd1446179
sunlan
sunlan@apache.org
2018-04-04 08:07:34 +0800
Avoid redundant array creation
diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/ExtractIndexAndSql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/ExtractIndexAndSql.java
index 59d9c7d33a..c8b67f770b 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/ExtractIndexAndSql.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/ExtractIndexAndSql.java
@@ -197,7 +197,7 @@ class ExtractIndexAndSql {
             int index = (indexStr == null || indexStr.length() == 0 || ":".equals(indexStr)) ? 0 : Integer.parseInt(indexStr) - 1;
             String prop = matcher.group(2);
             if (prop == null) prop = matcher.group(4);
-            indexPropList.add(new Tuple(new Object[]{index, prop == null || prop.length() == 0 ? "<this>" : prop}));
+            indexPropList.add(new Tuple(index, prop == null || prop.length() == 0 ? "<this>" : prop));
             txtIndex = matcher.end();
         }
         newSql.append(sql.substring(txtIndex)); // append ending SQL after last param.
diff --git a/subprojects/groovy-swing/src/main/java/groovy/model/ClosureModel.java b/subprojects/groovy-swing/src/main/java/groovy/model/ClosureModel.java
index d25c6e73f5..82c1471a84 100644
--- a/subprojects/groovy-swing/src/main/java/groovy/model/ClosureModel.java
+++ b/subprojects/groovy-swing/src/main/java/groovy/model/ClosureModel.java
@@ -65,7 +65,7 @@ public class ClosureModel implements ValueModel, NestedValueModel {
         if (writeClosure != null) {
             Object source = sourceModel.getValue();
             if (source != null) {
-                writeClosure.call(new Object[] { source, value });
+                writeClosure.call(source, value);
             }
         }
     }

Commit:
b07369a506c1792695fcfaf6d6337ceef7836d4f
sunlan
sunlan@apache.org
2018-04-04 08:05:38 +0800
'new String()' is redundant
diff --git a/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java b/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java
index 0d7d4add75..a2ed84a40c 100644
--- a/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java
+++ b/subprojects/groovy-json-direct/src/main/java/org/apache/groovy/jsondirect/DirectFastStringService.java
@@ -37,7 +37,7 @@ public class DirectFastStringService implements FastStringService {
     @Override
     public String noCopyStringFromChars(char[] chars) {
         if (WRITE_TO_FINAL_FIELDS) {
-            String string = new String();
+            String string = "";
             UNSAFE.putObject(string, STRING_VALUE_FIELD_OFFSET, chars);
             return string;
         } else {

Commit:
7e7efffa9026711e85317f3b5bae6ed3586b25d9
sunlan
sunlan@apache.org
2018-04-04 08:05:07 +0800
'addAll()' call can be replaced with parametrized constructor call
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
index ace2b452cc..b5be4d78b4 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
@@ -268,8 +268,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
     public Set<GroovyClassDoc> getParentInterfaces() {
         Set<GroovyClassDoc> result = new LinkedHashSet<GroovyClassDoc>();
         result.add(this);
-        Set<GroovyClassDoc> next = new LinkedHashSet<GroovyClassDoc>();
-        next.addAll(Arrays.asList(this.interfaces()));
+        Set<GroovyClassDoc> next = new LinkedHashSet<GroovyClassDoc>(Arrays.asList(this.interfaces()));
         while (!next.isEmpty()) {
             Set<GroovyClassDoc> temp = next;
             next = new LinkedHashSet<GroovyClassDoc>();

Commit:
668ec9f5916d67069a258a72e2b9f1c30d4cfd77
sunlan
sunlan@apache.org
2018-04-04 08:04:39 +0800
Avoid manual array to collection copy
diff --git a/subprojects/groovy-json/src/main/java/groovy/json/JsonBuilder.java b/subprojects/groovy-json/src/main/java/groovy/json/JsonBuilder.java
index 939570eefb..89cee15d7e 100644
--- a/subprojects/groovy-json/src/main/java/groovy/json/JsonBuilder.java
+++ b/subprojects/groovy-json/src/main/java/groovy/json/JsonBuilder.java
@@ -27,6 +27,7 @@ import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -176,9 +177,7 @@ public class JsonBuilder extends GroovyObjectSupport implements Writable {
      */
     public Object call(Object... args) {
         List<Object> listContent = new ArrayList<Object>();
-        for (Object it : args) {
-            listContent.add(it);
-        }
+        Collections.addAll(listContent, args);
         content = listContent;
 
         return content;

Commit:
fe4224a66872052ccefffcc724c45ad70a41f6eb
sunlan
sunlan@apache.org
2018-04-04 08:03:50 +0800
Avoid call to 'toArray()' with pre-sized array argument
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/FileSystemCompilerFacade.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/FileSystemCompilerFacade.java
index e9b3327b66..3235c23dc5 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/FileSystemCompilerFacade.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/FileSystemCompilerFacade.java
@@ -37,7 +37,7 @@ public class FileSystemCompilerFacade {
         if (forceLookupUnnamedFiles) {
             argList.remove("--forceLookupUnnamedFiles");
         }
-        String[] newArgs = forceLookupUnnamedFiles ? argList.toArray(new String[argList.size()]) : args;
+        String[] newArgs = forceLookupUnnamedFiles ? argList.toArray(new String[0]) : args;
         FileSystemCompiler.commandLineCompileWithErrorHandling(newArgs, forceLookupUnnamedFiles);
     }
 }
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
index 8af272b219..5543a327ec 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
@@ -1154,7 +1154,7 @@ public class Groovyc extends MatchingTask {
 
     private String[] makeCommandLine(List<String> commandLineList) {
         log.verbose("Compilation arguments:\n" + DefaultGroovyMethods.join((Iterable)commandLineList, "\n"));
-        return commandLineList.toArray(new String[commandLineList.size()]);
+        return commandLineList.toArray(new String[0]);
     }
 
     private void runForked(String[] commandLine) {
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/ExternalGroovyClassDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/ExternalGroovyClassDoc.java
index d4611f7ed4..c9fecb7873 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/ExternalGroovyClassDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/ExternalGroovyClassDoc.java
@@ -46,7 +46,7 @@ public class ExternalGroovyClassDoc implements GroovyClassDoc {
     }
 
     public GroovyAnnotationRef[] annotations() {
-        return annotationRefs.toArray(new GroovyAnnotationRef[annotationRefs.size()]);
+        return annotationRefs.toArray(new GroovyAnnotationRef[0]);
     }
 
     public String qualifiedTypeName() {
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
index e3d46379cb..ace2b452cc 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
@@ -116,7 +116,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
      */
     public GroovyConstructorDoc[] constructors() {
         Collections.sort(constructors);
-        return constructors.toArray(new GroovyConstructorDoc[constructors.size()]);
+        return constructors.toArray(new GroovyConstructorDoc[0]);
     }
 
     public boolean add(GroovyConstructorDoc constructor) {
@@ -145,7 +145,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
      */
     public GroovyClassDoc[] innerClasses() {
         Collections.sort(nested);
-        return nested.toArray(new GroovyClassDoc[nested.size()]);
+        return nested.toArray(new GroovyClassDoc[0]);
     }
 
     public boolean addNested(GroovyClassDoc nestedClass) {
@@ -157,7 +157,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
      */
     public GroovyFieldDoc[] fields() {
         Collections.sort(fields);
-        return fields.toArray(new GroovyFieldDoc[fields.size()]);
+        return fields.toArray(new GroovyFieldDoc[0]);
     }
 
     public boolean add(GroovyFieldDoc field) {
@@ -169,7 +169,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
      */
     public GroovyFieldDoc[] properties() {
         Collections.sort(properties);
-        return properties.toArray(new GroovyFieldDoc[properties.size()]);
+        return properties.toArray(new GroovyFieldDoc[0]);
     }
 
     public boolean addProperty(GroovyFieldDoc property) {
@@ -181,7 +181,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
      */
     public GroovyFieldDoc[] enumConstants() {
         Collections.sort(enumConstants);
-        return enumConstants.toArray(new GroovyFieldDoc[enumConstants.size()]);
+        return enumConstants.toArray(new GroovyFieldDoc[0]);
     }
 
     public boolean addEnumConstant(GroovyFieldDoc field) {
@@ -193,7 +193,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
      */
     public GroovyMethodDoc[] methods() {
         Collections.sort(methods);
-        return methods.toArray(new GroovyMethodDoc[methods.size()]);
+        return methods.toArray(new GroovyMethodDoc[0]);
     }
 
     public boolean add(GroovyMethodDoc method) {
@@ -732,7 +732,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
 
     public GroovyClassDoc[] interfaces() {
         Collections.sort(interfaceClasses);
-        return interfaceClasses.toArray(new GroovyClassDoc[interfaceClasses.size()]);
+        return interfaceClasses.toArray(new GroovyClassDoc[0]);
     }
 
     public GroovyType[] interfaceTypes() {/*todo*/
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java
index f87c7cd885..8dd1d9cb74 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyDoc.java
@@ -108,7 +108,7 @@ public class SimpleGroovyDoc implements GroovyDoc, GroovyTokenTypes {
                 setDeprecated(true);
             }
         }
-        tags = result.toArray(new GroovyTag[result.size()]);
+        tags = result.toArray(new GroovyTag[0]);
     }
 
     public static String calculateFirstSentence(String raw) {
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyExecutableMemberDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyExecutableMemberDoc.java
index 53219c19e4..5316ce46d3 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyExecutableMemberDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyExecutableMemberDoc.java
@@ -35,7 +35,7 @@ public class SimpleGroovyExecutableMemberDoc extends SimpleGroovyMemberDoc imple
     }
 
     public GroovyParameter[] parameters() {
-        return (GroovyParameter[]) parameters.toArray(new GroovyParameter[parameters.size()]);
+        return (GroovyParameter[]) parameters.toArray(new GroovyParameter[0]);
     }
 
     public void add(GroovyParameter parameter) {
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyPackageDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyPackageDoc.java
index b70355466e..36090fb8a2 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyPackageDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyPackageDoc.java
@@ -39,7 +39,7 @@ public class SimpleGroovyPackageDoc extends SimpleGroovyDoc implements GroovyPac
     }
 
     public GroovyClassDoc[] allClasses() {
-        return classDocs.values().toArray(new GroovyClassDoc[classDocs.values().size()]);
+        return classDocs.values().toArray(new GroovyClassDoc[0]);
     }
 
     public void setDescription(String description) {
@@ -68,7 +68,7 @@ public class SimpleGroovyPackageDoc extends SimpleGroovyDoc implements GroovyPac
 
     public GroovyClassDoc[] allClasses(boolean arg0) {
         List<GroovyClassDoc> classDocValues = new ArrayList<GroovyClassDoc>(classDocs.values());
-        return classDocValues.toArray(new GroovyClassDoc[classDocValues.size()]);
+        return classDocValues.toArray(new GroovyClassDoc[0]);
     }
 
     public GroovyClassDoc[] enums() {
@@ -78,7 +78,7 @@ public class SimpleGroovyPackageDoc extends SimpleGroovyDoc implements GroovyPac
                 result.add(doc);
             }
         }
-        return result.toArray(new GroovyClassDoc[result.size()]);
+        return result.toArray(new GroovyClassDoc[0]);
     }
 
     public GroovyClassDoc[] errors() {
@@ -88,7 +88,7 @@ public class SimpleGroovyPackageDoc extends SimpleGroovyDoc implements GroovyPac
                 result.add(doc);
             }
         }
-        return result.toArray(new GroovyClassDoc[result.size()]);
+        return result.toArray(new GroovyClassDoc[0]);
     }
 
     public GroovyClassDoc[] exceptions() {
@@ -98,7 +98,7 @@ public class SimpleGroovyPackageDoc extends SimpleGroovyDoc implements GroovyPac
                 result.add(doc);
             }
         }
-        return result.toArray(new GroovyClassDoc[result.size()]);
+        return result.toArray(new GroovyClassDoc[0]);
     }
 
     public GroovyClassDoc findClass(String arg0) {/*todo*/
@@ -112,7 +112,7 @@ public class SimpleGroovyPackageDoc extends SimpleGroovyDoc implements GroovyPac
                 result.add(doc);
             }
         }
-        return result.toArray(new GroovyClassDoc[result.size()]);
+        return result.toArray(new GroovyClassDoc[0]);
     }
 
     public GroovyClassDoc[] ordinaryClasses() {
@@ -122,7 +122,7 @@ public class SimpleGroovyPackageDoc extends SimpleGroovyDoc implements GroovyPac
                 result.add(doc);
             }
         }
-        return result.toArray(new GroovyClassDoc[result.size()]);
+        return result.toArray(new GroovyClassDoc[0]);
     }
 
     public String description() {
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java
index 947d48cf91..27cf037eb0 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java
@@ -62,7 +62,7 @@ public class SimpleGroovyParameter implements GroovyParameter {
     }
 
     public GroovyAnnotationRef[] annotations() {
-        return annotationRefs.toArray(new GroovyAnnotationRef[annotationRefs.size()]);
+        return annotationRefs.toArray(new GroovyAnnotationRef[0]);
     }
 
     public void addAnnotationRef(GroovyAnnotationRef ref) {
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyProgramElementDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyProgramElementDoc.java
index 7b86ea0c88..8a2339deca 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyProgramElementDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyProgramElementDoc.java
@@ -98,7 +98,7 @@ public class SimpleGroovyProgramElementDoc extends SimpleGroovyDoc implements Gr
     }
 
     public GroovyAnnotationRef[] annotations() {
-        return annotationRefs.toArray(new GroovyAnnotationRef[annotationRefs.size()]);
+        return annotationRefs.toArray(new GroovyAnnotationRef[0]);
     }
 
     public void addAnnotationRef(GroovyAnnotationRef ref) {
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
index cc0dd1b125..eeffd163bc 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyRootDoc.java
@@ -87,7 +87,7 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
             classDocValues = new ArrayList<GroovyClassDoc>(classDocs.values());
             Collections.sort(classDocValues);
         }
-        return classDocValues.toArray(new GroovyClassDoc[classDocValues.size()]);
+        return classDocValues.toArray(new GroovyClassDoc[0]);
     }
 
     public String[][] options() {/*todo*/
@@ -117,7 +117,7 @@ public class SimpleGroovyRootDoc extends SimpleGroovyDoc implements GroovyRootDo
             packageDocValues = new ArrayList<GroovyPackageDoc>(packageDocs.values());
             Collections.sort(packageDocValues);
         }
-        return packageDocValues.toArray(new GroovyPackageDoc[packageDocValues.size()]);
+        return packageDocValues.toArray(new GroovyPackageDoc[0]);
     }
 
     public Map<String, GroovyClassDoc> getVisibleClasses(List importedClassesAndPackages) {
diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
index a554644445..da61e9f3d7 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
@@ -4589,7 +4589,7 @@ public class Sql {
         @Override
         protected PreparedStatement execute(Connection connection, String sql) throws SQLException {
             if (returnGeneratedKeys == USE_COLUMN_NAMES && keyColumnNames != null) {
-                return connection.prepareStatement(sql, keyColumnNames.toArray(new String[keyColumnNames.size()]));
+                return connection.prepareStatement(sql, keyColumnNames.toArray(new String[0]));
             }
             if (returnGeneratedKeys != 0) {
                 return connection.prepareStatement(sql, returnGeneratedKeys);
diff --git a/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java b/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java
index 8a0fecb2ec..6c41a9eb17 100644
--- a/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java
+++ b/subprojects/groovy-swing/src/main/java/org/codehaus/groovy/binding/ClosureTriggerBinding.java
@@ -55,7 +55,7 @@ public class ClosureTriggerBinding implements TriggerBinding, SourceBinding {
         for (Map.Entry<String, BindPathSnooper> entry : snooper.fields.entrySet()) {
             childPaths.add(createBindPath(entry.getKey(), entry.getValue()));
         }
-        bp.children = childPaths.toArray(new BindPath[childPaths.size()]);
+        bp.children = childPaths.toArray(new BindPath[0]);
         return bp;
     }
 
@@ -123,7 +123,7 @@ public class ClosureTriggerBinding implements TriggerBinding, SourceBinding {
         PropertyPathFullBinding fb = new PropertyPathFullBinding();
         fb.setSourceBinding(new ClosureSourceBinding(closure));
         fb.setTargetBinding(target);
-        fb.bindPaths = rootPaths.toArray(new BindPath[rootPaths.size()]);
+        fb.bindPaths = rootPaths.toArray(new BindPath[0]);
         return fb;
     }
 

Commit:
5c9c724131df853859f823e22693457a306587e9
sunlan
sunlan@apache.org
2018-04-04 07:51:51 +0800
Trivial refactoring: simplify filling array
diff --git a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index f7f182d2c4..0776856f4a 100644
--- a/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/subprojects/parser-antlr4/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -3193,7 +3193,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> implements Groov
 
                 if (asBoolean(emptyDimList)) {
                     empties = new Expression[emptyDimList.size()];
-                    Arrays.setAll(empties, i -> ConstantExpression.EMPTY_EXPRESSION);
+                    Arrays.fill(empties, ConstantExpression.EMPTY_EXPRESSION);
                 } else {
                     empties = Expression.EMPTY_ARRAY;
                 }

Commit:
30da8cf02f9afeb1db23c71b85b072d0131a71d8
sunlan
sunlan@apache.org
2018-04-04 00:47:43 +0800
Refine error message of test
diff --git a/src/test/groovy/bugs/Groovy4252Bug.groovy b/src/test/groovy/bugs/Groovy4252Bug.groovy
index 39cab8872b..e6bee44591 100644
--- a/src/test/groovy/bugs/Groovy4252Bug.groovy
+++ b/src/test/groovy/bugs/Groovy4252Bug.groovy
@@ -78,7 +78,7 @@ class Groovy4252Bug extends GroovyShellTestCase {
         } catch (MultipleCompilationErrorsException e) {
             def syntaxError = e.errorCollector.getSyntaxError(0)
             assert syntaxError.message.contains("Expression list of the form (a; b; c) is not supported in this context") ||
-                    syntaxError.message.contains("Unexpected input:")
+                    syntaxError.message.contains("Unexpected input:") || syntaxError.message.contains("Missing ')'")
         }
     }
 

Commit:
b9929d2ebfa1874f3911acb020e367cfb5ea776e
sunlan
sunlan@apache.org
2018-04-04 00:28:31 +0800
Refine error handling for missing right parenthesis
diff --git a/src/antlr/GroovyParser.g4 b/src/antlr/GroovyParser.g4
index 930c1d645e..385fd11130 100644
--- a/src/antlr/GroovyParser.g4
+++ b/src/antlr/GroovyParser.g4
@@ -286,7 +286,7 @@ memberDeclaration[int t]
  */
 methodDeclaration[int t, int ct]
     :   { 3 == $ct }?
-        returnType[$ct] methodName LPAREN RPAREN (DEFAULT nls elementValue)?
+        returnType[$ct] methodName LPAREN rparen (DEFAULT nls elementValue)?
     |
         modifiersOpt typeParameters? returnType[$ct]?
         methodName formalParameters (nls THROWS nls qualifiedClassNameList)?
@@ -402,7 +402,7 @@ qualifiedClassNameList
     ;
 
 formalParameters
-    :   LPAREN formalParameterList? RPAREN
+    :   LPAREN formalParameterList? rparen
     ;
 
 formalParameterList
@@ -595,7 +595,7 @@ variableDeclaration[int t]
     ;
 
 typeNamePairs
-    :   LPAREN typeNamePair (COMMA typeNamePair)* RPAREN
+    :   LPAREN typeNamePair (COMMA typeNamePair)* rparen
     ;
 
 typeNamePair

Commit:
263393d77034cef8585d335d8d0564b3bf5a4755
Paul King
paulk@asert.com.au
2018-04-03 23:54:12 +1000
GROOVY-8523: also handle !instanceof operator
diff --git a/gradle/pomconfigurer.gradle b/gradle/pomconfigurer.gradle
index de35cdf7a9..9438dc18e8 100644
--- a/gradle/pomconfigurer.gradle
+++ b/gradle/pomconfigurer.gradle
@@ -561,6 +561,9 @@ project.ext.pomConfigureClosureWithoutTweaks = {
             contributor {
                 name 'Mike Spille'
             }
+            contributor {
+                name 'Nikolay Chugunov'
+            }
             contributor {
                 name 'Paolo Di Tommaso'
             }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index bd647fcfdd..c8e79bb6a4 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3470,7 +3470,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
         BinaryExpression instanceOfExpression = findInstanceOfNotReturnExpression(ifElse);
         if (instanceOfExpression == null) {
-        } else {
+            instanceOfExpression = findNotInstanceOfReturnExpression(ifElse);
+        }
+        if (instanceOfExpression != null) {
             if(typeCheckingContext.enclosingBlocks.size()>0) {
                 visitInstanceofNot(instanceOfExpression);
             }
@@ -3478,7 +3480,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
 
-    public void visitInstanceofNot(BinaryExpression be) {
+    protected void visitInstanceofNot(BinaryExpression be) {
         final BlockStatement currentBlock = typeCheckingContext.enclosingBlocks.getFirst();
         assert currentBlock != null;
         if (typeCheckingContext.blockStatements2Types.containsKey(currentBlock)) {
@@ -3517,15 +3519,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     /**
      * Check IfStatement matched pattern :
      * Object var1;
-     * if (!(var1 instanceOf Runnable)){
-     * return
+     * if (!(var1 instanceOf Runnable)) {
+     *   return
      * }
      * // Here var1 instance of Runnable
      *
      * Return expression , which contains instanceOf (without not)
      * Return null, if not found
      */
-    public BinaryExpression findInstanceOfNotReturnExpression(IfStatement ifElse) {
+    protected BinaryExpression findInstanceOfNotReturnExpression(IfStatement ifElse) {
         Statement elseBlock = ifElse.getElseBlock();
         if (!(elseBlock instanceof EmptyStatement)) {
             return null;
@@ -3544,19 +3546,56 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (op != Types.KEYWORD_INSTANCEOF) {
             return null;
         }
-        Statement block = ifElse.getIfBlock();
-        if (!(block instanceof BlockStatement)) {
+        if (notReturningBlock(ifElse.getIfBlock())) {
+            return null;
+        }
+        return instanceOfExpression;
+    }
+
+    /**
+     * Check IfStatement matched pattern :
+     * Object var1;
+     * if (var1 !instanceOf Runnable) {
+     *   return
+     * }
+     * // Here var1 instance of Runnable
+     *
+     * Return expression , which contains instanceOf (without not)
+     * Return null, if not found
+     */
+    protected BinaryExpression findNotInstanceOfReturnExpression(IfStatement ifElse) {
+        Statement elseBlock = ifElse.getElseBlock();
+        if (!(elseBlock instanceof EmptyStatement)) {
             return null;
         }
+        Expression conditionExpression = ifElse.getBooleanExpression().getExpression();
+        if (!(conditionExpression instanceof BinaryExpression)) {
+            return null;
+        }
+        BinaryExpression instanceOfExpression = (BinaryExpression) conditionExpression;
+        int op = instanceOfExpression.getOperation().getType();
+        if (op != Types.COMPARE_NOT_INSTANCEOF) {
+            return null;
+        }
+        if (notReturningBlock(ifElse.getIfBlock())) {
+            return null;
+        }
+        return instanceOfExpression;
+    }
+
+    private boolean notReturningBlock(Statement block) {
+        if (!(block instanceof BlockStatement)) {
+            return true;
+        }
         BlockStatement bs = (BlockStatement) block;
         if (bs.getStatements().size() == 0) {
-            return null;
+            return true;
         }
         Statement last = DefaultGroovyMethods.last(bs.getStatements());
         if (!(last instanceof ReturnStatement)) {
-            return null;
+            return true;
         }
-        return instanceOfExpression;
+        return false;
     }
 
     @Override
diff --git a/src/test/groovy/bugs/Groovy8523Bug.groovy b/src/test/groovy/bugs/Groovy8523Bug.groovy
index ac598544e1..d3c3165101 100755
--- a/src/test/groovy/bugs/Groovy8523Bug.groovy
+++ b/src/test/groovy/bugs/Groovy8523Bug.groovy
@@ -27,9 +27,9 @@ class Groovy8523Bug extends GroovyTestCase {
             static int checkRes = 0
 
             static void f1(Object var1) {
-                if(!(var1 instanceof Runnable)){
+                if (!(var1 instanceof Runnable)){
                     checkRes = 3
-                    return;
+                    return
                 }
                 f2(var1)
             }
@@ -41,7 +41,37 @@ class Groovy8523Bug extends GroovyTestCase {
 
         Runnable r = {}
         Test1.f1(r)
-        assert Test1.checkRes == 4;
+        assert Test1.checkRes == 4
+        Test1.f1(42)
+        assert Test1.checkRes == 3
+        '''
+    }
+
+    void testNotInstanceof1() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        @CompileStatic
+        class Test1 {
+            static int checkRes = 0
+
+            static void f1(Object var1) {
+                if (var1 !instanceof Runnable){
+                    checkRes = 3
+                    return
+                }
+                f2(var1)
+            }
+
+            static void f2(Runnable var2) {
+                checkRes = 4
+            }
+        }
+
+        Runnable r = {}
+        Test1.f1(r)
+        assert Test1.checkRes == 4
+        Test1.f1(42)
+        assert Test1.checkRes == 3
         '''
     }
 
@@ -54,13 +84,13 @@ class Groovy8523Bug extends GroovyTestCase {
             static int checkRes = 0
 
             static void f1(Object var1) {
-                if(!(var1 instanceof Runnable)){
+                if (!(var1 instanceof Runnable)){
                     checkRes = 3
-                    return;
+                    return
                 }
-                if(!(var1 instanceof List)){
+                if (!(var1 instanceof List)){
                     checkRes = 5
-                    return;
+                    return
                 }
                 f2(var1)
             }
@@ -72,7 +102,7 @@ class Groovy8523Bug extends GroovyTestCase {
 
         Runnable r = {}
         Test1.f1(r)
-        assert Test1.checkRes == 5;
+        assert Test1.checkRes == 5
         '''
     }
 
@@ -85,13 +115,13 @@ class Groovy8523Bug extends GroovyTestCase {
             static int checkRes = 0
 
             static void f1(Object var1) {
-                if(!(var1 instanceof Runnable)){
+                if (!(var1 instanceof Runnable)){
                     checkRes = 3
-                    return;
+                    return
                 }
-                if(!(var1 instanceof Thread)){
+                if (!(var1 instanceof Thread)){
                     checkRes = 5
-                    return;
+                    return
                 }
                 f2(var1)
             }
@@ -103,7 +133,7 @@ class Groovy8523Bug extends GroovyTestCase {
 
         Runnable r = {}
         Test1.f1(r)
-        assert Test1.checkRes == 5;
+        assert Test1.checkRes == 5
         '''
     }
 

Commit:
e79f837e6dbedd9f029ede3969b3194c5da174b4
Paul King
paulk@asert.com.au
2018-04-03 22:43:19 +1000
fix serializable compatibility test
diff --git a/src/test/groovy/SerializableCompatibilityTest.groovy b/src/test/groovy/SerializableCompatibilityTest.groovy
index c0704c14ce..4acbc44a73 100644
--- a/src/test/groovy/SerializableCompatibilityTest.groovy
+++ b/src/test/groovy/SerializableCompatibilityTest.groovy
@@ -16,7 +16,6 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-
 package groovy
 
 import groovy.bugs.TestSupport
@@ -37,7 +36,7 @@ class SerializableCompatibilityTest extends TestSupport {
 
     void testDeserialize() {
         // generated by testSerialize
-        def serializedObjectStr_2_4_X = 'rO0ABXNyACJncm9vdnkubGFuZy5Hcm9vdnlSdW50aW1lRXhjZXB0aW9uM1jWw9touJUCAAJMAAZtb2R1bGV0ACRMb3JnL2NvZGVoYXVzL2dyb292eS9hc3QvTW9kdWxlTm9kZTtMAARub2RldAAhTG9yZy9jb2RlaGF1cy9ncm9vdnkvYXN0L0FTVE5vZGU7eHIAGmphdmEubGFuZy5SdW50aW1lRXhjZXB0aW9unl8GRwo0g+UCAAB4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAKdAAEYm9vbXVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAHHNyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAHTAAIZmlsZU5hbWVxAH4AB0wACm1ldGhvZE5hbWVxAH4AB3hw/////nQAKXN1bi5yZWZsZWN0Lk5hdGl2ZUNvbnN0cnVjdG9yQWNjZXNzb3JJbXBsdAAiTmF0aXZlQ29uc3RydWN0b3JBY2Nlc3NvckltcGwuamF2YXQADG5ld0luc3RhbmNlMHNxAH4ADgAAAD5xAH4AEHEAfgARdAALbmV3SW5zdGFuY2VzcQB+AA4AAAAtdAAtc3VuLnJlZmxlY3QuRGVsZWdhdGluZ0NvbnN0cnVjdG9yQWNjZXNzb3JJbXBsdAAmRGVsZWdhdGluZ0NvbnN0cnVjdG9yQWNjZXNzb3JJbXBsLmphdmFxAH4AFHNxAH4ADgAAAad0AB1qYXZhLmxhbmcucmVmbGVjdC5Db25zdHJ1Y3RvcnQAEENvbnN0cnVjdG9yLmphdmFxAH4AFHNxAH4ADgAAAFN0ADBvcmcuY29kZWhhdXMuZ3Jvb3Z5LnJlZmxlY3Rpb24uQ2FjaGVkQ29uc3RydWN0b3J0ABZDYWNoZWRDb25zdHJ1Y3Rvci5qYXZhdAAGaW52b2tlc3EAfgAOAAAAaXQAVG9yZy5jb2RlaGF1cy5ncm9vdnkucnVudGltZS5jYWxsc2l0ZS5Db25zdHJ1Y3RvclNpdGUkQ29uc3RydWN0b3JTaXRlTm9VbndyYXBOb0NvZXJjZXQAFENvbnN0cnVjdG9yU2l0ZS5qYXZhdAAPY2FsbENvbnN0cnVjdG9yc3EAfgAOAAAAO3QAMm9yZy5jb2RlaGF1cy5ncm9vdnkucnVudGltZS5jYWxsc2l0ZS5DYWxsU2l0ZUFycmF5dAASQ2FsbFNpdGVBcnJheS5qYXZhdAAWZGVmYXVsdENhbGxDb25zdHJ1Y3RvcnNxAH4ADgAAAO50ADVvcmcuY29kZWhhdXMuZ3Jvb3Z5LnJ1bnRpbWUuY2FsbHNpdGUuQWJzdHJhY3RDYWxsU2l0ZXQAFUFic3RyYWN0Q2FsbFNpdGUuamF2YXEAfgAic3EAfgAOAAAA+nEAfgAocQB+AClxAH4AInNxAH4ADgAAABh0AA1TZXJpYWxpemVUZXN0dAAUU2VyaWFsaXplVGVzdC5ncm9vdnl0AAR0ZXN0c3EAfgAO/////nQAJHN1bi5yZWZsZWN0Lk5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbHQAHU5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAHaW52b2tlMHNxAH4ADgAAAD5xAH4AMHEAfgAxcQB+AB5zcQB+AA4AAAArdAAoc3VuLnJlZmxlY3QuRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbHQAIURlbGVnYXRpbmdNZXRob2RBY2Nlc3NvckltcGwuamF2YXEAfgAec3EAfgAOAAAB8nQAGGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZHQAC01ldGhvZC5qYXZhcQB+AB5zcQB+AA4AAACwdAAYanVuaXQuZnJhbWV3b3JrLlRlc3RDYXNldAANVGVzdENhc2UuamF2YXQAB3J1blRlc3RzcQB+AA4AAACNcQB+ADtxAH4APHQAB3J1bkJhcmVzcQB+AA4AAAB6dAAcanVuaXQuZnJhbWV3b3JrLlRlc3RSZXN1bHQkMXQAD1Rlc3RSZXN1bHQuamF2YXQAB3Byb3RlY3RzcQB+AA4AAACOdAAaanVuaXQuZnJhbWV3b3JrLlRlc3RSZXN1bHRxAH4AQnQADHJ1blByb3RlY3RlZHNxAH4ADgAAAH1xAH4ARXEAfgBCdAADcnVuc3EAfgAOAAAAgXEAfgA7cQB+ADxxAH4ASHNxAH4ADgAAAPx0ABlqdW5pdC5mcmFtZXdvcmsuVGVzdFN1aXRldAAOVGVzdFN1aXRlLmphdmFxAH4APXNxAH4ADgAAAPdxAH4AS3EAfgBMcQB+AEhzcQB+AA4AAABWdAAtb3JnLmp1bml0LmludGVybmFsLnJ1bm5lcnMuSlVuaXQzOENsYXNzUnVubmVydAAXSlVuaXQzOENsYXNzUnVubmVyLmphdmFxAH4ASHNxAH4ADgAAAIl0ABpvcmcuanVuaXQucnVubmVyLkpVbml0Q29yZXQADkpVbml0Q29yZS5qYXZhcQB+AEhzcQB+AA4AAABEdAAoY29tLmludGVsbGlqLmp1bml0NC5KVW5pdDRJZGVhVGVzdFJ1bm5lcnQAGUpVbml0NElkZWFUZXN0UnVubmVyLmphdmF0ABNzdGFydFJ1bm5lcldpdGhBcmdzc3EAfgAOAAAAL3QAN2NvbS5pbnRlbGxpai5ydC5leGVjdXRpb24uanVuaXQuSWRlYVRlc3RSdW5uZXIkUmVwZWF0ZXJ0ABNJZGVhVGVzdFJ1bm5lci5qYXZhcQB+AFdzcQB+AA4AAADydAAsY29tLmludGVsbGlqLnJ0LmV4ZWN1dGlvbi5qdW5pdC5KVW5pdFN0YXJ0ZXJ0ABFKVW5pdFN0YXJ0ZXIuamF2YXQAFnByZXBhcmVTdHJlYW1zQW5kU3RhcnRzcQB+AA4AAABGcQB+AFxxAH4AXXQABG1haW5zcgAmamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUxpc3T8DyUxteyOEAIAAUwABGxpc3RxAH4ACXhyACxqYXZhLnV0aWwuQ29sbGVjdGlvbnMkVW5tb2RpZmlhYmxlQ29sbGVjdGlvbhlCAIDLXvceAgABTAABY3QAFkxqYXZhL3V0aWwvQ29sbGVjdGlvbjt4cHNyABNqYXZhLnV0aWwuQXJyYXlMaXN0eIHSHZnHYZ0DAAFJAARzaXpleHAAAAAAdwQAAAAAeHEAfgBmeHBw'
+        def serializedObjectStr_2_4_X = 'rO0ABXNyACJncm9vdnkubGFuZy5Hcm9vdnlSdW50aW1lRXhjZXB0aW9u/VHW5CcH3PYCAAJMAAZtb2R1bGV0ACRMb3JnL2NvZGVoYXVzL2dyb292eS9hc3QvTW9kdWxlTm9kZTtMAARub2RldAAhTG9yZy9jb2RlaGF1cy9ncm9vdnkvYXN0L0FTVE5vZGU7eHIAGmphdmEubGFuZy5SdW50aW1lRXhjZXB0aW9unl8GRwo0g+UCAAB4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAKdAAEYm9vbXVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAIHNyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAHTAAIZmlsZU5hbWVxAH4AB0wACm1ldGhvZE5hbWVxAH4AB3hw/////nQAKXN1bi5yZWZsZWN0Lk5hdGl2ZUNvbnN0cnVjdG9yQWNjZXNzb3JJbXBsdAAiTmF0aXZlQ29uc3RydWN0b3JBY2Nlc3NvckltcGwuamF2YXQADG5ld0luc3RhbmNlMHNxAH4ADgAAAD5xAH4AEHEAfgARdAALbmV3SW5zdGFuY2VzcQB+AA4AAAAtdAAtc3VuLnJlZmxlY3QuRGVsZWdhdGluZ0NvbnN0cnVjdG9yQWNjZXNzb3JJbXBsdAAmRGVsZWdhdGluZ0NvbnN0cnVjdG9yQWNjZXNzb3JJbXBsLmphdmFxAH4AFHNxAH4ADgAAAad0AB1qYXZhLmxhbmcucmVmbGVjdC5Db25zdHJ1Y3RvcnQAEENvbnN0cnVjdG9yLmphdmFxAH4AFHNxAH4ADgAAAFN0ADBvcmcuY29kZWhhdXMuZ3Jvb3Z5LnJlZmxlY3Rpb24uQ2FjaGVkQ29uc3RydWN0b3J0ABZDYWNoZWRDb25zdHJ1Y3Rvci5qYXZhdAAGaW52b2tlc3EAfgAOAAAAaXQAVG9yZy5jb2RlaGF1cy5ncm9vdnkucnVudGltZS5jYWxsc2l0ZS5Db25zdHJ1Y3RvclNpdGUkQ29uc3RydWN0b3JTaXRlTm9VbndyYXBOb0NvZXJjZXQAFENvbnN0cnVjdG9yU2l0ZS5qYXZhdAAPY2FsbENvbnN0cnVjdG9yc3EAfgAOAAAAO3QAMm9yZy5jb2RlaGF1cy5ncm9vdnkucnVudGltZS5jYWxsc2l0ZS5DYWxsU2l0ZUFycmF5dAASQ2FsbFNpdGVBcnJheS5qYXZhdAAWZGVmYXVsdENhbGxDb25zdHJ1Y3RvcnNxAH4ADgAAAO50ADVvcmcuY29kZWhhdXMuZ3Jvb3Z5LnJ1bnRpbWUuY2FsbHNpdGUuQWJzdHJhY3RDYWxsU2l0ZXQAFUFic3RyYWN0Q2FsbFNpdGUuamF2YXEAfgAic3EAfgAOAAAA+nEAfgAocQB+AClxAH4AInNxAH4ADgAAAAF0AA9Db25zb2xlU2NyaXB0MzVxAH4ALHQAA3J1bnNxAH4ADgAAAQd0ABdncm9vdnkubGFuZy5Hcm9vdnlTaGVsbHQAEEdyb292eVNoZWxsLmphdmF0AB9ydW5TY3JpcHRPck1haW5PclRlc3RPclJ1bm5hYmxlc3EAfgAOAAAB+3EAfgAvcQB+ADBxAH4ALXNxAH4ADgAAAeZxAH4AL3EAfgAwcQB+AC1zcQB+AA4AAACrcQB+AC9xAH4AMHEAfgAtc3EAfgAO/////3QAHWdyb292eS5sYW5nLkdyb292eVNoZWxsJHJ1biQwcHQABGNhbGxzcQB+AA4AAAAvcQB+ACRxAH4AJXQAC2RlZmF1bHRDYWxsc3EAfgAOAAAAdHEAfgAocQB+AClxAH4AN3NxAH4ADgAAAJBxAH4AKHEAfgApcQB+ADdzcQB+AA4AAAPndAAqZ3Jvb3Z5LnVpLkNvbnNvbGUkX3J1blNjcmlwdEltcGxfY2xvc3VyZTE2dAAOQ29uc29sZS5ncm9vdnl0AAZkb0NhbGxzcQB+AA7/////cQB+AD1xAH4APnEAfgA/c3EAfgAO/////nQAJHN1bi5yZWZsZWN0Lk5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbHQAHU5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAHaW52b2tlMHNxAH4ADgAAAD5xAH4AQnEAfgBDcQB+AB5zcQB+AA4AAAArdAAoc3VuLnJlZmxlY3QuRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbHQAIURlbGVnYXRpbmdNZXRob2RBY2Nlc3NvckltcGwuamF2YXEAfgAec3EAfgAOAAAB8nQAGGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZHQAC01ldGhvZC5qYXZhcQB+AB5zcQB+AA4AAABidAArb3JnLmNvZGVoYXVzLmdyb292eS5yZWZsZWN0aW9uLkNhY2hlZE1ldGhvZHQAEUNhY2hlZE1ldGhvZC5qYXZhcQB+AB5zcQB+AA4AAAFFdAAWZ3Jvb3Z5LmxhbmcuTWV0YU1ldGhvZHQAD01ldGFNZXRob2QuamF2YXQADmRvTWV0aG9kSW52b2tlc3EAfgAOAAABCHQANm9yZy5jb2RlaGF1cy5ncm9vdnkucnVudGltZS5tZXRhY2xhc3MuQ2xvc3VyZU1ldGFDbGFzc3QAFUNsb3N1cmVNZXRhQ2xhc3MuamF2YXQADGludm9rZU1ldGhvZHNxAH4ADgAABAp0ABlncm9vdnkubGFuZy5NZXRhQ2xhc3NJbXBsdAASTWV0YUNsYXNzSW1wbC5qYXZhcQB+AFZzcQB+AA4AAAGidAATZ3Jvb3Z5LmxhbmcuQ2xvc3VyZXQADENsb3N1cmUuamF2YXEAfgA3c3EAfgAOAAABnHEAfgBbcQB+AFxxAH4AN3NxAH4ADgAAAfNxAH4AW3EAfgBccQB+AC1zcQB+AA4AAALsdAAQamF2YS5sYW5nLlRocmVhZHQAC1RocmVhZC5qYXZhcQB+AC1zcgAmamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUxpc3T8DyUxteyOEAIAAUwABGxpc3RxAH4ACXhyACxqYXZhLnV0aWwuQ29sbGVjdGlvbnMkVW5tb2RpZmlhYmxlQ29sbGVjdGlvbhlCAIDLXvceAgABTAABY3QAFkxqYXZhL3V0aWwvQ29sbGVjdGlvbjt4cHNyABNqYXZhLnV0aWwuQXJyYXlMaXN0eIHSHZnHYZ0DAAFJAARzaXpleHAAAAAAdwQAAAAAeHEAfgBneHBw'
         new ByteArrayInputStream(serializedObjectStr_2_4_X.decodeBase64()).withObjectInputStream {
             def newObj = it.readObject()
             assert newObj instanceof GroovyRuntimeException
@@ -45,4 +44,3 @@ class SerializableCompatibilityTest extends TestSupport {
         }
     }
 }
-

Commit:
323a58a51b52d98e389e154fd99944cf42c6b8d8
Paul King
paulk@asert.com.au
2018-04-03 22:43:18 +1000
fix some serializable incompatible issues (some more)
diff --git a/gradle/pomconfigurer.gradle b/gradle/pomconfigurer.gradle
index 1ecaf40102..de35cdf7a9 100644
--- a/gradle/pomconfigurer.gradle
+++ b/gradle/pomconfigurer.gradle
@@ -558,6 +558,9 @@ project.ext.pomConfigureClosureWithoutTweaks = {
             contributor {
                 name 'Tim Tiemens'
             }
+            contributor {
+                name 'Mike Spille'
+            }
             contributor {
                 name 'Paolo Di Tommaso'
             }
diff --git a/src/main/java/org/codehaus/groovy/GroovyBugError.java b/src/main/java/org/codehaus/groovy/GroovyBugError.java
index 89d855da1a..d234bb515d 100644
--- a/src/main/java/org/codehaus/groovy/GroovyBugError.java
+++ b/src/main/java/org/codehaus/groovy/GroovyBugError.java
@@ -19,15 +19,13 @@
 package org.codehaus.groovy;
 
 /**
- * This class represents an error that is thrown when a bug is 
+ * This class represents an error that is thrown when a bug is
  * recognized inside the runtime. Basically it is thrown when
  * a constraint is not fulfilled that should be fulfilled.
- * 
- * @author Jochen Theodorou
  */
 public class GroovyBugError extends AssertionError {
 
-    private static final long serialVersionUID = 7170193853899664927L;
+    private static final long serialVersionUID = -9165076784700059275L;
     // message string
     private String message;
     // optional exception
@@ -35,74 +33,75 @@ public class GroovyBugError extends AssertionError {
 
     /**
      * constructs a bug error using the given text
+     *
      * @param message the error message text
      */
-    public GroovyBugError( String message ) {
+    public GroovyBugError(String message) {
         this(message, null);
     }
-    
+
     /**
      * Constructs a bug error using the given exception
+     *
      * @param exception cause of this error
      */
-    public GroovyBugError( Exception exception ) {
+    public GroovyBugError(Exception exception) {
         this(null, exception);
     }
-    
+
     /**
      * Constructs a bug error using the given exception and
-     * a text with additional information about the cause 
-     * @param msg additional information about this error
+     * a text with additional information about the cause
+     *
+     * @param msg       additional information about this error
      * @param exception cause of this error
      */
-    public GroovyBugError( String msg, Exception exception ) {
+    public GroovyBugError(String msg, Exception exception) {
         this.exception = exception;
         this.message = msg;
     }
 
     /**
-     * Returns a String representation of this class by calling <code>getMessage()</code>.  
+     * Returns a String representation of this class by calling <code>getMessage()</code>.
+     *
      * @see #getMessage()
      */
     public String toString() {
         return getMessage();
     }
-    
+
     /**
-     * Returns the detail message string of this error. The message 
+     * Returns the detail message string of this error. The message
      * will consist of the bug text prefixed by "BUG! " if there this
      * instance was created using a message. If this error was
-     * constructed without using a bug text the message of the cause 
+     * constructed without using a bug text the message of the cause
      * is used prefixed by "BUG! UNCAUGHT EXCEPTION: "
-     *  
+     *
      * @return the detail message string of this error.
      */
     public String getMessage() {
-        if( message != null )
-        {
-            return "BUG! "+message;
-        }
-        else
-        {
+        if (message != null) {
+            return "BUG! " + message;
+        } else {
             return "BUG! UNCAUGHT EXCEPTION: " + exception.getMessage();
         }
     }
-    
+
     public Throwable getCause() {
         return this.exception;
-    }    
-    
+    }
+
     /**
      * Returns the bug text to describe this error
      */
-    public String getBugText(){
-        if( message != null ){
+    public String getBugText() {
+        if (message != null) {
             return message;
         } else {
             return exception.getMessage();
         }
     }
-    
+
     /**
      * Sets the bug text to describe this error
      */
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
index 372b04da36..a74ed935ba 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
@@ -23,10 +23,9 @@ import org.codehaus.groovy.syntax.ParserException;
 
 /**
  * Thrown when trying to parse the AST
- *
  */
 public class ASTParserException extends ParserException {
-    private static final long serialVersionUID = 2537232761345194260L;
+    private static final long serialVersionUID = 7307319325760515017L;
     private final AST ast;
 
     public ASTParserException(ASTRuntimeException e) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
index 032c24d3ac..11f082b07d 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
@@ -21,10 +21,10 @@ package org.codehaus.groovy.antlr;
 import antlr.collections.AST;
 
 /**
- * @author <a href="mailto:jstrachan@protique.com">James Strachan</a>
+ * Used within the Groovy's AntlrParserPlugin
  */
 public class ASTRuntimeException extends RuntimeException {
-    private static final long serialVersionUID = 3980229202392379560L;
+    private static final long serialVersionUID = 238104771184624613L;
     private final AST ast;
 
     public ASTRuntimeException(AST ast, String message) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
index fc62836f7c..80da2414cf 100644
--- a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
+++ b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
@@ -28,12 +28,9 @@ import java.util.List;
 /**
  * We have an AST subclass so we can track source information.
  * Very odd that ANTLR doesn't do this by default.
- *
- * @author Mike Spille
- * @author Jeremy Rayner <groovy@ross-rayner.com>
  */
 public class GroovySourceAST extends CommonAST implements Comparable, SourceInfo {
-    private static final long serialVersionUID = 2019901428136117486L;
+    private static final long serialVersionUID = 9116765466538981906L;
     private int line;
     private int col;
     private int lineLast;
diff --git a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
index 94dd173f33..8bce286f41 100644
--- a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
+++ b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
@@ -47,7 +47,7 @@ import java.util.Hashtable;
  * Swing application to graphically display the tokens produced by the lexer.
  */
 public class LexerFrame extends JFrame implements ActionListener {
-    private static final long serialVersionUID = 4753761422597441243L;
+    private static final long serialVersionUID = 2715693043143492893L;
     private final JSplitPane jSplitPane1 = new JSplitPane();
     private final JScrollPane jScrollPane1 = new JScrollPane();
     private final JScrollPane jScrollPane2 = new JScrollPane();
diff --git a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
index 9e226ad158..57782098f1 100644
--- a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
+++ b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
@@ -20,74 +20,47 @@ package org.codehaus.groovy.control;
 
 import org.codehaus.groovy.GroovyExceptionInterface;
 
-
-
-
 /**
- *  Thrown when configuration data is invalid.
- *
- *  @author <a href="mailto:cpoirier@dreaming.org">Chris Poirier</a>
+ * Thrown when configuration data is invalid.
  */
-
-public class ConfigurationException extends RuntimeException implements GroovyExceptionInterface
-{
-    private static final long serialVersionUID = -630757959041134069L;
-
-    //---------------------------------------------------------------------------
-  // CONSTRUCTION AND SUCH
+public class ConfigurationException extends RuntimeException implements GroovyExceptionInterface {
+    private static final long serialVersionUID = -3844401402301111613L;
 
     protected Exception cause;   // The phase in which the failures occurred
 
-    
-   /**
-    *  Initializes the exception from a cause exception.
-    */
-    
-    public ConfigurationException( Exception cause ) 
-    {
-        super( cause.getMessage() );
+    /**
+     * Initializes the exception from a cause exception.
+     */
+    public ConfigurationException(Exception cause) {
+        super(cause.getMessage());
         this.cause = cause;
     }
-    
-    
-   /**
-    *  Initializes the exception with just a message.
-    */
-    
-    public ConfigurationException( String message )
-    {
-        super( message );
+
+    /**
+     * Initializes the exception with just a message.
+     */
+    public ConfigurationException(String message) {
+        super(message);
     }
 
-    
-    
-   /**
-    *  Returns the causing exception, if available.
-    */
-    
-    public Throwable getCause()
-    {
+    /**
+     * Returns the causing exception, if available.
+     */
+    public Throwable getCause() {
         return cause;
     }
-    
-    
-   /**
-    *  Its always fatal.
-    */
-    
-    public boolean isFatal()
-    {
+
+    /**
+     * Its always fatal.
+     */
+    public boolean isFatal() {
         return true;
     }
-    
-    
-    
-   /**
-    *  Set fatal is just ignored.
-    */
-    
-    public void setFatal( boolean fatal )
-    {
+
+    /**
+     * Set fatal is just ignored.
+     */
+    public void setFatal(boolean fatal) {
     }
-    
+
 }
diff --git a/src/main/java/org/codehaus/groovy/control/ErrorCollector.java b/src/main/java/org/codehaus/groovy/control/ErrorCollector.java
index d6c97a80ee..67de50a663 100644
--- a/src/main/java/org/codehaus/groovy/control/ErrorCollector.java
+++ b/src/main/java/org/codehaus/groovy/control/ErrorCollector.java
@@ -27,6 +27,7 @@ import org.codehaus.groovy.syntax.CSTNode;
 import org.codehaus.groovy.syntax.SyntaxException;
 
 import java.io.PrintWriter;
+import java.io.Serializable;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
@@ -35,12 +36,10 @@ import java.util.List;
  * A base class for collecting messages and errors during processing.
  * Each CompilationUnit should have an ErrorCollector, and the SourceUnits
  * should share their ErrorCollector with the CompilationUnit.
- *
- * @author <a href="mailto:cpoirier@dreaming.org">Chris Poirier</a>
- * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  */
-public class ErrorCollector {
-    
+public class ErrorCollector implements Serializable {
+
+    private static final long serialVersionUID = 2844774170905056755L;
     /**
      * WarningMessages collected during processing
      */
diff --git a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
index 5e0a6e7523..8d7d14c92d 100644
--- a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
+++ b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
@@ -24,12 +24,12 @@ import java.io.PrintWriter;
 import java.io.Writer;
 
 /**
- * @author Jochen Theodorou
+ * Represents multiple other exceptions
  */
 public class MultipleCompilationErrorsException extends
         CompilationFailedException {
 
-    private static final long serialVersionUID = 2948487149304811836L;
+    private static final long serialVersionUID = 8583586586290252555L;
     protected ErrorCollector collector;
     
     public MultipleCompilationErrorsException(ErrorCollector ec) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java b/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
index f886ccd634..7e5beece80 100644
--- a/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
+++ b/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
@@ -29,7 +29,7 @@ import groovy.lang.GString;
  * @see groovy.lang.GString
  */
 public class GStringImpl extends GString {
-    private static final long serialVersionUID = -6400178815578597715L;
+    private static final long serialVersionUID = 3581289038662723858L;
     private String[] strings;
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
index 21a9e4079d..b4aef73baf 100644
--- a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
+++ b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
@@ -27,12 +27,9 @@ import java.io.Writer;
 
 /**
  * A Writable File.
- *
- * @author John Wilson
- *
  */
 public class WritableFile extends File implements Writable {
-    private static final long serialVersionUID = 1661640530283827325L;
+    private static final long serialVersionUID = 4157767752861425917L;
     private final String encoding;
 
     public WritableFile(final File delegate) {
diff --git a/src/main/java/org/codehaus/groovy/syntax/ReadException.java b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
index af70dd0c13..930b76735e 100644
--- a/src/main/java/org/codehaus/groovy/syntax/ReadException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
@@ -25,9 +25,8 @@ import java.io.IOException;
 /**
  * Encapsulates non-specific i/o exceptions.
  */
-
 public class ReadException extends GroovyException {
-    private static final long serialVersionUID = -6171846198126205359L;
+    private static final long serialVersionUID = 848585058428047961L;
     private final IOException cause;
 
     public ReadException(IOException cause) {
diff --git a/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java b/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
index 53bb453f52..660c87ff2f 100644
--- a/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
@@ -26,7 +26,7 @@ import org.codehaus.groovy.ast.ASTNode;
  */
 public class SyntaxException extends GroovyException {
 
-    private static final long serialVersionUID = 5547021570604495375L;
+    private static final long serialVersionUID = 7447641806794047013L;
     /** Line upon which the error occurred. */
     private final int startLine;
     private final int endLine;

Commit:
3e4b354ccff1453c612a8563ceb2f32378e86601
Paul King
paulk@asert.com.au
2018-04-03 22:43:17 +1000
fix some serializable incompatible issues
diff --git a/gradle/pomconfigurer.gradle b/gradle/pomconfigurer.gradle
index d6ee1df1ef..1ecaf40102 100644
--- a/gradle/pomconfigurer.gradle
+++ b/gradle/pomconfigurer.gradle
@@ -555,6 +555,9 @@ project.ext.pomConfigureClosureWithoutTweaks = {
             contributor {
                 name 'Thibault Kruse'
             }
+            contributor {
+                name 'Tim Tiemens'
+            }
             contributor {
                 name 'Paolo Di Tommaso'
             }
diff --git a/src/main/groovy/groovy/lang/GroovyRuntimeException.java b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
index 00f8f96ba8..de489c3bce 100644
--- a/src/main/groovy/groovy/lang/GroovyRuntimeException.java
+++ b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
@@ -23,12 +23,10 @@ import org.codehaus.groovy.ast.ModuleNode;
 
 /**
  * An exception thrown by the interpreter
- *
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
 public class GroovyRuntimeException extends RuntimeException {
 
-    private static final long serialVersionUID = 3699943230572902549L;
+    private static final long serialVersionUID = -193137033604506378L;
     private ModuleNode module;
     private ASTNode node;
 
diff --git a/src/main/groovy/groovy/lang/MissingMethodException.java b/src/main/groovy/groovy/lang/MissingMethodException.java
index b463c341e0..3dbaf86e6e 100644
--- a/src/main/groovy/groovy/lang/MissingMethodException.java
+++ b/src/main/groovy/groovy/lang/MissingMethodException.java
@@ -30,7 +30,7 @@ import org.codehaus.groovy.runtime.MethodRankHelper;
 public class MissingMethodException extends GroovyRuntimeException {
 
     private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
-    private static final long serialVersionUID = -2423785115382704124L;
+    private static final long serialVersionUID = -6676430495683939401L;
     private final String method;
     private final Class type;
     private final boolean isStatic;
diff --git a/src/main/groovy/groovy/lang/MissingPropertyException.java b/src/main/groovy/groovy/lang/MissingPropertyException.java
index 552031a28d..273d9638b8 100644
--- a/src/main/groovy/groovy/lang/MissingPropertyException.java
+++ b/src/main/groovy/groovy/lang/MissingPropertyException.java
@@ -20,19 +20,16 @@ package groovy.lang;
 
 import org.codehaus.groovy.runtime.MethodRankHelper;
 
-
 /**
  * An exception occurred if a dynamic property dispatch fails with an unknown property.
  * 
  * Note that the Missing*Exception classes were named for consistency and
  * to avoid conflicts with JDK exceptions of the same name.
- * 
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
 public class MissingPropertyException extends GroovyRuntimeException {
 
     public static final Object MPE = new Object();
-    private static final long serialVersionUID = -5493778577329511881L;
+    private static final long serialVersionUID = -1780027060966200019L;
 
     private final String property;
     private final Class type;
diff --git a/src/main/groovy/groovy/lang/Sequence.java b/src/main/groovy/groovy/lang/Sequence.java
index 1cc60791c3..54f27d45c3 100644
--- a/src/main/groovy/groovy/lang/Sequence.java
+++ b/src/main/groovy/groovy/lang/Sequence.java
@@ -31,8 +31,8 @@ import java.util.List;
  */
 public class Sequence extends ArrayList implements GroovyObject {
 
-    private static final long serialVersionUID = 7498505573299850715L;
-    private transient groovy.lang.MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
+    private static final long serialVersionUID = 5697409354934589471L;
+    private transient MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
     private final Class type;
     private int hashCode;
 
diff --git a/src/main/groovy/groovy/lang/SpreadMap.java b/src/main/groovy/groovy/lang/SpreadMap.java
index b9d742b06c..6b3d27b8c4 100644
--- a/src/main/groovy/groovy/lang/SpreadMap.java
+++ b/src/main/groovy/groovy/lang/SpreadMap.java
@@ -27,12 +27,9 @@ import java.util.Map;
 
 /**
  * Helper to turn a list with an even number of elements into a Map.
- * 
- * @author Pilho Kim
- * @author Tim Tiemens
  */
 public class SpreadMap extends HashMap {
-    private static final long serialVersionUID = 2870520857928038334L;
+    private static final long serialVersionUID = 3827653766235954251L;
     private int hashCode;
 
     public SpreadMap(Object[] values) {
diff --git a/src/main/groovy/groovy/util/NodeList.java b/src/main/groovy/groovy/util/NodeList.java
index 2822d9d147..8ce39f4fc6 100644
--- a/src/main/groovy/groovy/util/NodeList.java
+++ b/src/main/groovy/groovy/util/NodeList.java
@@ -33,12 +33,9 @@ import java.util.List;
 /**
  * A List implementation which is returned by queries on a {@link Node}
  * which provides some XPath like helper methods for GPath.
- *
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
- * @author Paul King
  */
 public class NodeList extends ArrayList {
-    private static final long serialVersionUID = 5454686773425258279L;
+    private static final long serialVersionUID = 8307095805417308716L;
 
     static {
         // wrap the standard MetaClass with the delegate
diff --git a/subprojects/groovy-test/src/test/groovy/groovy/lang/SpreadMapTest.java b/subprojects/groovy-test/src/test/groovy/groovy/lang/SpreadMapTest.java
index cb88874870..d7bfae7db8 100644
--- a/subprojects/groovy-test/src/test/groovy/groovy/lang/SpreadMapTest.java
+++ b/subprojects/groovy-test/src/test/groovy/groovy/lang/SpreadMapTest.java
@@ -24,8 +24,6 @@ import java.util.Map;
 
 /**
  * Tests the SpreadMap implementation.
- *
- * @author Tim Tiemens
  */
 public class SpreadMapTest extends GroovyTestCase {
     Map map;

Commit:
249d5731e3e7152208b3a921c959fde604fc69cd
sunlan
sunlan@apache.org
2018-04-03 18:44:56 +0800
Unnecessary zero length array usage
diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index 8409bbf22e..ab8b6557ac 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -137,7 +137,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             return o1.getName().compareTo(o2.getName());
         }
     };
-    private static final MetaMethod[] EMPTY = new MetaMethod[0];
+    private static final MetaMethod[] EMPTY = MetaMethod.EMPTY_ARRAY;
     private static final MetaMethod AMBIGUOUS_LISTENER_METHOD = new DummyMetaMethod();
 
     protected final Class theClass;
@@ -189,7 +189,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             List<MetaMethod> arr = new ArrayList<MetaMethod>();
             arr.addAll(Arrays.asList(metaMethods));
             arr.addAll(Arrays.asList(add));
-            myNewMetaMethods = arr.toArray(new MetaMethod[0]);
+            myNewMetaMethods = arr.toArray(MetaMethod.EMPTY_ARRAY);
             additionalMetaMethods = metaMethods;
         }
         else {

Commit:
fd7aa8115cf25361651a3886cdf493bc794c1489
sunlan
sunlan@apache.org
2018-04-03 17:52:11 +0800
Fix serializable class without 'serialVersionUID'
diff --git a/src/main/groovy/groovy/cli/TypedOption.java b/src/main/groovy/groovy/cli/TypedOption.java
index e669324834..3ac915c35f 100644
--- a/src/main/groovy/groovy/cli/TypedOption.java
+++ b/src/main/groovy/groovy/cli/TypedOption.java
@@ -21,6 +21,8 @@ package groovy.cli;
 import java.util.HashMap;
 
 public class TypedOption<T> extends HashMap<String, T> {
+    private static final long serialVersionUID = 8931624081859777854L;
+
     public T defaultValue() {
         return (T) super.get("defaultValue");
     }
diff --git a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
index ecc8098811..94dd173f33 100644
--- a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
+++ b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
@@ -134,6 +134,8 @@ public class LexerFrame extends JFrame implements ActionListener {
     }
 
     private final Action loadFileAction = new AbstractAction("Open File...") {
+        private static final long serialVersionUID = 4541927184172762704L;
+
         public void actionPerformed(ActionEvent ae) {
             final JFileChooser jfc = new JFileChooser();
             final int response = jfc.showOpenDialog(LexerFrame.this);
@@ -264,6 +266,8 @@ public class LexerFrame extends JFrame implements ActionListener {
     }
 
     private static class HScrollableTextPane extends JTextPane {
+        private static final long serialVersionUID = -8582328309470654441L;
+
         @Override
         public boolean getScrollableTracksViewportWidth() {
             return (getSize().width < getParent().getSize().width);
diff --git a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
index 924a76e776..34c652a200 100644
--- a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
+++ b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
@@ -395,6 +395,8 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
     }
 
     private static class StateMap extends HashMap<Variable, VariableState> {
+        private static final long serialVersionUID = -5881634573411342092L;
+
         @Override
         public VariableState get(final Object key) {
             return super.get(getTarget((Variable) key));
diff --git a/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java b/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
index c5388130c4..8dfa960ec8 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
@@ -21,6 +21,8 @@ package org.codehaus.groovy.reflection;
 import groovy.lang.GroovyRuntimeException;
 
 public class CacheAccessControlException extends GroovyRuntimeException {
+    private static final long serialVersionUID = -5315107566539656474L;
+
     public CacheAccessControlException(String message, Throwable cause) {
         super(message, cause);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
index e602658ffe..cfefb08dc3 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
@@ -32,6 +32,7 @@ import java.util.concurrent.ConcurrentHashMap;
  */
 @ThreadSafe
 public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V>, Serializable {
+    private static final long serialVersionUID = -857220494475488328L;
     private final ConcurrentHashMap<K, V> map;
 
     /**

Commit:
f88d0122525cabf6bdf61ab051533f9983f352f1
sunlan
sunlan@apache.org
2018-04-03 16:18:04 +0800
Test serializable compatibility between 2.4.x and 2.5.x+
diff --git a/src/test/groovy/SerializableCompatibilityTest.groovy b/src/test/groovy/SerializableCompatibilityTest.groovy
new file mode 100644
index 0000000000..c0704c14ce
--- /dev/null
+++ b/src/test/groovy/SerializableCompatibilityTest.groovy
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package groovy
+
+import groovy.bugs.TestSupport
+
+class SerializableCompatibilityTest extends TestSupport {
+    void testSerialize() {
+        def obj = new GroovyRuntimeException('boom')
+        assert obj instanceof GroovyRuntimeException
+        assert obj.message == 'boom'
+
+        def out = new ByteArrayOutputStream();
+        out.withObjectOutputStream{
+            it.writeObject(obj)
+        }
+
+        println out.toByteArray().encodeBase64().toString()
+    }
+
+    void testDeserialize() {
+        // generated by testSerialize
+        def serializedObjectStr_2_4_X = 'rO0ABXNyACJncm9vdnkubGFuZy5Hcm9vdnlSdW50aW1lRXhjZXB0aW9uM1jWw9touJUCAAJMAAZtb2R1bGV0ACRMb3JnL2NvZGVoYXVzL2dyb292eS9hc3QvTW9kdWxlTm9kZTtMAARub2RldAAhTG9yZy9jb2RlaGF1cy9ncm9vdnkvYXN0L0FTVE5vZGU7eHIAGmphdmEubGFuZy5SdW50aW1lRXhjZXB0aW9unl8GRwo0g+UCAAB4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAKdAAEYm9vbXVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAHHNyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAHTAAIZmlsZU5hbWVxAH4AB0wACm1ldGhvZE5hbWVxAH4AB3hw/////nQAKXN1bi5yZWZsZWN0Lk5hdGl2ZUNvbnN0cnVjdG9yQWNjZXNzb3JJbXBsdAAiTmF0aXZlQ29uc3RydWN0b3JBY2Nlc3NvckltcGwuamF2YXQADG5ld0luc3RhbmNlMHNxAH4ADgAAAD5xAH4AEHEAfgARdAALbmV3SW5zdGFuY2VzcQB+AA4AAAAtdAAtc3VuLnJlZmxlY3QuRGVsZWdhdGluZ0NvbnN0cnVjdG9yQWNjZXNzb3JJbXBsdAAmRGVsZWdhdGluZ0NvbnN0cnVjdG9yQWNjZXNzb3JJbXBsLmphdmFxAH4AFHNxAH4ADgAAAad0AB1qYXZhLmxhbmcucmVmbGVjdC5Db25zdHJ1Y3RvcnQAEENvbnN0cnVjdG9yLmphdmFxAH4AFHNxAH4ADgAAAFN0ADBvcmcuY29kZWhhdXMuZ3Jvb3Z5LnJlZmxlY3Rpb24uQ2FjaGVkQ29uc3RydWN0b3J0ABZDYWNoZWRDb25zdHJ1Y3Rvci5qYXZhdAAGaW52b2tlc3EAfgAOAAAAaXQAVG9yZy5jb2RlaGF1cy5ncm9vdnkucnVudGltZS5jYWxsc2l0ZS5Db25zdHJ1Y3RvclNpdGUkQ29uc3RydWN0b3JTaXRlTm9VbndyYXBOb0NvZXJjZXQAFENvbnN0cnVjdG9yU2l0ZS5qYXZhdAAPY2FsbENvbnN0cnVjdG9yc3EAfgAOAAAAO3QAMm9yZy5jb2RlaGF1cy5ncm9vdnkucnVudGltZS5jYWxsc2l0ZS5DYWxsU2l0ZUFycmF5dAASQ2FsbFNpdGVBcnJheS5qYXZhdAAWZGVmYXVsdENhbGxDb25zdHJ1Y3RvcnNxAH4ADgAAAO50ADVvcmcuY29kZWhhdXMuZ3Jvb3Z5LnJ1bnRpbWUuY2FsbHNpdGUuQWJzdHJhY3RDYWxsU2l0ZXQAFUFic3RyYWN0Q2FsbFNpdGUuamF2YXEAfgAic3EAfgAOAAAA+nEAfgAocQB+AClxAH4AInNxAH4ADgAAABh0AA1TZXJpYWxpemVUZXN0dAAUU2VyaWFsaXplVGVzdC5ncm9vdnl0AAR0ZXN0c3EAfgAO/////nQAJHN1bi5yZWZsZWN0Lk5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbHQAHU5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAHaW52b2tlMHNxAH4ADgAAAD5xAH4AMHEAfgAxcQB+AB5zcQB+AA4AAAArdAAoc3VuLnJlZmxlY3QuRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbHQAIURlbGVnYXRpbmdNZXRob2RBY2Nlc3NvckltcGwuamF2YXEAfgAec3EAfgAOAAAB8nQAGGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZHQAC01ldGhvZC5qYXZhcQB+AB5zcQB+AA4AAACwdAAYanVuaXQuZnJhbWV3b3JrLlRlc3RDYXNldAANVGVzdENhc2UuamF2YXQAB3J1blRlc3RzcQB+AA4AAACNcQB+ADtxAH4APHQAB3J1bkJhcmVzcQB+AA4AAAB6dAAcanVuaXQuZnJhbWV3b3JrLlRlc3RSZXN1bHQkMXQAD1Rlc3RSZXN1bHQuamF2YXQAB3Byb3RlY3RzcQB+AA4AAACOdAAaanVuaXQuZnJhbWV3b3JrLlRlc3RSZXN1bHRxAH4AQnQADHJ1blByb3RlY3RlZHNxAH4ADgAAAH1xAH4ARXEAfgBCdAADcnVuc3EAfgAOAAAAgXEAfgA7cQB+ADxxAH4ASHNxAH4ADgAAAPx0ABlqdW5pdC5mcmFtZXdvcmsuVGVzdFN1aXRldAAOVGVzdFN1aXRlLmphdmFxAH4APXNxAH4ADgAAAPdxAH4AS3EAfgBMcQB+AEhzcQB+AA4AAABWdAAtb3JnLmp1bml0LmludGVybmFsLnJ1bm5lcnMuSlVuaXQzOENsYXNzUnVubmVydAAXSlVuaXQzOENsYXNzUnVubmVyLmphdmFxAH4ASHNxAH4ADgAAAIl0ABpvcmcuanVuaXQucnVubmVyLkpVbml0Q29yZXQADkpVbml0Q29yZS5qYXZhcQB+AEhzcQB+AA4AAABEdAAoY29tLmludGVsbGlqLmp1bml0NC5KVW5pdDRJZGVhVGVzdFJ1bm5lcnQAGUpVbml0NElkZWFUZXN0UnVubmVyLmphdmF0ABNzdGFydFJ1bm5lcldpdGhBcmdzc3EAfgAOAAAAL3QAN2NvbS5pbnRlbGxpai5ydC5leGVjdXRpb24uanVuaXQuSWRlYVRlc3RSdW5uZXIkUmVwZWF0ZXJ0ABNJZGVhVGVzdFJ1bm5lci5qYXZhcQB+AFdzcQB+AA4AAADydAAsY29tLmludGVsbGlqLnJ0LmV4ZWN1dGlvbi5qdW5pdC5KVW5pdFN0YXJ0ZXJ0ABFKVW5pdFN0YXJ0ZXIuamF2YXQAFnByZXBhcmVTdHJlYW1zQW5kU3RhcnRzcQB+AA4AAABGcQB+AFxxAH4AXXQABG1haW5zcgAmamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUxpc3T8DyUxteyOEAIAAUwABGxpc3RxAH4ACXhyACxqYXZhLnV0aWwuQ29sbGVjdGlvbnMkVW5tb2RpZmlhYmxlQ29sbGVjdGlvbhlCAIDLXvceAgABTAABY3QAFkxqYXZhL3V0aWwvQ29sbGVjdGlvbjt4cHNyABNqYXZhLnV0aWwuQXJyYXlMaXN0eIHSHZnHYZ0DAAFJAARzaXpleHAAAAAAdwQAAAAAeHEAfgBmeHBw'
+        new ByteArrayInputStream(serializedObjectStr_2_4_X.decodeBase64()).withObjectInputStream {
+            def newObj = it.readObject()
+            assert newObj instanceof GroovyRuntimeException
+            assert newObj.message == 'boom'
+        }
+    }
+}
+

Commit:
95188e497c0d5ff003f1cbf77521f0368f8b4af1
sunlan
sunlan@apache.org
2018-04-03 16:17:55 +0800
Fix serializable class without 'serialVersionUID'
diff --git a/src/main/groovy/groovy/lang/Closure.java b/src/main/groovy/groovy/lang/Closure.java
index 11e261135e..9446186b8c 100644
--- a/src/main/groovy/groovy/lang/Closure.java
+++ b/src/main/groovy/groovy/lang/Closure.java
@@ -197,6 +197,8 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
     public static final int DONE = 1, SKIP = 2;
     private static final Object[] EMPTY_OBJECT_ARRAY = {};
     public static final Closure IDENTITY = new Closure<Object>(null) {
+        private static final long serialVersionUID = 730973623329943963L;
+
         public Object doCall(Object args) {
             return args;
         }
@@ -846,6 +848,8 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
      * inner class instead of the outer!
      */
     private class WritableClosure extends Closure implements Writable {
+        private static final long serialVersionUID = -5749205698681690370L;
+
         public WritableClosure() {
             super(Closure.this);
         }
diff --git a/src/main/groovy/groovy/lang/ClosureException.java b/src/main/groovy/groovy/lang/ClosureException.java
index 12986ad3b7..7a55631000 100644
--- a/src/main/groovy/groovy/lang/ClosureException.java
+++ b/src/main/groovy/groovy/lang/ClosureException.java
@@ -25,6 +25,7 @@ package groovy.lang;
  */
 public class ClosureException extends RuntimeException {
 
+    private static final long serialVersionUID = -945565055750688719L;
     private final Closure closure;
     
     public ClosureException(Closure closure, Throwable cause) {
diff --git a/src/main/groovy/groovy/lang/DeprecationException.java b/src/main/groovy/groovy/lang/DeprecationException.java
index 36ad893f46..8e5d087125 100644
--- a/src/main/groovy/groovy/lang/DeprecationException.java
+++ b/src/main/groovy/groovy/lang/DeprecationException.java
@@ -33,6 +33,8 @@ package groovy.lang;
  */
 public class DeprecationException extends RuntimeException {
 
+    private static final long serialVersionUID = 8828016729085737697L;
+
     public DeprecationException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/GroovyRuntimeException.java b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
index 33eb51ced8..00f8f96ba8 100644
--- a/src/main/groovy/groovy/lang/GroovyRuntimeException.java
+++ b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.ast.ModuleNode;
  */
 public class GroovyRuntimeException extends RuntimeException {
 
+    private static final long serialVersionUID = 3699943230572902549L;
     private ModuleNode module;
     private ASTNode node;
 
diff --git a/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java b/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
index 8227e3f087..b7971d9569 100644
--- a/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
+++ b/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
@@ -28,7 +28,9 @@ import java.lang.reflect.Modifier;
  * @author <a href="mailto:blackdrag@uni.de">Jochen Theodorou</a>
  */
 public class IllegalPropertyAccessException extends MissingPropertyException {
-    
+
+    private static final long serialVersionUID = 8149534204771978786L;
+
     private static String makeMessage(String propertyName, Class clazz, int modifiers, boolean isField) {
         String access = "private";
         if (Modifier.isProtected(modifiers)) access = "protected";
diff --git a/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java b/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
index f5b23f51ef..236f399a9c 100644
--- a/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
+++ b/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.runtime.InvokerHelper;
  */
 public class IncorrectClosureArgumentsException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 4208144749858078754L;
     private final Closure closure;
     private final Object arguments;
     private final Class[] expected;
diff --git a/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java b/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
index c882fda950..484efa3187 100644
--- a/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
+++ b/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
@@ -26,6 +26,7 @@ import java.util.EventObject;
  * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  */
 public class MetaClassRegistryChangeEvent extends EventObject {
+    private static final long serialVersionUID = 1647849176793457976L;
     private final Class clazz;
     private final Object instance;
     private final MetaClass metaClass;
diff --git a/src/main/groovy/groovy/lang/MissingClassException.java b/src/main/groovy/groovy/lang/MissingClassException.java
index ad8e5f5c91..b3579a644a 100644
--- a/src/main/groovy/groovy/lang/MissingClassException.java
+++ b/src/main/groovy/groovy/lang/MissingClassException.java
@@ -31,6 +31,7 @@ import org.codehaus.groovy.ast.ClassNode;
  */
 public class MissingClassException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = -4059735896182191589L;
     private final String type;
 
     public MissingClassException(String type, ASTNode node, String message) {
diff --git a/src/main/groovy/groovy/lang/MissingFieldException.java b/src/main/groovy/groovy/lang/MissingFieldException.java
index 3c17d3965d..4a222f559d 100644
--- a/src/main/groovy/groovy/lang/MissingFieldException.java
+++ b/src/main/groovy/groovy/lang/MissingFieldException.java
@@ -29,6 +29,7 @@ package groovy.lang;
  */
 public class MissingFieldException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = -9209464582858098430L;
     private final String field;
     private final Class type;
 
diff --git a/src/main/groovy/groovy/lang/MissingMethodException.java b/src/main/groovy/groovy/lang/MissingMethodException.java
index ae2eea18ec..b463c341e0 100644
--- a/src/main/groovy/groovy/lang/MissingMethodException.java
+++ b/src/main/groovy/groovy/lang/MissingMethodException.java
@@ -30,6 +30,7 @@ import org.codehaus.groovy.runtime.MethodRankHelper;
 public class MissingMethodException extends GroovyRuntimeException {
 
     private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
+    private static final long serialVersionUID = -2423785115382704124L;
     private final String method;
     private final Class type;
     private final boolean isStatic;
diff --git a/src/main/groovy/groovy/lang/MissingPropertyException.java b/src/main/groovy/groovy/lang/MissingPropertyException.java
index 270f039d83..552031a28d 100644
--- a/src/main/groovy/groovy/lang/MissingPropertyException.java
+++ b/src/main/groovy/groovy/lang/MissingPropertyException.java
@@ -32,6 +32,7 @@ import org.codehaus.groovy.runtime.MethodRankHelper;
 public class MissingPropertyException extends GroovyRuntimeException {
 
     public static final Object MPE = new Object();
+    private static final long serialVersionUID = -5493778577329511881L;
 
     private final String property;
     private final Class type;
diff --git a/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java b/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
index 342a182acd..77231d246d 100644
--- a/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
+++ b/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
@@ -26,6 +26,8 @@ package groovy.lang;
  */
 public class ReadOnlyPropertyException extends MissingPropertyException {
 
+    private static final long serialVersionUID = -1800912081930896077L;
+
     public ReadOnlyPropertyException(final String property, final Class type) {
         super("Cannot set readonly property: " + property + " for class: " + type.getName(), property, type);
     }
diff --git a/src/main/groovy/groovy/lang/Sequence.java b/src/main/groovy/groovy/lang/Sequence.java
index 57e6152ae8..1cc60791c3 100644
--- a/src/main/groovy/groovy/lang/Sequence.java
+++ b/src/main/groovy/groovy/lang/Sequence.java
@@ -31,8 +31,8 @@ import java.util.List;
  */
 public class Sequence extends ArrayList implements GroovyObject {
 
-    private static final long serialVersionUID = 7324025453767284764L;
-    private transient MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
+    private static final long serialVersionUID = 7498505573299850715L;
+    private transient groovy.lang.MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
     private final Class type;
     private int hashCode;
 
diff --git a/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java b/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
index b6de965cd0..f3360d328a 100644
--- a/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
+++ b/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
@@ -19,6 +19,8 @@
 package groovy.lang;
 
 public class SpreadListEvaluatingException extends GroovyRuntimeException {
+    private static final long serialVersionUID = 4565947835333349093L;
+
     public SpreadListEvaluatingException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/SpreadMap.java b/src/main/groovy/groovy/lang/SpreadMap.java
index 0fc6542b44..b9d742b06c 100644
--- a/src/main/groovy/groovy/lang/SpreadMap.java
+++ b/src/main/groovy/groovy/lang/SpreadMap.java
@@ -32,6 +32,7 @@ import java.util.Map;
  * @author Tim Tiemens
  */
 public class SpreadMap extends HashMap {
+    private static final long serialVersionUID = 2870520857928038334L;
     private int hashCode;
 
     public SpreadMap(Object[] values) {
diff --git a/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java b/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
index 408a2239cd..ee9dd21518 100644
--- a/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
+++ b/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
@@ -19,6 +19,8 @@
 package groovy.lang;
 
 public class SpreadMapEvaluatingException extends GroovyRuntimeException {
+    private static final long serialVersionUID = 4347220269418595368L;
+
     public SpreadMapEvaluatingException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/StringWriterIOException.java b/src/main/groovy/groovy/lang/StringWriterIOException.java
index 0372399dae..9fef866a32 100644
--- a/src/main/groovy/groovy/lang/StringWriterIOException.java
+++ b/src/main/groovy/groovy/lang/StringWriterIOException.java
@@ -27,6 +27,8 @@ import java.io.IOException;
  */
 public class StringWriterIOException extends RuntimeException {
 
+    private static final long serialVersionUID = -504499949457372681L;
+
     public StringWriterIOException(IOException e) {
         super(e);
     }
diff --git a/src/main/groovy/groovy/lang/TrampolineClosure.java b/src/main/groovy/groovy/lang/TrampolineClosure.java
index ed68f00445..71f31c8f69 100644
--- a/src/main/groovy/groovy/lang/TrampolineClosure.java
+++ b/src/main/groovy/groovy/lang/TrampolineClosure.java
@@ -30,6 +30,7 @@ package groovy.lang;
  */
 final class TrampolineClosure<V> extends Closure<V> {
 
+    private static final long serialVersionUID = -4096349147398489925L;
     private final Closure<V> original;
 
     TrampolineClosure(final Closure<V> original) {
diff --git a/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java b/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
index e723e0b98f..49032cdccb 100644
--- a/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
+++ b/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
@@ -30,6 +30,8 @@ import java.security.BasicPermission;
  */
 public final class GroovyCodeSourcePermission extends BasicPermission {
 
+    private static final long serialVersionUID = 8014290770546281019L;
+
     public GroovyCodeSourcePermission(String name) {
         super(name);
     }
diff --git a/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java b/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
index aed167a233..622acfd962 100644
--- a/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
+++ b/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
@@ -22,6 +22,8 @@ import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.syntax.SyntaxException;
 
 public class IncorrectTypeHintException extends SyntaxException {
+    private static final long serialVersionUID = 4481159236968540419L;
+
     public IncorrectTypeHintException(final MethodNode mn, final Throwable e, int line, int column) {
         super("Incorrect type hint in @ClosureParams in class "+mn.getDeclaringClass().getName()+" method "+mn.getTypeDescriptor()+" : "+e.getMessage(), e, line, column);
     }
diff --git a/src/main/groovy/groovy/util/NodeList.java b/src/main/groovy/groovy/util/NodeList.java
index e54009c2d4..2822d9d147 100644
--- a/src/main/groovy/groovy/util/NodeList.java
+++ b/src/main/groovy/groovy/util/NodeList.java
@@ -38,6 +38,8 @@ import java.util.List;
  * @author Paul King
  */
 public class NodeList extends ArrayList {
+    private static final long serialVersionUID = 5454686773425258279L;
+
     static {
         // wrap the standard MetaClass with the delegate
         setMetaClass(NodeList.class, GroovySystem.getMetaClassRegistry().getMetaClass(NodeList.class));
diff --git a/src/main/groovy/groovy/util/ObjectGraphBuilder.java b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
index 1004369913..ce031c71e9 100644
--- a/src/main/groovy/groovy/util/ObjectGraphBuilder.java
+++ b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
@@ -78,6 +78,8 @@ public class ObjectGraphBuilder extends FactoryBuilderSupport {
         referenceResolver = new DefaultReferenceResolver();
 
         addPostNodeCompletionDelegate(new Closure(this, this) {
+            private static final long serialVersionUID = 7282290918368141309L;
+
             public void doCall(ObjectGraphBuilder builder, Object parent, Object node) {
                 if (parent == null) {
                     builder.resolveLazyReferences();
diff --git a/src/main/groovy/groovy/util/ObservableList.java b/src/main/groovy/groovy/util/ObservableList.java
index 3d14734c3f..768459689b 100644
--- a/src/main/groovy/groovy/util/ObservableList.java
+++ b/src/main/groovy/groovy/util/ObservableList.java
@@ -475,7 +475,8 @@ public class ObservableList implements List {
     }
 
     public abstract static class ElementEvent extends PropertyChangeEvent {
-        private static final long serialVersionUID = 4985518099021958098L;
+
+        private static final long serialVersionUID = -218253929030274352L;
         private final ChangeType type;
         private final int index;
 
@@ -503,7 +504,7 @@ public class ObservableList implements List {
     }
 
     public static class ElementAddedEvent extends ElementEvent {
-        private static final long serialVersionUID = 6472450701680783544L;
+        private static final long serialVersionUID = -6594847306176480596L;
 
         public ElementAddedEvent(Object source, Object newValue, int index) {
             super(source, null, newValue, index, ChangeType.ADDED);
@@ -519,7 +520,7 @@ public class ObservableList implements List {
     }
 
     public static class ElementRemovedEvent extends ElementEvent {
-        private static final long serialVersionUID = 8480367764843668809L;
+        private static final long serialVersionUID = 9017470261231004168L;
 
         public ElementRemovedEvent(Object source, Object value, int index) {
             super(source, value, null, index, ChangeType.REMOVED);
@@ -527,8 +528,8 @@ public class ObservableList implements List {
     }
 
     public static class ElementClearedEvent extends ElementEvent {
-        private static final long serialVersionUID = -6586012825386453052L;
-        private final List values = new ArrayList();
+        private static final long serialVersionUID = -2754983590419383972L;
+        private List values = new ArrayList();
 
         public ElementClearedEvent(Object source, List values) {
             super(source, ChangeType.oldValue, ChangeType.newValue, 0, ChangeType.CLEARED);
@@ -543,8 +544,8 @@ public class ObservableList implements List {
     }
 
     public static class MultiElementAddedEvent extends ElementEvent {
-        private static final long serialVersionUID = 5142936559765501723L;
-        private final List values = new ArrayList();
+        private static final long serialVersionUID = 443060557109693114L;
+        private List values = new ArrayList();
 
         public MultiElementAddedEvent(Object source, int index, List values) {
             super(source, ChangeType.oldValue, ChangeType.newValue, index, ChangeType.MULTI_ADD);
@@ -559,8 +560,8 @@ public class ObservableList implements List {
     }
 
     public static class MultiElementRemovedEvent extends ElementEvent {
-        private static final long serialVersionUID = 2453305767752911341L;
-        private final List values = new ArrayList();
+        private static final long serialVersionUID = 2590238951081945868L;
+        private List values = new ArrayList();
 
         public MultiElementRemovedEvent(Object source, List values) {
             super(source, ChangeType.oldValue, ChangeType.newValue, 0, ChangeType.MULTI_REMOVE);
diff --git a/src/main/groovy/groovy/util/ObservableMap.java b/src/main/groovy/groovy/util/ObservableMap.java
index ab59388517..2ccec3c81b 100644
--- a/src/main/groovy/groovy/util/ObservableMap.java
+++ b/src/main/groovy/groovy/util/ObservableMap.java
@@ -330,8 +330,8 @@ public class ObservableMap implements Map {
     }
 
     public abstract static class PropertyEvent extends PropertyChangeEvent {
-        private static final long serialVersionUID = -3439518280585144435L;
-        private final ChangeType type;
+        private static final long serialVersionUID = -8328412226044328674L;
+        private ChangeType type;
 
         public PropertyEvent(Object source, String propertyName, Object oldValue, Object newValue, ChangeType type) {
             super(source, propertyName, oldValue, newValue);
@@ -352,7 +352,7 @@ public class ObservableMap implements Map {
     }
 
     public static class PropertyAddedEvent extends PropertyEvent {
-        private static final long serialVersionUID = -7237626384063194253L;
+        private static final long serialVersionUID = -5761685843732329868L;
 
         public PropertyAddedEvent(Object source, String propertyName, Object newValue) {
             super(source, propertyName, null, newValue, ChangeType.ADDED);
@@ -360,7 +360,7 @@ public class ObservableMap implements Map {
     }
 
     public static class PropertyUpdatedEvent extends PropertyEvent {
-        private static final long serialVersionUID = 1322327094566373342L;
+        private static final long serialVersionUID = -1104637722950032690L;
 
         public PropertyUpdatedEvent(Object source, String propertyName, Object oldValue, Object newValue) {
             super(source, propertyName, oldValue, newValue, ChangeType.UPDATED);
@@ -368,7 +368,7 @@ public class ObservableMap implements Map {
     }
 
     public static class PropertyRemovedEvent extends PropertyEvent {
-        private static final long serialVersionUID = 6646851287602912969L;
+        private static final long serialVersionUID = 1882656655856158470L;
 
         public PropertyRemovedEvent(Object source, String propertyName, Object oldValue) {
             super(source, propertyName, oldValue, null, ChangeType.REMOVED);
@@ -376,8 +376,8 @@ public class ObservableMap implements Map {
     }
 
     public static class PropertyClearedEvent extends PropertyEvent {
-        private static final long serialVersionUID = -5066784441907086768L;
-        private final Map values = new HashMap();
+        private static final long serialVersionUID = -1472110679547513634L;
+        private Map values = new HashMap();
 
         public PropertyClearedEvent(Object source, Map values) {
             super(source, ObservableMap.CLEARED_PROPERTY, values, null, ChangeType.CLEARED);
@@ -394,7 +394,7 @@ public class ObservableMap implements Map {
     public static class MultiPropertyEvent extends PropertyEvent {
         public static final String MULTI_PROPERTY = "groovy_util_ObservableMap_MultiPropertyEvent_MULTI";
         private static final PropertyEvent[] EMPTY_PROPERTY_EVENTS = new PropertyEvent[0];
-        private static final long serialVersionUID = 2185997629991653251L;
+        private static final long serialVersionUID = 3925136810810084267L;
 
         private final PropertyEvent[] events;
 
diff --git a/src/main/groovy/groovy/util/ObservableSet.java b/src/main/groovy/groovy/util/ObservableSet.java
index cbd9477f63..7ac3ce9575 100644
--- a/src/main/groovy/groovy/util/ObservableSet.java
+++ b/src/main/groovy/groovy/util/ObservableSet.java
@@ -345,7 +345,7 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public abstract static class ElementEvent extends PropertyChangeEvent {
-        private static final long serialVersionUID = 1636915619671510488L;
+        private static final long serialVersionUID = -7140793925623806823L;
         private final ChangeType type;
 
         public ElementEvent(Object source, Object oldValue, Object newValue, ChangeType type) {
@@ -367,7 +367,7 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class ElementAddedEvent extends ElementEvent {
-        private static final long serialVersionUID = 8487116924204612932L;
+        private static final long serialVersionUID = 4678444473287170956L;
 
         public ElementAddedEvent(Object source, Object newValue) {
             super(source, null, newValue, ChangeType.ADDED);
@@ -375,7 +375,7 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class ElementRemovedEvent extends ElementEvent {
-        private static final long serialVersionUID = 661289692849269910L;
+        private static final long serialVersionUID = 5934658331755545227L;
 
         public ElementRemovedEvent(Object source, Object value) {
             super(source, value, null, ChangeType.REMOVED);
@@ -383,8 +383,8 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class ElementClearedEvent extends ElementEvent {
-        private static final long serialVersionUID = -4285830355690031818L;
-        private final List values = new ArrayList();
+        private static final long serialVersionUID = 6075523774365623231L;
+        private List values = new ArrayList();
 
         public ElementClearedEvent(Object source, List values) {
             super(source, ChangeType.oldValue, ChangeType.newValue, ChangeType.CLEARED);
@@ -399,8 +399,8 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class MultiElementAddedEvent extends ElementEvent {
-        private static final long serialVersionUID = -4307534536004566487L;
-        private final List values = new ArrayList();
+        private static final long serialVersionUID = 575204921472897312L;
+        private List values = new ArrayList();
 
         public MultiElementAddedEvent(Object source, List values) {
             super(source, ChangeType.oldValue, ChangeType.newValue, ChangeType.MULTI_ADD);
@@ -415,8 +415,8 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class MultiElementRemovedEvent extends ElementEvent {
-        private static final long serialVersionUID = -2068802236380651658L;
-        private final List values = new ArrayList();
+        private static final long serialVersionUID = 8894701122065438905L;
+        private List values = new ArrayList();
 
         public MultiElementRemovedEvent(Object source, List values) {
             super(source, ChangeType.oldValue, ChangeType.newValue, ChangeType.MULTI_REMOVE);
diff --git a/src/main/groovy/groovy/util/ResourceException.java b/src/main/groovy/groovy/util/ResourceException.java
index 8b31d7ec89..0f57b5372c 100644
--- a/src/main/groovy/groovy/util/ResourceException.java
+++ b/src/main/groovy/groovy/util/ResourceException.java
@@ -23,6 +23,8 @@ package groovy.util;
  */
 public class ResourceException extends Exception {
 
+    private static final long serialVersionUID = -4640685456255837192L;
+
     /**
      *
      */
diff --git a/src/main/groovy/groovy/util/ScriptException.java b/src/main/groovy/groovy/util/ScriptException.java
index 85ce60fd2b..491b94a85e 100644
--- a/src/main/groovy/groovy/util/ScriptException.java
+++ b/src/main/groovy/groovy/util/ScriptException.java
@@ -23,6 +23,8 @@ package groovy.util;
  */
 public class ScriptException extends Exception {
 
+    private static final long serialVersionUID = 3447547760007143671L;
+
     /**
      *
      */
diff --git a/src/main/java/org/codehaus/groovy/GroovyBugError.java b/src/main/java/org/codehaus/groovy/GroovyBugError.java
index 30ed7de57d..89d855da1a 100644
--- a/src/main/java/org/codehaus/groovy/GroovyBugError.java
+++ b/src/main/java/org/codehaus/groovy/GroovyBugError.java
@@ -26,7 +26,8 @@ package org.codehaus.groovy;
  * @author Jochen Theodorou
  */
 public class GroovyBugError extends AssertionError {
-    
+
+    private static final long serialVersionUID = 7170193853899664927L;
     // message string
     private String message;
     // optional exception
diff --git a/src/main/java/org/codehaus/groovy/GroovyException.java b/src/main/java/org/codehaus/groovy/GroovyException.java
index 582da48782..61826f59ab 100644
--- a/src/main/java/org/codehaus/groovy/GroovyException.java
+++ b/src/main/java/org/codehaus/groovy/GroovyException.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy;
 
 public class GroovyException extends Exception implements GroovyExceptionInterface {
+    private static final long serialVersionUID = -61298636122042408L;
     private boolean fatal = true;
 
     public GroovyException() {
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
index 204674b885..372b04da36 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
@@ -26,6 +26,7 @@ import org.codehaus.groovy.syntax.ParserException;
  *
  */
 public class ASTParserException extends ParserException {
+    private static final long serialVersionUID = 2537232761345194260L;
     private final AST ast;
 
     public ASTParserException(ASTRuntimeException e) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
index aec85d40e0..032c24d3ac 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
@@ -24,6 +24,7 @@ import antlr.collections.AST;
  * @author <a href="mailto:jstrachan@protique.com">James Strachan</a>
  */
 public class ASTRuntimeException extends RuntimeException {
+    private static final long serialVersionUID = 3980229202392379560L;
     private final AST ast;
 
     public ASTRuntimeException(AST ast, String message) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
index d256e73b74..fc62836f7c 100644
--- a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
+++ b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
@@ -33,6 +33,7 @@ import java.util.List;
  * @author Jeremy Rayner <groovy@ross-rayner.com>
  */
 public class GroovySourceAST extends CommonAST implements Comparable, SourceInfo {
+    private static final long serialVersionUID = 2019901428136117486L;
     private int line;
     private int col;
     private int lineLast;
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
index 57a3e154f9..3f6efbb364 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -75,7 +75,10 @@ public class WideningCategories {
 
     private static final List<ClassNode> EMPTY_CLASSNODE_LIST = Collections.emptyList();
 
-    private static final Map<ClassNode, Integer> NUMBER_TYPES_PRECEDENCE = Collections.unmodifiableMap(new HashMap<ClassNode, Integer>() {{
+    private static final Map<ClassNode, Integer> NUMBER_TYPES_PRECEDENCE = Collections.unmodifiableMap(new HashMap<ClassNode, Integer>() {
+        private static final long serialVersionUID = -5178744121420941913L;
+
+        {
         put(ClassHelper.double_TYPE, 0);
         put(ClassHelper.float_TYPE, 1);
         put(ClassHelper.long_TYPE, 2);
diff --git a/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java b/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
index bce34481b3..5c404ecb29 100644
--- a/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
+++ b/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
@@ -25,6 +25,8 @@ package org.codehaus.groovy.classgen;
  */
 public class ClassGeneratorException extends RuntimeException {
 
+    private static final long serialVersionUID = 440899360174632769L;
+
     public ClassGeneratorException(String message) {
         super(message);
     }
diff --git a/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java b/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
index 741b647f21..2930b8c6f3 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
@@ -29,6 +29,7 @@ import groovy.lang.GroovyRuntimeException;
 
 public class CompilationFailedException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 4500269747315896966L;
     protected int phase;   // The phase in which the failures occurred
     protected ProcessingUnit unit;    // The *Unit object this exception wraps
 
diff --git a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
index 3d0658ab3f..9e226ad158 100644
--- a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
+++ b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
@@ -31,8 +31,9 @@ import org.codehaus.groovy.GroovyExceptionInterface;
 
 public class ConfigurationException extends RuntimeException implements GroovyExceptionInterface
 {
-    
-  //---------------------------------------------------------------------------
+    private static final long serialVersionUID = -630757959041134069L;
+
+    //---------------------------------------------------------------------------
   // CONSTRUCTION AND SUCH
 
     protected Exception cause;   // The phase in which the failures occurred
diff --git a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
index e53762e01b..5e0a6e7523 100644
--- a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
+++ b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
@@ -28,7 +28,8 @@ import java.io.Writer;
  */
 public class MultipleCompilationErrorsException extends
         CompilationFailedException {
-    
+
+    private static final long serialVersionUID = 2948487149304811836L;
     protected ErrorCollector collector;
     
     public MultipleCompilationErrorsException(ErrorCollector ec) {
diff --git a/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java b/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
index d0fc5416d7..1edf636658 100644
--- a/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
+++ b/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
@@ -115,6 +115,8 @@ public class SourceAwareCustomizerFactory extends AbstractFactory implements Pos
         Closure<Boolean> extensionValidator = data.extensionValidator;
         if (extensionValidator==null && !extensions.isEmpty()) {
             extensionValidator = new Closure<Boolean>(sourceAwareCustomizer) {
+                private static final long serialVersionUID = 925642730835101872L;
+
                 @Override
                 @SuppressWarnings("unchecked")
                 public Boolean call(final Object arguments) {
@@ -131,6 +133,8 @@ public class SourceAwareCustomizerFactory extends AbstractFactory implements Pos
         Closure<Boolean> basenameValidator = data.basenameValidator;
         if (basenameValidator==null && !basenames.isEmpty()) {
             basenameValidator = new Closure<Boolean>(sourceAwareCustomizer) {
+                private static final long serialVersionUID = 7714937867958607043L;
+
                 @Override
                 @SuppressWarnings("unchecked")
                 public Boolean call(final Object arguments) {
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index e1a55d722f..7c337cf40a 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -60,6 +60,8 @@ public class CachedClass {
     private static ReferenceBundle softBundle = ReferenceBundle.getSoftBundle();
 
     private final LazyReference<CachedField[]> fields = new LazyReference<CachedField[]>(softBundle) {
+        private static final long serialVersionUID = 5450437842165410025L;
+
         public CachedField[] initValue() {
             final Field[] declaredFields = (Field[])
                AccessController.doPrivileged(new PrivilegedAction<Field[]>() {
@@ -76,7 +78,9 @@ public class CachedClass {
         }
     };
 
-    private final LazyReference<CachedConstructor[]> constructors = new LazyReference<CachedConstructor[]>(softBundle) {
+    private LazyReference<CachedConstructor[]> constructors = new LazyReference<CachedConstructor[]>(softBundle) {
+        private static final long serialVersionUID = -5834446523983631635L;
+
         public CachedConstructor[] initValue() {
             final Constructor[] declaredConstructors = (Constructor[])
                AccessController.doPrivileged(new PrivilegedAction/*<Constructor[]>*/() {
@@ -113,6 +117,8 @@ public class CachedClass {
     }
 
     private final LazyReference<CachedMethod[]> methods = new LazyReference<CachedMethod[]>(softBundle) {
+        private static final long serialVersionUID = 6347586066597418308L;
+
         public CachedMethod[] initValue() {
             final Method[] declaredMethods = (Method[])
                AccessController.doPrivileged(new PrivilegedAction/*<Method[]>*/() {
@@ -162,7 +168,9 @@ public class CachedClass {
         }
     };
 
-    private final LazyReference<CachedClass> cachedSuperClass = new LazyReference<CachedClass>(softBundle) {
+    private LazyReference<CachedClass> cachedSuperClass = new LazyReference<CachedClass>(softBundle) {
+        private static final long serialVersionUID = -4663740963306806058L;
+
         public CachedClass initValue() {
             if (!isArray)
               return ReflectionCache.getCachedClass(getTheClass().getSuperclass());
@@ -175,6 +183,8 @@ public class CachedClass {
     };
 
     private final LazyReference<CallSiteClassLoader> callSiteClassLoader = new LazyReference<CallSiteClassLoader>(softBundle) {
+        private static final long serialVersionUID = 4410385968428074090L;
+
         public CallSiteClassLoader initValue() {
             return
                AccessController.doPrivileged(new PrivilegedAction<CallSiteClassLoader>() {
@@ -186,6 +196,8 @@ public class CachedClass {
     };
 
     private final LazyReference<LinkedList<ClassInfo>> hierarchy = new LazyReference<LinkedList<ClassInfo>>(softBundle) {
+        private static final long serialVersionUID = 7166687623678851596L;
+
         public LinkedList<ClassInfo> initValue() {
             Set<ClassInfo> res = new LinkedHashSet<ClassInfo> ();
 
@@ -213,6 +225,8 @@ public class CachedClass {
     public static final CachedClass[] EMPTY_ARRAY = new CachedClass[0];
 
     private final LazyReference<Set<CachedClass>> declaredInterfaces = new LazyReference<Set<CachedClass>> (softBundle) {
+        private static final long serialVersionUID = 2139190436931329873L;
+
         public Set<CachedClass> initValue() {
             Set<CachedClass> res = new HashSet<CachedClass> (0);
 
@@ -225,6 +239,8 @@ public class CachedClass {
     };
 
     private final LazyReference<Set<CachedClass>> interfaces = new LazyReference<Set<CachedClass>> (softBundle) {
+        private static final long serialVersionUID = 4060471819464086940L;
+
         public Set<CachedClass> initValue() {
             Set<CachedClass> res = new HashSet<CachedClass> (0);
 
diff --git a/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java b/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
index c7abeffa7e..1067e4b113 100644
--- a/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
+++ b/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
@@ -441,6 +441,7 @@ public class ClassInfo implements Finalizable {
     }
 
     private static class LazyCachedClassRef extends LazyReference<CachedClass> {
+        private static final long serialVersionUID = -1400274148849287400L;
         private final ClassInfo info;
 
         LazyCachedClassRef(ReferenceBundle bundle, ClassInfo info) {
@@ -454,6 +455,7 @@ public class ClassInfo implements Finalizable {
     }
 
     private static class LazyClassLoaderRef extends LazyReference<ClassLoaderForClassArtifacts> {
+        private static final long serialVersionUID = 1639196133085420609L;
         private final ClassInfo info;
 
         LazyClassLoaderRef(ReferenceBundle bundle, ClassInfo info) {
diff --git a/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java b/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
index 56ad0c16bc..02f893c457 100644
--- a/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
+++ b/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
@@ -54,7 +54,9 @@ class GroovyClassValuePreJava7<T> implements GroovyClassValue<T> {
 
 	private class GroovyClassValuePreJava7Segment extends ManagedConcurrentMap.Segment<Class<?>,T> {
 
-		GroovyClassValuePreJava7Segment(ReferenceBundle bundle, int initialCapacity) {
+        private static final long serialVersionUID = 1289753977947029168L;
+
+        GroovyClassValuePreJava7Segment(ReferenceBundle bundle, int initialCapacity) {
 			super(bundle, initialCapacity);
 		}
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java b/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
index f39ae85272..56ba50afd4 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
@@ -57,9 +57,9 @@ import java.util.List;
  */
 public final class ComposedClosure<V> extends Closure<V> {
 
-    private static final long serialVersionUID = -6410722393739184061L;
-    private final Closure first;
-    private final Closure<V> second;
+    private static final long serialVersionUID = 1290542293376731831L;
+    private Closure first;
+    private Closure<V> second;
 
     public ComposedClosure(Closure first, Closure<V> second) {
         super(first.clone());
diff --git a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
index 393d55eabe..9bc71fa138 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
@@ -31,6 +31,8 @@ import java.util.Map;
  */
 public class ConvertedMap extends ConversionHandler {
 
+    private static final long serialVersionUID = -8131432558241254137L;
+
     /**
      * to create a ConvertedMap object.
      *
diff --git a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
index cabe23003f..1db103760a 100644
--- a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
@@ -46,6 +46,7 @@ import groovy.lang.Closure;
  */
 public final class CurriedClosure<V> extends Closure<V> {
 
+    private static final long serialVersionUID = -1018388175778192754L;
     private final Object[] curriedParams;
     private final int minParamsExpected;
     private int index;
diff --git a/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java b/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
index 278c6a6980..f886ccd634 100644
--- a/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
+++ b/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
@@ -29,8 +29,8 @@ import groovy.lang.GString;
  * @see groovy.lang.GString
  */
 public class GStringImpl extends GString {
-    private static final long serialVersionUID = 3856688359714409314L;
-    private final String[] strings;
+    private static final long serialVersionUID = -6400178815578597715L;
+    private String[] strings;
 
     /**
      * Create a new GString with values and strings.
diff --git a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
index 19f53d2322..05ce6b0f95 100644
--- a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
+++ b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
@@ -47,6 +47,7 @@ public class GroovyCategorySupport {
     private static int categoriesInUse = 0;
 
     public static class CategoryMethodList extends ArrayList<CategoryMethod> {
+        private static final long serialVersionUID = 1569020062006842141L;
         public final int level;
         final CategoryMethodList previous;
         final AtomicInteger usage;
@@ -72,6 +73,7 @@ public class GroovyCategorySupport {
     public static class ThreadCategoryInfo extends HashMap<String, CategoryMethodList>{
 
         private static final Object LOCK = new Object();
+        private static final long serialVersionUID = 2609120843123833410L;
 
         int level;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
index 2f03126d46..da85b6b8a5 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
@@ -29,6 +29,8 @@ import java.lang.reflect.InvocationTargetException;
  */
 public class InvokerInvocationException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 5870532233180451709L;
+
     public InvokerInvocationException(InvocationTargetException e) {
         super(e.getTargetException());
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
index 24d74f6c0f..7f098d7013 100644
--- a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
@@ -32,6 +32,7 @@ import java.util.List;
  */
 public class IteratorClosureAdapter<T> extends Closure {
 
+    private static final long serialVersionUID = -3193812539363103534L;
     private final List<T> list = new ArrayList<T>();
     private MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
     
diff --git a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
index 60f57d80a8..938347b858 100644
--- a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
@@ -35,7 +35,7 @@ public class MethodClosure extends Closure {
     public static final String NEW = "new";
     public static final String ANY_INSTANCE_METHOD_EXISTS = "anyInstanceMethodExists";
 
-    private static final long serialVersionUID = -7600155510871887910L;
+    private static final long serialVersionUID = 5316055624606528584L;
     public static boolean ALLOW_RESOLVE = false;
 
     private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
diff --git a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
index 23858f6328..1874fc9c50 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
@@ -934,7 +934,7 @@ public class ProxyGeneratorAdapter extends ClassVisitor implements Opcodes {
 
             if (loadedClass != null) return loadedClass;
 
-            // Not loaded, try to load it 
+            // Not loaded, try to load it
             if (internalClassLoaders != null) {
                 for (ClassLoader i : internalClassLoaders) {
                     try {
@@ -953,7 +953,7 @@ public class ProxyGeneratorAdapter extends ClassVisitor implements Opcodes {
         }
     }
 
-    private static class ReturnValueWrappingClosure<V> extends Closure<V> {
+    private static class ReturnValueWrappingClosure<V> extends Closure<V>{
         private static final long serialVersionUID = 1313135457715304501L;
         private final V value;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
index 4d3eeb6760..a47adab505 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
@@ -142,6 +142,8 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
         final long[] size = {0L};
 
         eachFileRecurse(self, FileType.FILES, new Closure<Void>(null) {
+            private static final long serialVersionUID = 7688764529326404277L;
+
             public void doCall(Object[] args) {
                 size[0] += ((File) args[0]).length();
             }
diff --git a/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java b/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java
index 7d276031d5..ed180793ce 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java
@@ -26,9 +26,9 @@ import groovy.lang.Script;
  */
 public class ScriptReference extends Reference {
 
-    private static final long serialVersionUID = 9011836991962996884L;
-    private final Script script;
-    private final String variable;
+    private static final long serialVersionUID = -2914281513576690336L;
+    private Script script;
+    private String variable;
 
     public ScriptReference(Script script, String variable) {
         this.script = script;
diff --git a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
index ec2f481b44..21a9e4079d 100644
--- a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
+++ b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
@@ -32,6 +32,7 @@ import java.io.Writer;
  *
  */
 public class WritableFile extends File implements Writable {
+    private static final long serialVersionUID = 1661640530283827325L;
     private final String encoding;
 
     public WritableFile(final File delegate) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
index 68fe42d402..2d501b3a94 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
@@ -166,7 +166,9 @@ public class ConcurrentReaderHashMap
   */
 
   /** A Serializable class for barrier lock **/
-  protected static class BarrierLock implements java.io.Serializable { }
+  protected static class BarrierLock implements java.io.Serializable {
+      private static final long serialVersionUID = -5403150101810674636L;
+  }
 
   /**
    * Lock used only for its memory effects.
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
index a9f5538403..4f0cc4cb96 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
@@ -37,6 +37,7 @@ import java.lang.reflect.Modifier;
  */
 public class MethodSelectionException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 6260193948973669540L;
     private final String methodName;
     private final FastArray methods;
     private final Class[] arguments;
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
index 28437d28c6..80836c78e4 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
@@ -22,6 +22,8 @@ import groovy.lang.MissingMethodException;
 
 public class MissingMethodExceptionNoStack extends MissingMethodException {
 
+    private static final long serialVersionUID = 7075950754138801519L;
+
     public MissingMethodExceptionNoStack(String method, Class type, Object[] arguments) {
         this(method,type,arguments,false);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
index f7f6b5e5e5..557176dcb6 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
@@ -24,8 +24,8 @@ package org.codehaus.groovy.runtime.metaclass;
  * invokeMethod for GroovyObject implementing classes.
  */
 public class MissingMethodExecutionFailed extends MissingMethodExceptionNoStack {
-    private static final long serialVersionUID = -6384783636894179156L;
-    private final Throwable cause;
+    private static final long serialVersionUID = -6551412223364004284L;
+    private Throwable cause;
     public MissingMethodExecutionFailed(String method, Class type, Object[] arguments, boolean isStatic, Throwable cause) {
         super(method, type, arguments, isStatic);
         this.cause = cause;
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
index 0b2c33f8dc..a177eaba7d 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
@@ -22,6 +22,8 @@ import groovy.lang.MissingPropertyException;
 
 public class MissingPropertyExceptionNoStack extends MissingPropertyException {
 
+    private static final long serialVersionUID = -7734212543734003079L;
+
     public MissingPropertyExceptionNoStack(String propertyName, Class theClass) {
         super(propertyName, theClass);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
index d6ef9de74c..b79f0d75ba 100644
--- a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
+++ b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
@@ -24,6 +24,8 @@ package org.codehaus.groovy.runtime.powerassert;
  * @author Peter Niederwieser
  */
 public class PowerAssertionError extends java.lang.AssertionError {
+    private static final long serialVersionUID = 186840762256433109L;
+
     public PowerAssertionError(String msg) {
         super(msg);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java b/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
index 431dd08c0f..b7a6bd8ea2 100644
--- a/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
@@ -27,6 +27,8 @@ import org.codehaus.groovy.control.SourceUnit;
  * @author Peter Niederwieser
  */
 public class SourceTextNotAvailableException extends RuntimeException {
+    private static final long serialVersionUID = -3815868502019514479L;
+
     // only accepts AssertStatementS so that better error messages can be produced
     public SourceTextNotAvailableException(AssertStatement stat, SourceUnit unit, String msg) {
         super(String.format("%s for %s at (%d,%d)-(%d,%d) in %s",
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
index e2fc66a6c9..f9cace8baf 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
@@ -20,6 +20,8 @@ package org.codehaus.groovy.runtime.typehandling;
 
 public class GroovyCastException extends ClassCastException {
 
+    private static final long serialVersionUID = 6859089155641797356L;
+
     /**
      * @param objectToCast object we tried to cast
      * @param classToCastTo class we tried to cast to
diff --git a/src/main/java/org/codehaus/groovy/syntax/ParserException.java b/src/main/java/org/codehaus/groovy/syntax/ParserException.java
index 2215429d3e..beedb1c888 100644
--- a/src/main/java/org/codehaus/groovy/syntax/ParserException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/ParserException.java
@@ -19,6 +19,8 @@
 package org.codehaus.groovy.syntax;
 
 public class ParserException extends TokenException {
+    private static final long serialVersionUID = -3772086239731735693L;
+
     public ParserException(String message, Token token) {
         super(message, token);
     }
diff --git a/src/main/java/org/codehaus/groovy/syntax/ReadException.java b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
index 6885c24bbb..af70dd0c13 100644
--- a/src/main/java/org/codehaus/groovy/syntax/ReadException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
@@ -27,6 +27,7 @@ import java.io.IOException;
  */
 
 public class ReadException extends GroovyException {
+    private static final long serialVersionUID = -6171846198126205359L;
     private final IOException cause;
 
     public ReadException(IOException cause) {
diff --git a/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java b/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
index c47bc26710..ce804e1381 100644
--- a/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
@@ -29,6 +29,8 @@ import org.codehaus.groovy.ast.ASTNode;
  */
 public class RuntimeParserException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = -6612860527133856587L;
+
     public RuntimeParserException(String message, ASTNode node) {
         super(message + "\n", node);
     }
diff --git a/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java b/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
index 91df343ed7..53bb453f52 100644
--- a/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
@@ -26,7 +26,7 @@ import org.codehaus.groovy.ast.ASTNode;
  */
 public class SyntaxException extends GroovyException {
 
-    private static final long serialVersionUID = -6086822614839477581L;
+    private static final long serialVersionUID = 5547021570604495375L;
     /** Line upon which the error occurred. */
     private final int startLine;
     private final int endLine;
diff --git a/src/main/java/org/codehaus/groovy/syntax/TokenException.java b/src/main/java/org/codehaus/groovy/syntax/TokenException.java
index 5c9f2755d0..fea3ec2f04 100644
--- a/src/main/java/org/codehaus/groovy/syntax/TokenException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/TokenException.java
@@ -19,6 +19,8 @@
 package org.codehaus.groovy.syntax;
 
 public class TokenException extends SyntaxException {
+    private static final long serialVersionUID = 6850594285972085144L;
+
     public TokenException(String message, Token token) {
         super(
                 (token == null)
diff --git a/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java b/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
index 32c90a50d0..3f799fa929 100644
--- a/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy.syntax;
 
 public class TokenMismatchException extends TokenException {
+    private static final long serialVersionUID = -6321206176010272124L;
     private final Token unexpectedToken;
     private final int expectedType;
 
diff --git a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
index 74f9fffd40..4d5117d59a 100644
--- a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
+++ b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
@@ -24,7 +24,9 @@ import java.util.Set;
 import java.util.TreeSet;
 
 public class StringSetMap extends LinkedHashMap<String,Set<String>> {
-    
+
+    private static final long serialVersionUID = 4230491822783819152L;
+
     public StringSetMap() {
         super();
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
index 90c956ce82..fbb3fe3b94 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
@@ -56,7 +56,10 @@ import java.util.Map;
 public class StaticCompilationTransformer extends ClassCodeExpressionTransformer {
 
     protected static final ClassNode BYTECODE_ADAPTER_CLASS = ClassHelper.make(ScriptBytecodeAdapter.class);
-    protected static final Map<Integer, MethodNode> BYTECODE_BINARY_ADAPTERS = Collections.unmodifiableMap(new HashMap<Integer, MethodNode>() {{
+    protected static final Map<Integer, MethodNode> BYTECODE_BINARY_ADAPTERS = Collections.unmodifiableMap(new HashMap<Integer, MethodNode>() {
+        private static final long serialVersionUID = -9117028399464862605L;
+
+        {
         put(Types.COMPARE_EQUAL, BYTECODE_ADAPTER_CLASS.getMethods("compareEqual").get(0));
         put(Types.COMPARE_GREATER_THAN, BYTECODE_ADAPTER_CLASS.getMethods("compareGreaterThan").get(0));
         put(Types.COMPARE_GREATER_THAN_EQUAL, BYTECODE_ADAPTER_CLASS.getMethods("compareGreaterThanEqual").get(0));
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
index 8e2fad76ca..d6cae87668 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
@@ -436,6 +436,7 @@ public class AbstractTypeCheckingExtension extends TypeCheckingExtension {
     }
 
     private static class TypeCheckingScope extends LinkedHashMap<String, Object> {
+        private static final long serialVersionUID = 7607331333917615144L;
         private final AbstractTypeCheckingExtension.TypeCheckingScope parent;
 
         private TypeCheckingScope(final AbstractTypeCheckingExtension.TypeCheckingScope parentScope) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
index 52ccdf19b6..6254b0a69a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
@@ -65,7 +65,10 @@ public class GroovyTypeCheckingExtensionSupport extends AbstractTypeCheckingExte
 
     // method name to DSL name
     private static final Map<String, String> METHOD_ALIASES = Collections.unmodifiableMap(
-            new HashMap<String, String>() {{
+            new HashMap<String, String>() {
+                private static final long serialVersionUID = 8938707932245818749L;
+
+                {
                 put("onMethodSelection", "onMethodSelection");
                 put("afterMethodCall", "afterMethodCall");
                 put("beforeMethodCall", "beforeMethodCall");
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 571e6ac637..afb91d1a8b 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -165,7 +165,10 @@ public abstract class StaticTypeCheckingSupport {
     protected static final ClassNode ArrayList_TYPE = makeWithoutCaching(ArrayList.class);
     protected static final ExtensionMethodCache EXTENSION_METHOD_CACHE = new ExtensionMethodCache();
     protected static final Map<ClassNode, Integer> NUMBER_TYPES = Collections.unmodifiableMap(
-            new HashMap<ClassNode, Integer>() {{
+            new HashMap<ClassNode, Integer>() {
+                private static final long serialVersionUID = 8841951852732042766L;
+
+                {
                 put(byte_TYPE, 0);
                 put(Byte_TYPE, 0);
                 put(short_TYPE, 1);
@@ -181,7 +184,10 @@ public abstract class StaticTypeCheckingSupport {
             }});
 
     protected static final Map<String, Integer> NUMBER_OPS = Collections.unmodifiableMap(
-            new HashMap<String, Integer>() {{
+            new HashMap<String, Integer>() {
+                private static final long serialVersionUID = 6951856193525808411L;
+
+                {
                 put("plus", PLUS);
                 put("minus", MINUS);
                 put("multiply", MULTIPLY);
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
index d60396b0cc..349c9306ba 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
@@ -50,6 +50,8 @@ public abstract class AbstractConcurrentMap<K, V> extends AbstractConcurrentMapB
 
     public abstract static class Segment<K,V> extends AbstractConcurrentMapBase.Segment {
 
+        private static final long serialVersionUID = 5192533863182570468L;
+
         protected Segment(int initialCapacity) {
             super(initialCapacity);
         }
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
index b21c0af71f..2cfc82a99f 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
@@ -154,6 +154,7 @@ public abstract class AbstractConcurrentMapBase {
     }
 
     public static class Segment extends LockableObject {
+        private static final long serialVersionUID = -1071886855389945760L;
         volatile int count;
 
         int threshold;
diff --git a/src/main/java/org/codehaus/groovy/util/LazyReference.java b/src/main/java/org/codehaus/groovy/util/LazyReference.java
index fc348039e0..54e0ab2e78 100644
--- a/src/main/java/org/codehaus/groovy/util/LazyReference.java
+++ b/src/main/java/org/codehaus/groovy/util/LazyReference.java
@@ -24,6 +24,7 @@ package org.codehaus.groovy.util;
 public abstract class LazyReference<T> extends LockableObject {
     private static final ManagedReference INIT = new ManagedReference(ReferenceType.HARD,null,null){};
     private static final ManagedReference NULL_REFERENCE = new ManagedReference(ReferenceType.HARD,null,null){};
+    private static final long serialVersionUID = 3160238516132794621L;
     private ManagedReference<T> reference = INIT;
     private final ReferenceBundle bundle;
     
diff --git a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
index 209de66c2a..da06275840 100644
--- a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
@@ -33,6 +33,7 @@ public class ManagedConcurrentMap<K,V> extends AbstractConcurrentMap<K,V> {
     }
 
     public static class Segment<K,V> extends AbstractConcurrentMap.Segment<K,V>{
+        private static final long serialVersionUID = -2157582627873688747L;
         protected final ReferenceBundle bundle;
         public Segment(ReferenceBundle bundle, int cap) {
             super(cap);

Commit:
23e28fc0d1cf09d0fd399dcffc3ca61793c9a295
sunlan
sunlan@apache.org
2018-04-03 13:36:27 +0800
Revert "Add the missing `serialVersionUID`"
diff --git a/src/main/groovy/groovy/cli/TypedOption.java b/src/main/groovy/groovy/cli/TypedOption.java
index 3ac915c35f..e669324834 100644
--- a/src/main/groovy/groovy/cli/TypedOption.java
+++ b/src/main/groovy/groovy/cli/TypedOption.java
@@ -21,8 +21,6 @@ package groovy.cli;
 import java.util.HashMap;
 
 public class TypedOption<T> extends HashMap<String, T> {
-    private static final long serialVersionUID = 8931624081859777854L;
-
     public T defaultValue() {
         return (T) super.get("defaultValue");
     }
diff --git a/src/main/groovy/groovy/lang/Closure.java b/src/main/groovy/groovy/lang/Closure.java
index 9446186b8c..11e261135e 100644
--- a/src/main/groovy/groovy/lang/Closure.java
+++ b/src/main/groovy/groovy/lang/Closure.java
@@ -197,8 +197,6 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
     public static final int DONE = 1, SKIP = 2;
     private static final Object[] EMPTY_OBJECT_ARRAY = {};
     public static final Closure IDENTITY = new Closure<Object>(null) {
-        private static final long serialVersionUID = 730973623329943963L;
-
         public Object doCall(Object args) {
             return args;
         }
@@ -848,8 +846,6 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
      * inner class instead of the outer!
      */
     private class WritableClosure extends Closure implements Writable {
-        private static final long serialVersionUID = -5749205698681690370L;
-
         public WritableClosure() {
             super(Closure.this);
         }
diff --git a/src/main/groovy/groovy/lang/ClosureException.java b/src/main/groovy/groovy/lang/ClosureException.java
index 7a55631000..12986ad3b7 100644
--- a/src/main/groovy/groovy/lang/ClosureException.java
+++ b/src/main/groovy/groovy/lang/ClosureException.java
@@ -25,7 +25,6 @@ package groovy.lang;
  */
 public class ClosureException extends RuntimeException {
 
-    private static final long serialVersionUID = -945565055750688719L;
     private final Closure closure;
     
     public ClosureException(Closure closure, Throwable cause) {
diff --git a/src/main/groovy/groovy/lang/DeprecationException.java b/src/main/groovy/groovy/lang/DeprecationException.java
index 8e5d087125..36ad893f46 100644
--- a/src/main/groovy/groovy/lang/DeprecationException.java
+++ b/src/main/groovy/groovy/lang/DeprecationException.java
@@ -33,8 +33,6 @@ package groovy.lang;
  */
 public class DeprecationException extends RuntimeException {
 
-    private static final long serialVersionUID = 8828016729085737697L;
-
     public DeprecationException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/GroovyRuntimeException.java b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
index 00f8f96ba8..33eb51ced8 100644
--- a/src/main/groovy/groovy/lang/GroovyRuntimeException.java
+++ b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
@@ -28,7 +28,6 @@ import org.codehaus.groovy.ast.ModuleNode;
  */
 public class GroovyRuntimeException extends RuntimeException {
 
-    private static final long serialVersionUID = 3699943230572902549L;
     private ModuleNode module;
     private ASTNode node;
 
diff --git a/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java b/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
index b7971d9569..8227e3f087 100644
--- a/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
+++ b/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
@@ -28,9 +28,7 @@ import java.lang.reflect.Modifier;
  * @author <a href="mailto:blackdrag@uni.de">Jochen Theodorou</a>
  */
 public class IllegalPropertyAccessException extends MissingPropertyException {
-
-    private static final long serialVersionUID = 8149534204771978786L;
-
+    
     private static String makeMessage(String propertyName, Class clazz, int modifiers, boolean isField) {
         String access = "private";
         if (Modifier.isProtected(modifiers)) access = "protected";
diff --git a/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java b/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
index 236f399a9c..f5b23f51ef 100644
--- a/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
+++ b/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
@@ -28,7 +28,6 @@ import org.codehaus.groovy.runtime.InvokerHelper;
  */
 public class IncorrectClosureArgumentsException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = 4208144749858078754L;
     private final Closure closure;
     private final Object arguments;
     private final Class[] expected;
diff --git a/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java b/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
index 484efa3187..c882fda950 100644
--- a/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
+++ b/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
@@ -26,7 +26,6 @@ import java.util.EventObject;
  * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  */
 public class MetaClassRegistryChangeEvent extends EventObject {
-    private static final long serialVersionUID = 1647849176793457976L;
     private final Class clazz;
     private final Object instance;
     private final MetaClass metaClass;
diff --git a/src/main/groovy/groovy/lang/MissingClassException.java b/src/main/groovy/groovy/lang/MissingClassException.java
index b3579a644a..ad8e5f5c91 100644
--- a/src/main/groovy/groovy/lang/MissingClassException.java
+++ b/src/main/groovy/groovy/lang/MissingClassException.java
@@ -31,7 +31,6 @@ import org.codehaus.groovy.ast.ClassNode;
  */
 public class MissingClassException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = -4059735896182191589L;
     private final String type;
 
     public MissingClassException(String type, ASTNode node, String message) {
diff --git a/src/main/groovy/groovy/lang/MissingFieldException.java b/src/main/groovy/groovy/lang/MissingFieldException.java
index 4a222f559d..3c17d3965d 100644
--- a/src/main/groovy/groovy/lang/MissingFieldException.java
+++ b/src/main/groovy/groovy/lang/MissingFieldException.java
@@ -29,7 +29,6 @@ package groovy.lang;
  */
 public class MissingFieldException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = -9209464582858098430L;
     private final String field;
     private final Class type;
 
diff --git a/src/main/groovy/groovy/lang/MissingMethodException.java b/src/main/groovy/groovy/lang/MissingMethodException.java
index b463c341e0..ae2eea18ec 100644
--- a/src/main/groovy/groovy/lang/MissingMethodException.java
+++ b/src/main/groovy/groovy/lang/MissingMethodException.java
@@ -30,7 +30,6 @@ import org.codehaus.groovy.runtime.MethodRankHelper;
 public class MissingMethodException extends GroovyRuntimeException {
 
     private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
-    private static final long serialVersionUID = -2423785115382704124L;
     private final String method;
     private final Class type;
     private final boolean isStatic;
diff --git a/src/main/groovy/groovy/lang/MissingPropertyException.java b/src/main/groovy/groovy/lang/MissingPropertyException.java
index 552031a28d..270f039d83 100644
--- a/src/main/groovy/groovy/lang/MissingPropertyException.java
+++ b/src/main/groovy/groovy/lang/MissingPropertyException.java
@@ -32,7 +32,6 @@ import org.codehaus.groovy.runtime.MethodRankHelper;
 public class MissingPropertyException extends GroovyRuntimeException {
 
     public static final Object MPE = new Object();
-    private static final long serialVersionUID = -5493778577329511881L;
 
     private final String property;
     private final Class type;
diff --git a/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java b/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
index 77231d246d..342a182acd 100644
--- a/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
+++ b/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
@@ -26,8 +26,6 @@ package groovy.lang;
  */
 public class ReadOnlyPropertyException extends MissingPropertyException {
 
-    private static final long serialVersionUID = -1800912081930896077L;
-
     public ReadOnlyPropertyException(final String property, final Class type) {
         super("Cannot set readonly property: " + property + " for class: " + type.getName(), property, type);
     }
diff --git a/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java b/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
index f3360d328a..b6de965cd0 100644
--- a/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
+++ b/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
@@ -19,8 +19,6 @@
 package groovy.lang;
 
 public class SpreadListEvaluatingException extends GroovyRuntimeException {
-    private static final long serialVersionUID = 4565947835333349093L;
-
     public SpreadListEvaluatingException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/SpreadMap.java b/src/main/groovy/groovy/lang/SpreadMap.java
index b9d742b06c..0fc6542b44 100644
--- a/src/main/groovy/groovy/lang/SpreadMap.java
+++ b/src/main/groovy/groovy/lang/SpreadMap.java
@@ -32,7 +32,6 @@ import java.util.Map;
  * @author Tim Tiemens
  */
 public class SpreadMap extends HashMap {
-    private static final long serialVersionUID = 2870520857928038334L;
     private int hashCode;
 
     public SpreadMap(Object[] values) {
diff --git a/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java b/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
index ee9dd21518..408a2239cd 100644
--- a/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
+++ b/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
@@ -19,8 +19,6 @@
 package groovy.lang;
 
 public class SpreadMapEvaluatingException extends GroovyRuntimeException {
-    private static final long serialVersionUID = 4347220269418595368L;
-
     public SpreadMapEvaluatingException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/StringWriterIOException.java b/src/main/groovy/groovy/lang/StringWriterIOException.java
index 9fef866a32..0372399dae 100644
--- a/src/main/groovy/groovy/lang/StringWriterIOException.java
+++ b/src/main/groovy/groovy/lang/StringWriterIOException.java
@@ -27,8 +27,6 @@ import java.io.IOException;
  */
 public class StringWriterIOException extends RuntimeException {
 
-    private static final long serialVersionUID = -504499949457372681L;
-
     public StringWriterIOException(IOException e) {
         super(e);
     }
diff --git a/src/main/groovy/groovy/lang/TrampolineClosure.java b/src/main/groovy/groovy/lang/TrampolineClosure.java
index 71f31c8f69..ed68f00445 100644
--- a/src/main/groovy/groovy/lang/TrampolineClosure.java
+++ b/src/main/groovy/groovy/lang/TrampolineClosure.java
@@ -30,7 +30,6 @@ package groovy.lang;
  */
 final class TrampolineClosure<V> extends Closure<V> {
 
-    private static final long serialVersionUID = -4096349147398489925L;
     private final Closure<V> original;
 
     TrampolineClosure(final Closure<V> original) {
diff --git a/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java b/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
index 49032cdccb..e723e0b98f 100644
--- a/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
+++ b/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
@@ -30,8 +30,6 @@ import java.security.BasicPermission;
  */
 public final class GroovyCodeSourcePermission extends BasicPermission {
 
-    private static final long serialVersionUID = 8014290770546281019L;
-
     public GroovyCodeSourcePermission(String name) {
         super(name);
     }
diff --git a/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java b/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
index 622acfd962..aed167a233 100644
--- a/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
+++ b/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
@@ -22,8 +22,6 @@ import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.syntax.SyntaxException;
 
 public class IncorrectTypeHintException extends SyntaxException {
-    private static final long serialVersionUID = 4481159236968540419L;
-
     public IncorrectTypeHintException(final MethodNode mn, final Throwable e, int line, int column) {
         super("Incorrect type hint in @ClosureParams in class "+mn.getDeclaringClass().getName()+" method "+mn.getTypeDescriptor()+" : "+e.getMessage(), e, line, column);
     }
diff --git a/src/main/groovy/groovy/util/NodeList.java b/src/main/groovy/groovy/util/NodeList.java
index 2822d9d147..e54009c2d4 100644
--- a/src/main/groovy/groovy/util/NodeList.java
+++ b/src/main/groovy/groovy/util/NodeList.java
@@ -38,8 +38,6 @@ import java.util.List;
  * @author Paul King
  */
 public class NodeList extends ArrayList {
-    private static final long serialVersionUID = 5454686773425258279L;
-
     static {
         // wrap the standard MetaClass with the delegate
         setMetaClass(NodeList.class, GroovySystem.getMetaClassRegistry().getMetaClass(NodeList.class));
diff --git a/src/main/groovy/groovy/util/ObjectGraphBuilder.java b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
index ce031c71e9..1004369913 100644
--- a/src/main/groovy/groovy/util/ObjectGraphBuilder.java
+++ b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
@@ -78,8 +78,6 @@ public class ObjectGraphBuilder extends FactoryBuilderSupport {
         referenceResolver = new DefaultReferenceResolver();
 
         addPostNodeCompletionDelegate(new Closure(this, this) {
-            private static final long serialVersionUID = 7282290918368141309L;
-
             public void doCall(ObjectGraphBuilder builder, Object parent, Object node) {
                 if (parent == null) {
                     builder.resolveLazyReferences();
diff --git a/src/main/groovy/groovy/util/ResourceException.java b/src/main/groovy/groovy/util/ResourceException.java
index 0f57b5372c..8b31d7ec89 100644
--- a/src/main/groovy/groovy/util/ResourceException.java
+++ b/src/main/groovy/groovy/util/ResourceException.java
@@ -23,8 +23,6 @@ package groovy.util;
  */
 public class ResourceException extends Exception {
 
-    private static final long serialVersionUID = -4640685456255837192L;
-
     /**
      *
      */
diff --git a/src/main/groovy/groovy/util/ScriptException.java b/src/main/groovy/groovy/util/ScriptException.java
index 491b94a85e..85ce60fd2b 100644
--- a/src/main/groovy/groovy/util/ScriptException.java
+++ b/src/main/groovy/groovy/util/ScriptException.java
@@ -23,8 +23,6 @@ package groovy.util;
  */
 public class ScriptException extends Exception {
 
-    private static final long serialVersionUID = 3447547760007143671L;
-
     /**
      *
      */
diff --git a/src/main/java/org/codehaus/groovy/GroovyBugError.java b/src/main/java/org/codehaus/groovy/GroovyBugError.java
index 89d855da1a..30ed7de57d 100644
--- a/src/main/java/org/codehaus/groovy/GroovyBugError.java
+++ b/src/main/java/org/codehaus/groovy/GroovyBugError.java
@@ -26,8 +26,7 @@ package org.codehaus.groovy;
  * @author Jochen Theodorou
  */
 public class GroovyBugError extends AssertionError {
-
-    private static final long serialVersionUID = 7170193853899664927L;
+    
     // message string
     private String message;
     // optional exception
diff --git a/src/main/java/org/codehaus/groovy/GroovyException.java b/src/main/java/org/codehaus/groovy/GroovyException.java
index 61826f59ab..582da48782 100644
--- a/src/main/java/org/codehaus/groovy/GroovyException.java
+++ b/src/main/java/org/codehaus/groovy/GroovyException.java
@@ -19,7 +19,6 @@
 package org.codehaus.groovy;
 
 public class GroovyException extends Exception implements GroovyExceptionInterface {
-    private static final long serialVersionUID = -61298636122042408L;
     private boolean fatal = true;
 
     public GroovyException() {
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
index 372b04da36..204674b885 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
@@ -26,7 +26,6 @@ import org.codehaus.groovy.syntax.ParserException;
  *
  */
 public class ASTParserException extends ParserException {
-    private static final long serialVersionUID = 2537232761345194260L;
     private final AST ast;
 
     public ASTParserException(ASTRuntimeException e) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
index 032c24d3ac..aec85d40e0 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
@@ -24,7 +24,6 @@ import antlr.collections.AST;
  * @author <a href="mailto:jstrachan@protique.com">James Strachan</a>
  */
 public class ASTRuntimeException extends RuntimeException {
-    private static final long serialVersionUID = 3980229202392379560L;
     private final AST ast;
 
     public ASTRuntimeException(AST ast, String message) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
index fc62836f7c..d256e73b74 100644
--- a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
+++ b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
@@ -33,7 +33,6 @@ import java.util.List;
  * @author Jeremy Rayner <groovy@ross-rayner.com>
  */
 public class GroovySourceAST extends CommonAST implements Comparable, SourceInfo {
-    private static final long serialVersionUID = 2019901428136117486L;
     private int line;
     private int col;
     private int lineLast;
diff --git a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
index 94dd173f33..ecc8098811 100644
--- a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
+++ b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
@@ -134,8 +134,6 @@ public class LexerFrame extends JFrame implements ActionListener {
     }
 
     private final Action loadFileAction = new AbstractAction("Open File...") {
-        private static final long serialVersionUID = 4541927184172762704L;
-
         public void actionPerformed(ActionEvent ae) {
             final JFileChooser jfc = new JFileChooser();
             final int response = jfc.showOpenDialog(LexerFrame.this);
@@ -266,8 +264,6 @@ public class LexerFrame extends JFrame implements ActionListener {
     }
 
     private static class HScrollableTextPane extends JTextPane {
-        private static final long serialVersionUID = -8582328309470654441L;
-
         @Override
         public boolean getScrollableTracksViewportWidth() {
             return (getSize().width < getParent().getSize().width);
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
index 3f6efbb364..57a3e154f9 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -75,10 +75,7 @@ public class WideningCategories {
 
     private static final List<ClassNode> EMPTY_CLASSNODE_LIST = Collections.emptyList();
 
-    private static final Map<ClassNode, Integer> NUMBER_TYPES_PRECEDENCE = Collections.unmodifiableMap(new HashMap<ClassNode, Integer>() {
-        private static final long serialVersionUID = -5178744121420941913L;
-
-        {
+    private static final Map<ClassNode, Integer> NUMBER_TYPES_PRECEDENCE = Collections.unmodifiableMap(new HashMap<ClassNode, Integer>() {{
         put(ClassHelper.double_TYPE, 0);
         put(ClassHelper.float_TYPE, 1);
         put(ClassHelper.long_TYPE, 2);
diff --git a/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java b/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
index 5c404ecb29..bce34481b3 100644
--- a/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
+++ b/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
@@ -25,8 +25,6 @@ package org.codehaus.groovy.classgen;
  */
 public class ClassGeneratorException extends RuntimeException {
 
-    private static final long serialVersionUID = 440899360174632769L;
-
     public ClassGeneratorException(String message) {
         super(message);
     }
diff --git a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
index 34c652a200..924a76e776 100644
--- a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
+++ b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
@@ -395,8 +395,6 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
     }
 
     private static class StateMap extends HashMap<Variable, VariableState> {
-        private static final long serialVersionUID = -5881634573411342092L;
-
         @Override
         public VariableState get(final Object key) {
             return super.get(getTarget((Variable) key));
diff --git a/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java b/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
index 2930b8c6f3..741b647f21 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
@@ -29,7 +29,6 @@ import groovy.lang.GroovyRuntimeException;
 
 public class CompilationFailedException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = 4500269747315896966L;
     protected int phase;   // The phase in which the failures occurred
     protected ProcessingUnit unit;    // The *Unit object this exception wraps
 
diff --git a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
index 9e226ad158..3d0658ab3f 100644
--- a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
+++ b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
@@ -31,9 +31,8 @@ import org.codehaus.groovy.GroovyExceptionInterface;
 
 public class ConfigurationException extends RuntimeException implements GroovyExceptionInterface
 {
-    private static final long serialVersionUID = -630757959041134069L;
-
-    //---------------------------------------------------------------------------
+    
+  //---------------------------------------------------------------------------
   // CONSTRUCTION AND SUCH
 
     protected Exception cause;   // The phase in which the failures occurred
diff --git a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
index 5e0a6e7523..e53762e01b 100644
--- a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
+++ b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
@@ -28,8 +28,7 @@ import java.io.Writer;
  */
 public class MultipleCompilationErrorsException extends
         CompilationFailedException {
-
-    private static final long serialVersionUID = 2948487149304811836L;
+    
     protected ErrorCollector collector;
     
     public MultipleCompilationErrorsException(ErrorCollector ec) {
diff --git a/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java b/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
index 1edf636658..d0fc5416d7 100644
--- a/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
+++ b/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
@@ -115,8 +115,6 @@ public class SourceAwareCustomizerFactory extends AbstractFactory implements Pos
         Closure<Boolean> extensionValidator = data.extensionValidator;
         if (extensionValidator==null && !extensions.isEmpty()) {
             extensionValidator = new Closure<Boolean>(sourceAwareCustomizer) {
-                private static final long serialVersionUID = 925642730835101872L;
-
                 @Override
                 @SuppressWarnings("unchecked")
                 public Boolean call(final Object arguments) {
@@ -133,8 +131,6 @@ public class SourceAwareCustomizerFactory extends AbstractFactory implements Pos
         Closure<Boolean> basenameValidator = data.basenameValidator;
         if (basenameValidator==null && !basenames.isEmpty()) {
             basenameValidator = new Closure<Boolean>(sourceAwareCustomizer) {
-                private static final long serialVersionUID = 7714937867958607043L;
-
                 @Override
                 @SuppressWarnings("unchecked")
                 public Boolean call(final Object arguments) {
diff --git a/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java b/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
index 8dfa960ec8..c5388130c4 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
@@ -21,8 +21,6 @@ package org.codehaus.groovy.reflection;
 import groovy.lang.GroovyRuntimeException;
 
 public class CacheAccessControlException extends GroovyRuntimeException {
-    private static final long serialVersionUID = -5315107566539656474L;
-
     public CacheAccessControlException(String message, Throwable cause) {
         super(message, cause);
     }
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index 9204be2103..e1a55d722f 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -60,8 +60,6 @@ public class CachedClass {
     private static ReferenceBundle softBundle = ReferenceBundle.getSoftBundle();
 
     private final LazyReference<CachedField[]> fields = new LazyReference<CachedField[]>(softBundle) {
-        private static final long serialVersionUID = 5450437842165410025L;
-
         public CachedField[] initValue() {
             final Field[] declaredFields = (Field[])
                AccessController.doPrivileged(new PrivilegedAction<Field[]>() {
@@ -79,8 +77,6 @@ public class CachedClass {
     };
 
     private final LazyReference<CachedConstructor[]> constructors = new LazyReference<CachedConstructor[]>(softBundle) {
-        private static final long serialVersionUID = -5834446523983631635L;
-
         public CachedConstructor[] initValue() {
             final Constructor[] declaredConstructors = (Constructor[])
                AccessController.doPrivileged(new PrivilegedAction/*<Constructor[]>*/() {
@@ -117,8 +113,6 @@ public class CachedClass {
     }
 
     private final LazyReference<CachedMethod[]> methods = new LazyReference<CachedMethod[]>(softBundle) {
-        private static final long serialVersionUID = 6347586066597418308L;
-
         public CachedMethod[] initValue() {
             final Method[] declaredMethods = (Method[])
                AccessController.doPrivileged(new PrivilegedAction/*<Method[]>*/() {
@@ -169,8 +163,6 @@ public class CachedClass {
     };
 
     private final LazyReference<CachedClass> cachedSuperClass = new LazyReference<CachedClass>(softBundle) {
-        private static final long serialVersionUID = -4663740963306806058L;
-
         public CachedClass initValue() {
             if (!isArray)
               return ReflectionCache.getCachedClass(getTheClass().getSuperclass());
@@ -183,8 +175,6 @@ public class CachedClass {
     };
 
     private final LazyReference<CallSiteClassLoader> callSiteClassLoader = new LazyReference<CallSiteClassLoader>(softBundle) {
-        private static final long serialVersionUID = 4410385968428074090L;
-
         public CallSiteClassLoader initValue() {
             return
                AccessController.doPrivileged(new PrivilegedAction<CallSiteClassLoader>() {
@@ -196,8 +186,6 @@ public class CachedClass {
     };
 
     private final LazyReference<LinkedList<ClassInfo>> hierarchy = new LazyReference<LinkedList<ClassInfo>>(softBundle) {
-        private static final long serialVersionUID = 7166687623678851596L;
-
         public LinkedList<ClassInfo> initValue() {
             Set<ClassInfo> res = new LinkedHashSet<ClassInfo> ();
 
@@ -225,8 +213,6 @@ public class CachedClass {
     public static final CachedClass[] EMPTY_ARRAY = new CachedClass[0];
 
     private final LazyReference<Set<CachedClass>> declaredInterfaces = new LazyReference<Set<CachedClass>> (softBundle) {
-        private static final long serialVersionUID = 2139190436931329873L;
-
         public Set<CachedClass> initValue() {
             Set<CachedClass> res = new HashSet<CachedClass> (0);
 
@@ -239,8 +225,6 @@ public class CachedClass {
     };
 
     private final LazyReference<Set<CachedClass>> interfaces = new LazyReference<Set<CachedClass>> (softBundle) {
-        private static final long serialVersionUID = 4060471819464086940L;
-
         public Set<CachedClass> initValue() {
             Set<CachedClass> res = new HashSet<CachedClass> (0);
 
diff --git a/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java b/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
index 1067e4b113..c7abeffa7e 100644
--- a/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
+++ b/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
@@ -441,7 +441,6 @@ public class ClassInfo implements Finalizable {
     }
 
     private static class LazyCachedClassRef extends LazyReference<CachedClass> {
-        private static final long serialVersionUID = -1400274148849287400L;
         private final ClassInfo info;
 
         LazyCachedClassRef(ReferenceBundle bundle, ClassInfo info) {
@@ -455,7 +454,6 @@ public class ClassInfo implements Finalizable {
     }
 
     private static class LazyClassLoaderRef extends LazyReference<ClassLoaderForClassArtifacts> {
-        private static final long serialVersionUID = 1639196133085420609L;
         private final ClassInfo info;
 
         LazyClassLoaderRef(ReferenceBundle bundle, ClassInfo info) {
diff --git a/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java b/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
index 02f893c457..56ad0c16bc 100644
--- a/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
+++ b/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
@@ -54,9 +54,7 @@ class GroovyClassValuePreJava7<T> implements GroovyClassValue<T> {
 
 	private class GroovyClassValuePreJava7Segment extends ManagedConcurrentMap.Segment<Class<?>,T> {
 
-        private static final long serialVersionUID = 1289753977947029168L;
-
-        GroovyClassValuePreJava7Segment(ReferenceBundle bundle, int initialCapacity) {
+		GroovyClassValuePreJava7Segment(ReferenceBundle bundle, int initialCapacity) {
 			super(bundle, initialCapacity);
 		}
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
index 9bc71fa138..393d55eabe 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
@@ -31,8 +31,6 @@ import java.util.Map;
  */
 public class ConvertedMap extends ConversionHandler {
 
-    private static final long serialVersionUID = -8131432558241254137L;
-
     /**
      * to create a ConvertedMap object.
      *
diff --git a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
index 1db103760a..cabe23003f 100644
--- a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
@@ -46,7 +46,6 @@ import groovy.lang.Closure;
  */
 public final class CurriedClosure<V> extends Closure<V> {
 
-    private static final long serialVersionUID = -1018388175778192754L;
     private final Object[] curriedParams;
     private final int minParamsExpected;
     private int index;
diff --git a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
index 05ce6b0f95..19f53d2322 100644
--- a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
+++ b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
@@ -47,7 +47,6 @@ public class GroovyCategorySupport {
     private static int categoriesInUse = 0;
 
     public static class CategoryMethodList extends ArrayList<CategoryMethod> {
-        private static final long serialVersionUID = 1569020062006842141L;
         public final int level;
         final CategoryMethodList previous;
         final AtomicInteger usage;
@@ -73,7 +72,6 @@ public class GroovyCategorySupport {
     public static class ThreadCategoryInfo extends HashMap<String, CategoryMethodList>{
 
         private static final Object LOCK = new Object();
-        private static final long serialVersionUID = 2609120843123833410L;
 
         int level;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
index da85b6b8a5..2f03126d46 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
@@ -29,8 +29,6 @@ import java.lang.reflect.InvocationTargetException;
  */
 public class InvokerInvocationException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = 5870532233180451709L;
-
     public InvokerInvocationException(InvocationTargetException e) {
         super(e.getTargetException());
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
index 7f098d7013..24d74f6c0f 100644
--- a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
@@ -32,7 +32,6 @@ import java.util.List;
  */
 public class IteratorClosureAdapter<T> extends Closure {
 
-    private static final long serialVersionUID = -3193812539363103534L;
     private final List<T> list = new ArrayList<T>();
     private MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
     
diff --git a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
index a47adab505..4d3eeb6760 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
@@ -142,8 +142,6 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
         final long[] size = {0L};
 
         eachFileRecurse(self, FileType.FILES, new Closure<Void>(null) {
-            private static final long serialVersionUID = 7688764529326404277L;
-
             public void doCall(Object[] args) {
                 size[0] += ((File) args[0]).length();
             }
diff --git a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
index 21a9e4079d..ec2f481b44 100644
--- a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
+++ b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
@@ -32,7 +32,6 @@ import java.io.Writer;
  *
  */
 public class WritableFile extends File implements Writable {
-    private static final long serialVersionUID = 1661640530283827325L;
     private final String encoding;
 
     public WritableFile(final File delegate) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
index ef2a7b8798..e602658ffe 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
@@ -32,7 +32,6 @@ import java.util.concurrent.ConcurrentHashMap;
  */
 @ThreadSafe
 public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V>, Serializable {
-    private static final long serialVersionUID = -2062728248439701004L;
     private final ConcurrentHashMap<K, V> map;
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
index 2d501b3a94..68fe42d402 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
@@ -166,9 +166,7 @@ public class ConcurrentReaderHashMap
   */
 
   /** A Serializable class for barrier lock **/
-  protected static class BarrierLock implements java.io.Serializable {
-      private static final long serialVersionUID = -5403150101810674636L;
-  }
+  protected static class BarrierLock implements java.io.Serializable { }
 
   /**
    * Lock used only for its memory effects.
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
index 4f0cc4cb96..a9f5538403 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
@@ -37,7 +37,6 @@ import java.lang.reflect.Modifier;
  */
 public class MethodSelectionException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = 6260193948973669540L;
     private final String methodName;
     private final FastArray methods;
     private final Class[] arguments;
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
index 80836c78e4..28437d28c6 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
@@ -22,8 +22,6 @@ import groovy.lang.MissingMethodException;
 
 public class MissingMethodExceptionNoStack extends MissingMethodException {
 
-    private static final long serialVersionUID = 7075950754138801519L;
-
     public MissingMethodExceptionNoStack(String method, Class type, Object[] arguments) {
         this(method,type,arguments,false);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
index a177eaba7d..0b2c33f8dc 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
@@ -22,8 +22,6 @@ import groovy.lang.MissingPropertyException;
 
 public class MissingPropertyExceptionNoStack extends MissingPropertyException {
 
-    private static final long serialVersionUID = -7734212543734003079L;
-
     public MissingPropertyExceptionNoStack(String propertyName, Class theClass) {
         super(propertyName, theClass);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
index b79f0d75ba..d6ef9de74c 100644
--- a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
+++ b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
@@ -24,8 +24,6 @@ package org.codehaus.groovy.runtime.powerassert;
  * @author Peter Niederwieser
  */
 public class PowerAssertionError extends java.lang.AssertionError {
-    private static final long serialVersionUID = 186840762256433109L;
-
     public PowerAssertionError(String msg) {
         super(msg);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java b/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
index b7a6bd8ea2..431dd08c0f 100644
--- a/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
@@ -27,8 +27,6 @@ import org.codehaus.groovy.control.SourceUnit;
  * @author Peter Niederwieser
  */
 public class SourceTextNotAvailableException extends RuntimeException {
-    private static final long serialVersionUID = -3815868502019514479L;
-
     // only accepts AssertStatementS so that better error messages can be produced
     public SourceTextNotAvailableException(AssertStatement stat, SourceUnit unit, String msg) {
         super(String.format("%s for %s at (%d,%d)-(%d,%d) in %s",
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
index f9cace8baf..e2fc66a6c9 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
@@ -20,8 +20,6 @@ package org.codehaus.groovy.runtime.typehandling;
 
 public class GroovyCastException extends ClassCastException {
 
-    private static final long serialVersionUID = 6859089155641797356L;
-
     /**
      * @param objectToCast object we tried to cast
      * @param classToCastTo class we tried to cast to
diff --git a/src/main/java/org/codehaus/groovy/syntax/ParserException.java b/src/main/java/org/codehaus/groovy/syntax/ParserException.java
index beedb1c888..2215429d3e 100644
--- a/src/main/java/org/codehaus/groovy/syntax/ParserException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/ParserException.java
@@ -19,8 +19,6 @@
 package org.codehaus.groovy.syntax;
 
 public class ParserException extends TokenException {
-    private static final long serialVersionUID = -3772086239731735693L;
-
     public ParserException(String message, Token token) {
         super(message, token);
     }
diff --git a/src/main/java/org/codehaus/groovy/syntax/ReadException.java b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
index af70dd0c13..6885c24bbb 100644
--- a/src/main/java/org/codehaus/groovy/syntax/ReadException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
@@ -27,7 +27,6 @@ import java.io.IOException;
  */
 
 public class ReadException extends GroovyException {
-    private static final long serialVersionUID = -6171846198126205359L;
     private final IOException cause;
 
     public ReadException(IOException cause) {
diff --git a/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java b/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
index ce804e1381..c47bc26710 100644
--- a/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
@@ -29,8 +29,6 @@ import org.codehaus.groovy.ast.ASTNode;
  */
 public class RuntimeParserException extends GroovyRuntimeException {
 
-    private static final long serialVersionUID = -6612860527133856587L;
-
     public RuntimeParserException(String message, ASTNode node) {
         super(message + "\n", node);
     }
diff --git a/src/main/java/org/codehaus/groovy/syntax/TokenException.java b/src/main/java/org/codehaus/groovy/syntax/TokenException.java
index fea3ec2f04..5c9f2755d0 100644
--- a/src/main/java/org/codehaus/groovy/syntax/TokenException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/TokenException.java
@@ -19,8 +19,6 @@
 package org.codehaus.groovy.syntax;
 
 public class TokenException extends SyntaxException {
-    private static final long serialVersionUID = 6850594285972085144L;
-
     public TokenException(String message, Token token) {
         super(
                 (token == null)
diff --git a/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java b/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
index 3f799fa929..32c90a50d0 100644
--- a/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
@@ -19,7 +19,6 @@
 package org.codehaus.groovy.syntax;
 
 public class TokenMismatchException extends TokenException {
-    private static final long serialVersionUID = -6321206176010272124L;
     private final Token unexpectedToken;
     private final int expectedType;
 
diff --git a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
index 4d5117d59a..74f9fffd40 100644
--- a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
+++ b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
@@ -24,9 +24,7 @@ import java.util.Set;
 import java.util.TreeSet;
 
 public class StringSetMap extends LinkedHashMap<String,Set<String>> {
-
-    private static final long serialVersionUID = 4230491822783819152L;
-
+    
     public StringSetMap() {
         super();
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
index fbb3fe3b94..90c956ce82 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
@@ -56,10 +56,7 @@ import java.util.Map;
 public class StaticCompilationTransformer extends ClassCodeExpressionTransformer {
 
     protected static final ClassNode BYTECODE_ADAPTER_CLASS = ClassHelper.make(ScriptBytecodeAdapter.class);
-    protected static final Map<Integer, MethodNode> BYTECODE_BINARY_ADAPTERS = Collections.unmodifiableMap(new HashMap<Integer, MethodNode>() {
-        private static final long serialVersionUID = -9117028399464862605L;
-
-        {
+    protected static final Map<Integer, MethodNode> BYTECODE_BINARY_ADAPTERS = Collections.unmodifiableMap(new HashMap<Integer, MethodNode>() {{
         put(Types.COMPARE_EQUAL, BYTECODE_ADAPTER_CLASS.getMethods("compareEqual").get(0));
         put(Types.COMPARE_GREATER_THAN, BYTECODE_ADAPTER_CLASS.getMethods("compareGreaterThan").get(0));
         put(Types.COMPARE_GREATER_THAN_EQUAL, BYTECODE_ADAPTER_CLASS.getMethods("compareGreaterThanEqual").get(0));
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
index d6cae87668..8e2fad76ca 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
@@ -436,7 +436,6 @@ public class AbstractTypeCheckingExtension extends TypeCheckingExtension {
     }
 
     private static class TypeCheckingScope extends LinkedHashMap<String, Object> {
-        private static final long serialVersionUID = 7607331333917615144L;
         private final AbstractTypeCheckingExtension.TypeCheckingScope parent;
 
         private TypeCheckingScope(final AbstractTypeCheckingExtension.TypeCheckingScope parentScope) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
index 6254b0a69a..52ccdf19b6 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
@@ -65,10 +65,7 @@ public class GroovyTypeCheckingExtensionSupport extends AbstractTypeCheckingExte
 
     // method name to DSL name
     private static final Map<String, String> METHOD_ALIASES = Collections.unmodifiableMap(
-            new HashMap<String, String>() {
-                private static final long serialVersionUID = 8938707932245818749L;
-
-                {
+            new HashMap<String, String>() {{
                 put("onMethodSelection", "onMethodSelection");
                 put("afterMethodCall", "afterMethodCall");
                 put("beforeMethodCall", "beforeMethodCall");
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index afb91d1a8b..571e6ac637 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -165,10 +165,7 @@ public abstract class StaticTypeCheckingSupport {
     protected static final ClassNode ArrayList_TYPE = makeWithoutCaching(ArrayList.class);
     protected static final ExtensionMethodCache EXTENSION_METHOD_CACHE = new ExtensionMethodCache();
     protected static final Map<ClassNode, Integer> NUMBER_TYPES = Collections.unmodifiableMap(
-            new HashMap<ClassNode, Integer>() {
-                private static final long serialVersionUID = 8841951852732042766L;
-
-                {
+            new HashMap<ClassNode, Integer>() {{
                 put(byte_TYPE, 0);
                 put(Byte_TYPE, 0);
                 put(short_TYPE, 1);
@@ -184,10 +181,7 @@ public abstract class StaticTypeCheckingSupport {
             }});
 
     protected static final Map<String, Integer> NUMBER_OPS = Collections.unmodifiableMap(
-            new HashMap<String, Integer>() {
-                private static final long serialVersionUID = 6951856193525808411L;
-
-                {
+            new HashMap<String, Integer>() {{
                 put("plus", PLUS);
                 put("minus", MINUS);
                 put("multiply", MULTIPLY);
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
index 349c9306ba..d60396b0cc 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
@@ -50,8 +50,6 @@ public abstract class AbstractConcurrentMap<K, V> extends AbstractConcurrentMapB
 
     public abstract static class Segment<K,V> extends AbstractConcurrentMapBase.Segment {
 
-        private static final long serialVersionUID = 5192533863182570468L;
-
         protected Segment(int initialCapacity) {
             super(initialCapacity);
         }
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
index 2cfc82a99f..b21c0af71f 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
@@ -154,7 +154,6 @@ public abstract class AbstractConcurrentMapBase {
     }
 
     public static class Segment extends LockableObject {
-        private static final long serialVersionUID = -1071886855389945760L;
         volatile int count;
 
         int threshold;
diff --git a/src/main/java/org/codehaus/groovy/util/LazyReference.java b/src/main/java/org/codehaus/groovy/util/LazyReference.java
index 54e0ab2e78..fc348039e0 100644
--- a/src/main/java/org/codehaus/groovy/util/LazyReference.java
+++ b/src/main/java/org/codehaus/groovy/util/LazyReference.java
@@ -24,7 +24,6 @@ package org.codehaus.groovy.util;
 public abstract class LazyReference<T> extends LockableObject {
     private static final ManagedReference INIT = new ManagedReference(ReferenceType.HARD,null,null){};
     private static final ManagedReference NULL_REFERENCE = new ManagedReference(ReferenceType.HARD,null,null){};
-    private static final long serialVersionUID = 3160238516132794621L;
     private ManagedReference<T> reference = INIT;
     private final ReferenceBundle bundle;
     
diff --git a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
index da06275840..209de66c2a 100644
--- a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
@@ -33,7 +33,6 @@ public class ManagedConcurrentMap<K,V> extends AbstractConcurrentMap<K,V> {
     }
 
     public static class Segment<K,V> extends AbstractConcurrentMap.Segment<K,V>{
-        private static final long serialVersionUID = -2157582627873688747L;
         protected final ReferenceBundle bundle;
         public Segment(ReferenceBundle bundle, int cap) {
             super(cap);

Commit:
a63e2114767cbb6e200785a711ae71ae93939620
sunlan
sunlan@apache.org
2018-04-03 08:31:02 +0800
Optimize imports
diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index d5185f178b..e5d1f036f9 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -18,8 +18,6 @@
  */
 package org.codehaus.groovy.ast;
 
-import groovy.lang.groovydoc.Groovydoc;
-import groovy.lang.groovydoc.GroovydocHolder;
 import org.apache.groovy.ast.tools.ClassNodeUtils;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java b/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java
index 8a789fee8e..75ebcbb6f1 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/AsmDecompiler.java
@@ -25,7 +25,6 @@ import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.FieldVisitor;
 import org.objectweb.asm.MethodVisitor;
-import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 
 import java.io.BufferedInputStream;
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
index bb01a9561a..0c0603a2ac 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
@@ -22,7 +22,6 @@ import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.vmplugin.v5.Java5;
-import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.signature.SignatureVisitor;
 
 import java.util.ArrayList;
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
index 7b217fcc0f..21a7e6ca0b 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
@@ -23,7 +23,6 @@ import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.vmplugin.v5.Java5;
-import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.objectweb.asm.signature.SignatureVisitor;
 
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesStatementWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesStatementWriter.java
index c27ae5fa61..cabc3c48d9 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesStatementWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesStatementWriter.java
@@ -27,7 +27,6 @@ import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ForStatement;
 import org.codehaus.groovy.classgen.AsmClassGenerator;
-import org.codehaus.groovy.classgen.asm.BytecodeHelper;
 import org.codehaus.groovy.classgen.asm.BytecodeVariable;
 import org.codehaus.groovy.classgen.asm.CompileStack;
 import org.codehaus.groovy.classgen.asm.MethodCaller;
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/util/LoggableClassVisitor.java b/src/main/java/org/codehaus/groovy/classgen/asm/util/LoggableClassVisitor.java
index c102f6927c..dd86cbb173 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/util/LoggableClassVisitor.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/util/LoggableClassVisitor.java
@@ -20,7 +20,6 @@ package org.codehaus.groovy.classgen.asm.util;
 
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.objectweb.asm.ClassVisitor;
-import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.util.TraceClassVisitor;
 
 /**
diff --git a/src/main/java/org/codehaus/groovy/control/CompilationUnit.java b/src/main/java/org/codehaus/groovy/control/CompilationUnit.java
index b47a6534e3..edb4e8e6fc 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilationUnit.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilationUnit.java
@@ -52,14 +52,11 @@ import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
 import org.codehaus.groovy.transform.trait.TraitComposer;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
-import org.objectweb.asm.util.Textifier;
-import org.objectweb.asm.util.TraceClassVisitor;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.PrintWriter;
 import java.net.URL;
 import java.security.CodeSource;
 import java.util.ArrayList;
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index b2c944885b..07b7c25e54 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -18,14 +18,12 @@
  */
 package org.codehaus.groovy.runtime;
 
-import groovy.io.FileType;
 import groovy.io.GroovyPrintWriter;
 import groovy.lang.Closure;
 import groovy.lang.DelegatesTo;
 import groovy.lang.DelegatingMetaClass;
 import groovy.lang.EmptyRange;
 import groovy.lang.ExpandoMetaClass;
-import groovy.lang.GString;
 import groovy.lang.GroovyObject;
 import groovy.lang.GroovyRuntimeException;
 import groovy.lang.GroovySystem;
@@ -44,7 +42,6 @@ import groovy.lang.PropertyValue;
 import groovy.lang.Range;
 import groovy.lang.SpreadMap;
 import groovy.lang.Tuple2;
-import groovy.lang.Writable;
 import groovy.transform.stc.ClosureParams;
 import groovy.transform.stc.FirstParam;
 import groovy.transform.stc.FromString;
@@ -97,25 +94,10 @@ import org.codehaus.groovy.util.ArrayIterator;
 import org.codehaus.groovy.util.IteratorBufferedIterator;
 import org.codehaus.groovy.util.ListBufferedIterator;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
 import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.OutputStream;
 import java.io.PrintStream;
 import java.io.PrintWriter;
-import java.io.Reader;
-import java.io.StringWriter;
-import java.io.UnsupportedEncodingException;
 import java.io.Writer;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Array;
@@ -126,12 +108,6 @@ import java.lang.reflect.Proxy;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.RoundingMode;
-import java.net.MalformedURLException;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.text.MessageFormat;
@@ -164,8 +140,6 @@ import java.util.TreeMap;
 import java.util.TreeSet;
 import java.util.concurrent.BlockingQueue;
 import java.util.logging.Logger;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 import static groovy.lang.groovydoc.Groovydoc.EMPTY_GROOVYDOC;
 
diff --git a/src/main/java/org/codehaus/groovy/syntax/Types.java b/src/main/java/org/codehaus/groovy/syntax/Types.java
index a793d28fbb..6feeed5a90 100644
--- a/src/main/java/org/codehaus/groovy/syntax/Types.java
+++ b/src/main/java/org/codehaus/groovy/syntax/Types.java
@@ -25,7 +25,6 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
diff --git a/src/main/java/org/codehaus/groovy/transform/ToStringASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/ToStringASTTransformation.java
index 018079d4b2..3a76685103 100644
--- a/src/main/java/org/codehaus/groovy/transform/ToStringASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/ToStringASTTransformation.java
@@ -34,7 +34,6 @@ import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
-import org.codehaus.groovy.ast.tools.BeanUtils;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
@@ -57,7 +56,6 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.declS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.equalsNullX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getAllProperties;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.getInstanceNonPropertyFields;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getterThisX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.hasDeclaredMethod;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.ifElseS;
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 760eeedc7c..bd647fcfdd 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -62,6 +62,7 @@ import org.codehaus.groovy.ast.expr.MapEntryExpression;
 import org.codehaus.groovy.ast.expr.MapExpression;
 import org.codehaus.groovy.ast.expr.MethodCall;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.NotExpression;
 import org.codehaus.groovy.ast.expr.PostfixExpression;
 import org.codehaus.groovy.ast.expr.PrefixExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
@@ -73,7 +74,6 @@ import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.ast.expr.UnaryMinusExpression;
 import org.codehaus.groovy.ast.expr.UnaryPlusExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
-import org.codehaus.groovy.ast.expr.NotExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.CaseStatement;
 import org.codehaus.groovy.ast.stmt.CatchStatement;
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index 2e98b48647..79227701a6 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -29,7 +29,6 @@ import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.transform.trait.TraitASTTransformation;
 import org.codehaus.groovy.transform.trait.Traits;
 
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;

Commit:
d524b2ff964b07fbb443d38fc3df678dd6b5cb80
sunlan
sunlan@apache.org
2018-04-03 07:58:46 +0800
Trivial refactoring: avoid calling `toArray` with pre-sized array parameter
diff --git a/src/main/groovy/groovy/lang/MetaMethod.java b/src/main/groovy/groovy/lang/MetaMethod.java
index c58d6b7458..10815ed7a7 100644
--- a/src/main/groovy/groovy/lang/MetaMethod.java
+++ b/src/main/groovy/groovy/lang/MetaMethod.java
@@ -34,6 +34,7 @@ import java.lang.reflect.Modifier;
  * @author Alex Tkachman
  */
 public abstract class MetaMethod extends ParameterTypes implements Cloneable {
+    public static final MetaMethod[] EMPTY_ARRAY = new MetaMethod[0];
     private String signature;
     private String mopName;
 
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index 80bc0409e0..9204be2103 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -217,7 +217,7 @@ public class CachedClass {
         }
     };
 
-    static final MetaMethod[] EMPTY = new MetaMethod[0];
+    static final MetaMethod[] EMPTY = MetaMethod.EMPTY_ARRAY;
 
     int hashCode;
 
@@ -401,7 +401,7 @@ public class CachedClass {
             addSubclassExpandos(arr, mc);
         }
 
-        return arr.toArray(new MetaMethod[arr.size()]);
+        return arr.toArray(MetaMethod.EMPTY_ARRAY);
     }
 
     private void addSubclassExpandos(List<MetaMethod> arr, MetaClass mc) {
@@ -453,7 +453,7 @@ public class CachedClass {
 
     private void updateSetNewMopMethods(List<MetaMethod> arr) {
         if (arr != null) {
-            final MetaMethod[] metaMethods = arr.toArray(new MetaMethod[arr.size()]);
+            final MetaMethod[] metaMethods = arr.toArray(MetaMethod.EMPTY_ARRAY);
             classInfo.dgmMetaMethods = metaMethods;
             classInfo.newMetaMethods = metaMethods;
         }
@@ -501,7 +501,7 @@ public class CachedClass {
         List<MetaMethod> res = new ArrayList<MetaMethod>();
         res.addAll(Arrays.asList(classInfo.newMetaMethods));
         res.addAll(arr);
-        classInfo.newMetaMethods = res.toArray(new MetaMethod[res.size()]);
+        classInfo.newMetaMethods = res.toArray(MetaMethod.EMPTY_ARRAY);
         Class theClass = classInfo.getCachedClass().getTheClass();
         if (theClass==Closure.class || theClass==Class.class) {
             ClosureMetaClass.resetCachedMetaClasses();

Commit:
c0b5ea27efa2a82217197104fda1ba98271d344e
sunlan
sunlan@apache.org
2018-04-03 07:58:46 +0800
Unnecessary zero length array usage
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index c5f9c11c4d..80bc0409e0 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -151,7 +151,7 @@ public class CachedClass {
                 else
                   methods.add(cachedMethod);
             }
-            CachedMethod [] resMethods = methods.toArray(new CachedMethod[0]);
+            CachedMethod [] resMethods = methods.toArray(CachedMethod.EMPTY_ARRAY);
             Arrays.sort(resMethods);
 
             final CachedClass superClass = getCachedSuperClass();
diff --git a/src/main/java/org/codehaus/groovy/tools/DgmConverter.java b/src/main/java/org/codehaus/groovy/tools/DgmConverter.java
index 98d5cf99d8..b8adfd3be3 100644
--- a/src/main/java/org/codehaus/groovy/tools/DgmConverter.java
+++ b/src/main/java/org/codehaus/groovy/tools/DgmConverter.java
@@ -50,7 +50,7 @@ public class DgmConverter implements Opcodes {
         for (Class aClass : DefaultGroovyMethods.DGM_LIKE_CLASSES) {
             Collections.addAll(cachedMethodsList, ReflectionCache.getCachedClass(aClass).getMethods());
         }
-        final CachedMethod[] cachedMethods = cachedMethodsList.toArray(new CachedMethod[0]);
+        final CachedMethod[] cachedMethods = cachedMethodsList.toArray(CachedMethod.EMPTY_ARRAY);
 
         List<GeneratedMetaMethod.DgmMethodRecord> records = new ArrayList<GeneratedMetaMethod.DgmMethodRecord>();
 

Commit:
75e1e878bf0b07662019f3989f0ebcc82ba9805e
sunlan
sunlan@apache.org
2018-04-03 07:58:46 +0800
Unnecessary 'null' check before 'instanceof' expression or call
diff --git a/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java b/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java
index 82f13e7898..eac9e2c15f 100644
--- a/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java
+++ b/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java
@@ -469,7 +469,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
     private void checkForClassLoader(AnnotationNode node) {
         Object val = node.getMember("systemClassLoader");
-        if (val == null || !(val instanceof ConstantExpression)) return;
+        if (!(val instanceof ConstantExpression)) return;
         Object systemClassLoaderObject = ((ConstantExpression)val).getValue();
         if (!(systemClassLoaderObject instanceof Boolean)) return;
         Boolean systemClassLoader = (Boolean) systemClassLoaderObject;
@@ -478,7 +478,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
     private void checkForInitContextClassLoader(AnnotationNode node) {
         Object val = node.getMember("initContextClassLoader");
-        if (val == null || !(val instanceof ConstantExpression)) return;
+        if (!(val instanceof ConstantExpression)) return;
         Object initContextClassLoaderObject = ((ConstantExpression)val).getValue();
         if (!(initContextClassLoaderObject instanceof Boolean)) return;
         initContextClassLoader = (Boolean) initContextClassLoaderObject;
@@ -486,7 +486,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
     private void checkForAutoDownload(AnnotationNode node) {
         Object val = node.getMember(AUTO_DOWNLOAD_SETTING);
-        if (val == null || !(val instanceof ConstantExpression)) return;
+        if (!(val instanceof ConstantExpression)) return;
         Object autoDownloadValue = ((ConstantExpression)val).getValue();
         if (!(autoDownloadValue instanceof Boolean)) return;
         autoDownload = (Boolean) autoDownloadValue;
@@ -494,7 +494,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
     private void checkForDisableChecksums(AnnotationNode node) {
         Object val = node.getMember(DISABLE_CHECKSUMS_SETTING);
-        if (val == null || !(val instanceof ConstantExpression)) return;
+        if (!(val instanceof ConstantExpression)) return;
         Object disableChecksumsValue = ((ConstantExpression)val).getValue();
         if (!(disableChecksumsValue instanceof Boolean)) return;
         disableChecksums = (Boolean) disableChecksumsValue;
@@ -515,7 +515,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
     private static void checkForConvenienceForm(AnnotationNode node, boolean exclude) {
         Object val = node.getMember("value");
-        if (val == null || !(val instanceof ConstantExpression)) return;
+        if (!(val instanceof ConstantExpression)) return;
         Object allParts = ((ConstantExpression)val).getValue();
         if (!(allParts instanceof String)) return;
         String allstr = (String) allParts;
diff --git a/src/main/groovy/groovy/lang/GroovyCodeSource.java b/src/main/groovy/groovy/lang/GroovyCodeSource.java
index 18e84f16e1..12b8143671 100644
--- a/src/main/groovy/groovy/lang/GroovyCodeSource.java
+++ b/src/main/groovy/groovy/lang/GroovyCodeSource.java
@@ -149,7 +149,7 @@ public class GroovyCodeSource {
             this.codeSource = (CodeSource) info[1];
         } catch (PrivilegedActionException pae) {
             Throwable cause = pae.getCause();
-            if (cause != null && cause instanceof IOException) {
+            if (cause instanceof IOException) {
                 throw (IOException) cause;
             }
             throw new RuntimeException("Could not construct CodeSource for file: " + file, cause);
diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index 427bf29bec..8409bbf22e 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -872,7 +872,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         if(isGetter) {
             final Class[] getPropertyArgs = {String.class};
             final MetaMethod method = findMethodInClassHierarchy(instance.getClass(), GET_PROPERTY_METHOD, getPropertyArgs, this);
-            if(method != null && method instanceof ClosureMetaMethod) {
+            if(method instanceof ClosureMetaMethod) {
                 onGetPropertyFoundInHierarchy(method);
                 return method.invoke(instance,new Object[]{propertyName});
             }
@@ -880,7 +880,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         else {
             final Class[] setPropertyArgs = {String.class, Object.class};
             final MetaMethod method = findMethodInClassHierarchy(instance.getClass(), SET_PROPERTY_METHOD, setPropertyArgs, this);
-            if(method != null && method instanceof ClosureMetaMethod) {
+            if(method instanceof ClosureMetaMethod) {
                 onSetPropertyFoundInHierarchy(method);
                 return method.invoke(instance, new Object[]{propertyName, optionalValue});
             }
@@ -943,7 +943,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             // still not method here, so see if there is an invokeMethod method up the hierarchy
             final Class[] invokeMethodArgs = {String.class, Object[].class};
             method = findMethodInClassHierarchy(instanceKlazz, INVOKE_METHOD_METHOD, invokeMethodArgs, this );
-            if(method != null && method instanceof ClosureMetaMethod) {
+            if(method instanceof ClosureMetaMethod) {
                 onInvokeMethodFoundInHierarchy(method);
                 return method.invoke(instance, invokeMethodArgs);
             }
diff --git a/src/main/groovy/groovy/lang/Script.java b/src/main/groovy/groovy/lang/Script.java
index 196c74c855..ea70461afc 100644
--- a/src/main/groovy/groovy/lang/Script.java
+++ b/src/main/groovy/groovy/lang/Script.java
@@ -85,7 +85,7 @@ public abstract class Script extends GroovyObjectSupport {
             try {
                 if (name.equals(mme.getMethod())) {
                     Object boundClosure = getProperty(name);
-                    if (boundClosure != null && boundClosure instanceof Closure) {
+                    if (boundClosure instanceof Closure) {
                         return ((Closure) boundClosure).call((Object[])args);
                     } else {
                         throw mme;
diff --git a/src/main/groovy/groovy/lang/Tuple.java b/src/main/groovy/groovy/lang/Tuple.java
index 036d13e7de..eb9956f785 100644
--- a/src/main/groovy/groovy/lang/Tuple.java
+++ b/src/main/groovy/groovy/lang/Tuple.java
@@ -65,7 +65,7 @@ public class Tuple<E> extends AbstractList<E> implements Serializable {
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
-        if (o == null || !(o instanceof Tuple)) return false;
+        if (!(o instanceof Tuple)) return false;
 
         Tuple that = (Tuple) o;
         int size = size();
diff --git a/src/main/groovy/groovy/util/Expando.java b/src/main/groovy/groovy/util/Expando.java
index f0095514f2..7b2279a479 100644
--- a/src/main/groovy/groovy/util/Expando.java
+++ b/src/main/groovy/groovy/util/Expando.java
@@ -115,7 +115,7 @@ public class Expando extends GroovyObjectSupport {
      */
     public String toString() {
         Object method = getProperties().get("toString");
-        if (method != null && method instanceof Closure) {
+        if (method instanceof Closure) {
             // invoke overridden toString closure method
             Closure closure = (Closure) method;
             closure.setDelegate(this);
@@ -133,7 +133,7 @@ public class Expando extends GroovyObjectSupport {
      */
     public boolean equals(Object obj) {
         Object method = getProperties().get("equals");
-        if (method != null && method instanceof Closure) {
+        if (method instanceof Closure) {
             // invoke overridden equals closure method
             Closure closure = (Closure) method;
             closure.setDelegate(this);
@@ -152,7 +152,7 @@ public class Expando extends GroovyObjectSupport {
      */
     public int hashCode() {
         Object method = getProperties().get("hashCode");
-        if (method != null && method instanceof Closure) {
+        if (method instanceof Closure) {
             // invoke overridden hashCode closure method
             Closure closure = (Closure) method;
             closure.setDelegate(this);
diff --git a/src/main/groovy/groovy/util/Node.java b/src/main/groovy/groovy/util/Node.java
index b6e0e37474..7063fba98b 100644
--- a/src/main/groovy/groovy/util/Node.java
+++ b/src/main/groovy/groovy/util/Node.java
@@ -79,7 +79,7 @@ public class Node implements Serializable, Cloneable {
     @Override
     public Object clone() {
         Object newValue = value;
-        if (value != null && value instanceof NodeList) {
+        if (value instanceof NodeList) {
             NodeList nodes = (NodeList) value;
             newValue = nodes.clone();
         }
diff --git a/src/main/groovy/groovy/util/ObservableList.java b/src/main/groovy/groovy/util/ObservableList.java
index c860fea934..3d14734c3f 100644
--- a/src/main/groovy/groovy/util/ObservableList.java
+++ b/src/main/groovy/groovy/util/ObservableList.java
@@ -152,7 +152,7 @@ public class ObservableList implements List {
     private void fireAddWithTest(Object element, int index, int oldSize) {
         if (test != null) {
             Object result = test.call(element);
-            if (result != null && result instanceof Boolean && (Boolean) result) {
+            if (result instanceof Boolean && (Boolean) result) {
                 fireElementAddedEvent(index, element);
                 fireSizeChangedEvent(oldSize, size());
             }
@@ -175,7 +175,7 @@ public class ObservableList implements List {
             for (Object element : c) {
                 if (test != null) {
                     Object result = test.call(element);
-                    if (result != null && result instanceof Boolean && (Boolean) result) {
+                    if (result instanceof Boolean && (Boolean) result) {
                         values.add(element);
                     }
                 } else {
@@ -321,7 +321,7 @@ public class ObservableList implements List {
         Object oldValue = delegate.set(index, element);
         if (test != null) {
             Object result = test.call(element);
-            if (result != null && result instanceof Boolean && ((Boolean) result).booleanValue()) {
+            if (result instanceof Boolean && ((Boolean) result).booleanValue()) {
                 fireElementUpdatedEvent(index, oldValue, element);
             }
         } else {
diff --git a/src/main/groovy/groovy/util/ObservableMap.java b/src/main/groovy/groovy/util/ObservableMap.java
index ed340640db..ab59388517 100644
--- a/src/main/groovy/groovy/util/ObservableMap.java
+++ b/src/main/groovy/groovy/util/ObservableMap.java
@@ -189,7 +189,7 @@ public class ObservableMap implements Map {
             } else {
                 result = test.call(value);
             }
-            if (result != null && result instanceof Boolean && (Boolean) result) {
+            if (result instanceof Boolean && (Boolean) result) {
                 if (newKey) {
                     firePropertyAddedEvent(key, value);
                     fireSizeChangedEvent(oldSize, size());
@@ -229,7 +229,7 @@ public class ObservableMap implements Map {
                     } else {
                         result = test.call(newValue);
                     }
-                    if (result != null && result instanceof Boolean && (Boolean) result) {
+                    if (result instanceof Boolean && (Boolean) result) {
                         if (newKey) {
                             events.add(new PropertyAddedEvent(this, key, newValue));
                         } else if (oldValue != newValue) {
diff --git a/src/main/groovy/groovy/util/ObservableSet.java b/src/main/groovy/groovy/util/ObservableSet.java
index 851c651c7e..cbd9477f63 100644
--- a/src/main/groovy/groovy/util/ObservableSet.java
+++ b/src/main/groovy/groovy/util/ObservableSet.java
@@ -191,7 +191,7 @@ public class ObservableSet<E> implements Set<E> {
         if (success) {
             if (test != null) {
                 Object result = test.call(e);
-                if (result != null && result instanceof Boolean && (Boolean) result) {
+                if (result instanceof Boolean && (Boolean) result) {
                     fireElementAddedEvent(e);
                     fireSizeChangedEvent(oldSize, size());
                 }
@@ -234,7 +234,7 @@ public class ObservableSet<E> implements Set<E> {
             for (E element : c) {
                 if (test != null) {
                     Object result = test.call(element);
-                    if (result != null && result instanceof Boolean && (Boolean) result && !duplicates.contains(element)) {
+                    if (result instanceof Boolean && (Boolean) result && !duplicates.contains(element)) {
                         values.add(element);
                     }
                 } else if (!duplicates.contains(element)) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 6ddb6b7689..9b3981aae8 100644
--- a/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -1723,7 +1723,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
 
         // let's do the catch nodes
         List<CatchStatement> catches = new ArrayList<CatchStatement>();
-        for (; node != null && isType(LITERAL_catch, node); node = node.getNextSibling()) {
+        for (; isType(LITERAL_catch, node); node = node.getNextSibling()) {
             final List<CatchStatement> catchStatements = catchStatement(node);
             catches.addAll(catchStatements);
         }
diff --git a/src/main/java/org/codehaus/groovy/ast/ConstructorNode.java b/src/main/java/org/codehaus/groovy/ast/ConstructorNode.java
index fe7a7da0fa..2dcdc543a7 100644
--- a/src/main/java/org/codehaus/groovy/ast/ConstructorNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ConstructorNode.java
@@ -48,7 +48,7 @@ public class ConstructorNode extends MethodNode {
     
     public boolean firstStatementIsSpecialConstructorCall() {
         Statement code = getFirstStatement();
-        if (code == null || !(code instanceof ExpressionStatement)) return false;
+        if (!(code instanceof ExpressionStatement)) return false;
 
         Expression expression = ((ExpressionStatement) code).getExpression();
         if (!(expression instanceof ConstructorCallExpression)) return false;
diff --git a/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index b05f6bd336..e2a848b2f2 100644
--- a/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -149,7 +149,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
                         cn = ClassHelper.make(typeClass);
                     }
                 }
-                if (cn == null || !Traits.isTrait(cn)) {
+                if (!Traits.isTrait(cn)) {
                     ASTNode errorNode = methodNode;
                     String name = mn.getName();
                     if (errorNode.getLineNumber() == -1) {
diff --git a/src/main/java/org/codehaus/groovy/classgen/Verifier.java b/src/main/java/org/codehaus/groovy/classgen/Verifier.java
index 090cc4f7ac..dadb1d377c 100644
--- a/src/main/java/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/java/org/codehaus/groovy/classgen/Verifier.java
@@ -1094,7 +1094,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
     }
 
     private static ConstructorCallExpression getFirstIfSpecialConstructorCall(Statement code) {
-        if (code == null || !(code instanceof ExpressionStatement)) return null;
+        if (!(code instanceof ExpressionStatement)) return null;
 
         Expression expression = ((ExpressionStatement) code).getExpression();
         if (!(expression instanceof ConstructorCallExpression)) return null;
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 9db7599887..b44c54469e 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -164,7 +164,7 @@ public class StaticInvocationWriter extends InvocationWriter {
                     Map<MethodNode, MethodNode> bridgeMethods = declaringClass.getNodeMetaData(StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODS);
                     bridge = bridgeMethods != null ? bridgeMethods.get(cn) : null;
                 }
-                if (bridge != null && bridge instanceof ConstructorNode) {
+                if (bridge instanceof ConstructorNode) {
                     ArgumentListExpression newArgs = new ArgumentListExpression(new ConstantExpression(null));
                     for (Expression arg: args) {
                         newArgs.addExpression(arg);
@@ -247,7 +247,7 @@ public class StaticInvocationWriter extends InvocationWriter {
                     ClassNode current = thisClass.getOuterClass();
                     fixedReceiver = new VariableExpression("thisObject", current);
                     // adjust for multiple levels of nesting if needed
-                    while (current != null && current instanceof InnerClassNode && !lookupClassNode.equals(current)) {
+                    while (current instanceof InnerClassNode && !lookupClassNode.equals(current)) {
                         FieldNode thisField = current.getField("this$0");
                         current = current.getOuterClass();
                         if (thisField != null) {
@@ -359,7 +359,7 @@ public class StaticInvocationWriter extends InvocationWriter {
                     ClassNode current = classNode.getOuterClass();
                     fixedReceiver = new VariableExpression("thisObject", current);
                     // adjust for multiple levels of nesting if needed
-                    while (current != null && current instanceof InnerClassNode && !classNode.equals(current)) {
+                    while (current instanceof InnerClassNode && !classNode.equals(current)) {
                         FieldNode thisField = current.getField("this$0");
                         current = current.getOuterClass();
                         if (thisField != null) {
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index f89a675994..b717c42e99 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -639,7 +639,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         // first, direct access from within the class or inner class nodes
         if (declaringClass.equals(receiverType)) return true;
         if (receiverType instanceof InnerClassNode) {
-            while (receiverType!=null && receiverType instanceof InnerClassNode) {
+            while (receiverType instanceof InnerClassNode) {
                 if (declaringClass.equals(receiverType)) return true;
                 receiverType = receiverType.getOuterClass();
             }
diff --git a/src/main/java/org/codehaus/groovy/control/ErrorCollector.java b/src/main/java/org/codehaus/groovy/control/ErrorCollector.java
index b388caa68c..d6c97a80ee 100644
--- a/src/main/java/org/codehaus/groovy/control/ErrorCollector.java
+++ b/src/main/java/org/codehaus/groovy/control/ErrorCollector.java
@@ -242,7 +242,7 @@ public class ErrorCollector {
         SyntaxException exception = null;
 
         Message message = getError(index);
-        if (message != null && message instanceof SyntaxErrorMessage) {
+        if (message instanceof SyntaxErrorMessage) {
             exception = ((SyntaxErrorMessage) message).getCause();
         }
         return exception;
diff --git a/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
index 199b4ad8b4..86ff461f97 100644
--- a/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -199,7 +199,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
 
     protected Expression transformVariableExpression(VariableExpression ve) {
         Variable v = ve.getAccessedVariable();
-        if (v != null && v instanceof DynamicVariable) {
+        if (v instanceof DynamicVariable) {
             Expression result = findStaticFieldOrPropAccessorImportFromModule(v.getName());
             if (result != null) {
                 setSourcePosition(result, ve);
diff --git a/src/main/java/org/codehaus/groovy/control/StaticVerifier.java b/src/main/java/org/codehaus/groovy/control/StaticVerifier.java
index 53706f91d1..6bf3908886 100644
--- a/src/main/java/org/codehaus/groovy/control/StaticVerifier.java
+++ b/src/main/java/org/codehaus/groovy/control/StaticVerifier.java
@@ -59,7 +59,7 @@ public class StaticVerifier extends ClassCodeVisitorSupport {
     @Override
     public void visitVariableExpression(VariableExpression ve) {
         Variable v = ve.getAccessedVariable();
-        if (v != null && v instanceof DynamicVariable) {
+        if (v instanceof DynamicVariable) {
             if (!inPropertyExpression || inSpecialConstructorCall) addStaticVariableError(ve);
         }
     }
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index 8aad2e6bf8..c5f9c11c4d 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -405,7 +405,7 @@ public class CachedClass {
     }
 
     private void addSubclassExpandos(List<MetaMethod> arr, MetaClass mc) {
-        if (mc != null && mc instanceof ExpandoMetaClass) {
+        if (mc instanceof ExpandoMetaClass) {
             ExpandoMetaClass emc = (ExpandoMetaClass) mc;
             for (Object mm : emc.getExpandoSubclassMethods()) {
                 if (mm instanceof MetaMethod) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
index 8b102db097..f75c08b4db 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -509,7 +509,7 @@ public class InvokerHelper {
         } catch (InvokerInvocationException iie) {
             // GROOVY-5802 IAE for missing properties with classes that extend List
             Throwable cause = iie.getCause();
-            if (cause == null || !(cause instanceof IllegalArgumentException)) throw iie;
+            if (!(cause instanceof IllegalArgumentException)) throw iie;
         }
     }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java b/src/main/java/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java
index 7629ee7d89..29def6c857 100644
--- a/src/main/java/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java
@@ -246,7 +246,7 @@ public class ASTTransformationCollectorCodeVisitor extends ClassCodeVisitorSuppo
 
     private static AnnotationCollectorMode getMode(AnnotationNode node) {
         final Expression member = node.getMember("mode");
-        if (member != null && member instanceof PropertyExpression) {
+        if (member instanceof PropertyExpression) {
             PropertyExpression prop = (PropertyExpression) member;
             Expression oe = prop.getObjectExpression();
             if (oe instanceof ClassExpression) {
diff --git a/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
index 6e781adef4..c13c8ef98b 100644
--- a/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -94,20 +94,20 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
 
     public boolean memberHasValue(AnnotationNode node, String name, Object value) {
         final Expression member = node.getMember(name);
-        return member != null && member instanceof ConstantExpression && ((ConstantExpression) member).getValue().equals(value);
+        return member instanceof ConstantExpression && ((ConstantExpression) member).getValue().equals(value);
     }
 
     public Object getMemberValue(AnnotationNode node, String name) {
         final Expression member = node.getMember(name);
-        if (member != null && member instanceof ConstantExpression) return ((ConstantExpression) member).getValue();
+        if (member instanceof ConstantExpression) return ((ConstantExpression) member).getValue();
         return null;
     }
 
     public static String getMemberStringValue(AnnotationNode node, String name, String defaultValue) {
         final Expression member = node.getMember(name);
-        if (member != null && member instanceof ConstantExpression) {
+        if (member instanceof ConstantExpression) {
             Object result = ((ConstantExpression) member).getValue();
-            if (result != null && result instanceof String && isUndefined((String) result)) result = null;
+            if (result instanceof String && isUndefined((String) result)) result = null;
             if (result != null) return result.toString();
         }
         return defaultValue;
@@ -119,7 +119,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
 
     public int getMemberIntValue(AnnotationNode node, String name) {
         Object value = getMemberValue(node, name);
-        if (value != null && value instanceof Integer) {
+        if (value instanceof Integer) {
             return (Integer) value;
         }
         return 0;
@@ -178,7 +178,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     public static List<String> getMemberList(AnnotationNode anno, String name) {
         List<String> list;
         Expression expr = anno.getMember(name);
-        if (expr != null && expr instanceof ListExpression) {
+        if (expr instanceof ListExpression) {
             final ListExpression listExpression = (ListExpression) expr;
             list = getValueStringList(listExpression);
         } else {
@@ -190,7 +190,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     private static List<String> getValueStringList(ListExpression listExpression) {
         List<String> list = new ArrayList<String>();
         for (Expression itemExpr : listExpression.getExpressions()) {
-            if (itemExpr != null && itemExpr instanceof ConstantExpression) {
+            if (itemExpr instanceof ConstantExpression) {
                 Object value = ((ConstantExpression) itemExpr).getValue();
                 if (value != null) list.add(value.toString());
             }
@@ -202,10 +202,10 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     public List<ClassNode> getClassList(AnnotationNode anno, String name) {
         List<ClassNode> list = new ArrayList<ClassNode>();
         Expression expr = anno.getMember(name);
-        if (expr != null && expr instanceof ListExpression) {
+        if (expr instanceof ListExpression) {
             final ListExpression listExpression = (ListExpression) expr;
             list = getTypeList(listExpression);
-        } else if (expr != null && expr instanceof ClassExpression) {
+        } else if (expr instanceof ClassExpression) {
             ClassNode cn = expr.getType();
             if (cn != null) list.add(cn);
         }
@@ -235,7 +235,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     private static List<ClassNode> getTypeList(ListExpression listExpression) {
         List<ClassNode> list = new ArrayList<ClassNode>();
         for (Expression itemExpr : listExpression.getExpressions()) {
-            if (itemExpr != null && itemExpr instanceof ClassExpression) {
+            if (itemExpr instanceof ClassExpression) {
                 ClassNode cn = itemExpr.getType();
                 if (cn != null) list.add(cn);
             }
diff --git a/src/main/java/org/codehaus/groovy/transform/AutoCloneASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
index a7827755c1..c935502cb8 100644
--- a/src/main/java/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
@@ -289,7 +289,7 @@ public class AutoCloneASTTransformation extends AbstractASTTransformation {
 
     private static AutoCloneStyle getStyle(AnnotationNode node, String name) {
         final Expression member = node.getMember(name);
-        if (member != null && member instanceof PropertyExpression) {
+        if (member instanceof PropertyExpression) {
             PropertyExpression prop = (PropertyExpression) member;
             Expression oe = prop.getObjectExpression();
             if (oe instanceof ClassExpression) {
diff --git a/src/main/java/org/codehaus/groovy/transform/BuilderASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/BuilderASTTransformation.java
index 3cc49a2de3..3f4ea2701f 100644
--- a/src/main/java/org/codehaus/groovy/transform/BuilderASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/BuilderASTTransformation.java
@@ -121,7 +121,7 @@ public class BuilderASTTransformation extends AbstractASTTransformation implemen
 
         protected boolean unsupportedAttribute(BuilderASTTransformation transform, AnnotationNode anno, String memberName, String extraMessage) {
             Object memberValue = transform.getMemberValue(anno, memberName);
-            if (memberValue != null && memberValue instanceof String && isUndefined((String) memberValue)) return false;
+            if (memberValue instanceof String && isUndefined((String) memberValue)) return false;
             if (memberValue == null) {
                 memberValue = transform.getMemberClassValue(anno, memberName);
                 if (memberValue != null && isUndefined((ClassNode) memberValue)) {
diff --git a/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
index 6189c1cf72..2e9831c0b4 100644
--- a/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
@@ -281,7 +281,7 @@ public class CategoryASTTransformation implements ASTTransformation, Opcodes {
 
     private static ClassNode getTargetClass(SourceUnit source, AnnotationNode annotation) {
         Expression value = annotation.getMember("value");
-        if (value == null || !(value instanceof ClassExpression)) {
+        if (!(value instanceof ClassExpression)) {
             //noinspection ThrowableInstanceNeverThrown
             source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
                     new SyntaxException("@groovy.lang.Category must define 'value' which is the class to apply this category to",
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/ListExpressionTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/ListExpressionTransformer.java
index 55970e65ad..a415d054bd 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/ListExpressionTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/ListExpressionTransformer.java
@@ -41,7 +41,7 @@ public class ListExpressionTransformer {
 
     Expression transformListExpression(final ListExpression expr) {
         MethodNode target = expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
-        if (target!=null && target instanceof ConstructorNode) {
+        if (target instanceof ConstructorNode) {
             if (target.getDeclaringClass().isArray()) {
                 return transformArrayConstructor(expr, target);
             }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index f944c99c48..afb91d1a8b 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -702,7 +702,7 @@ public abstract class StaticTypeCheckingSupport {
 
         // char as left expression
         if (leftRedirect == char_TYPE && rightRedirect==STRING_TYPE) {
-            if (rightExpression!=null && rightExpression instanceof ConstantExpression) {
+            if (rightExpression instanceof ConstantExpression) {
                 String value = rightExpression.getText();
                 return value.length()==1;
             }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index d335b6d896..760eeedc7c 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1819,7 +1819,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (key instanceof VariableExpression) {
                 ClassNode origType = varOrigType.get(key);
                 ClassNode newType = entry.getValue();
-                if (varOrigType.containsKey(key) && (origType == null || !newType.equals(origType))) {
+                if (varOrigType.containsKey(key) && (!newType.equals(origType))) {
                     return true;
                 }
             }
@@ -2885,7 +2885,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     final List<Expression> expressions = arguments.getExpressions();
                     final int expressionsSize = expressions.size();
                     Expression parameter = annotation.getMember("target");
-                    String parameterName = parameter!=null && parameter instanceof ConstantExpression ?parameter.getText():"";
+                    String parameterName = parameter instanceof ConstantExpression ?parameter.getText():"";
                     // todo: handle vargs!
                     for (int j = 0, paramsLength = params.length; j < paramsLength; j++) {
                         final Parameter methodParam = params[j];
@@ -2893,12 +2893,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (targets != null && targets.size() == 1) {
                             AnnotationNode targetAnnotation = targets.get(0); // @DelegatesTo.Target Obj foo
                             Expression idMember = targetAnnotation.getMember("value");
-                            String id = idMember != null && idMember instanceof ConstantExpression ? idMember.getText() : "";
+                            String id = idMember instanceof ConstantExpression ? idMember.getText() : "";
                             if (id.equals(parameterName)) {
                                 if (j < expressionsSize) {
                                     Expression actualArgument = expressions.get(j);
                                     ClassNode actualType = getType(actualArgument);
-                                    if (genericTypeIndex!=null && genericTypeIndex instanceof ConstantExpression) {
+                                    if (genericTypeIndex instanceof ConstantExpression) {
                                         int gti = Integer.parseInt(genericTypeIndex.getText());
                                         ClassNode paramType = methodParam.getType(); // type annotated with @DelegatesTo.Target
                                         GenericsType[] genericsTypes = paramType.getGenericsTypes();
@@ -3710,7 +3710,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     /// it seems attractive to want to do this for more cases but perhaps not all cases
     private ClassNode checkForTargetType(final Expression expr, final ClassNode type) {
         BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();
-        if (enclosingBinaryExpression != null && enclosingBinaryExpression instanceof DeclarationExpression
+        if (enclosingBinaryExpression instanceof DeclarationExpression
                 && isEmptyCollection(expr) && isAssignment(enclosingBinaryExpression.getOperation().getType())) {
             VariableExpression target = (VariableExpression) enclosingBinaryExpression.getLeftExpression();
             return adjustForTargetType(target.getType(), type);
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index a7c647f636..2e98b48647 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -77,7 +77,7 @@ public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
                 } else if (isThisTraitReceiver(var)) {
                     type = receiver;
                 }
-                if (type != null && Traits.isTrait(type) && !(type instanceof UnionTypeClassNode)) {
+                if (Traits.isTrait(type) && !(type instanceof UnionTypeClassNode)) {
                     ClassNode helper = Traits.findHelper(type);
                     Parameter[] params = new Parameter[argumentTypes.length + 1];
                     params[0] = new Parameter(ClassHelper.CLASS_Type.getPlainNodeReference(), "staticSelf");

Commit:
0e737d7b9f9a0e695b179babd37b19fad5e078c1
Paul King
paulk@asert.com.au
2018-04-03 08:50:18 +1000
GROOVY-8523 Static type checking instanceof_not (closes #680)
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 4419379d77..d335b6d896 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -73,6 +73,8 @@ import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.ast.expr.UnaryMinusExpression;
 import org.codehaus.groovy.ast.expr.UnaryPlusExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.expr.NotExpression;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.CaseStatement;
 import org.codehaus.groovy.ast.stmt.CatchStatement;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
@@ -96,6 +98,7 @@ import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.TokenUtil;
+import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.StaticTypesTransformation;
 import org.codehaus.groovy.transform.trait.Traits;
 import org.codehaus.groovy.util.ListHashMap;
@@ -3465,6 +3468,95 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         } finally {
             popAssignmentTracking(oldTracker);
         }
+        BinaryExpression instanceOfExpression = findInstanceOfNotReturnExpression(ifElse);
+        if (instanceOfExpression == null) {
+        } else {
+            if(typeCheckingContext.enclosingBlocks.size()>0) {
+                visitInstanceofNot(instanceOfExpression);
+            }
+        }
+    }
+
+
+    public void visitInstanceofNot(BinaryExpression be) {
+        final BlockStatement currentBlock = typeCheckingContext.enclosingBlocks.getFirst();
+        assert currentBlock != null;
+        if (typeCheckingContext.blockStatements2Types.containsKey(currentBlock)) {
+            // another instanceOf_not was before, no need store vars
+        } else {
+            // saving type of variables to restoring them after returning from block
+            Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();
+            getTypeCheckingContext().pushTemporaryTypeInfo();
+            typeCheckingContext.blockStatements2Types.put(currentBlock, oldTracker);
+        }
+        pushInstanceOfTypeInfo(be.getLeftExpression(), be.getRightExpression());
+    }
+
+
+    @Override
+    public void visitBlockStatement(BlockStatement block) {
+        if (block != null) {
+            typeCheckingContext.enclosingBlocks.addFirst(block);
+        }
+        super.visitBlockStatement(block);
+        if (block != null) {
+            visitClosingBlock(block);
+        }
+    }
+
+    public void visitClosingBlock(BlockStatement block) {
+        BlockStatement peekBlock = typeCheckingContext.enclosingBlocks.removeFirst();
+        boolean found = typeCheckingContext.blockStatements2Types.containsKey(peekBlock);
+        if (found) {
+            Map<VariableExpression, List<ClassNode>> oldTracker = typeCheckingContext.blockStatements2Types.remove(peekBlock);
+            getTypeCheckingContext().popTemporaryTypeInfo();
+            popAssignmentTracking(oldTracker);
+        }
+    }
+
+    /**
+     * Check IfStatement matched pattern :
+     * Object var1;
+     * if (!(var1 instanceOf Runnable)){
+     * return
+     * }
+     * // Here var1 instance of Runnable
+     *
+     * Return expression , which contains instanceOf (without not)
+     * Return null, if not found
+     */
+    public BinaryExpression findInstanceOfNotReturnExpression(IfStatement ifElse) {
+        Statement elseBlock = ifElse.getElseBlock();
+        if (!(elseBlock instanceof EmptyStatement)) {
+            return null;
+        }
+        Expression conditionExpression = ifElse.getBooleanExpression().getExpression();
+        if (!(conditionExpression instanceof NotExpression)) {
+            return null;
+        }
+        NotExpression notExpression = (NotExpression) conditionExpression;
+        Expression expression = notExpression.getExpression();
+        if (!(expression instanceof BinaryExpression)) {
+            return null;
+        }
+        BinaryExpression instanceOfExpression = (BinaryExpression) expression;
+        int op = instanceOfExpression.getOperation().getType();
+        if (op != Types.KEYWORD_INSTANCEOF) {
+            return null;
+        }
+        Statement block = ifElse.getIfBlock();
+        if (!(block instanceof BlockStatement)) {
+            return null;
+        }
+        BlockStatement bs = (BlockStatement) block;
+        if (bs.getStatements().size() == 0) {
+            return null;
+        }
+        Statement last = DefaultGroovyMethods.last(bs.getStatements());
+        if (!(last instanceof ReturnStatement)) {
+            return null;
+        }
+        return instanceOfExpression;
     }
 
     @Override
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java b/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
index 57fcee0929..4d0b0973e2 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
@@ -27,6 +27,7 @@ import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.ErrorCollector;
 import org.codehaus.groovy.control.SourceUnit;
@@ -34,6 +35,7 @@ import org.codehaus.groovy.control.SourceUnit;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.IdentityHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -51,6 +53,8 @@ public class TypeCheckingContext {
     protected final LinkedList<ClassNode> enclosingClassNodes = new LinkedList<ClassNode>();
     protected final LinkedList<MethodNode> enclosingMethods = new LinkedList<MethodNode>();
     protected final LinkedList<Expression> enclosingMethodCalls = new LinkedList<Expression>();
+    protected final LinkedList<BlockStatement> enclosingBlocks = new LinkedList<BlockStatement>();
+
 
     // used for closure return type inference
     protected final LinkedList<EnclosingClosure> enclosingClosures = new LinkedList<EnclosingClosure>();
@@ -68,6 +72,20 @@ public class TypeCheckingContext {
      * be the LUB of (int, String)
      */
     protected Map<VariableExpression, List<ClassNode>> ifElseForWhileAssignmentTracker = null;
+
+
+    /**
+     * This field used for type derivation
+     * Check IfStatement matched pattern :
+     * Object var1;
+     * if (!(var1 instanceOf Runnable)){
+     * return
+     * }
+     * // Here var1 instance of Runnable
+     */
+    protected final IdentityHashMap<BlockStatement, Map<VariableExpression, List<ClassNode>>> blockStatements2Types = new IdentityHashMap<BlockStatement, Map<VariableExpression, List<ClassNode>>>();
+
+
     /**
      * Stores information which is only valid in the "if" branch of an if-then-else statement. This is used when the if
      * condition expression makes use of an instanceof check
diff --git a/src/test/groovy/bugs/Groovy8523Bug.groovy b/src/test/groovy/bugs/Groovy8523Bug.groovy
new file mode 100755
index 0000000000..ac598544e1
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8523Bug.groovy
@@ -0,0 +1,111 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy8523Bug extends GroovyTestCase {
+    void testInstanceofNot1() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        @CompileStatic
+        class Test1 {
+            static int checkRes = 0
+
+            static void f1(Object var1) {
+                if(!(var1 instanceof Runnable)){
+                    checkRes = 3
+                    return;
+                }
+                f2(var1)
+            }
+
+            static void f2(Runnable var2) {
+                checkRes = 4
+            }
+        }
+
+        Runnable r = {}
+        Test1.f1(r)
+        assert Test1.checkRes == 4;
+        '''
+    }
+
+
+    void testInstanceofNot2() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        @CompileStatic
+        class Test1 {
+            static int checkRes = 0
+
+            static void f1(Object var1) {
+                if(!(var1 instanceof Runnable)){
+                    checkRes = 3
+                    return;
+                }
+                if(!(var1 instanceof List)){
+                    checkRes = 5
+                    return;
+                }
+                f2(var1)
+            }
+
+            static void f2(Runnable var2) {
+                checkRes = 4
+            }
+        }
+
+        Runnable r = {}
+        Test1.f1(r)
+        assert Test1.checkRes == 5;
+        '''
+    }
+
+
+    void testInstanceofNot3() {
+        assertScript '''
+        import groovy.transform.CompileStatic
+        @CompileStatic
+        class Test1 {
+            static int checkRes = 0
+
+            static void f1(Object var1) {
+                if(!(var1 instanceof Runnable)){
+                    checkRes = 3
+                    return;
+                }
+                if(!(var1 instanceof Thread)){
+                    checkRes = 5
+                    return;
+                }
+                f2(var1)
+            }
+
+            static void f2(Runnable var2) {
+                checkRes = 4
+            }
+        }
+
+        Runnable r = {}
+        Test1.f1(r)
+        assert Test1.checkRes == 5;
+        '''
+    }
+
+
+}

Commit:
1bcaaeaf60078dd5a9aca5cbf1df8f45de68db60
sunlan
sunlan@apache.org
2018-04-03 00:12:54 +0800
Add the missing `serialVersionUID`
diff --git a/src/main/groovy/groovy/cli/TypedOption.java b/src/main/groovy/groovy/cli/TypedOption.java
index e669324834..3ac915c35f 100644
--- a/src/main/groovy/groovy/cli/TypedOption.java
+++ b/src/main/groovy/groovy/cli/TypedOption.java
@@ -21,6 +21,8 @@ package groovy.cli;
 import java.util.HashMap;
 
 public class TypedOption<T> extends HashMap<String, T> {
+    private static final long serialVersionUID = 8931624081859777854L;
+
     public T defaultValue() {
         return (T) super.get("defaultValue");
     }
diff --git a/src/main/groovy/groovy/lang/Closure.java b/src/main/groovy/groovy/lang/Closure.java
index 11e261135e..9446186b8c 100644
--- a/src/main/groovy/groovy/lang/Closure.java
+++ b/src/main/groovy/groovy/lang/Closure.java
@@ -197,6 +197,8 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
     public static final int DONE = 1, SKIP = 2;
     private static final Object[] EMPTY_OBJECT_ARRAY = {};
     public static final Closure IDENTITY = new Closure<Object>(null) {
+        private static final long serialVersionUID = 730973623329943963L;
+
         public Object doCall(Object args) {
             return args;
         }
@@ -846,6 +848,8 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
      * inner class instead of the outer!
      */
     private class WritableClosure extends Closure implements Writable {
+        private static final long serialVersionUID = -5749205698681690370L;
+
         public WritableClosure() {
             super(Closure.this);
         }
diff --git a/src/main/groovy/groovy/lang/ClosureException.java b/src/main/groovy/groovy/lang/ClosureException.java
index 12986ad3b7..7a55631000 100644
--- a/src/main/groovy/groovy/lang/ClosureException.java
+++ b/src/main/groovy/groovy/lang/ClosureException.java
@@ -25,6 +25,7 @@ package groovy.lang;
  */
 public class ClosureException extends RuntimeException {
 
+    private static final long serialVersionUID = -945565055750688719L;
     private final Closure closure;
     
     public ClosureException(Closure closure, Throwable cause) {
diff --git a/src/main/groovy/groovy/lang/DeprecationException.java b/src/main/groovy/groovy/lang/DeprecationException.java
index 36ad893f46..8e5d087125 100644
--- a/src/main/groovy/groovy/lang/DeprecationException.java
+++ b/src/main/groovy/groovy/lang/DeprecationException.java
@@ -33,6 +33,8 @@ package groovy.lang;
  */
 public class DeprecationException extends RuntimeException {
 
+    private static final long serialVersionUID = 8828016729085737697L;
+
     public DeprecationException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/GroovyRuntimeException.java b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
index 33eb51ced8..00f8f96ba8 100644
--- a/src/main/groovy/groovy/lang/GroovyRuntimeException.java
+++ b/src/main/groovy/groovy/lang/GroovyRuntimeException.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.ast.ModuleNode;
  */
 public class GroovyRuntimeException extends RuntimeException {
 
+    private static final long serialVersionUID = 3699943230572902549L;
     private ModuleNode module;
     private ASTNode node;
 
diff --git a/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java b/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
index 8227e3f087..b7971d9569 100644
--- a/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
+++ b/src/main/groovy/groovy/lang/IllegalPropertyAccessException.java
@@ -28,7 +28,9 @@ import java.lang.reflect.Modifier;
  * @author <a href="mailto:blackdrag@uni.de">Jochen Theodorou</a>
  */
 public class IllegalPropertyAccessException extends MissingPropertyException {
-    
+
+    private static final long serialVersionUID = 8149534204771978786L;
+
     private static String makeMessage(String propertyName, Class clazz, int modifiers, boolean isField) {
         String access = "private";
         if (Modifier.isProtected(modifiers)) access = "protected";
diff --git a/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java b/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
index f5b23f51ef..236f399a9c 100644
--- a/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
+++ b/src/main/groovy/groovy/lang/IncorrectClosureArgumentsException.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.runtime.InvokerHelper;
  */
 public class IncorrectClosureArgumentsException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 4208144749858078754L;
     private final Closure closure;
     private final Object arguments;
     private final Class[] expected;
diff --git a/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java b/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
index c882fda950..484efa3187 100644
--- a/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
+++ b/src/main/groovy/groovy/lang/MetaClassRegistryChangeEvent.java
@@ -26,6 +26,7 @@ import java.util.EventObject;
  * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  */
 public class MetaClassRegistryChangeEvent extends EventObject {
+    private static final long serialVersionUID = 1647849176793457976L;
     private final Class clazz;
     private final Object instance;
     private final MetaClass metaClass;
diff --git a/src/main/groovy/groovy/lang/MissingClassException.java b/src/main/groovy/groovy/lang/MissingClassException.java
index ad8e5f5c91..b3579a644a 100644
--- a/src/main/groovy/groovy/lang/MissingClassException.java
+++ b/src/main/groovy/groovy/lang/MissingClassException.java
@@ -31,6 +31,7 @@ import org.codehaus.groovy.ast.ClassNode;
  */
 public class MissingClassException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = -4059735896182191589L;
     private final String type;
 
     public MissingClassException(String type, ASTNode node, String message) {
diff --git a/src/main/groovy/groovy/lang/MissingFieldException.java b/src/main/groovy/groovy/lang/MissingFieldException.java
index 3c17d3965d..4a222f559d 100644
--- a/src/main/groovy/groovy/lang/MissingFieldException.java
+++ b/src/main/groovy/groovy/lang/MissingFieldException.java
@@ -29,6 +29,7 @@ package groovy.lang;
  */
 public class MissingFieldException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = -9209464582858098430L;
     private final String field;
     private final Class type;
 
diff --git a/src/main/groovy/groovy/lang/MissingMethodException.java b/src/main/groovy/groovy/lang/MissingMethodException.java
index ae2eea18ec..b463c341e0 100644
--- a/src/main/groovy/groovy/lang/MissingMethodException.java
+++ b/src/main/groovy/groovy/lang/MissingMethodException.java
@@ -30,6 +30,7 @@ import org.codehaus.groovy.runtime.MethodRankHelper;
 public class MissingMethodException extends GroovyRuntimeException {
 
     private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
+    private static final long serialVersionUID = -2423785115382704124L;
     private final String method;
     private final Class type;
     private final boolean isStatic;
diff --git a/src/main/groovy/groovy/lang/MissingPropertyException.java b/src/main/groovy/groovy/lang/MissingPropertyException.java
index 270f039d83..552031a28d 100644
--- a/src/main/groovy/groovy/lang/MissingPropertyException.java
+++ b/src/main/groovy/groovy/lang/MissingPropertyException.java
@@ -32,6 +32,7 @@ import org.codehaus.groovy.runtime.MethodRankHelper;
 public class MissingPropertyException extends GroovyRuntimeException {
 
     public static final Object MPE = new Object();
+    private static final long serialVersionUID = -5493778577329511881L;
 
     private final String property;
     private final Class type;
diff --git a/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java b/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
index 342a182acd..77231d246d 100644
--- a/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
+++ b/src/main/groovy/groovy/lang/ReadOnlyPropertyException.java
@@ -26,6 +26,8 @@ package groovy.lang;
  */
 public class ReadOnlyPropertyException extends MissingPropertyException {
 
+    private static final long serialVersionUID = -1800912081930896077L;
+
     public ReadOnlyPropertyException(final String property, final Class type) {
         super("Cannot set readonly property: " + property + " for class: " + type.getName(), property, type);
     }
diff --git a/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java b/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
index b6de965cd0..f3360d328a 100644
--- a/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
+++ b/src/main/groovy/groovy/lang/SpreadListEvaluatingException.java
@@ -19,6 +19,8 @@
 package groovy.lang;
 
 public class SpreadListEvaluatingException extends GroovyRuntimeException {
+    private static final long serialVersionUID = 4565947835333349093L;
+
     public SpreadListEvaluatingException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/SpreadMap.java b/src/main/groovy/groovy/lang/SpreadMap.java
index 0fc6542b44..b9d742b06c 100644
--- a/src/main/groovy/groovy/lang/SpreadMap.java
+++ b/src/main/groovy/groovy/lang/SpreadMap.java
@@ -32,6 +32,7 @@ import java.util.Map;
  * @author Tim Tiemens
  */
 public class SpreadMap extends HashMap {
+    private static final long serialVersionUID = 2870520857928038334L;
     private int hashCode;
 
     public SpreadMap(Object[] values) {
diff --git a/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java b/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
index 408a2239cd..ee9dd21518 100644
--- a/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
+++ b/src/main/groovy/groovy/lang/SpreadMapEvaluatingException.java
@@ -19,6 +19,8 @@
 package groovy.lang;
 
 public class SpreadMapEvaluatingException extends GroovyRuntimeException {
+    private static final long serialVersionUID = 4347220269418595368L;
+
     public SpreadMapEvaluatingException(String message) {
         super(message);
     }
diff --git a/src/main/groovy/groovy/lang/StringWriterIOException.java b/src/main/groovy/groovy/lang/StringWriterIOException.java
index 0372399dae..9fef866a32 100644
--- a/src/main/groovy/groovy/lang/StringWriterIOException.java
+++ b/src/main/groovy/groovy/lang/StringWriterIOException.java
@@ -27,6 +27,8 @@ import java.io.IOException;
  */
 public class StringWriterIOException extends RuntimeException {
 
+    private static final long serialVersionUID = -504499949457372681L;
+
     public StringWriterIOException(IOException e) {
         super(e);
     }
diff --git a/src/main/groovy/groovy/lang/TrampolineClosure.java b/src/main/groovy/groovy/lang/TrampolineClosure.java
index ed68f00445..71f31c8f69 100644
--- a/src/main/groovy/groovy/lang/TrampolineClosure.java
+++ b/src/main/groovy/groovy/lang/TrampolineClosure.java
@@ -30,6 +30,7 @@ package groovy.lang;
  */
 final class TrampolineClosure<V> extends Closure<V> {
 
+    private static final long serialVersionUID = -4096349147398489925L;
     private final Closure<V> original;
 
     TrampolineClosure(final Closure<V> original) {
diff --git a/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java b/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
index e723e0b98f..49032cdccb 100644
--- a/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
+++ b/src/main/groovy/groovy/security/GroovyCodeSourcePermission.java
@@ -30,6 +30,8 @@ import java.security.BasicPermission;
  */
 public final class GroovyCodeSourcePermission extends BasicPermission {
 
+    private static final long serialVersionUID = 8014290770546281019L;
+
     public GroovyCodeSourcePermission(String name) {
         super(name);
     }
diff --git a/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java b/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
index aed167a233..622acfd962 100644
--- a/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
+++ b/src/main/groovy/groovy/transform/stc/IncorrectTypeHintException.java
@@ -22,6 +22,8 @@ import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.syntax.SyntaxException;
 
 public class IncorrectTypeHintException extends SyntaxException {
+    private static final long serialVersionUID = 4481159236968540419L;
+
     public IncorrectTypeHintException(final MethodNode mn, final Throwable e, int line, int column) {
         super("Incorrect type hint in @ClosureParams in class "+mn.getDeclaringClass().getName()+" method "+mn.getTypeDescriptor()+" : "+e.getMessage(), e, line, column);
     }
diff --git a/src/main/groovy/groovy/util/NodeList.java b/src/main/groovy/groovy/util/NodeList.java
index e54009c2d4..2822d9d147 100644
--- a/src/main/groovy/groovy/util/NodeList.java
+++ b/src/main/groovy/groovy/util/NodeList.java
@@ -38,6 +38,8 @@ import java.util.List;
  * @author Paul King
  */
 public class NodeList extends ArrayList {
+    private static final long serialVersionUID = 5454686773425258279L;
+
     static {
         // wrap the standard MetaClass with the delegate
         setMetaClass(NodeList.class, GroovySystem.getMetaClassRegistry().getMetaClass(NodeList.class));
diff --git a/src/main/groovy/groovy/util/ObjectGraphBuilder.java b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
index 1004369913..ce031c71e9 100644
--- a/src/main/groovy/groovy/util/ObjectGraphBuilder.java
+++ b/src/main/groovy/groovy/util/ObjectGraphBuilder.java
@@ -78,6 +78,8 @@ public class ObjectGraphBuilder extends FactoryBuilderSupport {
         referenceResolver = new DefaultReferenceResolver();
 
         addPostNodeCompletionDelegate(new Closure(this, this) {
+            private static final long serialVersionUID = 7282290918368141309L;
+
             public void doCall(ObjectGraphBuilder builder, Object parent, Object node) {
                 if (parent == null) {
                     builder.resolveLazyReferences();
diff --git a/src/main/groovy/groovy/util/ResourceException.java b/src/main/groovy/groovy/util/ResourceException.java
index 8b31d7ec89..0f57b5372c 100644
--- a/src/main/groovy/groovy/util/ResourceException.java
+++ b/src/main/groovy/groovy/util/ResourceException.java
@@ -23,6 +23,8 @@ package groovy.util;
  */
 public class ResourceException extends Exception {
 
+    private static final long serialVersionUID = -4640685456255837192L;
+
     /**
      *
      */
diff --git a/src/main/groovy/groovy/util/ScriptException.java b/src/main/groovy/groovy/util/ScriptException.java
index 85ce60fd2b..491b94a85e 100644
--- a/src/main/groovy/groovy/util/ScriptException.java
+++ b/src/main/groovy/groovy/util/ScriptException.java
@@ -23,6 +23,8 @@ package groovy.util;
  */
 public class ScriptException extends Exception {
 
+    private static final long serialVersionUID = 3447547760007143671L;
+
     /**
      *
      */
diff --git a/src/main/java/org/codehaus/groovy/GroovyBugError.java b/src/main/java/org/codehaus/groovy/GroovyBugError.java
index 30ed7de57d..89d855da1a 100644
--- a/src/main/java/org/codehaus/groovy/GroovyBugError.java
+++ b/src/main/java/org/codehaus/groovy/GroovyBugError.java
@@ -26,7 +26,8 @@ package org.codehaus.groovy;
  * @author Jochen Theodorou
  */
 public class GroovyBugError extends AssertionError {
-    
+
+    private static final long serialVersionUID = 7170193853899664927L;
     // message string
     private String message;
     // optional exception
diff --git a/src/main/java/org/codehaus/groovy/GroovyException.java b/src/main/java/org/codehaus/groovy/GroovyException.java
index 582da48782..61826f59ab 100644
--- a/src/main/java/org/codehaus/groovy/GroovyException.java
+++ b/src/main/java/org/codehaus/groovy/GroovyException.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy;
 
 public class GroovyException extends Exception implements GroovyExceptionInterface {
+    private static final long serialVersionUID = -61298636122042408L;
     private boolean fatal = true;
 
     public GroovyException() {
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
index 204674b885..372b04da36 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTParserException.java
@@ -26,6 +26,7 @@ import org.codehaus.groovy.syntax.ParserException;
  *
  */
 public class ASTParserException extends ParserException {
+    private static final long serialVersionUID = 2537232761345194260L;
     private final AST ast;
 
     public ASTParserException(ASTRuntimeException e) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
index aec85d40e0..032c24d3ac 100644
--- a/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
+++ b/src/main/java/org/codehaus/groovy/antlr/ASTRuntimeException.java
@@ -24,6 +24,7 @@ import antlr.collections.AST;
  * @author <a href="mailto:jstrachan@protique.com">James Strachan</a>
  */
 public class ASTRuntimeException extends RuntimeException {
+    private static final long serialVersionUID = 3980229202392379560L;
     private final AST ast;
 
     public ASTRuntimeException(AST ast, String message) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
index d256e73b74..fc62836f7c 100644
--- a/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
+++ b/src/main/java/org/codehaus/groovy/antlr/GroovySourceAST.java
@@ -33,6 +33,7 @@ import java.util.List;
  * @author Jeremy Rayner <groovy@ross-rayner.com>
  */
 public class GroovySourceAST extends CommonAST implements Comparable, SourceInfo {
+    private static final long serialVersionUID = 2019901428136117486L;
     private int line;
     private int col;
     private int lineLast;
diff --git a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
index ecc8098811..94dd173f33 100644
--- a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
+++ b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
@@ -134,6 +134,8 @@ public class LexerFrame extends JFrame implements ActionListener {
     }
 
     private final Action loadFileAction = new AbstractAction("Open File...") {
+        private static final long serialVersionUID = 4541927184172762704L;
+
         public void actionPerformed(ActionEvent ae) {
             final JFileChooser jfc = new JFileChooser();
             final int response = jfc.showOpenDialog(LexerFrame.this);
@@ -264,6 +266,8 @@ public class LexerFrame extends JFrame implements ActionListener {
     }
 
     private static class HScrollableTextPane extends JTextPane {
+        private static final long serialVersionUID = -8582328309470654441L;
+
         @Override
         public boolean getScrollableTracksViewportWidth() {
             return (getSize().width < getParent().getSize().width);
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
index 57a3e154f9..3f6efbb364 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -75,7 +75,10 @@ public class WideningCategories {
 
     private static final List<ClassNode> EMPTY_CLASSNODE_LIST = Collections.emptyList();
 
-    private static final Map<ClassNode, Integer> NUMBER_TYPES_PRECEDENCE = Collections.unmodifiableMap(new HashMap<ClassNode, Integer>() {{
+    private static final Map<ClassNode, Integer> NUMBER_TYPES_PRECEDENCE = Collections.unmodifiableMap(new HashMap<ClassNode, Integer>() {
+        private static final long serialVersionUID = -5178744121420941913L;
+
+        {
         put(ClassHelper.double_TYPE, 0);
         put(ClassHelper.float_TYPE, 1);
         put(ClassHelper.long_TYPE, 2);
diff --git a/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java b/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
index bce34481b3..5c404ecb29 100644
--- a/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
+++ b/src/main/java/org/codehaus/groovy/classgen/ClassGeneratorException.java
@@ -25,6 +25,8 @@ package org.codehaus.groovy.classgen;
  */
 public class ClassGeneratorException extends RuntimeException {
 
+    private static final long serialVersionUID = 440899360174632769L;
+
     public ClassGeneratorException(String message) {
         super(message);
     }
diff --git a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
index 924a76e776..34c652a200 100644
--- a/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
+++ b/src/main/java/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
@@ -395,6 +395,8 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
     }
 
     private static class StateMap extends HashMap<Variable, VariableState> {
+        private static final long serialVersionUID = -5881634573411342092L;
+
         @Override
         public VariableState get(final Object key) {
             return super.get(getTarget((Variable) key));
diff --git a/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java b/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
index 741b647f21..2930b8c6f3 100644
--- a/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
+++ b/src/main/java/org/codehaus/groovy/control/CompilationFailedException.java
@@ -29,6 +29,7 @@ import groovy.lang.GroovyRuntimeException;
 
 public class CompilationFailedException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 4500269747315896966L;
     protected int phase;   // The phase in which the failures occurred
     protected ProcessingUnit unit;    // The *Unit object this exception wraps
 
diff --git a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
index 3d0658ab3f..9e226ad158 100644
--- a/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
+++ b/src/main/java/org/codehaus/groovy/control/ConfigurationException.java
@@ -31,8 +31,9 @@ import org.codehaus.groovy.GroovyExceptionInterface;
 
 public class ConfigurationException extends RuntimeException implements GroovyExceptionInterface
 {
-    
-  //---------------------------------------------------------------------------
+    private static final long serialVersionUID = -630757959041134069L;
+
+    //---------------------------------------------------------------------------
   // CONSTRUCTION AND SUCH
 
     protected Exception cause;   // The phase in which the failures occurred
diff --git a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
index e53762e01b..5e0a6e7523 100644
--- a/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
+++ b/src/main/java/org/codehaus/groovy/control/MultipleCompilationErrorsException.java
@@ -28,7 +28,8 @@ import java.io.Writer;
  */
 public class MultipleCompilationErrorsException extends
         CompilationFailedException {
-    
+
+    private static final long serialVersionUID = 2948487149304811836L;
     protected ErrorCollector collector;
     
     public MultipleCompilationErrorsException(ErrorCollector ec) {
diff --git a/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java b/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
index d0fc5416d7..1edf636658 100644
--- a/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
+++ b/src/main/java/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java
@@ -115,6 +115,8 @@ public class SourceAwareCustomizerFactory extends AbstractFactory implements Pos
         Closure<Boolean> extensionValidator = data.extensionValidator;
         if (extensionValidator==null && !extensions.isEmpty()) {
             extensionValidator = new Closure<Boolean>(sourceAwareCustomizer) {
+                private static final long serialVersionUID = 925642730835101872L;
+
                 @Override
                 @SuppressWarnings("unchecked")
                 public Boolean call(final Object arguments) {
@@ -131,6 +133,8 @@ public class SourceAwareCustomizerFactory extends AbstractFactory implements Pos
         Closure<Boolean> basenameValidator = data.basenameValidator;
         if (basenameValidator==null && !basenames.isEmpty()) {
             basenameValidator = new Closure<Boolean>(sourceAwareCustomizer) {
+                private static final long serialVersionUID = 7714937867958607043L;
+
                 @Override
                 @SuppressWarnings("unchecked")
                 public Boolean call(final Object arguments) {
diff --git a/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java b/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
index c5388130c4..8dfa960ec8 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CacheAccessControlException.java
@@ -21,6 +21,8 @@ package org.codehaus.groovy.reflection;
 import groovy.lang.GroovyRuntimeException;
 
 public class CacheAccessControlException extends GroovyRuntimeException {
+    private static final long serialVersionUID = -5315107566539656474L;
+
     public CacheAccessControlException(String message, Throwable cause) {
         super(message, cause);
     }
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index c5ca547bde..8aad2e6bf8 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -60,6 +60,8 @@ public class CachedClass {
     private static ReferenceBundle softBundle = ReferenceBundle.getSoftBundle();
 
     private final LazyReference<CachedField[]> fields = new LazyReference<CachedField[]>(softBundle) {
+        private static final long serialVersionUID = 5450437842165410025L;
+
         public CachedField[] initValue() {
             final Field[] declaredFields = (Field[])
                AccessController.doPrivileged(new PrivilegedAction<Field[]>() {
@@ -77,6 +79,8 @@ public class CachedClass {
     };
 
     private final LazyReference<CachedConstructor[]> constructors = new LazyReference<CachedConstructor[]>(softBundle) {
+        private static final long serialVersionUID = -5834446523983631635L;
+
         public CachedConstructor[] initValue() {
             final Constructor[] declaredConstructors = (Constructor[])
                AccessController.doPrivileged(new PrivilegedAction/*<Constructor[]>*/() {
@@ -113,6 +117,8 @@ public class CachedClass {
     }
 
     private final LazyReference<CachedMethod[]> methods = new LazyReference<CachedMethod[]>(softBundle) {
+        private static final long serialVersionUID = 6347586066597418308L;
+
         public CachedMethod[] initValue() {
             final Method[] declaredMethods = (Method[])
                AccessController.doPrivileged(new PrivilegedAction/*<Method[]>*/() {
@@ -163,6 +169,8 @@ public class CachedClass {
     };
 
     private final LazyReference<CachedClass> cachedSuperClass = new LazyReference<CachedClass>(softBundle) {
+        private static final long serialVersionUID = -4663740963306806058L;
+
         public CachedClass initValue() {
             if (!isArray)
               return ReflectionCache.getCachedClass(getTheClass().getSuperclass());
@@ -175,6 +183,8 @@ public class CachedClass {
     };
 
     private final LazyReference<CallSiteClassLoader> callSiteClassLoader = new LazyReference<CallSiteClassLoader>(softBundle) {
+        private static final long serialVersionUID = 4410385968428074090L;
+
         public CallSiteClassLoader initValue() {
             return
                AccessController.doPrivileged(new PrivilegedAction<CallSiteClassLoader>() {
@@ -186,6 +196,8 @@ public class CachedClass {
     };
 
     private final LazyReference<LinkedList<ClassInfo>> hierarchy = new LazyReference<LinkedList<ClassInfo>>(softBundle) {
+        private static final long serialVersionUID = 7166687623678851596L;
+
         public LinkedList<ClassInfo> initValue() {
             Set<ClassInfo> res = new LinkedHashSet<ClassInfo> ();
 
@@ -213,6 +225,8 @@ public class CachedClass {
     public static final CachedClass[] EMPTY_ARRAY = new CachedClass[0];
 
     private final LazyReference<Set<CachedClass>> declaredInterfaces = new LazyReference<Set<CachedClass>> (softBundle) {
+        private static final long serialVersionUID = 2139190436931329873L;
+
         public Set<CachedClass> initValue() {
             Set<CachedClass> res = new HashSet<CachedClass> (0);
 
@@ -225,6 +239,8 @@ public class CachedClass {
     };
 
     private final LazyReference<Set<CachedClass>> interfaces = new LazyReference<Set<CachedClass>> (softBundle) {
+        private static final long serialVersionUID = 4060471819464086940L;
+
         public Set<CachedClass> initValue() {
             Set<CachedClass> res = new HashSet<CachedClass> (0);
 
diff --git a/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java b/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
index c7abeffa7e..1067e4b113 100644
--- a/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
+++ b/src/main/java/org/codehaus/groovy/reflection/ClassInfo.java
@@ -441,6 +441,7 @@ public class ClassInfo implements Finalizable {
     }
 
     private static class LazyCachedClassRef extends LazyReference<CachedClass> {
+        private static final long serialVersionUID = -1400274148849287400L;
         private final ClassInfo info;
 
         LazyCachedClassRef(ReferenceBundle bundle, ClassInfo info) {
@@ -454,6 +455,7 @@ public class ClassInfo implements Finalizable {
     }
 
     private static class LazyClassLoaderRef extends LazyReference<ClassLoaderForClassArtifacts> {
+        private static final long serialVersionUID = 1639196133085420609L;
         private final ClassInfo info;
 
         LazyClassLoaderRef(ReferenceBundle bundle, ClassInfo info) {
diff --git a/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java b/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
index 56ad0c16bc..02f893c457 100644
--- a/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
+++ b/src/main/java/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java
@@ -54,7 +54,9 @@ class GroovyClassValuePreJava7<T> implements GroovyClassValue<T> {
 
 	private class GroovyClassValuePreJava7Segment extends ManagedConcurrentMap.Segment<Class<?>,T> {
 
-		GroovyClassValuePreJava7Segment(ReferenceBundle bundle, int initialCapacity) {
+        private static final long serialVersionUID = 1289753977947029168L;
+
+        GroovyClassValuePreJava7Segment(ReferenceBundle bundle, int initialCapacity) {
 			super(bundle, initialCapacity);
 		}
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
index 393d55eabe..9bc71fa138 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ConvertedMap.java
@@ -31,6 +31,8 @@ import java.util.Map;
  */
 public class ConvertedMap extends ConversionHandler {
 
+    private static final long serialVersionUID = -8131432558241254137L;
+
     /**
      * to create a ConvertedMap object.
      *
diff --git a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
index cabe23003f..1db103760a 100644
--- a/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/CurriedClosure.java
@@ -46,6 +46,7 @@ import groovy.lang.Closure;
  */
 public final class CurriedClosure<V> extends Closure<V> {
 
+    private static final long serialVersionUID = -1018388175778192754L;
     private final Object[] curriedParams;
     private final int minParamsExpected;
     private int index;
diff --git a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
index 19f53d2322..05ce6b0f95 100644
--- a/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
+++ b/src/main/java/org/codehaus/groovy/runtime/GroovyCategorySupport.java
@@ -47,6 +47,7 @@ public class GroovyCategorySupport {
     private static int categoriesInUse = 0;
 
     public static class CategoryMethodList extends ArrayList<CategoryMethod> {
+        private static final long serialVersionUID = 1569020062006842141L;
         public final int level;
         final CategoryMethodList previous;
         final AtomicInteger usage;
@@ -72,6 +73,7 @@ public class GroovyCategorySupport {
     public static class ThreadCategoryInfo extends HashMap<String, CategoryMethodList>{
 
         private static final Object LOCK = new Object();
+        private static final long serialVersionUID = 2609120843123833410L;
 
         int level;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
index 2f03126d46..da85b6b8a5 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerInvocationException.java
@@ -29,6 +29,8 @@ import java.lang.reflect.InvocationTargetException;
  */
 public class InvokerInvocationException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 5870532233180451709L;
+
     public InvokerInvocationException(InvocationTargetException e) {
         super(e.getTargetException());
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
index 24d74f6c0f..7f098d7013 100644
--- a/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/IteratorClosureAdapter.java
@@ -32,6 +32,7 @@ import java.util.List;
  */
 public class IteratorClosureAdapter<T> extends Closure {
 
+    private static final long serialVersionUID = -3193812539363103534L;
     private final List<T> list = new ArrayList<T>();
     private MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
     
diff --git a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
index 4d3eeb6760..a47adab505 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
@@ -142,6 +142,8 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
         final long[] size = {0L};
 
         eachFileRecurse(self, FileType.FILES, new Closure<Void>(null) {
+            private static final long serialVersionUID = 7688764529326404277L;
+
             public void doCall(Object[] args) {
                 size[0] += ((File) args[0]).length();
             }
diff --git a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
index ec2f481b44..21a9e4079d 100644
--- a/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
+++ b/src/main/java/org/codehaus/groovy/runtime/WritableFile.java
@@ -32,6 +32,7 @@ import java.io.Writer;
  *
  */
 public class WritableFile extends File implements Writable {
+    private static final long serialVersionUID = 1661640530283827325L;
     private final String encoding;
 
     public WritableFile(final File delegate) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
index e602658ffe..ef2a7b8798 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
@@ -32,6 +32,7 @@ import java.util.concurrent.ConcurrentHashMap;
  */
 @ThreadSafe
 public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V>, Serializable {
+    private static final long serialVersionUID = -2062728248439701004L;
     private final ConcurrentHashMap<K, V> map;
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
index 68fe42d402..2d501b3a94 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/ConcurrentReaderHashMap.java
@@ -166,7 +166,9 @@ public class ConcurrentReaderHashMap
   */
 
   /** A Serializable class for barrier lock **/
-  protected static class BarrierLock implements java.io.Serializable { }
+  protected static class BarrierLock implements java.io.Serializable {
+      private static final long serialVersionUID = -5403150101810674636L;
+  }
 
   /**
    * Lock used only for its memory effects.
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
index a9f5538403..4f0cc4cb96 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MethodSelectionException.java
@@ -37,6 +37,7 @@ import java.lang.reflect.Modifier;
  */
 public class MethodSelectionException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = 6260193948973669540L;
     private final String methodName;
     private final FastArray methods;
     private final Class[] arguments;
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
index 28437d28c6..80836c78e4 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExceptionNoStack.java
@@ -22,6 +22,8 @@ import groovy.lang.MissingMethodException;
 
 public class MissingMethodExceptionNoStack extends MissingMethodException {
 
+    private static final long serialVersionUID = 7075950754138801519L;
+
     public MissingMethodExceptionNoStack(String method, Class type, Object[] arguments) {
         this(method,type,arguments,false);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
index 0b2c33f8dc..a177eaba7d 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingPropertyExceptionNoStack.java
@@ -22,6 +22,8 @@ import groovy.lang.MissingPropertyException;
 
 public class MissingPropertyExceptionNoStack extends MissingPropertyException {
 
+    private static final long serialVersionUID = -7734212543734003079L;
+
     public MissingPropertyExceptionNoStack(String propertyName, Class theClass) {
         super(propertyName, theClass);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
index d6ef9de74c..b79f0d75ba 100644
--- a/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
+++ b/src/main/java/org/codehaus/groovy/runtime/powerassert/PowerAssertionError.java
@@ -24,6 +24,8 @@ package org.codehaus.groovy.runtime.powerassert;
  * @author Peter Niederwieser
  */
 public class PowerAssertionError extends java.lang.AssertionError {
+    private static final long serialVersionUID = 186840762256433109L;
+
     public PowerAssertionError(String msg) {
         super(msg);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java b/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
index 431dd08c0f..b7a6bd8ea2 100644
--- a/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/powerassert/SourceTextNotAvailableException.java
@@ -27,6 +27,8 @@ import org.codehaus.groovy.control.SourceUnit;
  * @author Peter Niederwieser
  */
 public class SourceTextNotAvailableException extends RuntimeException {
+    private static final long serialVersionUID = -3815868502019514479L;
+
     // only accepts AssertStatementS so that better error messages can be produced
     public SourceTextNotAvailableException(AssertStatement stat, SourceUnit unit, String msg) {
         super(String.format("%s for %s at (%d,%d)-(%d,%d) in %s",
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
index e2fc66a6c9..f9cace8baf 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
@@ -20,6 +20,8 @@ package org.codehaus.groovy.runtime.typehandling;
 
 public class GroovyCastException extends ClassCastException {
 
+    private static final long serialVersionUID = 6859089155641797356L;
+
     /**
      * @param objectToCast object we tried to cast
      * @param classToCastTo class we tried to cast to
diff --git a/src/main/java/org/codehaus/groovy/syntax/ParserException.java b/src/main/java/org/codehaus/groovy/syntax/ParserException.java
index 2215429d3e..beedb1c888 100644
--- a/src/main/java/org/codehaus/groovy/syntax/ParserException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/ParserException.java
@@ -19,6 +19,8 @@
 package org.codehaus.groovy.syntax;
 
 public class ParserException extends TokenException {
+    private static final long serialVersionUID = -3772086239731735693L;
+
     public ParserException(String message, Token token) {
         super(message, token);
     }
diff --git a/src/main/java/org/codehaus/groovy/syntax/ReadException.java b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
index 6885c24bbb..af70dd0c13 100644
--- a/src/main/java/org/codehaus/groovy/syntax/ReadException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/ReadException.java
@@ -27,6 +27,7 @@ import java.io.IOException;
  */
 
 public class ReadException extends GroovyException {
+    private static final long serialVersionUID = -6171846198126205359L;
     private final IOException cause;
 
     public ReadException(IOException cause) {
diff --git a/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java b/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
index c47bc26710..ce804e1381 100644
--- a/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/RuntimeParserException.java
@@ -29,6 +29,8 @@ import org.codehaus.groovy.ast.ASTNode;
  */
 public class RuntimeParserException extends GroovyRuntimeException {
 
+    private static final long serialVersionUID = -6612860527133856587L;
+
     public RuntimeParserException(String message, ASTNode node) {
         super(message + "\n", node);
     }
diff --git a/src/main/java/org/codehaus/groovy/syntax/TokenException.java b/src/main/java/org/codehaus/groovy/syntax/TokenException.java
index 5c9f2755d0..fea3ec2f04 100644
--- a/src/main/java/org/codehaus/groovy/syntax/TokenException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/TokenException.java
@@ -19,6 +19,8 @@
 package org.codehaus.groovy.syntax;
 
 public class TokenException extends SyntaxException {
+    private static final long serialVersionUID = 6850594285972085144L;
+
     public TokenException(String message, Token token) {
         super(
                 (token == null)
diff --git a/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java b/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
index 32c90a50d0..3f799fa929 100644
--- a/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/TokenMismatchException.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy.syntax;
 
 public class TokenMismatchException extends TokenException {
+    private static final long serialVersionUID = -6321206176010272124L;
     private final Token unexpectedToken;
     private final int expectedType;
 
diff --git a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
index 74f9fffd40..4d5117d59a 100644
--- a/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
+++ b/src/main/java/org/codehaus/groovy/tools/gse/StringSetMap.java
@@ -24,7 +24,9 @@ import java.util.Set;
 import java.util.TreeSet;
 
 public class StringSetMap extends LinkedHashMap<String,Set<String>> {
-    
+
+    private static final long serialVersionUID = 4230491822783819152L;
+
     public StringSetMap() {
         super();
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
index 90c956ce82..fbb3fe3b94 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
@@ -56,7 +56,10 @@ import java.util.Map;
 public class StaticCompilationTransformer extends ClassCodeExpressionTransformer {
 
     protected static final ClassNode BYTECODE_ADAPTER_CLASS = ClassHelper.make(ScriptBytecodeAdapter.class);
-    protected static final Map<Integer, MethodNode> BYTECODE_BINARY_ADAPTERS = Collections.unmodifiableMap(new HashMap<Integer, MethodNode>() {{
+    protected static final Map<Integer, MethodNode> BYTECODE_BINARY_ADAPTERS = Collections.unmodifiableMap(new HashMap<Integer, MethodNode>() {
+        private static final long serialVersionUID = -9117028399464862605L;
+
+        {
         put(Types.COMPARE_EQUAL, BYTECODE_ADAPTER_CLASS.getMethods("compareEqual").get(0));
         put(Types.COMPARE_GREATER_THAN, BYTECODE_ADAPTER_CLASS.getMethods("compareGreaterThan").get(0));
         put(Types.COMPARE_GREATER_THAN_EQUAL, BYTECODE_ADAPTER_CLASS.getMethods("compareGreaterThanEqual").get(0));
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
index 8e2fad76ca..d6cae87668 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/AbstractTypeCheckingExtension.java
@@ -436,6 +436,7 @@ public class AbstractTypeCheckingExtension extends TypeCheckingExtension {
     }
 
     private static class TypeCheckingScope extends LinkedHashMap<String, Object> {
+        private static final long serialVersionUID = 7607331333917615144L;
         private final AbstractTypeCheckingExtension.TypeCheckingScope parent;
 
         private TypeCheckingScope(final AbstractTypeCheckingExtension.TypeCheckingScope parentScope) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
index 52ccdf19b6..6254b0a69a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.java
@@ -65,7 +65,10 @@ public class GroovyTypeCheckingExtensionSupport extends AbstractTypeCheckingExte
 
     // method name to DSL name
     private static final Map<String, String> METHOD_ALIASES = Collections.unmodifiableMap(
-            new HashMap<String, String>() {{
+            new HashMap<String, String>() {
+                private static final long serialVersionUID = 8938707932245818749L;
+
+                {
                 put("onMethodSelection", "onMethodSelection");
                 put("afterMethodCall", "afterMethodCall");
                 put("beforeMethodCall", "beforeMethodCall");
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index c13a163684..f944c99c48 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -165,7 +165,10 @@ public abstract class StaticTypeCheckingSupport {
     protected static final ClassNode ArrayList_TYPE = makeWithoutCaching(ArrayList.class);
     protected static final ExtensionMethodCache EXTENSION_METHOD_CACHE = new ExtensionMethodCache();
     protected static final Map<ClassNode, Integer> NUMBER_TYPES = Collections.unmodifiableMap(
-            new HashMap<ClassNode, Integer>() {{
+            new HashMap<ClassNode, Integer>() {
+                private static final long serialVersionUID = 8841951852732042766L;
+
+                {
                 put(byte_TYPE, 0);
                 put(Byte_TYPE, 0);
                 put(short_TYPE, 1);
@@ -181,7 +184,10 @@ public abstract class StaticTypeCheckingSupport {
             }});
 
     protected static final Map<String, Integer> NUMBER_OPS = Collections.unmodifiableMap(
-            new HashMap<String, Integer>() {{
+            new HashMap<String, Integer>() {
+                private static final long serialVersionUID = 6951856193525808411L;
+
+                {
                 put("plus", PLUS);
                 put("minus", MINUS);
                 put("multiply", MULTIPLY);
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
index d60396b0cc..349c9306ba 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMap.java
@@ -50,6 +50,8 @@ public abstract class AbstractConcurrentMap<K, V> extends AbstractConcurrentMapB
 
     public abstract static class Segment<K,V> extends AbstractConcurrentMapBase.Segment {
 
+        private static final long serialVersionUID = 5192533863182570468L;
+
         protected Segment(int initialCapacity) {
             super(initialCapacity);
         }
diff --git a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
index b21c0af71f..2cfc82a99f 100644
--- a/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
+++ b/src/main/java/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
@@ -154,6 +154,7 @@ public abstract class AbstractConcurrentMapBase {
     }
 
     public static class Segment extends LockableObject {
+        private static final long serialVersionUID = -1071886855389945760L;
         volatile int count;
 
         int threshold;
diff --git a/src/main/java/org/codehaus/groovy/util/LazyReference.java b/src/main/java/org/codehaus/groovy/util/LazyReference.java
index fc348039e0..54e0ab2e78 100644
--- a/src/main/java/org/codehaus/groovy/util/LazyReference.java
+++ b/src/main/java/org/codehaus/groovy/util/LazyReference.java
@@ -24,6 +24,7 @@ package org.codehaus.groovy.util;
 public abstract class LazyReference<T> extends LockableObject {
     private static final ManagedReference INIT = new ManagedReference(ReferenceType.HARD,null,null){};
     private static final ManagedReference NULL_REFERENCE = new ManagedReference(ReferenceType.HARD,null,null){};
+    private static final long serialVersionUID = 3160238516132794621L;
     private ManagedReference<T> reference = INIT;
     private final ReferenceBundle bundle;
     
diff --git a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
index 209de66c2a..da06275840 100644
--- a/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
+++ b/src/main/java/org/codehaus/groovy/util/ManagedConcurrentMap.java
@@ -33,6 +33,7 @@ public class ManagedConcurrentMap<K,V> extends AbstractConcurrentMap<K,V> {
     }
 
     public static class Segment<K,V> extends AbstractConcurrentMap.Segment<K,V>{
+        private static final long serialVersionUID = -2157582627873688747L;
         protected final ReferenceBundle bundle;
         public Segment(ReferenceBundle bundle, int cap) {
             super(cap);

Commit:
5d91321562a1158b7463ed1749ce04eecc72858e
sunlan
sunlan@apache.org
2018-04-03 00:06:53 +0800
Trivial refactoring: simplify collection initialization and avoid calling `toArray` with pre-sized array parameter
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index 1c285c9bec..c5ca547bde 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -155,7 +155,7 @@ public class CachedClass {
                 for (int i = 0; i != superMopMethods.length; ++i)
                   mopMethods.add(superMopMethods[i]);
             }
-            CachedClass.this.mopMethods = mopMethods.toArray(new CachedMethod[mopMethods.size()]);
+            CachedClass.this.mopMethods = mopMethods.toArray(CachedMethod.EMPTY_ARRAY);
             Arrays.sort(CachedClass.this.mopMethods, CachedMethodComparatorByName.INSTANCE);
 
             return resMethods;
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedMethod.java b/src/main/java/org/codehaus/groovy/reflection/CachedMethod.java
index 58314e2646..6014c85c9d 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedMethod.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedMethod.java
@@ -42,6 +42,7 @@ import java.util.Comparator;
  * @author Alex.Tkachman
  */
 public class CachedMethod extends MetaMethod implements Comparable {
+    public static final CachedMethod[] EMPTY_ARRAY = new CachedMethod[0];
     public final CachedClass cachedClass;
 
     private final Method cachedMethod;
diff --git a/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
index 1affbf0427..6189c1cf72 100644
--- a/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
@@ -134,8 +134,7 @@ public class CategoryASTTransformation implements ASTTransformation, Opcodes {
 
             @Override
             public void visitBlockStatement(BlockStatement block) {
-                Set<String> names = new HashSet<String>();
-                names.addAll(varStack.getLast());
+                Set<String> names = new HashSet<String>(varStack.getLast());
                 varStack.add(names);
                 super.visitBlockStatement(block);
                 varStack.remove(names);

Commit:
08c197a0d59612d4578db1bed66fe410b2327b59
sunlan
sunlan@apache.org
2018-04-02 21:57:40 +0800
Trivial refactoring: avoid creating zero length array
diff --git a/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 7f765902c5..6ddb6b7689 100644
--- a/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -2608,7 +2608,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     private static void setTypeArgumentsOnMethodCallExpression(MethodCallExpression expression,
                                                         List<GenericsType> typeArgumentList) {
         if (typeArgumentList != null && !typeArgumentList.isEmpty()) {
-            expression.setGenericsTypes(typeArgumentList.toArray(new GenericsType[0]));
+            expression.setGenericsTypes(typeArgumentList.toArray(GenericsType.EMPTY_ARRAY));
         }
     }
 
@@ -3022,7 +3022,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     private ClassNode addTypeArguments(ClassNode basicType, AST node) {
         List<GenericsType> typeArgumentList = getTypeArgumentsList(node);
         // a 0-length type argument list means we face the diamond operator
-        basicType.setGenericsTypes(typeArgumentList.toArray(new GenericsType[0]));
+        basicType.setGenericsTypes(typeArgumentList.toArray(GenericsType.EMPTY_ARRAY));
         return basicType;
     }
 
@@ -3055,7 +3055,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             bounds.add(bound);
         }
         if (bounds.isEmpty()) return null;
-        return (ClassNode[]) bounds.toArray(new ClassNode[0]);
+        return (ClassNode[]) bounds.toArray(ClassNode.EMPTY_ARRAY);
     }
 
     protected GenericsType[] makeGenericsType(AST rootNode) {
@@ -3073,7 +3073,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             ret.add(gt);
             typeParameter = typeParameter.getNextSibling();
         }
-        return (GenericsType[]) ret.toArray(new GenericsType[0]);
+        return (GenericsType[]) ret.toArray(GenericsType.EMPTY_ARRAY);
     }
 
     protected ClassNode makeType(AST typeNode) {
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java
index 1bfaeb7c2d..2c0d28cfff 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java
@@ -79,6 +79,6 @@ class ClassSignatureParser {
         if (typeParameters.length > 0) {
             classNode.setGenericsTypes(typeParameters);
         }
-        classNode.setInterfaces(interfaces.toArray(new ClassNode[0]));
+        classNode.setInterfaces(interfaces.toArray(ClassNode.EMPTY_ARRAY));
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
index 5f8f03dbcc..7b217fcc0f 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
@@ -117,7 +117,7 @@ abstract class TypeSignatureParser extends SignatureVisitor {
         }
 
         ClassNode bound = base.getPlainNodeReference();
-        bound.setGenericsTypes(arguments.toArray(new GenericsType[0]));
+        bound.setGenericsTypes(arguments.toArray(GenericsType.EMPTY_ARRAY));
         finished(bound);
     }
 
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
index 712e80b1c4..57a3e154f9 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -573,7 +573,7 @@ public class WideningCategories {
                 itcn.remove();
             }
         }
-        ClassNode[] interfaceArray = interfaces.toArray(new ClassNode[0]);
+        ClassNode[] interfaceArray = interfaces.toArray(ClassNode.EMPTY_ARRAY);
         Arrays.sort(interfaceArray, INTERFACE_CLASSNODE_COMPARATOR);
         type = new LowestUpperBoundClassNode(name, superClass, interfaceArray);
         return type;
@@ -632,7 +632,7 @@ public class WideningCategories {
                         Collections.addAll(asArrayList, genericsTypes);
                     }
                 }
-                setGenericsTypes(asArrayList.toArray(new GenericsType[0]));
+                setGenericsTypes(asArrayList.toArray(GenericsType.EMPTY_ARRAY));
             }
             StringBuilder sb = new StringBuilder();
             if (!upper.equals(OBJECT_TYPE)) sb.append(upper.getName());
diff --git a/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java b/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java
index 56fbc72e67..c8a64de693 100644
--- a/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java
+++ b/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java
@@ -219,7 +219,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
             pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));
         }
 
-        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);
+        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(Parameter.EMPTY_ARRAY), ClassNode.EMPTY_ARRAY, block);
     }
 
     private boolean isStaticThis(InnerClassNode innerClass, VariableScope scope) {
diff --git a/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java b/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java
index 24a9c31374..b7fa503d6f 100644
--- a/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java
@@ -86,7 +86,7 @@ public class OptimizerVisitor extends ClassCodeExpressionTransformer {
                         newInterfaces.add(classNode);
                     }
                 }
-                node.setInterfaces(newInterfaces.toArray(new ClassNode[0]));
+                node.setInterfaces(newInterfaces.toArray(ClassNode.EMPTY_ARRAY));
             }
         }
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
index 551708798e..23858f6328 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
@@ -215,7 +215,7 @@ public class ProxyGeneratorAdapter extends ClassVisitor implements Opcodes {
         }
         if (!traits.isEmpty()) {
             String name = superClass.getName() + "$TraitAdapter";
-            ClassNode cn = new ClassNode(name, ACC_PUBLIC | ACC_ABSTRACT, ClassHelper.OBJECT_TYPE, traits.toArray(new ClassNode[0]), null);
+            ClassNode cn = new ClassNode(name, ACC_PUBLIC | ACC_ABSTRACT, ClassHelper.OBJECT_TYPE, traits.toArray(ClassNode.EMPTY_ARRAY), null);
             CompilationUnit cu = new CompilationUnit(loader);
             CompilerConfiguration config = new CompilerConfiguration();
             SourceUnit su = new SourceUnit(name + "wrapper", "", config, loader, new ErrorCollector(config));
diff --git a/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
index 9016c164df..709cdb4ead 100644
--- a/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
@@ -131,7 +131,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
                 anno.setMember("pre", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));
             }
             if (post != null) {
-                anno.setMember("post", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));
+                anno.setMember("post", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));
             }
         }
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
index 905ced8b15..64e2b32158 100644
--- a/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
@@ -152,7 +152,7 @@ public class NamedVariantASTTransformation extends AbstractASTTransformation {
                                 plusX(new ConstantExpression("Unrecognized namedArgKey: "), varX(namedArgKey)))
                 ));
 
-        Parameter[] genParamsArray = genParams.toArray(new Parameter[0]);
+        Parameter[] genParamsArray = genParams.toArray(Parameter.EMPTY_ARRAY);
         // TODO account for default params giving multiple signatures
         if (cNode.hasMethod(mNode.getName(), genParamsArray)) {
             addError("Error during " + MY_TYPE_NAME + " processing. Class " + cNode.getNameWithoutPackage() +
diff --git a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 6d49c5d467..d421a47304 100644
--- a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -256,7 +256,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
 
         boolean hasMapCons = AnnotatedNodeUtils.hasAnnotation(cNode, MapConstructorASTTransformation.MY_TYPE);
         int modifiers = getVisibility(anno, cNode, ConstructorNode.class, ACC_PUBLIC);
-        ConstructorNode consNode = new ConstructorNode(modifiers, params.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, body);
+        ConstructorNode consNode = new ConstructorNode(modifiers, params.toArray(Parameter.EMPTY_ARRAY), ClassNode.EMPTY_ARRAY, body);
         markAsGenerated(cNode, consNode);
         cNode.addConstructor(consNode);
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index b46937045a..4419379d77 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2144,7 +2144,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 } else if (arr.size()==1) {
                     result = arr.get(0);
                 } else {
-                    result = new UnionTypeClassNode(arr.toArray(new ClassNode[0]));
+                    result = new UnionTypeClassNode(arr.toArray(ClassNode.EMPTY_ARRAY));
                 }
             }
         }
@@ -3289,7 +3289,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         nodes.add(arg);
                     }
                 }
-                return new LowestUpperBoundClassNode(returnType.getName()+"Composed", OBJECT_TYPE, nodes.toArray(new ClassNode[0]));
+                return new LowestUpperBoundClassNode(returnType.getName()+"Composed", OBJECT_TYPE, nodes.toArray(ClassNode.EMPTY_ARRAY));
             }
         }
         return returnType;
@@ -4458,7 +4458,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         Traits.collectSelfTypes(ret, selfTypes);
         if (!selfTypes.isEmpty()) {
             selfTypes.add(ret);
-            ret = new UnionTypeClassNode(selfTypes.toArray(new ClassNode[0]));
+            ret = new UnionTypeClassNode(selfTypes.toArray(ClassNode.EMPTY_ARRAY));
         }
         return ret;
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index 3138c187ca..a7c647f636 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -111,7 +111,7 @@ public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
         String traitName = decomposed[0];
         String name = decomposed[1];
         LinkedHashSet<ClassNode> traitsAsList = Traits.collectAllInterfacesReverseOrder(receiver, new LinkedHashSet<ClassNode>());
-        ClassNode[] implementedTraits = traitsAsList.toArray(new ClassNode[0]);
+        ClassNode[] implementedTraits = traitsAsList.toArray(ClassNode.EMPTY_ARRAY);
         ClassNode nextTrait = null;
         for (int i = 0; i < implementedTraits.length - 1; i++) {
             ClassNode implementedTrait = implementedTraits[i];
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java b/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
index ac23d81c0d..1513421c27 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
@@ -293,7 +293,7 @@ class UnionTypeClassNode extends ClassNode {
             ClassNode[] interfaces = delegate.getInterfaces();
             if (interfaces != null) Collections.addAll(nodes, interfaces);
         }
-        return nodes.toArray(new ClassNode[0]);
+        return nodes.toArray(ClassNode.EMPTY_ARRAY);
     }
 
     @Override
@@ -328,7 +328,7 @@ class UnionTypeClassNode extends ClassNode {
             ClassNode[] interfaces = delegate.getUnresolvedInterfaces();
             if (interfaces != null) Collections.addAll(nodes, interfaces);
         }
-        return nodes.toArray(new ClassNode[0]);
+        return nodes.toArray(ClassNode.EMPTY_ARRAY);
     }
 
     @Override
@@ -338,7 +338,7 @@ class UnionTypeClassNode extends ClassNode {
             ClassNode[] interfaces = delegate.getUnresolvedInterfaces(useRedirect);
             if (interfaces != null) Collections.addAll(nodes, interfaces);
         }
-        return nodes.toArray(new ClassNode[0]);
+        return nodes.toArray(ClassNode.EMPTY_ARRAY);
     }
 
     @Override
diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
index b3bdca20ac..34fe24811b 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
@@ -405,7 +405,7 @@ public abstract class TraitComposer {
         }
         if (!modified) return oldTypes;
         if (l.isEmpty()) return null;
-        return l.toArray(new GenericsType[0]);
+        return l.toArray(GenericsType.EMPTY_ARRAY);
     }
 
     /**
@@ -431,7 +431,7 @@ public abstract class TraitComposer {
             }
         }
         for (MethodNode superForwarder : superForwarders) {
-            doCreateSuperForwarder(targetNode, superForwarder, traits.toArray(new ClassNode[0]), genericsSpec);
+            doCreateSuperForwarder(targetNode, superForwarder, traits.toArray(ClassNode.EMPTY_ARRAY), genericsSpec);
         }
     }
 

Commit:
f38e2751daefa1b7a97f435bd87741ff49796f6f
sunlan
sunlan@apache.org
2018-04-02 12:41:13 +0800
Trivial refactoring: simplify collection initialization
diff --git a/src/main/groovy/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/groovy/lang/ExpandoMetaClass.java
index d56f738abd..8183e0885b 100644
--- a/src/main/groovy/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/groovy/lang/ExpandoMetaClass.java
@@ -926,8 +926,7 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
     }
 
     public List<MetaProperty> getProperties() {
-        List<MetaProperty> propertyList = new ArrayList<MetaProperty>();
-        propertyList.addAll(super.getProperties());
+        List<MetaProperty> propertyList = new ArrayList<MetaProperty>(super.getProperties());
         return propertyList;
     }
 
diff --git a/src/main/groovy/groovy/util/ObservableList.java b/src/main/groovy/groovy/util/ObservableList.java
index 01c2e2f7ba..c860fea934 100644
--- a/src/main/groovy/groovy/util/ObservableList.java
+++ b/src/main/groovy/groovy/util/ObservableList.java
@@ -193,8 +193,7 @@ public class ObservableList implements List {
 
     public void clear() {
         int oldSize = size();
-        List values = new ArrayList();
-        values.addAll(delegate);
+        List values = new ArrayList(delegate);
         delegate.clear();
         if (!values.isEmpty()) {
             fireElementClearedEvent(values);
diff --git a/src/main/groovy/groovy/util/ObservableSet.java b/src/main/groovy/groovy/util/ObservableSet.java
index 2a50d2d407..851c651c7e 100644
--- a/src/main/groovy/groovy/util/ObservableSet.java
+++ b/src/main/groovy/groovy/util/ObservableSet.java
@@ -300,8 +300,7 @@ public class ObservableSet<E> implements Set<E> {
 
     public void clear() {
         int oldSize = size();
-        List<E> values = new ArrayList<E>();
-        values.addAll(delegate);
+        List<E> values = new ArrayList<E>(delegate);
         delegate.clear();
         if (!values.isEmpty()) {
             fireElementClearedEvent(values);
diff --git a/src/main/java/org/codehaus/groovy/classgen/ExtendedVerifier.java b/src/main/java/org/codehaus/groovy/classgen/ExtendedVerifier.java
index 5e13cd7e9a..8b7ed89cbb 100644
--- a/src/main/java/org/codehaus/groovy/classgen/ExtendedVerifier.java
+++ b/src/main/java/org/codehaus/groovy/classgen/ExtendedVerifier.java
@@ -267,8 +267,7 @@ public class ExtendedVerifier extends ClassCodeVisitorSupport {
                 MethodNode found = getDeclaredMethodCorrected(genericsSpec, mn, correctedNext);
                 if (found != null) break;
             }
-            List<ClassNode> ifaces = new ArrayList<ClassNode>();
-            ifaces.addAll(Arrays.asList(next.getInterfaces()));
+            List<ClassNode> ifaces = new ArrayList<ClassNode>(Arrays.asList(next.getInterfaces()));
             Map updatedGenericsSpec = new HashMap(genericsSpec);
             while (!ifaces.isEmpty()) {
                 ClassNode origInterface = ifaces.remove(0);
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index 55d2a434c4..1c285c9bec 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -362,11 +362,10 @@ public class CachedClass {
     }
 
     public MetaMethod[] getNewMetaMethods() {
-        List<MetaMethod> arr = new ArrayList<MetaMethod>();
-        arr.addAll(Arrays.asList(classInfo.newMetaMethods));
+        List<MetaMethod> arr = new ArrayList<MetaMethod>(Arrays.asList(classInfo.newMetaMethods));
 
         final MetaClass metaClass = classInfo.getStrongMetaClass();
-        if (metaClass != null && metaClass instanceof ExpandoMetaClass) {
+        if (metaClass instanceof ExpandoMetaClass) {
             arr.addAll(((ExpandoMetaClass)metaClass).getExpandoMethods());
         }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
index d992cceeb7..1affbf0427 100644
--- a/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/CategoryASTTransformation.java
@@ -111,8 +111,7 @@ public class CategoryASTTransformation implements ASTTransformation, Opcodes {
             }
 
             private void addVariablesToStack(Parameter[] params) {
-                Set<String> names = new HashSet<String>();
-                names.addAll(varStack.getLast());
+                Set<String> names = new HashSet<String>(varStack.getLast());
                 for (Parameter param : params) {
                     names.add(param.getName());
                 }

Commit:
068be445664dd1a2a871c5c13788df9033a0c60f
sunlan
sunlan@apache.org
2018-04-02 11:49:32 +0800
Trivial refactoring: avoid creating zero length array
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
index 9f281ab5d1..bb01a9561a 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
@@ -51,7 +51,7 @@ abstract class FormalParameterParser extends SignatureVisitor {
     protected void flushTypeParameter() {
         if (currentTypeParameter != null) {
             ClassNode ref = Java5.configureTypeVariableReference(currentTypeParameter);
-            ClassNode[] boundNodes = parameterBounds.toArray(new ClassNode[0]);
+            ClassNode[] boundNodes = parameterBounds.toArray(ClassNode.EMPTY_ARRAY);
             typeParameters.add(Java5.configureTypeVariableDefinition(ref, boundNodes));
 
             currentTypeParameter = null;
@@ -76,6 +76,6 @@ abstract class FormalParameterParser extends SignatureVisitor {
 
     public GenericsType[] getTypeParameters() {
         flushTypeParameter();
-        return typeParameters.toArray(new GenericsType[0]);
+        return typeParameters.toArray(GenericsType.EMPTY_ARRAY);
     }
 }

Commit:
ead1ab00a49492373d816becf663de4569ae35e5
sunlan
sunlan@apache.org
2018-04-02 11:48:02 +0800
Trivial refactoring: avoid calling `toArray` with pre-sized array parameter
diff --git a/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java b/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java
index e21e608382..82f13e7898 100644
--- a/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java
+++ b/src/main/groovy/groovy/grape/GrabAnnotationTransformation.java
@@ -373,7 +373,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
             if (systemProperties != null) basicArgs.put(SYSTEM_PROPERTIES_SETTING, systemProperties);
 
             try {
-                Grape.grab(basicArgs, grabMaps.toArray(new Map[grabMaps.size()]));
+                Grape.grab(basicArgs, grabMaps.toArray(new Map[0]));
                 // grab may have added more transformations through new URLs added to classpath, so do one more scan
                 if (compilationUnit!=null) {
                     ASTTransformationVisitor.addGlobalTransformsAfterGrab(compilationUnit.getASTTransformationsContext());
diff --git a/src/main/groovy/groovy/lang/GroovyShell.java b/src/main/groovy/groovy/lang/GroovyShell.java
index 4dc51c919a..1ac2fc4290 100644
--- a/src/main/groovy/groovy/lang/GroovyShell.java
+++ b/src/main/groovy/groovy/lang/GroovyShell.java
@@ -364,7 +364,7 @@ public class GroovyShell extends GroovyObjectSupport {
      * @param args      the command line arguments to pass in
      */
     public Object run(GroovyCodeSource source, List args) throws CompilationFailedException {
-        return run(source, ((String[]) args.toArray(new String[args.size()])));
+        return run(source, ((String[]) args.toArray(new String[0])));
     }
 
     /**
@@ -385,7 +385,7 @@ public class GroovyShell extends GroovyObjectSupport {
      * @param args      the command line arguments to pass in
      */
     public Object run(URI source, List args) throws CompilationFailedException, IOException {
-        return run(new GroovyCodeSource(source), ((String[]) args.toArray(new String[args.size()])));
+        return run(new GroovyCodeSource(source), ((String[]) args.toArray(new String[0])));
     }
 
     /**
@@ -406,7 +406,7 @@ public class GroovyShell extends GroovyObjectSupport {
      * @param list     the command line arguments to pass in
      */
     public Object run(final Reader in, final String fileName, List list) throws CompilationFailedException {
-        return run(in, fileName, (String[]) list.toArray(new String[list.size()]));
+        return run(in, fileName, (String[]) list.toArray(new String[0]));
     }
 
     /**
diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index e281567af8..427bf29bec 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -189,7 +189,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             List<MetaMethod> arr = new ArrayList<MetaMethod>();
             arr.addAll(Arrays.asList(metaMethods));
             arr.addAll(Arrays.asList(add));
-            myNewMetaMethods = arr.toArray(new MetaMethod[arr.size()]);
+            myNewMetaMethods = arr.toArray(new MetaMethod[0]);
             additionalMetaMethods = metaMethods;
         }
         else {
diff --git a/src/main/groovy/groovy/util/CharsetToolkit.java b/src/main/groovy/groovy/util/CharsetToolkit.java
index e1274590b6..fd7893bc07 100644
--- a/src/main/groovy/groovy/util/CharsetToolkit.java
+++ b/src/main/groovy/groovy/util/CharsetToolkit.java
@@ -414,6 +414,6 @@ public class CharsetToolkit {
      */
     public static Charset[] getAvailableCharsets() {
         Collection collection = Charset.availableCharsets().values();
-        return (Charset[]) collection.toArray(new Charset[collection.size()]);
+        return (Charset[]) collection.toArray(new Charset[0]);
     }
 }
diff --git a/src/main/groovy/groovy/util/ObservableMap.java b/src/main/groovy/groovy/util/ObservableMap.java
index c55d3b1284..ed340640db 100644
--- a/src/main/groovy/groovy/util/ObservableMap.java
+++ b/src/main/groovy/groovy/util/ObservableMap.java
@@ -113,7 +113,7 @@ public class ObservableMap implements Map {
     }
 
     protected void fireMultiPropertyEvent(List<PropertyEvent> events) {
-        firePropertyEvent(new MultiPropertyEvent(this, (PropertyEvent[]) events.toArray(new PropertyEvent[events.size()])));
+        firePropertyEvent(new MultiPropertyEvent(this, (PropertyEvent[]) events.toArray(new PropertyEvent[0])));
     }
 
     protected void fireMultiPropertyEvent(PropertyEvent[] events) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 2af9882a8b..7f765902c5 100644
--- a/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/java/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -2608,7 +2608,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     private static void setTypeArgumentsOnMethodCallExpression(MethodCallExpression expression,
                                                         List<GenericsType> typeArgumentList) {
         if (typeArgumentList != null && !typeArgumentList.isEmpty()) {
-            expression.setGenericsTypes(typeArgumentList.toArray(new GenericsType[typeArgumentList.size()]));
+            expression.setGenericsTypes(typeArgumentList.toArray(new GenericsType[0]));
         }
     }
 
@@ -3022,7 +3022,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     private ClassNode addTypeArguments(ClassNode basicType, AST node) {
         List<GenericsType> typeArgumentList = getTypeArgumentsList(node);
         // a 0-length type argument list means we face the diamond operator
-        basicType.setGenericsTypes(typeArgumentList.toArray(new GenericsType[typeArgumentList.size()]));
+        basicType.setGenericsTypes(typeArgumentList.toArray(new GenericsType[0]));
         return basicType;
     }
 
@@ -3055,7 +3055,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             bounds.add(bound);
         }
         if (bounds.isEmpty()) return null;
-        return (ClassNode[]) bounds.toArray(new ClassNode[bounds.size()]);
+        return (ClassNode[]) bounds.toArray(new ClassNode[0]);
     }
 
     protected GenericsType[] makeGenericsType(AST rootNode) {
@@ -3073,7 +3073,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             ret.add(gt);
             typeParameter = typeParameter.getNextSibling();
         }
-        return (GenericsType[]) ret.toArray(new GenericsType[ret.size()]);
+        return (GenericsType[]) ret.toArray(new GenericsType[0]);
     }
 
     protected ClassNode makeType(AST typeNode) {
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java
index 2222590976..1bfaeb7c2d 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/ClassSignatureParser.java
@@ -79,6 +79,6 @@ class ClassSignatureParser {
         if (typeParameters.length > 0) {
             classNode.setGenericsTypes(typeParameters);
         }
-        classNode.setInterfaces(interfaces.toArray(new ClassNode[interfaces.size()]));
+        classNode.setInterfaces(interfaces.toArray(new ClassNode[0]));
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
index 3ed8c3fb09..9f281ab5d1 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/FormalParameterParser.java
@@ -51,7 +51,7 @@ abstract class FormalParameterParser extends SignatureVisitor {
     protected void flushTypeParameter() {
         if (currentTypeParameter != null) {
             ClassNode ref = Java5.configureTypeVariableReference(currentTypeParameter);
-            ClassNode[] boundNodes = parameterBounds.toArray(new ClassNode[parameterBounds.size()]);
+            ClassNode[] boundNodes = parameterBounds.toArray(new ClassNode[0]);
             typeParameters.add(Java5.configureTypeVariableDefinition(ref, boundNodes));
 
             currentTypeParameter = null;
@@ -76,6 +76,6 @@ abstract class FormalParameterParser extends SignatureVisitor {
 
     public GenericsType[] getTypeParameters() {
         flushTypeParameter();
-        return typeParameters.toArray(new GenericsType[typeParameters.size()]);
+        return typeParameters.toArray(new GenericsType[0]);
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java b/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
index ae5efb18ef..5f8f03dbcc 100644
--- a/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
+++ b/src/main/java/org/codehaus/groovy/ast/decompiled/TypeSignatureParser.java
@@ -117,7 +117,7 @@ abstract class TypeSignatureParser extends SignatureVisitor {
         }
 
         ClassNode bound = base.getPlainNodeReference();
-        bound.setGenericsTypes(arguments.toArray(new GenericsType[arguments.size()]));
+        bound.setGenericsTypes(arguments.toArray(new GenericsType[0]));
         finished(bound);
     }
 
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
index 1489a565e9..712e80b1c4 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -573,7 +573,7 @@ public class WideningCategories {
                 itcn.remove();
             }
         }
-        ClassNode[] interfaceArray = interfaces.toArray(new ClassNode[interfaces.size()]);
+        ClassNode[] interfaceArray = interfaces.toArray(new ClassNode[0]);
         Arrays.sort(interfaceArray, INTERFACE_CLASSNODE_COMPARATOR);
         type = new LowestUpperBoundClassNode(name, superClass, interfaceArray);
         return type;
@@ -632,7 +632,7 @@ public class WideningCategories {
                         Collections.addAll(asArrayList, genericsTypes);
                     }
                 }
-                setGenericsTypes(asArrayList.toArray(new GenericsType[asArrayList.size()]));
+                setGenericsTypes(asArrayList.toArray(new GenericsType[0]));
             }
             StringBuilder sb = new StringBuilder();
             if (!upper.equals(OBJECT_TYPE)) sb.append(upper.getName());
diff --git a/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java b/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java
index 87815a88f2..56fbc72e67 100644
--- a/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java
+++ b/src/main/java/org/codehaus/groovy/classgen/InnerClassVisitor.java
@@ -219,7 +219,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
             pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));
         }
 
-        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[parameters.size()]), ClassNode.EMPTY_ARRAY, block);
+        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);
     }
 
     private boolean isStaticThis(InnerClassNode innerClass, VariableScope scope) {
diff --git a/src/main/java/org/codehaus/groovy/cli/GroovyPosixParser.java b/src/main/java/org/codehaus/groovy/cli/GroovyPosixParser.java
index e583ac9953..4168fa6809 100644
--- a/src/main/java/org/codehaus/groovy/cli/GroovyPosixParser.java
+++ b/src/main/java/org/codehaus/groovy/cli/GroovyPosixParser.java
@@ -159,7 +159,7 @@ public class GroovyPosixParser extends Parser
             gobble(iter);
         }
 
-        return (String[]) tokens.toArray(new String[tokens.size()]);
+        return (String[]) tokens.toArray(new String[0]);
     }
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java b/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java
index 6bb343b35c..24a9c31374 100644
--- a/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/OptimizerVisitor.java
@@ -86,7 +86,7 @@ public class OptimizerVisitor extends ClassCodeExpressionTransformer {
                         newInterfaces.add(classNode);
                     }
                 }
-                node.setInterfaces(newInterfaces.toArray(new ClassNode[newInterfaces.size()]));
+                node.setInterfaces(newInterfaces.toArray(new ClassNode[0]));
             }
         }
     }
diff --git a/src/main/java/org/codehaus/groovy/control/customizers/builder/CustomizersFactory.java b/src/main/java/org/codehaus/groovy/control/customizers/builder/CustomizersFactory.java
index 40ce7e7acb..ded70d8b31 100644
--- a/src/main/java/org/codehaus/groovy/control/customizers/builder/CustomizersFactory.java
+++ b/src/main/java/org/codehaus/groovy/control/customizers/builder/CustomizersFactory.java
@@ -52,7 +52,7 @@ public class CustomizersFactory extends AbstractFactory implements PostCompletio
     public Object postCompleteNode(final FactoryBuilderSupport factory, final Object parent, final Object node) {
         if (node instanceof List) {
             List col = (List) node;
-            return col.toArray(new CompilationCustomizer[col.size()]);
+            return col.toArray(new CompilationCustomizer[0]);
         }
         return node;
     }
diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index c4cb542b91..55d2a434c4 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -145,7 +145,7 @@ public class CachedClass {
                 else
                   methods.add(cachedMethod);
             }
-            CachedMethod [] resMethods = methods.toArray(new CachedMethod[methods.size()]);
+            CachedMethod [] resMethods = methods.toArray(new CachedMethod[0]);
             Arrays.sort(resMethods);
 
             final CachedClass superClass = getCachedSuperClass();
diff --git a/src/main/java/org/codehaus/groovy/runtime/MethodRankHelper.java b/src/main/java/org/codehaus/groovy/runtime/MethodRankHelper.java
index 295cbe8550..689245c911 100644
--- a/src/main/java/org/codehaus/groovy/runtime/MethodRankHelper.java
+++ b/src/main/java/org/codehaus/groovy/runtime/MethodRankHelper.java
@@ -310,7 +310,7 @@ public class MethodRankHelper{
             l.add(rc[index].c);
             index++;
         }
-        return l.toArray(new Constructor[l.size()]);
+        return l.toArray(new Constructor[0]);
     }
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
index 47b6f3b79c..551708798e 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
@@ -215,7 +215,7 @@ public class ProxyGeneratorAdapter extends ClassVisitor implements Opcodes {
         }
         if (!traits.isEmpty()) {
             String name = superClass.getName() + "$TraitAdapter";
-            ClassNode cn = new ClassNode(name, ACC_PUBLIC | ACC_ABSTRACT, ClassHelper.OBJECT_TYPE, traits.toArray(new ClassNode[traits.size()]), null);
+            ClassNode cn = new ClassNode(name, ACC_PUBLIC | ACC_ABSTRACT, ClassHelper.OBJECT_TYPE, traits.toArray(new ClassNode[0]), null);
             CompilationUnit cu = new CompilationUnit(loader);
             CompilerConfiguration config = new CompilerConfiguration();
             SourceUnit su = new SourceUnit(name + "wrapper", "", config, loader, new ErrorCollector(config));
@@ -341,7 +341,7 @@ public class ProxyGeneratorAdapter extends ClassVisitor implements Opcodes {
             classList.add(GeneratedGroovyProxy.class);
             interfacesSet.add("groovy/lang/GeneratedGroovyProxy");
         }
-        super.visit(V1_5, ACC_PUBLIC, proxyName, signature, BytecodeHelper.getClassInternalName(superClass), interfacesSet.toArray(new String[interfacesSet.size()]));
+        super.visit(V1_5, ACC_PUBLIC, proxyName, signature, BytecodeHelper.getClassInternalName(superClass), interfacesSet.toArray(new String[0]));
         visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
         addDelegateFields();
         if (addGroovyObjectSupport) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
index 2914d02d9c..40416a3006 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
@@ -415,7 +415,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
                     new ArrayList<MetaClassRegistryChangeEventListener>(changeListenerList.size()+nonRemoveableChangeListenerList.size());
             ret.addAll(nonRemoveableChangeListenerList);
             ret.addAll(changeListenerList);
-            return ret.toArray(new MetaClassRegistryChangeEventListener[ret.size()]);
+            return ret.toArray(new MetaClassRegistryChangeEventListener[0]);
         }
     }
     
diff --git a/src/main/java/org/codehaus/groovy/tools/DgmConverter.java b/src/main/java/org/codehaus/groovy/tools/DgmConverter.java
index f733227faf..98d5cf99d8 100644
--- a/src/main/java/org/codehaus/groovy/tools/DgmConverter.java
+++ b/src/main/java/org/codehaus/groovy/tools/DgmConverter.java
@@ -50,7 +50,7 @@ public class DgmConverter implements Opcodes {
         for (Class aClass : DefaultGroovyMethods.DGM_LIKE_CLASSES) {
             Collections.addAll(cachedMethodsList, ReflectionCache.getCachedClass(aClass).getMethods());
         }
-        final CachedMethod[] cachedMethods = cachedMethodsList.toArray(new CachedMethod[cachedMethodsList.size()]);
+        final CachedMethod[] cachedMethods = cachedMethodsList.toArray(new CachedMethod[0]);
 
         List<GeneratedMetaMethod.DgmMethodRecord> records = new ArrayList<GeneratedMetaMethod.DgmMethodRecord>();
 
diff --git a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
index 2e140b2411..df10a023fb 100644
--- a/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
+++ b/src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java
@@ -267,7 +267,7 @@ public class FileSystemCompiler {
         if (errors) {
             return null;
         } else {
-            return fileList.toArray(new String[fileList.size()]);
+            return fileList.toArray(new String[0]);
         }
     }
 
diff --git a/src/main/java/org/codehaus/groovy/tools/LoaderConfiguration.java b/src/main/java/org/codehaus/groovy/tools/LoaderConfiguration.java
index 4124ddbf48..de0fb4964d 100644
--- a/src/main/java/org/codehaus/groovy/tools/LoaderConfiguration.java
+++ b/src/main/java/org/codehaus/groovy/tools/LoaderConfiguration.java
@@ -329,7 +329,7 @@ public class LoaderConfiguration {
      * @see java.net.URLClassLoader
      */
     public URL[] getClassPathUrls() {
-        return classPath.toArray(new URL[classPath.size()]);
+        return classPath.toArray(new URL[0]);
     }
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/tools/StringHelper.java b/src/main/java/org/codehaus/groovy/tools/StringHelper.java
index 279f34e4a7..6f7865f1be 100644
--- a/src/main/java/org/codehaus/groovy/tools/StringHelper.java
+++ b/src/main/java/org/codehaus/groovy/tools/StringHelper.java
@@ -46,7 +46,7 @@ public class StringHelper {
             }
             first = last;
         }
-        return (String[])tokens.toArray(new String[tokens.size()]);
+        return (String[])tokens.toArray(new String[0]);
     }
 
     private static int scanToken(String s, int pos0) {
diff --git a/src/main/java/org/codehaus/groovy/tools/javac/JavacJavaCompiler.java b/src/main/java/org/codehaus/groovy/tools/javac/JavacJavaCompiler.java
index 32fd5d6649..e50da83af7 100644
--- a/src/main/java/org/codehaus/groovy/tools/javac/JavacJavaCompiler.java
+++ b/src/main/java/org/codehaus/groovy/tools/javac/JavacJavaCompiler.java
@@ -172,7 +172,7 @@ public class JavacJavaCompiler implements JavaCompiler {
         // files to compile
         paras.addAll(files);
 
-        return paras.toArray(new String[paras.size()]);
+        return paras.toArray(new String[0]);
     }
 
     private Class findJavac(CompilationUnit cu) throws ClassNotFoundException {
diff --git a/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
index 54008af1a6..905ced8b15 100644
--- a/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
@@ -152,7 +152,7 @@ public class NamedVariantASTTransformation extends AbstractASTTransformation {
                                 plusX(new ConstantExpression("Unrecognized namedArgKey: "), varX(namedArgKey)))
                 ));
 
-        Parameter[] genParamsArray = genParams.toArray(new Parameter[genParams.size()]);
+        Parameter[] genParamsArray = genParams.toArray(new Parameter[0]);
         // TODO account for default params giving multiple signatures
         if (cNode.hasMethod(mNode.getName(), genParamsArray)) {
             addError("Error during " + MY_TYPE_NAME + " processing. Class " + cNode.getNameWithoutPackage() +
diff --git a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 94e31f9e96..6d49c5d467 100644
--- a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -256,7 +256,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
 
         boolean hasMapCons = AnnotatedNodeUtils.hasAnnotation(cNode, MapConstructorASTTransformation.MY_TYPE);
         int modifiers = getVisibility(anno, cNode, ConstructorNode.class, ACC_PUBLIC);
-        ConstructorNode consNode = new ConstructorNode(modifiers, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body);
+        ConstructorNode consNode = new ConstructorNode(modifiers, params.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, body);
         markAsGenerated(cNode, consNode);
         cNode.addConstructor(consNode);
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 05fc6599c2..b46937045a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2144,7 +2144,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 } else if (arr.size()==1) {
                     result = arr.get(0);
                 } else {
-                    result = new UnionTypeClassNode(arr.toArray(new ClassNode[arr.size()]));
+                    result = new UnionTypeClassNode(arr.toArray(new ClassNode[0]));
                 }
             }
         }
@@ -2831,7 +2831,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             for (Expression expression : list) {
                 result.add(expression.getText());
             }
-            return result.toArray(new String[result.size()]);
+            return result.toArray(new String[0]);
         }
         throw new IllegalArgumentException("Unexpected options for @ClosureParams:"+options);
     }
@@ -3289,7 +3289,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         nodes.add(arg);
                     }
                 }
-                return new LowestUpperBoundClassNode(returnType.getName()+"Composed", OBJECT_TYPE, nodes.toArray(new ClassNode[nodes.size()]));
+                return new LowestUpperBoundClassNode(returnType.getName()+"Composed", OBJECT_TYPE, nodes.toArray(new ClassNode[0]));
             }
         }
         return returnType;
@@ -4458,7 +4458,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         Traits.collectSelfTypes(ret, selfTypes);
         if (!selfTypes.isEmpty()) {
             selfTypes.add(ret);
-            ret = new UnionTypeClassNode(selfTypes.toArray(new ClassNode[selfTypes.size()]));
+            ret = new UnionTypeClassNode(selfTypes.toArray(new ClassNode[0]));
         }
         return ret;
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index 4a108d973c..3138c187ca 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -111,7 +111,7 @@ public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
         String traitName = decomposed[0];
         String name = decomposed[1];
         LinkedHashSet<ClassNode> traitsAsList = Traits.collectAllInterfacesReverseOrder(receiver, new LinkedHashSet<ClassNode>());
-        ClassNode[] implementedTraits = traitsAsList.toArray(new ClassNode[traitsAsList.size()]);
+        ClassNode[] implementedTraits = traitsAsList.toArray(new ClassNode[0]);
         ClassNode nextTrait = null;
         for (int i = 0; i < implementedTraits.length - 1; i++) {
             ClassNode implementedTrait = implementedTraits[i];
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java b/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
index c11219e568..ac23d81c0d 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
@@ -293,7 +293,7 @@ class UnionTypeClassNode extends ClassNode {
             ClassNode[] interfaces = delegate.getInterfaces();
             if (interfaces != null) Collections.addAll(nodes, interfaces);
         }
-        return nodes.toArray(new ClassNode[nodes.size()]);
+        return nodes.toArray(new ClassNode[0]);
     }
 
     @Override
@@ -328,7 +328,7 @@ class UnionTypeClassNode extends ClassNode {
             ClassNode[] interfaces = delegate.getUnresolvedInterfaces();
             if (interfaces != null) Collections.addAll(nodes, interfaces);
         }
-        return nodes.toArray(new ClassNode[nodes.size()]);
+        return nodes.toArray(new ClassNode[0]);
     }
 
     @Override
@@ -338,7 +338,7 @@ class UnionTypeClassNode extends ClassNode {
             ClassNode[] interfaces = delegate.getUnresolvedInterfaces(useRedirect);
             if (interfaces != null) Collections.addAll(nodes, interfaces);
         }
-        return nodes.toArray(new ClassNode[nodes.size()]);
+        return nodes.toArray(new ClassNode[0]);
     }
 
     @Override
diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
index 18126de016..b3bdca20ac 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
@@ -405,7 +405,7 @@ public abstract class TraitComposer {
         }
         if (!modified) return oldTypes;
         if (l.isEmpty()) return null;
-        return l.toArray(new GenericsType[l.size()]);
+        return l.toArray(new GenericsType[0]);
     }
 
     /**
@@ -431,7 +431,7 @@ public abstract class TraitComposer {
             }
         }
         for (MethodNode superForwarder : superForwarders) {
-            doCreateSuperForwarder(targetNode, superForwarder, traits.toArray(new ClassNode[traits.size()]), genericsSpec);
+            doCreateSuperForwarder(targetNode, superForwarder, traits.toArray(new ClassNode[0]), genericsSpec);
         }
     }
 

Commit:
02dd6d669d7d5cb4abc376d2c7672f3ac9fe12d9
sunlan
sunlan@apache.org
2018-04-02 11:41:42 +0800
Trivial refactoring: avoid creating zero length array
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
index c327ba1075..88ef2844a3 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
@@ -85,7 +85,7 @@ import static org.codehaus.groovy.transform.stc.StaticTypesMarker.INFERRED_TYPE;
 public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpressionMultiTypeDispatcher implements Opcodes {
 
     private final AtomicInteger labelCounter = new AtomicInteger();
-    private static final MethodNode CLOSURE_GETTHISOBJECT_METHOD = CLOSURE_TYPE.getMethod("getThisObject", new Parameter[0]);
+    private static final MethodNode CLOSURE_GETTHISOBJECT_METHOD = CLOSURE_TYPE.getMethod("getThisObject", Parameter.EMPTY_ARRAY);
 
 
     public StaticTypesBinaryExpressionMultiTypeDispatcher(WriterController wc) {
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index f1ff7ddd5d..f89a675994 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -100,7 +100,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
     private static final MethodNode GROOVYOBJECT_GETPROPERTY_METHOD = GROOVY_OBJECT_TYPE.getMethod("getProperty", new Parameter[]{new Parameter(STRING_TYPE, "propertyName")});
     private static final MethodNode INVOKERHELPER_GETPROPERTY_METHOD = INVOKERHELPER_TYPE.getMethod("getProperty", new Parameter[]{new Parameter(OBJECT_TYPE, "object"), new Parameter(STRING_TYPE, "propertyName")});
     private static final MethodNode INVOKERHELPER_GETPROPERTYSAFE_METHOD = INVOKERHELPER_TYPE.getMethod("getPropertySafe", new Parameter[]{new Parameter(OBJECT_TYPE, "object"), new Parameter(STRING_TYPE, "propertyName")});
-    private static final MethodNode CLOSURE_GETTHISOBJECT_METHOD = CLOSURE_TYPE.getMethod("getThisObject", new Parameter[0]);
+    private static final MethodNode CLOSURE_GETTHISOBJECT_METHOD = CLOSURE_TYPE.getMethod("getThisObject", Parameter.EMPTY_ARRAY);
     private static final ClassNode COLLECTION_TYPE = make(Collection.class);
     private static final MethodNode COLLECTION_SIZE_METHOD = COLLECTION_TYPE.getMethod("size", Parameter.EMPTY_ARRAY);
     private static final MethodNode MAP_GET_METHOD = MAP_TYPE.getMethod("get", new Parameter[] { new Parameter(OBJECT_TYPE, "key")});
diff --git a/src/main/java/org/codehaus/groovy/transform/AutoImplementASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/AutoImplementASTTransformation.java
index ed097119f2..0507116f64 100644
--- a/src/main/java/org/codehaus/groovy/transform/AutoImplementASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/AutoImplementASTTransformation.java
@@ -85,7 +85,7 @@ public class AutoImplementASTTransformation extends AbstractASTTransformation {
             }
             createMethods(cNode, exception, message, (ClosureExpression) code);
             if (code != null) {
-                anno.setMember("code", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));
+                anno.setMember("code", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));
             }
         }
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
index a1aa0949e7..9016c164df 100644
--- a/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
@@ -128,7 +128,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
             createConstructors(this, anno, handler, cNode, includeFields, includeProperties, includeSuperProperties, includeSuperFields, noArg, allNames, allProperties, specialNamedArgHandling, includeStatic, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);
 
             if (pre != null) {
-                anno.setMember("pre", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));
+                anno.setMember("pre", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));
             }
             if (post != null) {
                 anno.setMember("post", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));
diff --git a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 33b17290ff..94e31f9e96 100644
--- a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -156,10 +156,10 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
                     sourceUnit, handler, (ClosureExpression) pre, (ClosureExpression) post);
 
             if (pre != null) {
-                anno.setMember("pre", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));
+                anno.setMember("pre", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));
             }
             if (post != null) {
-                anno.setMember("post", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));
+                anno.setMember("post", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));
             }
         }
     }

Commit:
b901cd65790f8842b16cbc6c1b7ac882466e9f45
sunlan
sunlan@apache.org
2018-04-02 11:38:39 +0800
Trivial refactoring: simplify bitwise operation
diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index 99c0fa4152..e281567af8 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -1652,7 +1652,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             break;
         }
         // NOTE: must be changed to "1 |" if constructor was vargs
-        return 0 | (found << 8);
+        return (found << 8);
     }
 
     private CachedConstructor createCachedConstructor(Object[] arguments) {

Commit:
db2240a5cb7c4468f08e5ce32f06d4546d1fb18f
Paul King
paulk@asert.com.au
2018-04-01 23:59:29 +1000
grab should support legacy extension method location
diff --git a/src/main/groovy/groovy/grape/GrapeIvy.groovy b/src/main/groovy/groovy/grape/GrapeIvy.groovy
index 6109dab8a4..d5efa4a1e8 100644
--- a/src/main/groovy/groovy/grape/GrapeIvy.groovy
+++ b/src/main/groovy/groovy/grape/GrapeIvy.groovy
@@ -297,6 +297,9 @@ class GrapeIvy implements GrapeEngine {
                 try {
                     JarFile jar = new JarFile(file)
                     def entry = jar.getEntry(ExtensionModuleScanner.MODULE_META_INF_FILE)
+                    if (!entry) {
+                        entry = jar.getEntry(ExtensionModuleScanner.LEGACY_MODULE_META_INF_FILE)
+                    }
                     if (entry) {
                         Properties props = new Properties()
                         props.load(jar.getInputStream(entry))
diff --git a/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java b/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
index 91031ddab9..89d5804dfe 100644
--- a/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
+++ b/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
@@ -38,7 +38,7 @@ import static org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport.closeQuiet
  * @since 2.1.2
  */
 public class ExtensionModuleScanner {
-    private static final String LEGACY_MODULE_META_INF_FILE = "META-INF/services/org.codehaus.groovy.runtime.ExtensionModule";
+    public static final String LEGACY_MODULE_META_INF_FILE = "META-INF/services/org.codehaus.groovy.runtime.ExtensionModule";
     public static final String MODULE_META_INF_FILE = "META-INF/groovy/org.codehaus.groovy.runtime.ExtensionModule";
 
     private final ExtensionModuleListener listener;

Commit:
d4e7925239a33c0f7eb9a641d03d5da76d1d5b12
Paul King
paulk@asert.com.au
2018-04-01 23:40:34 +1000
smarter extension method detection
diff --git a/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java b/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
index 5d59c1287c..91031ddab9 100644
--- a/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
+++ b/src/main/java/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
@@ -50,11 +50,13 @@ public class ExtensionModuleScanner {
     }
 
     public void scanClasspathModules() {
+        scanClasspathModulesFrom(MODULE_META_INF_FILE);
+        scanClasspathModulesFrom(LEGACY_MODULE_META_INF_FILE);
+    }
+
+    private void scanClasspathModulesFrom(String moduleMetaInfFile) {
         try {
-            Enumeration<URL> resources = classLoader.getResources(MODULE_META_INF_FILE);
-            if (!resources.hasMoreElements()) {
-                resources = classLoader.getResources(LEGACY_MODULE_META_INF_FILE);
-            }
+            Enumeration<URL> resources = classLoader.getResources(moduleMetaInfFile);
             while (resources.hasMoreElements()) {
                 URL url = resources.nextElement();
                 scanExtensionModuleFromMetaInf(url);

Commit:
a3ed9d482381f8ea0e6a9efd16c35028c66791e0
Paul King
paulk@asert.com.au
2018-04-01 23:40:33 +1000
formatting
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
index ff30a2beab..2914d02d9c 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
@@ -513,22 +513,22 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
 
         public void onModule(final ExtensionModule module) {
             if (moduleRegistry.hasModule(module.getName())) {
-            ExtensionModule loadedModule = moduleRegistry.getModule(module.getName());
-            if (loadedModule.getVersion().equals(module.getVersion())) {
-                // already registered
-                return;
-            } else {
-                throw new GroovyRuntimeException("Conflicting module versions. Module ["+module.getName()+" is loaded in version "+
-                        loadedModule.getVersion()+" and you are trying to load version "+module.getVersion());
+                ExtensionModule loadedModule = moduleRegistry.getModule(module.getName());
+                if (loadedModule.getVersion().equals(module.getVersion())) {
+                    // already registered
+                    return;
+                } else {
+                    throw new GroovyRuntimeException("Conflicting module versions. Module [" + module.getName() + " is loaded in version " +
+                            loadedModule.getVersion() + " and you are trying to load version " + module.getVersion());
+                }
             }
-        }
             moduleRegistry.addModule(module);
             // register MetaMethods
             List<MetaMethod> metaMethods = module.getMetaMethods();
             for (MetaMethod metaMethod : metaMethods) {
                 CachedClass cachedClass = metaMethod.getDeclaringClass();
                 List<MetaMethod> methods = map.get(cachedClass);
-                if (methods==null) {
+                if (methods == null) {
                     methods = new ArrayList<MetaMethod>(4);
                     map.put(cachedClass, methods);
                 }

Commit:
650c16c58f1647f154740ab2bdd2fe338c9ebd39
Paul King
paulk@asert.com.au
2018-04-01 12:46:03 +1000
binary compatibility changes for Verifier
diff --git a/build.gradle b/build.gradle
index 3f410cb93b..0ea74ed8e9 100644
--- a/build.gradle
+++ b/build.gradle
@@ -325,6 +325,7 @@ compileJava {
         ant.java(classname:'org.jboss.bridger.Bridger', classpath: rootProject.configurations.tools.asPath, outputproperty: 'stdout') {
             arg(value: "${sourceSets.main.java.outputDir.canonicalPath}/org/codehaus/groovy/runtime/DefaultGroovyMethods.class")
             arg(value: "${sourceSets.main.java.outputDir.canonicalPath}/org/codehaus/groovy/runtime/StringGroovyMethods.class")
+            arg(value: "${sourceSets.main.java.outputDir.canonicalPath}/org/codehaus/groovy/classgen/Verifier.class")
         }
         ant.echo('Bridger: ' + ant.properties.stdout)
     }
diff --git a/src/main/java/org/codehaus/groovy/classgen/Verifier.java b/src/main/java/org/codehaus/groovy/classgen/Verifier.java
index d02b6ca3ba..090cc4f7ac 100644
--- a/src/main/java/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/java/org/codehaus/groovy/classgen/Verifier.java
@@ -570,6 +570,12 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         }
     }
 
+    // for binary compatibility only, don't use or override this
+    protected void addMethod$$bridge(ClassNode node, boolean shouldBeSynthetic, String name, int modifiers, ClassNode returnType, Parameter[] parameters,
+                                   ClassNode[] exceptions, Statement code) {
+        addMethod(node, shouldBeSynthetic, name, modifiers, returnType, parameters, exceptions, code);
+    }
+
     @Deprecated
     protected void addTimeStamp(ClassNode node) {
     }
diff --git a/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index b6af6ab376..56f6fbc66e 100644
--- a/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -165,7 +165,6 @@ public class JavaStubGenerator {
                 }
 
                 public void addCovariantMethods(ClassNode cn) {}
-                protected void addTimeStamp(ClassNode node) {}
                 protected void addInitialization(ClassNode node) {}
                 protected void addPropertyMethod(MethodNode method) {
                     doAddMethod(method);

Commit:
61e1c01ed07f5e422b6d6e7060471e3366068ab4
Paul King
paulk@asert.com.au
2018-04-01 12:36:53 +1000
reduce deprecated method usage
diff --git a/src/main/groovy/groovy/util/Node.java b/src/main/groovy/groovy/util/Node.java
index 8a53aa2c24..b6e0e37474 100644
--- a/src/main/groovy/groovy/util/Node.java
+++ b/src/main/groovy/groovy/util/Node.java
@@ -798,7 +798,7 @@ public class Node implements Serializable, Cloneable {
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toInteger(text());
+        return StringGroovyMethods.toInteger((CharSequence)text());
     }
 
     /**
@@ -810,7 +810,7 @@ public class Node implements Serializable, Cloneable {
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toLong(text());
+        return StringGroovyMethods.toLong((CharSequence)text());
     }
 
     /**
@@ -822,7 +822,7 @@ public class Node implements Serializable, Cloneable {
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toFloat(text());
+        return StringGroovyMethods.toFloat((CharSequence)text());
     }
 
     /**
@@ -834,7 +834,7 @@ public class Node implements Serializable, Cloneable {
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toDouble(text());
+        return StringGroovyMethods.toDouble((CharSequence)text());
     }
 
     /**
@@ -846,7 +846,7 @@ public class Node implements Serializable, Cloneable {
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toBigDecimal(text());
+        return StringGroovyMethods.toBigDecimal((CharSequence)text());
     }
 
     /**
@@ -858,7 +858,7 @@ public class Node implements Serializable, Cloneable {
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toBigInteger(text());
+        return StringGroovyMethods.toBigInteger((CharSequence)text());
     }
 
     private boolean textIsEmptyOrNull() {
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index b16717db96..b2c944885b 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -5228,7 +5228,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 2.2.0
      */
     public static List combinations(Iterable self, Closure<?> function) {
-        return collect(GroovyCollections.combinations(self), function);
+        return collect((Iterable)GroovyCollections.combinations(self), function);
     }
 
     /**
@@ -5305,7 +5305,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 2.2.0
      */
     public static <T,V> List<V> permutations(Iterable<T> self, Closure<V> function) {
-        return collect(permutations(self),function);
+        return collect((Iterable<List<T>>) permutations(self),function);
     }
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
index b51814601c..8b102db097 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -944,11 +944,11 @@ public class InvokerHelper {
         }
         if (value instanceof String) {
             // value is a regular expression.
-            return StringGroovyMethods.bitwiseNegate(value.toString());
+            return StringGroovyMethods.bitwiseNegate((CharSequence)value.toString());
         }
         if (value instanceof GString) {
             // value is a regular expression.
-            return StringGroovyMethods.bitwiseNegate(value.toString());
+            return StringGroovyMethods.bitwiseNegate((CharSequence)value.toString());
         }
         if (value instanceof ArrayList) {
             // value is a list.
diff --git a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
index 789b27515b..4d3eeb6760 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
@@ -1459,7 +1459,7 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
         // null check because of http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4803836
         if (origFiles != null) {
             List<File> files = Arrays.asList(origFiles);
-            if (sort != null) files = DefaultGroovyMethods.sort(files, sort);
+            if (sort != null) files = DefaultGroovyMethods.sort((Iterable<File>)files, sort);
             for (File file : files) {
                 if (file.isDirectory()) {
                     if (type != FileType.FILES) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java b/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
index 1b5493eef3..83a9dc4141 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
@@ -785,7 +785,7 @@ public class ScriptBytecodeAdapter {
 
     //regexpr
     public static Pattern regexPattern(Object regex) {
-        return StringGroovyMethods.bitwiseNegate(regex.toString());
+        return StringGroovyMethods.bitwiseNegate((CharSequence)regex.toString());
     }
 
     public static Matcher findRegex(Object left, Object right) throws Throwable {
diff --git a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
index 81fffa6303..e332407c33 100644
--- a/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy
@@ -210,7 +210,7 @@ class DefaultGroovyMethodsTest extends GroovyTestCase {
         assertTrue(DefaultGroovyMethods.removeAll(list, "def".split("")))
         assertTrue(DefaultGroovyMethods.retainAll(list, "bcd".split("")))
         List<String> bAndC = ['b', 'c']
-        assertTrue(DefaultGroovyMethods.containsAll(list, bAndC.toArray(new String[2])))
+        assertTrue(DefaultGroovyMethods.containsAll((Iterable)list, bAndC.toArray(new String[2])))
         assertEquals(list, bAndC)
         assertTrue(DefaultGroovyMethods.addAll(list, 1, ['a', 's', 'i'].toArray(new String[3])))
         assertEquals(list, ['b', 'a', 's', 'i', 'c'])
diff --git a/src/test/org/codehaus/groovy/runtime/powerassert/AssertionTestUtil.groovy b/src/test/org/codehaus/groovy/runtime/powerassert/AssertionTestUtil.groovy
index 1dfd4094bd..0aac26a693 100644
--- a/src/test/org/codehaus/groovy/runtime/powerassert/AssertionTestUtil.groovy
+++ b/src/test/org/codehaus/groovy/runtime/powerassert/AssertionTestUtil.groovy
@@ -18,12 +18,10 @@
  */
 package org.codehaus.groovy.runtime.powerassert
 
-import junit.framework.Assert
+import org.junit.Assert
 
 /**
  * Utility methods for testing power assertions.
- *
- * @author Peter Niederwieser
  */
 
 abstract class AssertionTestUtil {
diff --git a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
index 58cd3e779f..8af272b219 100644
--- a/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
+++ b/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
@@ -1153,7 +1153,7 @@ public class Groovyc extends MatchingTask {
     }
 
     private String[] makeCommandLine(List<String> commandLineList) {
-        log.verbose("Compilation arguments:\n" + DefaultGroovyMethods.join(commandLineList, "\n"));
+        log.verbose("Compilation arguments:\n" + DefaultGroovyMethods.join((Iterable)commandLineList, "\n"));
         return commandLineList.toArray(new String[commandLineList.size()]);
     }
 
diff --git a/subprojects/groovy-console/src/main/groovy/groovy/ui/ConsoleTextEditor.java b/subprojects/groovy-console/src/main/groovy/groovy/ui/ConsoleTextEditor.java
index b9be0ea0b8..161452749a 100644
--- a/subprojects/groovy-console/src/main/groovy/groovy/ui/ConsoleTextEditor.java
+++ b/subprojects/groovy-console/src/main/groovy/groovy/ui/ConsoleTextEditor.java
@@ -93,7 +93,7 @@ public class ConsoleTextEditor extends JScrollPane {
             }
             g.setFont(f);
             for (int line = startline, y = startingY; line <= endline; y += fontHeight, line++) {
-                String lineNumber = StringGroovyMethods.padLeft(Integer.toString(line), 4, " ");
+                String lineNumber = StringGroovyMethods.padLeft((CharSequence)Integer.toString(line), 4, " ");
                 g.drawString(lineNumber, 0, y);
             }
         }
diff --git a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy b/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
index 699f70ce45..eb1c35e411 100644
--- a/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
+++ b/subprojects/groovy-docgenerator/src/main/groovy/org/codehaus/groovy/tools/DocGenerator.groovy
@@ -402,7 +402,7 @@ class DocGenerator {
         }
 
         String getReturnTypeDocUrl() {
-            def returnType = javaMethod.returns
+            def returnType = javaMethod.returnType
             def resolvedReturnType = (returnType) ? DocUtil.resolveJdkClassName(returnType.toString()) : ""
             DocUtil.getLinkAnchor(resolvedReturnType, declaringDocType.packageName)
         }
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
index a7c8687027..e3d46379cb 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
@@ -476,7 +476,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
                     }
                     sb = new StringBuilder(getDocUrl(outerType, full, links, relativePath, rootDoc, classDoc));
                     sb.append("&lt;");
-                    sb.append(DefaultGroovyMethods.join(typeUrls, ", "));
+                    sb.append(DefaultGroovyMethods.join((Iterable) typeUrls, ", "));
                     sb.append("&gt;");
                     return sb.toString();
                 }
@@ -910,7 +910,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
                 sb.append(preKey);
                 sb.append(e.getKey());
                 sb.append(postKey);
-                sb.append(DefaultGroovyMethods.join(e.getValue(), valueSeparator));
+                sb.append(DefaultGroovyMethods.join((Iterable)e.getValue(), valueSeparator));
                 sb.append(postValues);
             }
             return sb.toString();
diff --git a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java
index 7d7855e10e..3796f4659d 100644
--- a/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java
+++ b/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java
@@ -890,7 +890,7 @@ public class SimpleGroovyClassDocAssembler extends VisitorAdapter implements Gro
                 }
                 typeArgumentsNext = (GroovySourceAST) typeArgumentsNext.getNextSibling();
             }
-            result.append(DefaultGroovyMethods.join(typeArgumentParts, ", "));
+            result.append(DefaultGroovyMethods.join((Iterable)typeArgumentParts, ", "));
             result.append(">");
         }
     }
@@ -906,7 +906,7 @@ public class SimpleGroovyClassDocAssembler extends VisitorAdapter implements Gro
                 }
                 typeParametersNext = (GroovySourceAST) typeParametersNext.getNextSibling();
             }
-            result.append(DefaultGroovyMethods.join(typeParameterParts, ", "));
+            result.append(DefaultGroovyMethods.join((Iterable)typeParameterParts, ", "));
             result.append(">");
         }
     }
diff --git a/subprojects/groovy-nio/src/main/java/org/codehaus/groovy/runtime/NioGroovyMethods.java b/subprojects/groovy-nio/src/main/java/org/codehaus/groovy/runtime/NioGroovyMethods.java
index 128bc090a6..58ad3f00a2 100644
--- a/subprojects/groovy-nio/src/main/java/org/codehaus/groovy/runtime/NioGroovyMethods.java
+++ b/subprojects/groovy-nio/src/main/java/org/codehaus/groovy/runtime/NioGroovyMethods.java
@@ -1141,7 +1141,7 @@ public class NioGroovyMethods extends DefaultGroovyMethodsSupport {
                 files.add(itr.next());
             }
 
-            if (sort != null) files = DefaultGroovyMethods.sort(files, sort);
+            if (sort != null) files = DefaultGroovyMethods.sort((Iterable<Path>)files, sort);
 
             for (Path path : files) {
                 if (Files.isDirectory(path)) {
diff --git a/subprojects/groovy-test/src/main/groovy/groovy/util/StringTestUtil.groovy b/subprojects/groovy-test/src/main/groovy/groovy/util/StringTestUtil.groovy
index d605a4779e..b9bb85566c 100644
--- a/subprojects/groovy-test/src/main/groovy/groovy/util/StringTestUtil.groovy
+++ b/subprojects/groovy-test/src/main/groovy/groovy/util/StringTestUtil.groovy
@@ -18,7 +18,7 @@
  */
 package groovy.util
 
-import junit.framework.Assert
+import org.junit.Assert
 
 class StringTestUtil {
     static void assertMultilineStringsEqual(String a, String b) {
@@ -29,4 +29,4 @@ class StringTestUtil {
             Assert.assertEquals(aLines[i].trim(), bLines[i].trim())
         }
     }
-}
\ No newline at end of file
+}
diff --git a/subprojects/groovy-xml/src/main/java/groovy/util/slurpersupport/GPathResult.java b/subprojects/groovy-xml/src/main/java/groovy/util/slurpersupport/GPathResult.java
index 0020c67cf7..65e24d1a5b 100644
--- a/subprojects/groovy-xml/src/main/java/groovy/util/slurpersupport/GPathResult.java
+++ b/subprojects/groovy-xml/src/main/java/groovy/util/slurpersupport/GPathResult.java
@@ -285,7 +285,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toInteger(text());
+        return StringGroovyMethods.toInteger((CharSequence)text());
     }
 
     /**
@@ -297,7 +297,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toLong(text());
+        return StringGroovyMethods.toLong((CharSequence)text());
     }
 
     /**
@@ -309,7 +309,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toFloat(text());
+        return StringGroovyMethods.toFloat((CharSequence)text());
     }
 
     /**
@@ -321,7 +321,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toDouble(text());
+        return StringGroovyMethods.toDouble((CharSequence)text());
     }
 
     /**
@@ -333,7 +333,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toBigDecimal(text());
+        return StringGroovyMethods.toBigDecimal((CharSequence)text());
     }
 
     /**
@@ -345,7 +345,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
         if(textIsEmptyOrNull()){
             return null;
         }
-        return StringGroovyMethods.toBigInteger(text());
+        return StringGroovyMethods.toBigInteger((CharSequence)text());
     }
 
     private boolean textIsEmptyOrNull() {
@@ -359,7 +359,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
      * @return the GPathResult, converted to a <code>URL</code>
      */
     public URL toURL() throws MalformedURLException {
-        return ResourceGroovyMethods.toURL(text());
+        return ResourceGroovyMethods.toURL((CharSequence)text());
     }
 
     /**
@@ -368,7 +368,7 @@ public abstract class GPathResult extends GroovyObjectSupport implements Writabl
      * @return the GPathResult, converted to a <code>URI</code>
      */
     public URI toURI() throws URISyntaxException {
-        return ResourceGroovyMethods.toURI(text());
+        return ResourceGroovyMethods.toURI((CharSequence)text());
     }
 
     /**

Commit:
a3b8a4f62c594ecdd48eef51ded98f8320c90c5d
Paul King
paulk@asert.com.au
2018-04-01 11:39:51 +1000
unused deprecated method changed - reverting for binary compatibility
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v5/Java5.java b/src/main/java/org/codehaus/groovy/vmplugin/v5/Java5.java
index 8e4fe7fe77..6580b76ee6 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v5/Java5.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v5/Java5.java
@@ -213,8 +213,9 @@ public class Java5 implements VMPlugin {
     }
 
     @Deprecated
-    public static void configureAnnotationFromDefinition(AnnotationNode definition, AnnotationNode root) {
-        VMPluginFactory.getPlugin().configureAnnotationNodeFromDefinition(definition, root);
+    public void configureAnnotationFromDefinition(AnnotationNode definition, AnnotationNode root) {
+        VMPlugin plugin = VMPluginFactory.getPlugin();
+        plugin.configureAnnotationNodeFromDefinition(definition, root);
     }
 
     public void configureAnnotationNodeFromDefinition(AnnotationNode definition, AnnotationNode root) {
@@ -244,11 +245,12 @@ public class Java5 implements VMPlugin {
 
     public void configureAnnotation(AnnotationNode node) {
         ClassNode type = node.getClassNode();
+        VMPlugin plugin = VMPluginFactory.getPlugin();
         List<AnnotationNode> annotations = type.getAnnotations();
         for (AnnotationNode an : annotations) {
-            configureAnnotationFromDefinition(an, node);
+            plugin.configureAnnotationNodeFromDefinition(an, node);
         }
-        configureAnnotationFromDefinition(node, node);
+        plugin.configureAnnotationNodeFromDefinition(node, node);
     }
 
     private void configureAnnotation(AnnotationNode node, Annotation annotation) {

Commit:
e367eb4b439455518b974d3ea5e29bceea127d2b
Paul King
paulk@asert.com.au
2018-04-01 11:39:50 +1000
deprecated method modifiers changed - reverting for binary compatibility
diff --git a/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
index fad53bed38..6e781adef4 100644
--- a/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -175,7 +175,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     }
 
     @Deprecated
-    public List<String> getMemberList(AnnotationNode anno, String name) {
+    public static List<String> getMemberList(AnnotationNode anno, String name) {
         List<String> list;
         Expression expr = anno.getMember(name);
         if (expr != null && expr instanceof ListExpression) {

Commit:
1c47117ec229ef5b19d863f4841ac1a1e03a205f
Paul King
paulk@asert.com.au
2018-04-01 11:39:49 +1000
remove an unused build file and add two $$bridge methods for binary compatibility
diff --git a/build.gradle b/build.gradle
index 3e094e64cc..3f410cb93b 100644
--- a/build.gradle
+++ b/build.gradle
@@ -324,6 +324,7 @@ compileJava {
     doLast {
         ant.java(classname:'org.jboss.bridger.Bridger', classpath: rootProject.configurations.tools.asPath, outputproperty: 'stdout') {
             arg(value: "${sourceSets.main.java.outputDir.canonicalPath}/org/codehaus/groovy/runtime/DefaultGroovyMethods.class")
+            arg(value: "${sourceSets.main.java.outputDir.canonicalPath}/org/codehaus/groovy/runtime/StringGroovyMethods.class")
         }
         ant.echo('Bridger: ' + ant.properties.stdout)
     }
@@ -358,7 +359,6 @@ task ensureGrammars {
     }
 }
 
-apply from: 'gradle/utils.gradle'
 apply from: 'wrapper.gradle'
 
 task dgmConverter(dependsOn:compileJava) {
diff --git a/gradle/utils.gradle b/gradle/utils.gradle
deleted file mode 100644
index 6baf1c91ac..0000000000
--- a/gradle/utils.gradle
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-import org.objectweb.asm.MethodVisitor
-import org.objectweb.asm.ClassWriter
-import org.objectweb.asm.Label
-
-import static org.objectweb.asm.Opcodes.ACC_PUBLIC
-import static org.objectweb.asm.Opcodes.ACC_STATIC
-import static org.objectweb.asm.Opcodes.ACC_SUPER
-import static org.objectweb.asm.Opcodes.ALOAD
-import static org.objectweb.asm.Opcodes.ATHROW
-import static org.objectweb.asm.Opcodes.INVOKESPECIAL
-import static org.objectweb.asm.Opcodes.RETURN
-import static org.objectweb.asm.Opcodes.V1_5
-
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath "org.ow2.asm:asm:$asmVersion"
-    }
-}
diff --git a/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java
index 0ae574c371..35d9ab6f5a 100644
--- a/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java
@@ -547,6 +547,12 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
         return join(DefaultGroovyMethods.dropWhile(selfIter, condition), "");
     }
 
+    // for binary compatibility only
+    @Deprecated
+    public static CharSequence dropWhile$$bridge(CharSequence self, @ClosureParams(value=FromString.class, conflictResolutionStrategy=PickFirstResolver.class, options={"String", "Character"}) Closure condition) {
+        return dropWhile(self, condition);
+    }
+
     /**
      * A GString variant of the equivalent CharSequence method.
      *
@@ -3344,6 +3350,12 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
         return join(DefaultGroovyMethods.takeWhile(selfIter, condition), "");
     }
 
+    // for binary compatibility only
+    @Deprecated
+    public static CharSequence takeWhile$$bridge(CharSequence self, @ClosureParams(value=FromString.class, conflictResolutionStrategy=PickFirstResolver.class, options={"String", "Character"}) Closure condition) {
+        return takeWhile(self, condition);
+    }
+
     /**
      * A GString variant of the equivalent GString method.
      *

Commit:
fff3cf02c49f012107f4dac099d7b93a6c2590c6
Paul King
paulk@asert.com.au
2018-04-01 11:39:48 +1000
remove javadoc warnings
diff --git a/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeExtensions.java b/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeExtensions.java
index 9ba60149a4..c46789a34c 100644
--- a/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeExtensions.java
+++ b/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeExtensions.java
@@ -140,7 +140,7 @@ public class DateTimeExtensions {
      * {@link java.time.temporal.Temporal} argument.
      * <p>
      * If the unit is too large to iterate to the second Temporal exactly, such as iterating from two LocalDateTimes
-     * that are seconds apart using {@java.time.temporal.ChronoUnit#DAYS} as the unit, the iteration will cease
+     * that are seconds apart using {@link java.time.temporal.ChronoUnit#DAYS} as the unit, the iteration will cease
      * as soon as the current value of the iteration is later than the second Temporal argument. The closure will
      * not be called with any value later than the {@code to} value.
      *
@@ -208,7 +208,7 @@ public class DateTimeExtensions {
      * {@link java.time.temporal.Temporal} argument.
      * <p>
      * If the unit is too large to iterate to the second Temporal exactly, such as iterating from two LocalDateTimes
-     * that are seconds apart using {@java.time.temporal.ChronoUnit#DAYS} as the unit, the iteration will cease
+     * that are seconds apart using {@link java.time.temporal.ChronoUnit#DAYS} as the unit, the iteration will cease
      * as soon as the current value of the iteration is earlier than the second Temporal argument. The closure will
      * not be called with any value earlier than the {@code to} value.
      *

Commit:
076106dd83e56e2336926f579bb6de35eb758a40
danielsun1106
realbluesun@hotmail.com
2018-03-31 20:51:54 +0800
Refine the lexer rule for triple quote string
diff --git a/src/antlr/GroovyLexer.g4 b/src/antlr/GroovyLexer.g4
index 9fc0f8524e..097dd4c129 100644
--- a/src/antlr/GroovyLexer.g4
+++ b/src/antlr/GroovyLexer.g4
@@ -314,14 +314,14 @@ SqStringCharacter
 // character in the triple double quotation string. e.g. """a"""
 fragment TdqStringCharacter
     :   ~["\\$]
-    |   GStringQuotationMark { _input.LA(1) != '"' || _input.LA(2) != '"' || (_input.LA(3) == '"' && _input.LA(4) != '"') || (_input.LA(3) == '"' && _input.LA(5) != '"') }?
+    |   GStringQuotationMark { _input.LA(1) != '"' || _input.LA(2) != '"' || _input.LA(3) == '"' && (_input.LA(4) != '"' || _input.LA(5) != '"') }?
     |   EscapeSequence
     ;
 
 // character in the triple single quotation string. e.g. '''a'''
 fragment TsqStringCharacter
     :   ~['\\]
-    |   SqStringQuotationMark { _input.LA(1) != '\'' || _input.LA(2) != '\'' || (_input.LA(3) == '\'' && _input.LA(4) != '\'') || (_input.LA(3) == '\'' && _input.LA(5) != '\'') }?
+    |   SqStringQuotationMark { _input.LA(1) != '\'' || _input.LA(2) != '\'' || _input.LA(3) == '\'' && (_input.LA(4) != '\'' || _input.LA(5) != '\'') }?
     |   EscapeSequence
     ;
 

Commit:
cf34f4c019f4db85e03508ce043f130fdf153ebe
danielsun1106
realbluesun@hotmail.com
2018-03-31 20:08:07 +0800
Forbid `"""` and `'''` quoting themselves at the end of string
diff --git a/src/antlr/GroovyLexer.g4 b/src/antlr/GroovyLexer.g4
index 78bbd69ea0..9fc0f8524e 100644
--- a/src/antlr/GroovyLexer.g4
+++ b/src/antlr/GroovyLexer.g4
@@ -314,14 +314,14 @@ SqStringCharacter
 // character in the triple double quotation string. e.g. """a"""
 fragment TdqStringCharacter
     :   ~["\\$]
-    |   GStringQuotationMark { _input.LA(1) != '"' || _input.LA(2) != '"' || _input.LA(3) == '"' }?
+    |   GStringQuotationMark { _input.LA(1) != '"' || _input.LA(2) != '"' || (_input.LA(3) == '"' && _input.LA(4) != '"') || (_input.LA(3) == '"' && _input.LA(5) != '"') }?
     |   EscapeSequence
     ;
 
 // character in the triple single quotation string. e.g. '''a'''
 fragment TsqStringCharacter
     :   ~['\\]
-    |   SqStringQuotationMark { _input.LA(1) != '\'' || _input.LA(2) != '\'' || _input.LA(3) == '\'' }?
+    |   SqStringQuotationMark { _input.LA(1) != '\'' || _input.LA(2) != '\'' || (_input.LA(3) == '\'' && _input.LA(4) != '\'') || (_input.LA(3) == '\'' && _input.LA(5) != '\'') }?
     |   EscapeSequence
     ;
 
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
index a956e4c71b..c23e8f4b9e 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/SyntaxErrorTest.groovy
@@ -217,6 +217,11 @@ class SyntaxErrorTest extends GroovyTestCase {
         TestUtils.doRunAndShouldFail('fail/Var_02x.groovy');
     }
 
+    void "test groovy core - String"() {
+        TestUtils.doRunAndShouldFail('fail/String_01x.groovy');
+        TestUtils.doRunAndShouldFail('fail/String_02x.groovy');
+    }
+
     /**************************************/
     static unzipScriptAndShouldFail(String entryName, List ignoreClazzList, Map<String, String> replacementsMap=[:], boolean toCheckNewParserOnly = false) {
         ignoreClazzList.addAll(TestUtils.COMMON_IGNORE_CLASS_LIST)
diff --git a/subprojects/parser-antlr4/src/test/resources/core/String_01x.groovy b/subprojects/parser-antlr4/src/test/resources/core/String_01x.groovy
index 8f9a5ca459..636bb2df96 100644
--- a/subprojects/parser-antlr4/src/test/resources/core/String_01x.groovy
+++ b/subprojects/parser-antlr4/src/test/resources/core/String_01x.groovy
@@ -17,7 +17,7 @@
  *  under the License.
  */
 
-def v = '''string='a''''
-assert v == '''string=\'a\''''
-def v2 = """string="a""""
-assert v2 == """string=\"a\""""
\ No newline at end of file
+assert '''string=\'a\'''' == '''string='a''''
+assert """string=\"a\"""" == """string="a""""
+assert '''123\'\'''' == '''123'''''
+assert """123\"\"""" == """123"""""
\ No newline at end of file
diff --git a/subprojects/parser-antlr4/src/test/resources/fail/String_01x.groovy b/subprojects/parser-antlr4/src/test/resources/fail/String_01x.groovy
new file mode 100644
index 0000000000..8e810de375
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/fail/String_01x.groovy
@@ -0,0 +1,20 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+def v = '''123''''''
\ No newline at end of file
diff --git a/subprojects/parser-antlr4/src/test/resources/fail/String_02x.groovy b/subprojects/parser-antlr4/src/test/resources/fail/String_02x.groovy
new file mode 100644
index 0000000000..0476ff5742
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/fail/String_02x.groovy
@@ -0,0 +1,20 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+def v2 = """123""""""
\ No newline at end of file

Commit:
49fae701c71fa6e52882e7a9c82715e9d92a7589
Paul King
paulk@asert.com.au
2018-03-31 16:00:09 +1000
Merge remote-tracking branch 'origin/master'
Commit:
38c7a7492080a93d067b8eaa4c81edd1cd7ef784
Paul King
paulk@asert.com.au
2018-03-31 15:33:41 +1000
GROOVY-8525: Binary compatibility issue for GroovyClassLoader between 2.4 vs later branches (closes #679)
diff --git a/src/main/groovy/groovy/lang/GroovyClassLoader.java b/src/main/groovy/groovy/lang/GroovyClassLoader.java
index 23c63b2107..626ffb04b2 100644
--- a/src/main/groovy/groovy/lang/GroovyClassLoader.java
+++ b/src/main/groovy/groovy/lang/GroovyClassLoader.java
@@ -90,13 +90,13 @@ public class GroovyClassLoader extends URLClassLoader {
     /**
      * this cache contains the loaded classes or PARSING, if the class is currently parsed
      */
-    protected final EvictableCache<String, Class> classCache = new UnlimitedConcurrentCache<String, Class>();
+    protected final Map<String, Class> classCache = new UnlimitedConcurrentCache<String, Class>();
 
     /**
      * This cache contains mappings of file name to class. It is used
      * to bypass compilation.
      */
-    protected final EvictableCache<String, Class> sourceCache = new StampedCommonCache<String, Class>();
+    protected final Map<String, Class> sourceCache = new StampedCommonCache<String, Class>();
 
     private final CompilerConfiguration config;
     private String sourceEncoding;
@@ -1017,7 +1017,7 @@ public class GroovyClassLoader extends URLClassLoader {
      * @see #removeClassCacheEntry(String)
      */
     public void clearCache() {
-        Map<String, Class> clearedClasses = classCache.clear();
+        Map<String, Class> clearedClasses = ((EvictableCache<String, Class>)classCache).clearAll();
 
         sourceCache.clear();
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/CommonCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/CommonCache.java
index af193da890..0f7fb751d8 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/CommonCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/CommonCache.java
@@ -108,7 +108,7 @@ public class CommonCache<K, V> implements EvictableCache<K, V>, ValueConvertable
      * {@inheritDoc}
      */
     @Override
-    public V get(K key) {
+    public V get(Object key) {
         return map.get(key);
     }
 
@@ -150,6 +150,11 @@ public class CommonCache<K, V> implements EvictableCache<K, V>, ValueConvertable
         return map.values();
     }
 
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return map.entrySet();
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -158,11 +163,16 @@ public class CommonCache<K, V> implements EvictableCache<K, V>, ValueConvertable
         return map.keySet();
     }
 
+    @Override
+    public boolean containsValue(Object value) {
+        return map.containsValue(value);
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public boolean containsKey(K key) {
+    public boolean containsKey(Object key) {
         return map.containsKey(key);
     }
 
@@ -174,22 +184,36 @@ public class CommonCache<K, V> implements EvictableCache<K, V>, ValueConvertable
         return map.size();
     }
 
+    @Override
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public V remove(K key) {
+    public V remove(Object key) {
         return map.remove(key);
     }
 
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        map.putAll(m);
+    }
+
+    @Override
+    public Set<K> keySet() {
+        return map.keySet();
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public Map<K, V> clear() {
+    public Map<K, V> clearAll() {
         Map<K, V> result = new LinkedHashMap<K, V>(map);
         map.clear();
-
         return result;
     }
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java
index ad852be772..7032889c80 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java
@@ -93,7 +93,7 @@ public class ConcurrentCommonCache<K, V> implements EvictableCache<K, V>, ValueC
      * {@inheritDoc}
      */
     @Override
-    public V get(final K key) {
+    public V get(final Object key) {
         return doWithReadLock(c -> c.get(key));
     }
 
@@ -153,6 +153,11 @@ public class ConcurrentCommonCache<K, V> implements EvictableCache<K, V>, ValueC
         return doWithReadLock(c -> c.values());
     }
 
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return doWithReadLock(c -> c.entrySet());
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -165,10 +170,15 @@ public class ConcurrentCommonCache<K, V> implements EvictableCache<K, V>, ValueC
      * {@inheritDoc}
      */
     @Override
-    public boolean containsKey(final K key) {
+    public boolean containsKey(final Object key) {
         return doWithReadLock(c -> c.containsKey(key));
     }
 
+    @Override
+    public boolean containsValue(Object value) {
+        return doWithReadLock(c -> c.containsValue(value));
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -177,20 +187,38 @@ public class ConcurrentCommonCache<K, V> implements EvictableCache<K, V>, ValueC
         return doWithReadLock(c -> c.size());
     }
 
+    @Override
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public V remove(final K key) {
+    public V remove(final Object key) {
         return doWithWriteLock(c -> c.remove(key));
     }
 
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        doWithWriteLock(c -> {
+            c.putAll(m);
+            return null;
+        });
+    }
+
+    @Override
+    public Set<K> keySet() {
+        return keys();
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public Map<K, V> clear() {
-        return doWithWriteLock(c -> c.clear());
+    public Map<K, V> clearAll() {
+        return doWithWriteLock(c -> c.clearAll());
     }
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/EvictableCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/EvictableCache.java
index 6621f99d10..306df8bc03 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/EvictableCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/EvictableCache.java
@@ -29,19 +29,27 @@ import java.util.Set;
  *
  * @since 2.5.0
  */
-public interface EvictableCache<K, V> extends MemoizeCache<K, V> {
+public interface EvictableCache<K, V> extends MemoizeCache<K, V>, Map<K, V>/* */ {
     /**
      * Remove the cached value by the key
-     * @param key
+     * @param key of the cached value
      * @return returns the removed value
      */
-    V remove(K key);
+    V remove(Object key);
 
     /**
      * Clear the cache
      * @return returns the content of the cleared map
      */
-    Map<K, V> clear();
+    Map<K, V> clearAll();
+
+    /**
+     * Clear the cache
+     * @see #clearAll()
+     */
+    default void clear() {
+        clearAll();
+    }
 
     /**
      * Get all cached values
@@ -60,7 +68,7 @@ public interface EvictableCache<K, V> extends MemoizeCache<K, V> {
      * @param key key whose presence in this cache is to be tested.
      * @return true if the cache contains a mapping for the specified key
      */
-    boolean containsKey(K key);
+    boolean containsKey(Object key);
 
     /**
      * Get the size of the cache
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/LRUCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/LRUCache.java
index 63dc43a826..947a23900c 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/LRUCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/LRUCache.java
@@ -28,9 +28,6 @@ import java.util.concurrent.ConcurrentMap;
 
 /**
  * A cache backed by a ConcurrentLinkedHashMap
- *
- * @author Vaclav Pech
- * @author <a href="mailto:realbluesun@hotmail.com">Daniel.Sun</a>
  */
 @ThreadSafe
 public final class LRUCache<K, V> implements MemoizeCache<K, V> {
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/LRUProtectionStorage.java b/src/main/java/org/codehaus/groovy/runtime/memoize/LRUProtectionStorage.java
index b7b063764f..f72c211b19 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/LRUProtectionStorage.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/LRUProtectionStorage.java
@@ -26,8 +26,6 @@ import java.util.Map;
  * If the maximum size has been reached all newly added elements will cause the oldest element to be removed from the storage
  * in order not to exceed the maximum capacity.
  * The touch method can be used to renew an element and move it to the from the LRU queue.
- *
- * @author Vaclav Pech
  */
 final class LRUProtectionStorage extends LinkedHashMap<Object, Object> implements ProtectionStorage {
     private static final long serialVersionUID = 1L;
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/Memoize.java b/src/main/java/org/codehaus/groovy/runtime/memoize/Memoize.java
index 035228f786..21608df884 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/Memoize.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/Memoize.java
@@ -30,8 +30,6 @@ import static java.util.Arrays.copyOf;
 /**
  * Implements memoize for Closures.
  * It is supposed to be used by the Closure class itself to implement the memoize() family of methods.
- *
- * @author Vaclav Pech
  */
 public abstract class Memoize {
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/MemoizeCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/MemoizeCache.java
index 0efbddaa45..c52591920e 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/MemoizeCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/MemoizeCache.java
@@ -22,8 +22,6 @@ package org.codehaus.groovy.runtime.memoize;
  * Represents a memoize cache with its essential methods
  * @param <K> type of the keys
  * @param <V> type of the values
- *
- * @author Vaclav Pech
  */
 public interface MemoizeCache<K, V> {
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/NullProtectionStorage.java b/src/main/java/org/codehaus/groovy/runtime/memoize/NullProtectionStorage.java
index 2a54e5bf79..372a23d9d4 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/NullProtectionStorage.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/NullProtectionStorage.java
@@ -22,8 +22,6 @@ package org.codehaus.groovy.runtime.memoize;
  * A NullObject pattern implementation for ProtectionStorage
  * Doesn't protect any resources.
  * Used when the user doesn't mind to eventually have the whole memoize cache emptied by gc.
- *
- * @author Vaclav Pech
  */
 public final class NullProtectionStorage implements ProtectionStorage{
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/ProtectionStorage.java b/src/main/java/org/codehaus/groovy/runtime/memoize/ProtectionStorage.java
index a820389e25..cc4f32892d 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/ProtectionStorage.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/ProtectionStorage.java
@@ -21,8 +21,6 @@ package org.codehaus.groovy.runtime.memoize;
 /**
  * Protects stored resources from eviction from memory following the LRU (Last Recently Used) strategy.
  * The touch method can be used to renew an element and move it to the from the LRU queue.
- *
- * @author Vaclav Pech
  */
 interface ProtectionStorage<K, V> {
     void touch(K key, V value);
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/StampedCommonCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/StampedCommonCache.java
index 19fab992a0..f46524889f 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/StampedCommonCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/StampedCommonCache.java
@@ -31,7 +31,6 @@ import java.util.concurrent.locks.StampedLock;
  * but it is not reentrant, in other words, <b>it may cause deadlock</b> if {@link #getAndPut(K, ValueProvider)} OR {@link #getAndPut(K, ValueProvider, boolean)} is called recursively:
  * readlock -> upgrade to writelock -> readlock(fails to get and wait forever)
  *
- *
  * @param <K> type of the keys
  * @param <V> type of the values
  * @since 3.0.0
@@ -95,7 +94,7 @@ public class StampedCommonCache<K, V> implements EvictableCache<K, V>, ValueConv
      * {@inheritDoc}
      */
     @Override
-    public V get(final K key) {
+    public V get(final Object key) {
         return doWithReadLock(c -> c.get(key));
     }
 
@@ -175,6 +174,11 @@ public class StampedCommonCache<K, V> implements EvictableCache<K, V>, ValueConv
         return doWithReadLock(c -> c.values());
     }
 
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return doWithReadLock(c -> c.entrySet());
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -187,10 +191,15 @@ public class StampedCommonCache<K, V> implements EvictableCache<K, V>, ValueConv
      * {@inheritDoc}
      */
     @Override
-    public boolean containsKey(final K key) {
+    public boolean containsKey(final Object key) {
         return doWithReadLock(c -> c.containsKey(key));
     }
 
+    @Override
+    public boolean containsValue(Object value) {
+        return doWithReadLock(c -> c.containsValue(value));
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -199,20 +208,38 @@ public class StampedCommonCache<K, V> implements EvictableCache<K, V>, ValueConv
         return doWithReadLock(c -> c.size());
     }
 
+    @Override
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public V remove(final K key) {
+    public V remove(final Object key) {
         return doWithWriteLock(c -> c.remove(key));
     }
 
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        doWithWriteLock(c -> {
+            c.putAll(m);
+            return null;
+        });
+    }
+
+    @Override
+    public Set<K> keySet() {
+        return keys();
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public Map<K, V> clear() {
-        return doWithWriteLock(c -> c.clear());
+    public Map<K, V> clearAll() {
+        return doWithWriteLock(c -> c.clearAll());
     }
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
index 0460fe9ecb..e602658ffe 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCache.java
@@ -29,8 +29,6 @@ import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * A cache backed by a ConcurrentHashMap
- *
- * @author Vaclav Pech
  */
 @ThreadSafe
 public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V>, Serializable {
@@ -67,17 +65,27 @@ public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V
      * @return returns the removed value
      */
     @Override
-    public V remove(K key) {
+    public V remove(Object key) {
         return map.remove(key);
     }
 
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        map.putAll(m);
+    }
+
+    @Override
+    public Set<K> keySet() {
+        return map.keySet();
+    }
+
     /**
      * Clear the cache
      *
      * @return returns the content of the cleared map
      */
     @Override
-    public Map<K, V> clear() {
+    public Map<K, V> clearAll() {
         Map<K, V> result = new LinkedHashMap<K, V>(map.size());
 
         for (Map.Entry<K, V> entry : map.entrySet()) {
@@ -104,6 +112,11 @@ public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V
         return map.values();
     }
 
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return map.entrySet();
+    }
+
     /**
      * Get all keys associated to cached values
      *
@@ -121,10 +134,15 @@ public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V
      * @return true if the cache contains a mapping for the specified key
      */
     @Override
-    public boolean containsKey(K key) {
+    public boolean containsKey(Object key) {
         return map.containsKey(key);
     }
 
+    @Override
+    public boolean containsValue(Object value) {
+        return map.containsValue(value);
+    }
+
     /**
      * Get the size of the cache
      *
@@ -135,6 +153,11 @@ public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V
         return map.size();
     }
 
+    @Override
+    public boolean isEmpty() {
+        return map.isEmpty();
+    }
+
     /**
      * Associates the specified value with the specified key in the cache.
      *
@@ -154,7 +177,7 @@ public final class UnlimitedConcurrentCache<K, V> implements EvictableCache<K, V
      * @return the value, or null, if it does not exist.
      */
     @Override
-    public V get(K key) {
+    public V get(Object key) {
         return map.get(key);
     }
 
diff --git a/src/test/org/codehaus/groovy/runtime/memoize/CacheCleanupTest.groovy b/src/test/org/codehaus/groovy/runtime/memoize/CacheCleanupTest.groovy
index f4d48d93be..8cf2415855 100644
--- a/src/test/org/codehaus/groovy/runtime/memoize/CacheCleanupTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/memoize/CacheCleanupTest.groovy
@@ -22,9 +22,6 @@ import java.lang.ref.SoftReference
 import java.util.concurrent.CyclicBarrier
 import java.util.concurrent.TimeUnit
 
-/**
- * @author Vaclav Pech
- */
 public class CacheCleanupTest extends GroovyTestCase {
     private static final Object ANCHOR = "I'm never gonna go"
     
@@ -34,14 +31,14 @@ public class CacheCleanupTest extends GroovyTestCase {
     }
 
     private def checkCache(MemoizeCache cache) {
-        assert cache.map.size() == 0
+        assert cache.@map.size() == 0
         cache.put('key1', new SoftReference(ANCHOR))
         cache.put('key2', new SoftReference(ANCHOR))
-        assert cache.map.size() == 2
+        assert cache.@map.size() == 2
         cache.put('key3', new SoftReference(null))  //Simulating evicted objects
         cache.put('key4', new SoftReference(null))
         cache.cleanUpNullReferences()
-        assert cache.map.size() == 2
+        assert cache.@map.size() == 2
     }
 
     public void testUnlimitedCacheConcurrently() {
@@ -51,10 +48,10 @@ public class CacheCleanupTest extends GroovyTestCase {
     }
 
     private def checkCacheConcurrently(MemoizeCache cache) {
-        assert cache.map.size() == 0
+        assert cache.@map.size() == 0
         cache.put('key1', new SoftReference(ANCHOR))
         cache.put('key2', new SoftReference(ANCHOR))
-        assert cache.map.size() == 2
+        assert cache.@map.size() == 2
         for (i in (3..1000)) {
             cache.put("key${i}", new SoftReference(null))  //Simulating evicted objects
             cache.get('key1')  //touch the non-null cache entries to keep them hot to prevent a potential LRU algorithm from evicting them
@@ -72,6 +69,6 @@ public class CacheCleanupTest extends GroovyTestCase {
         barrier.await(30, TimeUnit.SECONDS)  //start threads
         barrier.await(30, TimeUnit.SECONDS)  //wait for threads to finish
 
-        assert cache.map.size() == 2
+        assert cache.@map.size() == 2
     }
 }
diff --git a/src/test/org/codehaus/groovy/runtime/memoize/CommonCacheTest.java b/src/test/org/codehaus/groovy/runtime/memoize/CommonCacheTest.java
index 74defbd85c..bd2c7e9686 100644
--- a/src/test/org/codehaus/groovy/runtime/memoize/CommonCacheTest.java
+++ b/src/test/org/codehaus/groovy/runtime/memoize/CommonCacheTest.java
@@ -156,7 +156,7 @@ public class CommonCacheTest {
                         )
                 );
 
-        Assert.assertArrayEquals(new String[] {"Daniel", "Male", "Shanghai"}, sc.clear().values().toArray(new String[0]));
+        Assert.assertArrayEquals(new String[] {"Daniel", "Male", "Shanghai"}, sc.clearAll().values().toArray(new String[0]));
     }
 
     @Test
diff --git a/src/test/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCacheTest.java b/src/test/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCacheTest.java
index a8d57f512a..967685bc24 100644
--- a/src/test/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCacheTest.java
+++ b/src/test/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCacheTest.java
@@ -157,7 +157,7 @@ public class ConcurrentCommonCacheTest {
                         )
                 );
 
-        Assert.assertArrayEquals(new String[] {"Daniel", "Male", "Shanghai"}, sc.clear().values().toArray(new String[0]));
+        Assert.assertArrayEquals(new String[] {"Daniel", "Male", "Shanghai"}, sc.clearAll().values().toArray(new String[0]));
     }
 
     @Test
diff --git a/src/test/org/codehaus/groovy/runtime/memoize/StampedCommonCacheTest.java b/src/test/org/codehaus/groovy/runtime/memoize/StampedCommonCacheTest.java
index 953425da44..7b8b071b52 100644
--- a/src/test/org/codehaus/groovy/runtime/memoize/StampedCommonCacheTest.java
+++ b/src/test/org/codehaus/groovy/runtime/memoize/StampedCommonCacheTest.java
@@ -157,7 +157,7 @@ public class StampedCommonCacheTest {
                         )
                 );
 
-        Assert.assertArrayEquals(new String[] {"Daniel", "Male", "Shanghai"}, sc.clear().values().toArray(new String[0]));
+        Assert.assertArrayEquals(new String[] {"Daniel", "Male", "Shanghai"}, sc.clearAll().values().toArray(new String[0]));
     }
 
     @Test
diff --git a/src/test/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCacheTest.java b/src/test/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCacheTest.java
index 1e407e8060..d0e2a5a2f0 100644
--- a/src/test/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCacheTest.java
+++ b/src/test/org/codehaus/groovy/runtime/memoize/UnlimitedConcurrentCacheTest.java
@@ -155,7 +155,7 @@ public class UnlimitedConcurrentCacheTest {
                         )
                 );
 
-        Assert.assertEquals(new TreeSet<>(Arrays.asList("Daniel", "Male", "Shanghai")), new TreeSet<>(sc.clear().values()));
+        Assert.assertEquals(new TreeSet<>(Arrays.asList("Daniel", "Male", "Shanghai")), new TreeSet<>(sc.clearAll().values()));
     }
 
     @Test

Commit:
7e7b508c02bf35e72fca1efcb7cc0d8a4f25038a
sunlan
sunlan@apache.org
2018-03-30 18:56:24 +0800
GROOVY-8524: Triple quoted string with quotes on end of line
diff --git a/src/antlr/GroovyLexer.g4 b/src/antlr/GroovyLexer.g4
index bf855bf11b..78bbd69ea0 100644
--- a/src/antlr/GroovyLexer.g4
+++ b/src/antlr/GroovyLexer.g4
@@ -314,14 +314,14 @@ SqStringCharacter
 // character in the triple double quotation string. e.g. """a"""
 fragment TdqStringCharacter
     :   ~["\\$]
-    |   GStringQuotationMark { !(_input.LA(1) == '"' && _input.LA(2) == '"') }?
+    |   GStringQuotationMark { _input.LA(1) != '"' || _input.LA(2) != '"' || _input.LA(3) == '"' }?
     |   EscapeSequence
     ;
 
 // character in the triple single quotation string. e.g. '''a'''
 fragment TsqStringCharacter
     :   ~['\\]
-    |   SqStringQuotationMark { !(_input.LA(1) == '\'' && _input.LA(2) == '\'') }?
+    |   SqStringQuotationMark { _input.LA(1) != '\'' || _input.LA(2) != '\'' || _input.LA(3) == '\'' }?
     |   EscapeSequence
     ;
 
diff --git a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
index a4a12e301a..4701e77ef2 100644
--- a/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
+++ b/subprojects/parser-antlr4/src/test/groovy/org/apache/groovy/parser/antlr4/GroovyParserTest.groovy
@@ -379,6 +379,10 @@ class GroovyParserTest extends GroovyTestCase {
         doRunAndTestAntlr4('core/Var_01x.groovy');
     }
 
+    void "test groovy core - String"() {
+        doRunAndTestAntlr4('core/String_01x.groovy');
+    }
+
     void "test groovy core - BUG"() {
         doRunAndTestAntlr4('bugs/BUG-GROOVY-4757.groovy')
         doRunAndTestAntlr4('bugs/BUG-GROOVY-5652.groovy')
diff --git a/subprojects/parser-antlr4/src/test/resources/core/String_01x.groovy b/subprojects/parser-antlr4/src/test/resources/core/String_01x.groovy
new file mode 100644
index 0000000000..8f9a5ca459
--- /dev/null
+++ b/subprojects/parser-antlr4/src/test/resources/core/String_01x.groovy
@@ -0,0 +1,23 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+def v = '''string='a''''
+assert v == '''string=\'a\''''
+def v2 = """string="a""""
+assert v2 == """string=\"a\""""
\ No newline at end of file

Commit:
a1af003841060e3465a0a9a13e0a4d9a0cf654e1
Paul King
paulk@asert.com.au
2018-03-30 18:17:08 +1000
align protected field types between 2.5/2.6 with 3.0 for binary compatibility
diff --git a/gradle/pomconfigurer.gradle b/gradle/pomconfigurer.gradle
index 1ebe9ed32c..d6ee1df1ef 100644
--- a/gradle/pomconfigurer.gradle
+++ b/gradle/pomconfigurer.gradle
@@ -549,6 +549,9 @@ project.ext.pomConfigureClosureWithoutTweaks = {
             contributor {
                 name 'Peter Ledbrook'
             }
+            contributor {
+                name 'Scott Stirling'
+            }
             contributor {
                 name 'Thibault Kruse'
             }
diff --git a/src/main/groovy/groovy/lang/GroovyClassLoader.java b/src/main/groovy/groovy/lang/GroovyClassLoader.java
index 1beecfe53e..23c63b2107 100644
--- a/src/main/groovy/groovy/lang/GroovyClassLoader.java
+++ b/src/main/groovy/groovy/lang/GroovyClassLoader.java
@@ -82,13 +82,6 @@ import java.util.Map;
  * to keep anything like a "class not found" information for that class name.
  * This includes possible parent loaders. Classes that are not cached are always
  * reloaded.
- *
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
- * @author Guillaume Laforge
- * @author Steve Goetze
- * @author Bing Ran
- * @author <a href="mailto:scottstirling@rcn.com">Scott Stirling</a>
- * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  */
 public class GroovyClassLoader extends URLClassLoader {
     private static final URL[] EMPTY_URL_ARRAY = new URL[0];
@@ -103,12 +96,12 @@ public class GroovyClassLoader extends URLClassLoader {
      * This cache contains mappings of file name to class. It is used
      * to bypass compilation.
      */
-    protected final StampedCommonCache<String, Class> sourceCache = new StampedCommonCache<String, Class>();
+    protected final EvictableCache<String, Class> sourceCache = new StampedCommonCache<String, Class>();
 
     private final CompilerConfiguration config;
     private String sourceEncoding;
     private Boolean recompile;
-    // use 1000000 as offset to avoid conflicts with names form the GroovyShell
+    // use 1000000 as offset to avoid conflicts with names from the GroovyShell
     private static int scriptNameCounter = 1000000;
 
     private GroovyResourceLoader resourceLoader = new GroovyResourceLoader() {
@@ -321,7 +314,7 @@ public class GroovyClassLoader extends URLClassLoader {
      * @return the main class defined in the given script
      */
     public Class parseClass(final GroovyCodeSource codeSource, boolean shouldCacheSource) throws CompilationFailedException {
-        return sourceCache.getAndPut(
+        return ((StampedCommonCache<String, Class>) sourceCache).getAndPut(
                 codeSource.getName(),
                 new EvictableCache.ValueProvider<String, Class>() {
                     @Override

Commit:
702b954744912e5cca58bc0ab9d661c289c1f080
Paul King
paulk@asert.com.au
2018-03-30 09:26:55 +1000
changes to address japicmp serializable version issue warnings
diff --git a/src/main/groovy/groovy/lang/NonEmptySequence.java b/src/main/groovy/groovy/lang/NonEmptySequence.java
index f069b7aa5d..4a6dbd8e15 100644
--- a/src/main/groovy/groovy/lang/NonEmptySequence.java
+++ b/src/main/groovy/groovy/lang/NonEmptySequence.java
@@ -21,14 +21,13 @@ package groovy.lang;
 import java.util.List;
 
 /**
- * Represents a sequence of objects which represents one or many instances of
- * of objects of a given type. The type can be omitted in which case any type of
- * object can be added.
- *
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * Represents a sequence of one or more objects of a given type.
+ * The type can be omitted in which case any type of object can be added.
  */
 public class NonEmptySequence extends Sequence {
 
+    private static final long serialVersionUID = 1614604919062836998L;
+
     public NonEmptySequence() {
         super(null);
     }
@@ -44,4 +43,4 @@ public class NonEmptySequence extends Sequence {
     public int minimumSize() {
         return 1;
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/groovy/groovy/lang/Sequence.java b/src/main/groovy/groovy/lang/Sequence.java
index 2b4316cf81..57e6152ae8 100644
--- a/src/main/groovy/groovy/lang/Sequence.java
+++ b/src/main/groovy/groovy/lang/Sequence.java
@@ -23,19 +23,16 @@ import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Iterator;
 import java.util.List;
 
 /**
- * Represents a sequence of objects which represents zero or many instances of
- * of objects of a given type. The type can be omitted in which case any type of
- * object can be added.
- *
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * Represents a sequence of zero or more objects of a given type.
+ * The type can be omitted in which case any type of object can be added.
  */
 public class Sequence extends ArrayList implements GroovyObject {
 
-    private MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
+    private static final long serialVersionUID = 7324025453767284764L;
+    private transient MetaClass metaClass = InvokerHelper.getMetaClass(getClass());
     private final Class type;
     private int hashCode;
 
@@ -62,7 +59,7 @@ public class Sequence extends ArrayList implements GroovyObject {
         clear();
         addAll(collection);
     }
-    
+
     public boolean equals(Object that) {
         if (that instanceof Sequence) {
             return equals((Sequence) that);
@@ -107,7 +104,7 @@ public class Sequence extends ArrayList implements GroovyObject {
     public Class type() {
         return type;
     }
-    
+
     public void add(int index, Object element) {
         checkType(element);
         hashCode = 0;
@@ -156,13 +153,11 @@ public class Sequence extends ArrayList implements GroovyObject {
     //-------------------------------------------------------------------------
     public Object invokeMethod(String name, Object args) {
         try {
-        return getMetaClass().invokeMethod(this, name, args);
-        }
-        catch (MissingMethodException e) {
-            // lets apply the method to each item in the collection
+            return getMetaClass().invokeMethod(this, name, args);
+        } catch (MissingMethodException e) {
+            // let's apply the method to each item in the collection
             List answer = new ArrayList(size());
-            for (Iterator iter = iterator(); iter.hasNext(); ) {
-                Object element = iter.next();
+            for (Object element : this) {
                 Object value = InvokerHelper.invokeMethod(element, name, args);
                 answer.add(value);
             }
@@ -188,22 +183,20 @@ public class Sequence extends ArrayList implements GroovyObject {
 
     // Implementation methods
     //-------------------------------------------------------------------------
-    
+
     /**
      * Checks that each member of the given collection are of the correct
      * type
      */
     protected void checkCollectionType(Collection c) {
         if (type != null) {
-            for (Iterator iter = c.iterator(); iter.hasNext(); ) {
-                Object element = iter.next();
+            for (Object element : c) {
                 checkType(element);
             }
         }
     }
 
-
-    /** 
+    /**
      * Checks that the given object instance is of the correct type
      * otherwise a runtime exception is thrown
      */
@@ -214,10 +207,10 @@ public class Sequence extends ArrayList implements GroovyObject {
         if (type != null) {
             if (!type.isInstance(object)) {
                 throw new IllegalArgumentException(
-                    "Invalid type of argument for sequence of type: "
-                        + type.getName()
-                        + " cannot add object: "
-                        + object);
+                        "Invalid type of argument for sequence of type: "
+                                + type.getName()
+                                + " cannot add object: "
+                                + object);
             }
         }
     }
diff --git a/src/main/groovy/groovy/util/ObservableList.java b/src/main/groovy/groovy/util/ObservableList.java
index 31b5745e08..01c2e2f7ba 100644
--- a/src/main/groovy/groovy/util/ObservableList.java
+++ b/src/main/groovy/groovy/util/ObservableList.java
@@ -63,8 +63,6 @@ import java.util.Set;
  * <li><tt>content</tt> - read-only.</li>
  * <li><tt>size</tt> - read-only.</li>
  * </ul>
- *
- * @author <a href="mailto:aalmiray@users.sourceforge.net">Andres Almiray</a>
  */
 public class ObservableList implements List {
     private final List delegate;
@@ -453,8 +451,8 @@ public class ObservableList implements List {
     public enum ChangeType {
         ADDED, UPDATED, REMOVED, CLEARED, MULTI_ADD, MULTI_REMOVE, NONE;
 
-        public static final Object oldValue = new Object();
-        public static final Object newValue = new Object();
+        public static final Object oldValue = new Object[0];
+        public static final Object newValue = new Object[0];
 
         public static ChangeType resolve(int ordinal) {
             switch (ordinal) {
@@ -478,7 +476,7 @@ public class ObservableList implements List {
     }
 
     public abstract static class ElementEvent extends PropertyChangeEvent {
-
+        private static final long serialVersionUID = 4985518099021958098L;
         private final ChangeType type;
         private final int index;
 
@@ -506,24 +504,31 @@ public class ObservableList implements List {
     }
 
     public static class ElementAddedEvent extends ElementEvent {
+        private static final long serialVersionUID = 6472450701680783544L;
+
         public ElementAddedEvent(Object source, Object newValue, int index) {
             super(source, null, newValue, index, ChangeType.ADDED);
         }
     }
 
     public static class ElementUpdatedEvent extends ElementEvent {
+        private static final long serialVersionUID = 1116018076124047485L;
+
         public ElementUpdatedEvent(Object source, Object oldValue, Object newValue, int index) {
             super(source, oldValue, newValue, index, ChangeType.UPDATED);
         }
     }
 
     public static class ElementRemovedEvent extends ElementEvent {
+        private static final long serialVersionUID = 8480367764843668809L;
+
         public ElementRemovedEvent(Object source, Object value, int index) {
             super(source, value, null, index, ChangeType.REMOVED);
         }
     }
 
     public static class ElementClearedEvent extends ElementEvent {
+        private static final long serialVersionUID = -6586012825386453052L;
         private final List values = new ArrayList();
 
         public ElementClearedEvent(Object source, List values) {
@@ -539,6 +544,7 @@ public class ObservableList implements List {
     }
 
     public static class MultiElementAddedEvent extends ElementEvent {
+        private static final long serialVersionUID = 5142936559765501723L;
         private final List values = new ArrayList();
 
         public MultiElementAddedEvent(Object source, int index, List values) {
@@ -554,6 +560,7 @@ public class ObservableList implements List {
     }
 
     public static class MultiElementRemovedEvent extends ElementEvent {
+        private static final long serialVersionUID = 2453305767752911341L;
         private final List values = new ArrayList();
 
         public MultiElementRemovedEvent(Object source, List values) {
diff --git a/src/main/groovy/groovy/util/ObservableMap.java b/src/main/groovy/groovy/util/ObservableMap.java
index a71165fe9e..c55d3b1284 100644
--- a/src/main/groovy/groovy/util/ObservableMap.java
+++ b/src/main/groovy/groovy/util/ObservableMap.java
@@ -60,8 +60,6 @@ import java.util.Set;
  * <li><tt>content</tt> - read-only.</li>
  * <li><tt>size</tt> - read-only.</li>
  * </ul>
- *
- * @author <a href="mailto:aalmiray@users.sourceforge.net">Andres Almiray</a>
  */
 public class ObservableMap implements Map {
     private final Map delegate;
@@ -309,8 +307,8 @@ public class ObservableMap implements Map {
     public enum ChangeType {
         ADDED, UPDATED, REMOVED, CLEARED, MULTI, NONE;
 
-        public static final Object oldValue = new Object();
-        public static final Object newValue = new Object();
+        public static final Object oldValue = new Object[0];
+        public static final Object newValue = new Object[0];
 
         public static ChangeType resolve(int ordinal) {
             switch (ordinal) {
@@ -332,6 +330,7 @@ public class ObservableMap implements Map {
     }
 
     public abstract static class PropertyEvent extends PropertyChangeEvent {
+        private static final long serialVersionUID = -3439518280585144435L;
         private final ChangeType type;
 
         public PropertyEvent(Object source, String propertyName, Object oldValue, Object newValue, ChangeType type) {
@@ -353,24 +352,31 @@ public class ObservableMap implements Map {
     }
 
     public static class PropertyAddedEvent extends PropertyEvent {
+        private static final long serialVersionUID = -7237626384063194253L;
+
         public PropertyAddedEvent(Object source, String propertyName, Object newValue) {
             super(source, propertyName, null, newValue, ChangeType.ADDED);
         }
     }
 
     public static class PropertyUpdatedEvent extends PropertyEvent {
+        private static final long serialVersionUID = 1322327094566373342L;
+
         public PropertyUpdatedEvent(Object source, String propertyName, Object oldValue, Object newValue) {
             super(source, propertyName, oldValue, newValue, ChangeType.UPDATED);
         }
     }
 
     public static class PropertyRemovedEvent extends PropertyEvent {
+        private static final long serialVersionUID = 6646851287602912969L;
+
         public PropertyRemovedEvent(Object source, String propertyName, Object oldValue) {
             super(source, propertyName, oldValue, null, ChangeType.REMOVED);
         }
     }
 
     public static class PropertyClearedEvent extends PropertyEvent {
+        private static final long serialVersionUID = -5066784441907086768L;
         private final Map values = new HashMap();
 
         public PropertyClearedEvent(Object source, Map values) {
@@ -388,6 +394,7 @@ public class ObservableMap implements Map {
     public static class MultiPropertyEvent extends PropertyEvent {
         public static final String MULTI_PROPERTY = "groovy_util_ObservableMap_MultiPropertyEvent_MULTI";
         private static final PropertyEvent[] EMPTY_PROPERTY_EVENTS = new PropertyEvent[0];
+        private static final long serialVersionUID = 2185997629991653251L;
 
         private final PropertyEvent[] events;
 
diff --git a/src/main/groovy/groovy/util/ObservableSet.java b/src/main/groovy/groovy/util/ObservableSet.java
index b794436595..2a50d2d407 100644
--- a/src/main/groovy/groovy/util/ObservableSet.java
+++ b/src/main/groovy/groovy/util/ObservableSet.java
@@ -64,8 +64,6 @@ import java.util.Stack;
  * <li><tt>content</tt> - read-only.</li>
  * <li><tt>size</tt> - read-only.</li>
  * </ul>
- *
- * @author <a href="mailto:aalmiray@users.sourceforge.net">Andres Almiray</a>
  */
 public class ObservableSet<E> implements Set<E> {
     private final Set<E> delegate;
@@ -343,11 +341,12 @@ public class ObservableSet<E> implements Set<E> {
     public enum ChangeType {
         ADDED, REMOVED, CLEARED, MULTI_ADD, MULTI_REMOVE, NONE;
 
-        public static final Object oldValue = new Object();
-        public static final Object newValue = new Object();
+        public static final Object oldValue = new Object[0];
+        public static final Object newValue = new Object[0];
     }
 
     public abstract static class ElementEvent extends PropertyChangeEvent {
+        private static final long serialVersionUID = 1636915619671510488L;
         private final ChangeType type;
 
         public ElementEvent(Object source, Object oldValue, Object newValue, ChangeType type) {
@@ -369,18 +368,23 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class ElementAddedEvent extends ElementEvent {
+        private static final long serialVersionUID = 8487116924204612932L;
+
         public ElementAddedEvent(Object source, Object newValue) {
             super(source, null, newValue, ChangeType.ADDED);
         }
     }
 
     public static class ElementRemovedEvent extends ElementEvent {
+        private static final long serialVersionUID = 661289692849269910L;
+
         public ElementRemovedEvent(Object source, Object value) {
             super(source, value, null, ChangeType.REMOVED);
         }
     }
 
     public static class ElementClearedEvent extends ElementEvent {
+        private static final long serialVersionUID = -4285830355690031818L;
         private final List values = new ArrayList();
 
         public ElementClearedEvent(Object source, List values) {
@@ -396,6 +400,7 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class MultiElementAddedEvent extends ElementEvent {
+        private static final long serialVersionUID = -4307534536004566487L;
         private final List values = new ArrayList();
 
         public MultiElementAddedEvent(Object source, List values) {
@@ -411,6 +416,7 @@ public class ObservableSet<E> implements Set<E> {
     }
 
     public static class MultiElementRemovedEvent extends ElementEvent {
+        private static final long serialVersionUID = -2068802236380651658L;
         private final List values = new ArrayList();
 
         public MultiElementRemovedEvent(Object source, List values) {
diff --git a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
index 046fd17c85..ecc8098811 100644
--- a/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
+++ b/src/main/java/org/codehaus/groovy/antlr/LexerFrame.java
@@ -47,6 +47,7 @@ import java.util.Hashtable;
  * Swing application to graphically display the tokens produced by the lexer.
  */
 public class LexerFrame extends JFrame implements ActionListener {
+    private static final long serialVersionUID = 4753761422597441243L;
     private final JSplitPane jSplitPane1 = new JSplitPane();
     private final JScrollPane jScrollPane1 = new JScrollPane();
     private final JScrollPane jScrollPane2 = new JScrollPane();
diff --git a/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java b/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
index 63e0406f1c..f39ae85272 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ComposedClosure.java
@@ -54,11 +54,10 @@ import java.util.List;
  * def twiceBothPlus10 = twiceBoth >> add2plus10
  * assert twiceBothPlus10(5, 10) == 40
  * </pre>
- *
- * @author Paul King
  */
 public final class ComposedClosure<V> extends Closure<V> {
 
+    private static final long serialVersionUID = -6410722393739184061L;
     private final Closure first;
     private final Closure<V> second;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java b/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
index d4cd85772f..278c6a6980 100644
--- a/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
+++ b/src/main/java/org/codehaus/groovy/runtime/GStringImpl.java
@@ -26,10 +26,10 @@ import groovy.lang.GString;
  * consist of a list of values and strings which can be combined to
  * create a new String.
  *
- * @author Jochen Theodorou
  * @see groovy.lang.GString
  */
 public class GStringImpl extends GString {
+    private static final long serialVersionUID = 3856688359714409314L;
     private final String[] strings;
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
index 60a6a3fc6c..60f57d80a8 100644
--- a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
@@ -27,16 +27,15 @@ import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
 
-
 /**
  * Represents a method on an object using a closure which can be invoked
  * at any time
- * 
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
 public class MethodClosure extends Closure {
     public static final String NEW = "new";
     public static final String ANY_INSTANCE_METHOD_EXISTS = "anyInstanceMethodExists";
+
+    private static final long serialVersionUID = -7600155510871887910L;
     public static boolean ALLOW_RESOLVE = false;
 
     private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
diff --git a/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java b/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java
index 6877f512e6..7d276031d5 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ScriptReference.java
@@ -23,11 +23,10 @@ import groovy.lang.Script;
 
 /**
  * Represents a reference to a variable in a script
- * 
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
 public class ScriptReference extends Reference {
 
+    private static final long serialVersionUID = 9011836991962996884L;
     private final Script script;
     private final String variable;
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
index 9a3a0ba7ca..f7f6b5e5e5 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
@@ -24,6 +24,7 @@ package org.codehaus.groovy.runtime.metaclass;
  * invokeMethod for GroovyObject implementing classes.
  */
 public class MissingMethodExecutionFailed extends MissingMethodExceptionNoStack {
+    private static final long serialVersionUID = -6384783636894179156L;
     private final Throwable cause;
     public MissingMethodExecutionFailed(String method, Class type, Object[] arguments, boolean isStatic, Throwable cause) {
         super(method, type, arguments, isStatic);
diff --git a/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java b/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
index eb5b69fa4f..91df343ed7 100644
--- a/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
+++ b/src/main/java/org/codehaus/groovy/syntax/SyntaxException.java
@@ -21,12 +21,12 @@ package org.codehaus.groovy.syntax;
 import org.codehaus.groovy.GroovyException;
 import org.codehaus.groovy.ast.ASTNode;
 
-/** Base exception indicating a syntax error.
- *
- *  @author <a href="bob@werken.com">bob mcwhirter</a>
+/**
+ * Base exception indicating a syntax error.
  */
 public class SyntaxException extends GroovyException {
 
+    private static final long serialVersionUID = -6086822614839477581L;
     /** Line upon which the error occurred. */
     private final int startLine;
     private final int endLine;

Commit:
072fc7056b7f3b49947fd9612d1fdf9eeffcc901
Paul King
paulk@asert.com.au
2018-03-29 12:25:10 +1000
update bin compat version
diff --git a/build.gradle b/build.gradle
index 60ed04e2c7..3e094e64cc 100644
--- a/build.gradle
+++ b/build.gradle
@@ -42,7 +42,6 @@ buildscript {
         classpath 'org.asciidoctor:asciidoctor-gradle-plugin:1.5.7'
         classpath "org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3"
         classpath 'me.champeau.gradle:gradle-javadoc-hotfix-plugin:0.1'
-        //classpath 'me.champeau.gradle:japicmp-gradle-plugin:0.1.1'
         //classpath 'nl.javadude.gradle.plugins:license-gradle-plugin:0.11.0'
         classpath "gradle.plugin.org.nosphere.apache:creadur-rat-gradle:0.1.3"
         classpath "gradle.plugin.com.github.jk1:gradle-license-report:0.3.2"
diff --git a/gradle/binarycompatibility.gradle b/gradle/binarycompatibility.gradle
index 0b6e04f105..aa0175ae4f 100644
--- a/gradle/binarycompatibility.gradle
+++ b/gradle/binarycompatibility.gradle
@@ -40,7 +40,7 @@ def excludeModules = ['groovy-dateutil', 'groovy-datetime', 'performance', 'groo
 
 Set projectsToCheck = allprojects.findAll{ !(it.name in excludeModules) }
 
-def compatibilityBaselineVersion = '2.4.13'
+def compatibilityBaselineVersion = '2.4.15'
 
 allprojects {
     if (project in projectsToCheck) {

Commit:
6bb2ac40f05cffd5c7f399a274f98af95094ebb2
Paul King
paulk@asert.com.au
2018-03-29 01:44:45 +1000
fix a binary compatibility regression since 2.4
diff --git a/src/main/groovy/groovy/transform/builder/InitializerStrategy.java b/src/main/groovy/groovy/transform/builder/InitializerStrategy.java
index 1b7e0be10f..0ed615ea9f 100644
--- a/src/main/groovy/groovy/transform/builder/InitializerStrategy.java
+++ b/src/main/groovy/groovy/transform/builder/InitializerStrategy.java
@@ -20,6 +20,7 @@ package groovy.transform.builder;
 
 import groovy.transform.TupleConstructor;
 import groovy.transform.Undefined;
+import org.apache.groovy.ast.tools.AnnotatedNodeUtils;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
@@ -161,7 +162,7 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
         addFields(buildee, filteredFields, builder);
 
         buildCommon(buildee, anno, filteredFields, builder);
-        boolean needsConstructor = !transform.hasAnnotation(buildee, TUPLECONS_TYPE) || force;
+        boolean needsConstructor = !AnnotatedNodeUtils.hasAnnotation(buildee, TUPLECONS_TYPE) || force;
         createBuildeeConstructors(transform, buildee, builder, filteredFields, needsConstructor, useSetters);
     }
 
diff --git a/src/main/java/org/apache/groovy/ast/tools/AnnotatedNodeUtils.java b/src/main/java/org/apache/groovy/ast/tools/AnnotatedNodeUtils.java
index e378f990c7..fd60278ef3 100644
--- a/src/main/java/org/apache/groovy/ast/tools/AnnotatedNodeUtils.java
+++ b/src/main/java/org/apache/groovy/ast/tools/AnnotatedNodeUtils.java
@@ -24,6 +24,8 @@ import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 
+import java.util.List;
+
 /**
  * Utility class for working with AnnotatedNodes
  */
@@ -33,10 +35,15 @@ public class AnnotatedNodeUtils {
     private AnnotatedNodeUtils() {
     }
 
-    public static void markAsGenerated(ClassNode cNode, AnnotatedNode aNode) {
-        boolean shouldAnnotate = cNode.getModule() != null && cNode.getModule().getContext() != null;
+    public static void markAsGenerated(ClassNode containingClass, AnnotatedNode nodeToMark) {
+        boolean shouldAnnotate = containingClass.getModule() != null && containingClass.getModule().getContext() != null;
         if (shouldAnnotate) {
-            aNode.addAnnotation(new AnnotationNode(GENERATED_TYPE));
+            nodeToMark.addAnnotation(new AnnotationNode(GENERATED_TYPE));
         }
     }
+
+    public static boolean hasAnnotation(AnnotatedNode node, ClassNode annotation) {
+        List annots = node.getAnnotations(annotation);
+        return (annots != null && !annots.isEmpty());
+    }
 }
diff --git a/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java b/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
index f78e99de8a..51cab66d9a 100644
--- a/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
+++ b/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
@@ -37,6 +37,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import static org.apache.groovy.ast.tools.AnnotatedNodeUtils.hasAnnotation;
 import static org.codehaus.groovy.ast.ClassHelper.boolean_TYPE;
 
 /**
@@ -297,7 +298,7 @@ public class ClassNodeUtils {
         List<ConstructorNode> declaredConstructors = cNode.getDeclaredConstructors();
         for (ConstructorNode constructorNode : declaredConstructors) {
             // allow constructors added by other transforms if flagged as Generated
-            if (AbstractASTTransformation.hasAnnotation(constructorNode, GENERATED_TYPE)) {
+            if (hasAnnotation(constructorNode, GENERATED_TYPE)) {
                 continue;
             }
             if (xform != null) {
diff --git a/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
index 947c7f1cf7..fad53bed38 100644
--- a/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -18,6 +18,7 @@
  */
 package org.codehaus.groovy.transform;
 
+import org.apache.groovy.ast.tools.AnnotatedNodeUtils;
 import org.apache.groovy.ast.tools.MethodNodeUtils;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ASTNode;
@@ -259,9 +260,8 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return true;
     }
 
-    public static boolean hasAnnotation(AnnotatedNode node, ClassNode annotation) {
-        List annots = node.getAnnotations(annotation);
-        return (annots != null && !annots.isEmpty());
+    public boolean hasAnnotation(ClassNode node, ClassNode annotation) {
+        return AnnotatedNodeUtils.hasAnnotation(node, annotation);
     }
 
     public static List<String> tokenize(String rawExcludes) {
diff --git a/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
index 3a7e3abc1f..54008af1a6 100644
--- a/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/NamedVariantASTTransformation.java
@@ -21,6 +21,7 @@ package org.codehaus.groovy.transform;
 import groovy.transform.NamedDelegate;
 import groovy.transform.NamedParam;
 import groovy.transform.NamedVariant;
+import org.apache.groovy.ast.tools.AnnotatedNodeUtils;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
@@ -44,7 +45,6 @@ import org.codehaus.groovy.control.SourceUnit;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 
 import static org.apache.groovy.ast.tools.ClassNodeUtils.isInnerClass;
@@ -100,7 +100,7 @@ public class NamedVariantASTTransformation extends AbstractASTTransformation {
         // first pass, just check for absence of annotations of interest
         boolean annoFound = false;
         for (Parameter fromParam : fromParams) {
-            if (hasAnnotation(fromParam, NAMED_PARAM_TYPE) || hasAnnotation(fromParam, NAMED_DELEGATE_TYPE)) {
+            if (AnnotatedNodeUtils.hasAnnotation(fromParam, NAMED_PARAM_TYPE) || AnnotatedNodeUtils.hasAnnotation(fromParam, NAMED_DELEGATE_TYPE)) {
                 annoFound = true;
             }
         }
@@ -110,7 +110,7 @@ public class NamedVariantASTTransformation extends AbstractASTTransformation {
             processDelegateParam(mNode, mapParam, args, propNames, fromParams[0]);
         } else {
             for (Parameter fromParam : fromParams) {
-                if (hasAnnotation(fromParam, NAMED_PARAM_TYPE)) {
+                if (AnnotatedNodeUtils.hasAnnotation(fromParam, NAMED_PARAM_TYPE)) {
                     AnnotationNode namedParam = fromParam.getAnnotations(NAMED_PARAM_TYPE).get(0);
                     boolean required = memberHasValue(namedParam, "required", true);
                     if (getMemberValue(namedParam, "name") == null) {
@@ -134,7 +134,7 @@ public class NamedVariantASTTransformation extends AbstractASTTransformation {
                     args.addExpression(propX(varX(mapParam), name));
                     mapParam.addAnnotation(namedParam);
                     fromParam.getAnnotations().remove(namedParam);
-                } else if (hasAnnotation(fromParam, NAMED_DELEGATE_TYPE)) {
+                } else if (AnnotatedNodeUtils.hasAnnotation(fromParam, NAMED_DELEGATE_TYPE)) {
                     if (!processDelegateParam(mNode, mapParam, args, propNames, fromParam)) return;
                 } else {
                     args.addExpression(varX(fromParam));
diff --git a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 0d10cace99..33b17290ff 100644
--- a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -23,6 +23,7 @@ import groovy.transform.CompilationUnitAware;
 import groovy.transform.MapConstructor;
 import groovy.transform.TupleConstructor;
 import groovy.transform.options.PropertyHandler;
+import org.apache.groovy.ast.tools.AnnotatedNodeUtils;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
@@ -253,7 +254,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             Collections.sort(params, includeComparator);
         }
 
-        boolean hasMapCons = hasAnnotation(cNode, MapConstructorASTTransformation.MY_TYPE);
+        boolean hasMapCons = AnnotatedNodeUtils.hasAnnotation(cNode, MapConstructorASTTransformation.MY_TYPE);
         int modifiers = getVisibility(anno, cNode, ConstructorNode.class, ACC_PUBLIC);
         ConstructorNode consNode = new ConstructorNode(modifiers, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body);
         markAsGenerated(cNode, consNode);
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 800453ff51..05fc6599c2 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4399,13 +4399,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         final Parameter[] parameters = closureExpression.getParameters();
         String name = parameter.getName();
 
-        if (parameters.length == 0) {
-            return "it".equals(name) && closureParamTypes.length != 0 ? closureParamTypes[0] : null;
-        }
+        if (parameters != null) {
+            if (parameters.length == 0) {
+                return "it".equals(name) && closureParamTypes.length != 0 ? closureParamTypes[0] : null;
+            }
 
-        for (int index = 0; index < parameters.length; index++) {
-            if (name.equals(parameters[index].getName())) {
-                return closureParamTypes.length > index ? closureParamTypes[index] : null;
+            for (int index = 0; index < parameters.length; index++) {
+                if (name.equals(parameters[index].getName())) {
+                    return closureParamTypes.length > index ? closureParamTypes[index] : null;
+                }
             }
         }
 
diff --git a/subprojects/groovy-groovydoc/build.gradle b/subprojects/groovy-groovydoc/build.gradle
index 6dda7b613a..f12a4d10ef 100644
--- a/subprojects/groovy-groovydoc/build.gradle
+++ b/subprojects/groovy-groovydoc/build.gradle
@@ -20,6 +20,7 @@ dependencies {
     compile rootProject
     testCompile rootProject.sourceSets.test.runtimeClasspath
     compile project(':groovy-templates')
+    runtime project(':groovy-dateutil')
     testCompile project(':groovy-test')
     testCompile project(':groovy-ant')
     testCompile "org.apache.ant:ant-testutil:$antVersion"

Commit:
12069be392048d953cc7033a9bf7ce0e99339455
sunlan
sunlan@apache.org
2018-03-28 08:25:01 +0800
Bump asm version to 6.1.1
diff --git a/build.gradle b/build.gradle
index e05d973bb9..60ed04e2c7 100644
--- a/build.gradle
+++ b/build.gradle
@@ -153,7 +153,7 @@ configurations {
 
 ext {
     antVersion = '1.10.1'
-    asmVersion = '6.1'
+    asmVersion = '6.1.1'
     antlrVersion = '2.7.7'
     bridgerVersion = '1.1.Final'
     coberturaVersion = '1.9.4.1'

Commit:
9f7826eca6dd7cbe02dc2b0aaaab681848c87f6f
Paul King
paulk@asert.com.au
2018-03-27 22:31:53 +1000
temporarily disable a test
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java
index 7a272934fc..7655899d19 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java
@@ -84,7 +84,7 @@ public class PluginDefaultGroovyMethods {
 
     /**
      * Returns a Future asynchronously returning a transformed result.
-     * <pre class="groovyTestCase">
+     * <pre class="_temp_disabled_groovyTestCase">
      * import java.util.concurrent.*
      * def executor = Executors.newSingleThreadExecutor()
      * Future<String> foobar = executor.submit{ "foobar" }

Commit:
031a0f93532c1d3dce628f109758888f75394f4b
Paul King
paulk@asert.com.au
2018-03-27 20:29:52 +1000
fix failing tests
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index d9a2b59a19..b16717db96 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -17606,4 +17606,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
                     ? EMPTY_GROOVYDOC
                     : new groovy.lang.groovydoc.Groovydoc(groovydocAnnotation.value(), holder);
     }
+
+    @Deprecated
+    public static <T> T asType(CharSequence self, Class<T> c) {
+        return StringGroovyMethods.asType(self, c);
+    }
 }
diff --git a/src/test/groovy/bugs/Groovy4386_Bug.groovy b/src/test/groovy/bugs/Groovy4386_Bug.groovy
index 0324f8ad86..8154a0609f 100644
--- a/src/test/groovy/bugs/Groovy4386_Bug.groovy
+++ b/src/test/groovy/bugs/Groovy4386_Bug.groovy
@@ -18,8 +18,8 @@
  */
 package groovy.bugs
 
-import org.codehaus.groovy.runtime.DefaultGroovyMethods
 import org.codehaus.groovy.control.CompilerConfiguration
+import org.codehaus.groovy.runtime.ResourceGroovyMethods
 
 /**
  * Test for GROOVY-4386: Using static imports to a script on the classpath.
@@ -39,7 +39,7 @@ class Groovy4386_Bug extends GroovyTestCase {
         File dir = new File(tmpDir, 'foo')
         dir.mkdir()
         File file = new File(dir, "Constants.groovy")
-        DefaultGroovyMethods.setText(file, scriptSource);
+        ResourceGroovyMethods.setText(file, scriptSource);
     }
 
     @Override protected void tearDown() {
diff --git a/src/test/org/codehaus/groovy/runtime/NewStaticMetaMethodTest.java b/src/test/org/codehaus/groovy/runtime/NewStaticMetaMethodTest.java
index a68c965809..20ce806154 100644
--- a/src/test/org/codehaus/groovy/runtime/NewStaticMetaMethodTest.java
+++ b/src/test/org/codehaus/groovy/runtime/NewStaticMetaMethodTest.java
@@ -42,7 +42,7 @@ public class NewStaticMetaMethodTest extends TestCase {
     }
 
     public void testInvokeDefaultGroovyMethod() throws Exception {
-        Method method = DefaultGroovyMethods.class.getMethod("plus", new Class[]{String.class, Object.class});
+        Method method = StringGroovyMethods.class.getMethod("plus", new Class[]{String.class, Object.class});
         assertTrue("Should have found a method", method != null);
 
         NewInstanceMetaMethod metaMethod = createNewMetaMethod(method);

Commit:
e3a52edba1232f0b98377296409afe67ab3a3889
paulk
paulk@asert.com.au
2018-03-26 13:30:23 +1000
remove long time deprecated and moved DGM methods
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index fedaa29873..d9a2b59a19 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -17327,1941 +17327,6 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return InvokerHelper.getMetaClass(self).hasProperty(self, name);
     }
 
-    @Deprecated
-    public static boolean asBoolean(CharSequence string) {
-        return StringGroovyMethods.asBoolean(string);
-    }
-
-    @Deprecated
-    public static boolean asBoolean(Matcher matcher) {
-        return StringGroovyMethods.asBoolean(matcher);
-    }
-
-    @Deprecated
-    public static <T> T asType(CharSequence self, Class<T> c) {
-        return StringGroovyMethods.asType(self, c);
-    }
-
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public static <T> T asType(GString self, Class<T> c) {
-        return StringGroovyMethods.asType(self, c);
-    }
-
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public static <T> T asType(String self, Class<T> c) {
-        return StringGroovyMethods.asType(self, c);
-    }
-
-    @Deprecated
-    public static Pattern bitwiseNegate(CharSequence self) {
-        return StringGroovyMethods.bitwiseNegate(self);
-    }
-
-    @Deprecated
-    public static Pattern bitwiseNegate(String self) {
-        return StringGroovyMethods.bitwiseNegate(self);
-    }
-
-    @Deprecated
-    public static CharSequence capitalize(CharSequence self) {
-        return StringGroovyMethods.capitalize(self);
-    }
-
-    @Deprecated
-    public static String capitalize(String self) {
-        return StringGroovyMethods.capitalize(self);
-    }
-
-    @Deprecated
-    public static CharSequence center(CharSequence self, Number numberOfChars) {
-        return StringGroovyMethods.center(self, numberOfChars);
-    }
-
-    @Deprecated
-    public static CharSequence center(CharSequence self, Number numberOfChars, CharSequence padding) {
-        return StringGroovyMethods.center(self, numberOfChars, padding);
-    }
-
-    @Deprecated
-    public static String center(String self, Number numberOfChars) {
-        return StringGroovyMethods.center(self, numberOfChars);
-    }
-
-    @Deprecated
-    public static String center(String self, Number numberOfChars, String padding) {
-        return StringGroovyMethods.center(self, numberOfChars, padding);
-    }
-
-    @Deprecated
-    public static boolean contains(CharSequence self, CharSequence text) {
-        return StringGroovyMethods.contains(self, text);
-    }
-
-    @Deprecated
-    public static boolean contains(String self, String text) {
-        return StringGroovyMethods.contains(self, text);
-    }
-
-    @Deprecated
-    public static int count(CharSequence self, CharSequence text) {
-        return StringGroovyMethods.count(self, text);
-    }
-
-    @Deprecated
-    public static int count(String self, String text) {
-        return StringGroovyMethods.count(self, text);
-    }
-
-    @Deprecated
-    protected static StringBufferWriter createStringBufferWriter(StringBuffer self) {
-        return new StringBufferWriter(self);
-    }
-
-    @Deprecated
-    protected static StringWriter createStringWriter(String self) {
-        StringWriter answer = new StringWriter();
-        answer.write(self);
-        return answer;
-    }
-
-    @Deprecated
-    public static CharSequence denormalize(final CharSequence self) {
-        return StringGroovyMethods.denormalize(self);
-    }
-
-    @Deprecated
-    public static String denormalize(final String self) {
-        return StringGroovyMethods.denormalize(self);
-    }
-
-    @Deprecated
-    public static CharSequence
-    drop(CharSequence self, int num) {
-        return StringGroovyMethods.drop(self, num);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(CharSequence self, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.eachLine(self, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(CharSequence self, int firstLine, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.eachLine(self, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(String self, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.eachLine(self, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(String self, int firstLine, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.eachLine(self, firstLine, closure);
-    }
-
-    @Deprecated
-    public static String eachMatch(CharSequence self, CharSequence regex, Closure closure) {
-        return (String) StringGroovyMethods.eachMatch(self, regex, closure);
-    }
-
-    @Deprecated
-    public static String eachMatch(CharSequence self, Pattern pattern, Closure closure) {
-        return (String) StringGroovyMethods.eachMatch(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String eachMatch(String self, Pattern pattern, Closure closure) {
-        return StringGroovyMethods.eachMatch(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String eachMatch(String self, String regex, Closure closure) {
-        return StringGroovyMethods.eachMatch(self, regex, closure);
-    }
-
-    @Deprecated
-    public static CharSequence expand(CharSequence self) {
-        return StringGroovyMethods.expand(self);
-    }
-
-    @Deprecated
-    public static CharSequence expand(CharSequence self, int tabStop) {
-        return StringGroovyMethods.expand(self, tabStop);
-    }
-
-    @Deprecated
-    public static String expand(String self) {
-        return StringGroovyMethods.expand(self);
-    }
-
-    @Deprecated
-    public static String expand(String self, int tabStop) {
-        return StringGroovyMethods.expand(self, tabStop);
-    }
-
-    @Deprecated
-    public static CharSequence expandLine(CharSequence self, int tabStop) {
-        return StringGroovyMethods.expandLine(self, tabStop);
-    }
-
-    @Deprecated
-    public static String expandLine(String self, int tabStop) {
-        return StringGroovyMethods.expandLine(self, tabStop);
-    }
-
-    @Deprecated
-    public static CharSequence find(CharSequence self, CharSequence regex) {
-        return StringGroovyMethods.find(self, regex);
-    }
-
-    @Deprecated
-    public static CharSequence find(CharSequence self, CharSequence regex, Closure closure) {
-        return StringGroovyMethods.find(self, regex, closure);
-    }
-
-    @Deprecated
-    public static CharSequence find(CharSequence self, Pattern pattern) {
-        return StringGroovyMethods.find(self, pattern);
-    }
-
-    @Deprecated
-    public static CharSequence find(CharSequence self, Pattern pattern, Closure closure) {
-        return StringGroovyMethods.find(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String find(String self, Pattern pattern) {
-        return StringGroovyMethods.find(self, pattern);
-    }
-
-    @Deprecated
-    public static String find(String self, Pattern pattern, Closure closure) {
-        return StringGroovyMethods.find(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String find(String self, String regex) {
-        return StringGroovyMethods.find(self, regex);
-    }
-
-    @Deprecated
-    public static String find(String self, String regex, Closure closure) {
-        return StringGroovyMethods.find(self, regex, closure);
-    }
-
-    @Deprecated
-    public static List<String> findAll(CharSequence self, CharSequence regex) {
-        return StringGroovyMethods.findAll(self, regex);
-    }
-
-    @Deprecated
-    public static <T> List<T> findAll(CharSequence self, CharSequence regex, Closure<T> closure) {
-        return StringGroovyMethods.findAll(self, regex, closure);
-    }
-
-    @Deprecated
-    public static List<String> findAll(CharSequence self, Pattern pattern) {
-        return StringGroovyMethods.findAll(self, pattern);
-    }
-
-    @Deprecated
-    public static <T> List<T> findAll(CharSequence self, Pattern pattern, Closure<T> closure) {
-        return StringGroovyMethods.findAll(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static List<String> findAll(String self, Pattern pattern) {
-        return StringGroovyMethods.findAll(self, pattern);
-    }
-
-    @Deprecated
-    public static <T> List<T> findAll(String self, Pattern pattern, Closure<T> closure) {
-        return StringGroovyMethods.findAll(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static List<String> findAll(String self, String regex) {
-        return StringGroovyMethods.findAll(self, regex);
-    }
-
-    @Deprecated
-    public static <T> List<T> findAll(String self, String regex, Closure<T> closure) {
-        return StringGroovyMethods.findAll(self, regex, closure);
-    }
-
-    @Deprecated
-    public static CharSequence getAt(CharSequence self, Collection indices) {
-        return StringGroovyMethods.getAt(self, indices);
-    }
-
-    @Deprecated
-    public static CharSequence getAt(CharSequence text, EmptyRange range) {
-        return StringGroovyMethods.getAt(text, range);
-    }
-
-    @Deprecated
-    public static CharSequence getAt(CharSequence text, int index) {
-        return StringGroovyMethods.getAt(text, index);
-    }
-
-    @Deprecated
-    public static CharSequence getAt(CharSequence text, IntRange range) {
-        return StringGroovyMethods.getAt(text, range);
-    }
-
-    @Deprecated
-    public static CharSequence getAt(CharSequence text, Range range) {
-        return StringGroovyMethods.getAt(text, range);
-    }
-
-    @Deprecated
-    public static List getAt(Matcher self, Collection indices) {
-        return StringGroovyMethods.getAt(self, indices);
-    }
-
-    @Deprecated
-    public static Object getAt(Matcher matcher, int idx) {
-        return StringGroovyMethods.getAt(matcher, idx);
-    }
-
-    @Deprecated
-    public static String getAt(String self, Collection indices) {
-        return StringGroovyMethods.getAt(self, indices);
-    }
-
-    @Deprecated
-    public static String getAt(String text, EmptyRange range) {
-        return StringGroovyMethods.getAt(text, range);
-    }
-
-    @Deprecated
-    public static String getAt(String text, int index) {
-        return StringGroovyMethods.getAt(text, index);
-    }
-
-    @Deprecated
-    public static String getAt(String text, IntRange range) {
-        return StringGroovyMethods.getAt(text, range);
-    }
-
-    @Deprecated
-    public static String getAt(String text, Range range) {
-        return StringGroovyMethods.getAt(text, range);
-    }
-
-    @Deprecated
-    public static char[] getChars(CharSequence self) {
-        return StringGroovyMethods.getChars(self);
-    }
-
-    @Deprecated
-    public static char[] getChars(String self) {
-        return StringGroovyMethods.getChars(self);
-    }
-
-    @Deprecated
-    public static int getCount(Matcher matcher) {
-        return StringGroovyMethods.getCount(matcher);
-    }
-
-    @Deprecated
-    public static boolean hasGroup(Matcher matcher) {
-        return StringGroovyMethods.hasGroup(matcher);
-    }
-
-    @Deprecated
-    public static boolean isAllWhitespace(CharSequence self) {
-        return StringGroovyMethods.isAllWhitespace(self);
-    }
-
-    @Deprecated
-    public static boolean isAllWhitespace(String self) {
-        return StringGroovyMethods.isAllWhitespace(self);
-    }
-
-    @Deprecated
-    public static boolean isBigDecimal(CharSequence self) {
-        return StringGroovyMethods.isBigDecimal(self);
-    }
-
-    @Deprecated
-    public static boolean isBigDecimal(String self) {
-        return StringGroovyMethods.isBigDecimal(self);
-    }
-
-    @Deprecated
-    public static boolean isBigInteger(CharSequence self) {
-        return StringGroovyMethods.isBigInteger(self);
-    }
-
-    @Deprecated
-    public static boolean isBigInteger(String self) {
-        return StringGroovyMethods.isBigInteger(self);
-    }
-
-    @Deprecated
-    public static boolean isCase(CharSequence caseValue, Object switchValue) {
-        return StringGroovyMethods.isCase(caseValue, switchValue);
-    }
-
-    @Deprecated
-    public static boolean isCase(GString caseValue, Object switchValue) {
-        return StringGroovyMethods.isCase(caseValue, switchValue);
-    }
-
-    @Deprecated
-    public static boolean isCase(Pattern caseValue, Object switchValue) {
-        return StringGroovyMethods.isCase(caseValue, switchValue);
-    }
-
-    @Deprecated
-    public static boolean isCase(String caseValue, Object switchValue) {
-        return StringGroovyMethods.isCase(caseValue, switchValue);
-    }
-
-    @Deprecated
-    public static boolean isDouble(CharSequence self) {
-        return StringGroovyMethods.isDouble(self);
-    }
-
-    @Deprecated
-    public static boolean isDouble(String self) {
-        return StringGroovyMethods.isDouble(self);
-    }
-
-    @Deprecated
-    public static boolean isFloat(CharSequence self) {
-        return StringGroovyMethods.isFloat(self);
-    }
-
-    @Deprecated
-    public static boolean isFloat(String self) {
-        return StringGroovyMethods.isFloat(self);
-    }
-
-    @Deprecated
-    public static boolean isInteger(CharSequence self) {
-        return StringGroovyMethods.isInteger(self);
-    }
-
-    @Deprecated
-    public static boolean isInteger(String self) {
-        return StringGroovyMethods.isInteger(self);
-    }
-
-    @Deprecated
-    public static boolean isLong(CharSequence self) {
-        return StringGroovyMethods.isLong(self);
-    }
-
-    @Deprecated
-    public static boolean isLong(String self) {
-        return StringGroovyMethods.isLong(self);
-    }
-
-    @Deprecated
-    public static boolean isNumber(CharSequence self) {
-        return StringGroovyMethods.isNumber(self);
-    }
-
-    @Deprecated
-    public static boolean isNumber(String self) {
-        return StringGroovyMethods.isNumber(self);
-    }
-
-    @Deprecated
-    public static Iterator iterator(final Matcher matcher) {
-        return StringGroovyMethods.iterator(matcher);
-    }
-
-    @Deprecated
-    public static StringBuilder leftShift(CharSequence self, Object value) {
-        return StringGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static StringBuffer leftShift(String self, Object value) {
-        return StringGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static StringBuffer leftShift(StringBuffer self, Object value) {
-        return StringGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static StringBuilder leftShift(StringBuilder self, Object value) {
-        return StringGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static boolean matches(CharSequence self, Pattern pattern) {
-        return StringGroovyMethods.matches(self, pattern);
-    }
-
-    @Deprecated
-    public static boolean matches(String self, Pattern pattern) {
-        return StringGroovyMethods.matches(self, pattern);
-    }
-
-    @Deprecated
-    public static CharSequence minus(CharSequence self, Object target) {
-        return StringGroovyMethods.minus(self, target);
-    }
-
-    @Deprecated
-    public static String minus(String self, Object target) {
-        return StringGroovyMethods.minus(self, target);
-    }
-
-    @Deprecated
-    public static CharSequence multiply(CharSequence self, Number factor) {
-        return StringGroovyMethods.multiply(self, factor);
-    }
-
-    @Deprecated
-    public static String multiply(String self, Number factor) {
-        return StringGroovyMethods.multiply(self, factor);
-    }
-
-    @Deprecated
-    public static CharSequence next(CharSequence self) {
-        return StringGroovyMethods.next(self);
-    }
-
-    @Deprecated
-    public static String next(String self) {
-        return StringGroovyMethods.next(self);
-    }
-
-    @Deprecated
-    public static CharSequence normalize(final CharSequence self) {
-        return StringGroovyMethods.normalize(self);
-    }
-
-    @Deprecated
-    public static String normalize(final String self) {
-        return StringGroovyMethods.normalize(self);
-    }
-
-    @Deprecated
-    public static CharSequence padLeft(CharSequence self, Number numberOfChars) {
-        return StringGroovyMethods.padLeft(self, numberOfChars);
-    }
-
-    @Deprecated
-    public static CharSequence padLeft(CharSequence self, Number numberOfChars, CharSequence padding) {
-        return StringGroovyMethods.padLeft(self, numberOfChars, padding);
-    }
-
-    @Deprecated
-    public static String padLeft(String self, Number numberOfChars) {
-        return StringGroovyMethods.padLeft(self, numberOfChars);
-    }
-
-    @Deprecated
-    public static String padLeft(String self, Number numberOfChars, String padding) {
-        return StringGroovyMethods.padLeft(self, numberOfChars, padding);
-    }
-
-    @Deprecated
-    public static CharSequence padRight(CharSequence self, Number numberOfChars) {
-        return StringGroovyMethods.padRight(self, numberOfChars);
-    }
-
-    @Deprecated
-    public static CharSequence padRight(CharSequence self, Number numberOfChars, CharSequence padding) {
-        return StringGroovyMethods.padRight(self, numberOfChars, padding);
-    }
-
-    @Deprecated
-    public static String padRight(String self, Number numberOfChars) {
-        return StringGroovyMethods.padRight(self, numberOfChars);
-    }
-
-    @Deprecated
-    public static String padRight(String self, Number numberOfChars, String padding) {
-        return StringGroovyMethods.padRight(self, numberOfChars, padding);
-    }
-
-    @Deprecated
-    public static CharSequence plus(CharSequence left, Object value) {
-        return StringGroovyMethods.plus(left, value);
-    }
-
-    @Deprecated
-    public static String plus(Number value, String right) {
-        return StringGroovyMethods.plus(value, right);
-    }
-
-    @Deprecated
-    public static String plus(String left, Object value) {
-        return StringGroovyMethods.plus(left, value);
-    }
-
-    @Deprecated
-    public static String plus(StringBuffer left, String value) {
-        return StringGroovyMethods.plus(left, value);
-    }
-
-    @Deprecated
-    public static CharSequence previous(CharSequence self) {
-        return StringGroovyMethods.previous(self);
-    }
-
-    @Deprecated
-    public static String previous(String self) {
-        return StringGroovyMethods.previous(self);
-    }
-
-    @Deprecated
-    public static void putAt(StringBuffer self, EmptyRange range, Object value) {
-        StringGroovyMethods.putAt(self, range, value);
-    }
-
-    @Deprecated
-    public static void putAt(StringBuffer self, IntRange range, Object value) {
-        StringGroovyMethods.putAt(self, range, value);
-    }
-
-    @Deprecated
-    public static List<String> readLines(CharSequence self) throws IOException {
-        return StringGroovyMethods.readLines(self);
-    }
-
-    @Deprecated
-    public static List<String> readLines(String self) throws IOException {
-        return StringGroovyMethods.readLines(self);
-    }
-
-    @Deprecated
-    public static CharSequence replaceAll(final CharSequence self, final CharSequence regex, final CharSequence replacement) {
-        return StringGroovyMethods.replaceAll(self, regex, replacement);
-    }
-
-    @Deprecated
-    public static CharSequence replaceAll(final CharSequence self, final CharSequence regex, final Closure closure) {
-        return StringGroovyMethods.replaceAll(self, regex, closure);
-    }
-
-    @Deprecated
-    public static CharSequence replaceAll(CharSequence self, Pattern pattern, CharSequence replacement) {
-        return StringGroovyMethods.replaceAll(self, pattern, replacement);
-    }
-
-    @Deprecated
-    public static String replaceAll(final CharSequence self, final Pattern pattern, final Closure closure) {
-        return StringGroovyMethods.replaceAll(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String replaceAll(final String self, final Pattern pattern, final Closure closure) {
-        return StringGroovyMethods.replaceAll(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String replaceAll(String self, Pattern pattern, String replacement) {
-        return StringGroovyMethods.replaceAll(self, pattern, replacement);
-    }
-
-    @Deprecated
-    public static String replaceAll(final String self, final String regex, final Closure closure) {
-        return StringGroovyMethods.replaceAll(self, regex, closure);
-    }
-
-    @Deprecated
-    public static String replaceFirst(final CharSequence self, final CharSequence regex, final CharSequence replacement) {
-        return StringGroovyMethods.replaceFirst(self, regex, replacement);
-    }
-
-    @Deprecated
-    public static String replaceFirst(final CharSequence self, final CharSequence regex, final Closure closure) {
-        return StringGroovyMethods.replaceFirst(self, regex, closure);
-    }
-
-    @Deprecated
-    public static CharSequence replaceFirst(CharSequence self, Pattern pattern, CharSequence replacement) {
-        return StringGroovyMethods.replaceFirst(self, pattern, replacement);
-    }
-
-    @Deprecated
-    public static String replaceFirst(final CharSequence self, final Pattern pattern, final Closure closure) {
-        return StringGroovyMethods.replaceFirst(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String replaceFirst(final String self, final Pattern pattern, final Closure closure) {
-        return StringGroovyMethods.replaceFirst(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static String replaceFirst(String self, Pattern pattern, String replacement) {
-        return StringGroovyMethods.replaceFirst(self, pattern, replacement);
-    }
-
-    @Deprecated
-    public static String replaceFirst(final String self, final String regex, final Closure closure) {
-        return StringGroovyMethods.replaceFirst(self, regex, closure);
-    }
-
-    @Deprecated
-    public static CharSequence reverse(CharSequence self) {
-        return StringGroovyMethods.reverse(self);
-    }
-
-    @Deprecated
-    public static String reverse(String self) {
-        return StringGroovyMethods.reverse(self);
-    }
-
-    @Deprecated
-    public static void setIndex(Matcher matcher, int idx) {
-        StringGroovyMethods.setIndex(matcher, idx);
-    }
-
-    @Deprecated
-    public static int size(CharSequence text) {
-        return StringGroovyMethods.size(text);
-    }
-
-    @Deprecated
-    public static long size(Matcher self) {
-        return StringGroovyMethods.size(self);
-    }
-
-    @Deprecated
-    public static int size(String text) {
-        return StringGroovyMethods.size(text);
-    }
-
-    @Deprecated
-    public static int size(StringBuffer buffer) {
-        return StringGroovyMethods.size(buffer);
-    }
-
-    @Deprecated
-    public static CharSequence[] split(CharSequence self) {
-        return StringGroovyMethods.split(self);
-    }
-
-    @Deprecated
-    public static String[] split(GString self) {
-        return StringGroovyMethods.split(self);
-    }
-
-    @Deprecated
-    public static String[] split(String self) {
-        return StringGroovyMethods.split(self);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(CharSequence self, CharSequence regex, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.splitEachLine(self, regex, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(CharSequence self, Pattern pattern, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.splitEachLine(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(String self, Pattern pattern, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.splitEachLine(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(String self, String regex, Closure<T> closure) throws IOException {
-        return StringGroovyMethods.splitEachLine(self, regex, closure);
-    }
-
-    @Deprecated
-    public static CharSequence stripIndent(CharSequence self) {
-        return StringGroovyMethods.stripIndent(self);
-    }
-
-    @Deprecated
-    public static CharSequence stripIndent(CharSequence self, int numChars) {
-        return StringGroovyMethods.stripIndent(self, numChars);
-    }
-
-    @Deprecated
-    public static String stripIndent(String self) {
-        return StringGroovyMethods.stripIndent(self);
-    }
-
-    @Deprecated
-    public static String stripIndent(String self, int numChars) {
-        return StringGroovyMethods.stripIndent(self, numChars);
-    }
-
-    @Deprecated
-    public static CharSequence stripMargin(CharSequence self) {
-        return StringGroovyMethods.stripMargin(self);
-    }
-
-    @Deprecated
-    public static CharSequence stripMargin(CharSequence self, char marginChar) {
-        return StringGroovyMethods.stripMargin(self, marginChar);
-    }
-
-    @Deprecated
-    public static String stripMargin(CharSequence self, CharSequence marginChar) {
-        return StringGroovyMethods.stripMargin(self, marginChar);
-    }
-
-    @Deprecated
-    public static String stripMargin(String self) {
-        return StringGroovyMethods.stripMargin(self);
-    }
-
-    @Deprecated
-    public static String stripMargin(String self, char marginChar) {
-        return StringGroovyMethods.stripMargin(self, marginChar);
-    }
-
-    @Deprecated
-    public static String stripMargin(String self, String marginChar) {
-        return StringGroovyMethods.stripMargin(self, marginChar);
-    }
-
-    @Deprecated
-    public static BigDecimal toBigDecimal(CharSequence self) {
-        return StringGroovyMethods.toBigDecimal(self);
-    }
-
-    @Deprecated
-    public static BigDecimal toBigDecimal(String self) {
-        return StringGroovyMethods.toBigDecimal(self);
-    }
-
-    @Deprecated
-    public static BigInteger toBigInteger(CharSequence self) {
-        return StringGroovyMethods.toBigInteger(self);
-    }
-
-    @Deprecated
-    public static BigInteger toBigInteger(String self) {
-        return StringGroovyMethods.toBigInteger(self);
-    }
-
-    @Deprecated
-    public static Boolean toBoolean(String self) {
-        return StringGroovyMethods.toBoolean(self);
-    }
-
-    @Deprecated
-    public static Character toCharacter(String self) {
-        return StringGroovyMethods.toCharacter(self);
-    }
-
-    @Deprecated
-    public static Double toDouble(CharSequence self) {
-        return StringGroovyMethods.toDouble(self);
-    }
-
-    @Deprecated
-    public static Double toDouble(String self) {
-        return StringGroovyMethods.toDouble(self);
-    }
-
-    @Deprecated
-    public static Float toFloat(CharSequence self) {
-        return StringGroovyMethods.toFloat(self);
-    }
-
-    @Deprecated
-    public static Float toFloat(String self) {
-        return StringGroovyMethods.toFloat(self);
-    }
-
-    @Deprecated
-    public static Integer toInteger(CharSequence self) {
-        return StringGroovyMethods.toInteger(self);
-    }
-
-    @Deprecated
-    public static Integer toInteger(String self) {
-        return StringGroovyMethods.toInteger(self);
-    }
-
-    @Deprecated
-    public static List<String> tokenize(CharSequence self) {
-        return StringGroovyMethods.tokenize(self);
-    }
-
-    @Deprecated
-    public static List<String> tokenize(CharSequence self, Character token) {
-        return StringGroovyMethods.tokenize(self, token);
-    }
-
-    @Deprecated
-    public static List<String> tokenize(CharSequence self, CharSequence token) {
-        return StringGroovyMethods.tokenize(self, token);
-    }
-
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public static List<String> tokenize(String self) {
-        return StringGroovyMethods.tokenize(self);
-    }
-
-    @Deprecated
-    public static List<String> tokenize(String self, Character token) {
-        return StringGroovyMethods.tokenize(self, token);
-    }
-
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public static List<String> tokenize(String self, String token) {
-        return StringGroovyMethods.tokenize(self, token);
-    }
-
-    @Deprecated
-    public static List<String> toList(CharSequence self) {
-        return StringGroovyMethods.toList(self);
-    }
-
-    @Deprecated
-    public static List<String> toList(String self) {
-        return StringGroovyMethods.toList(self);
-    }
-
-    @Deprecated
-    public static Long toLong(CharSequence self) {
-        return StringGroovyMethods.toLong(self);
-    }
-
-    @Deprecated
-    public static Long toLong(String self) {
-        return StringGroovyMethods.toLong(self);
-    }
-
-    @Deprecated
-    public static Set<String> toSet(CharSequence self) {
-        return StringGroovyMethods.toSet(self);
-    }
-
-    @Deprecated
-    public static Set<String> toSet(String self) {
-        return StringGroovyMethods.toSet(self);
-    }
-
-    @Deprecated
-    public static Short toShort(CharSequence self) {
-        return StringGroovyMethods.toShort(self);
-    }
-
-    @Deprecated
-    public static Short toShort(String self) {
-        return StringGroovyMethods.toShort(self);
-    }
-
-    @Deprecated
-    public static URI toURI(CharSequence self) throws URISyntaxException {
-        return ResourceGroovyMethods.toURI(self);
-    }
-
-    @Deprecated
-    public static URI toURI(String self) throws URISyntaxException {
-        return ResourceGroovyMethods.toURI(self);
-    }
-
-    @Deprecated
-    public static URL toURL(CharSequence self) throws MalformedURLException {
-        return ResourceGroovyMethods.toURL(self);
-    }
-
-    @Deprecated
-    public static URL toURL(String self) throws MalformedURLException {
-        return ResourceGroovyMethods.toURL(self);
-    }
-
-    @Deprecated
-    public static CharSequence tr(final CharSequence self, CharSequence sourceSet, CharSequence replacementSet) throws ClassNotFoundException {
-        return StringGroovyMethods.tr(self, sourceSet, replacementSet);
-    }
-
-    @Deprecated
-    public static String tr(final String self, String sourceSet, String replacementSet) throws ClassNotFoundException {
-        return StringGroovyMethods.tr(self, sourceSet, replacementSet);
-    }
-
-    @Deprecated
-    public static CharSequence unexpand(CharSequence self) {
-        return StringGroovyMethods.unexpand(self);
-    }
-
-    @Deprecated
-    public static CharSequence unexpand(CharSequence self, int tabStop) {
-        return StringGroovyMethods.unexpand(self, tabStop);
-    }
-
-    @Deprecated
-    public static String unexpand(String self) {
-        return StringGroovyMethods.unexpand(self);
-    }
-
-    @Deprecated
-    public static String unexpand(String self, int tabStop) {
-        return StringGroovyMethods.unexpand(self, tabStop);
-    }
-
-    @Deprecated
-    public static CharSequence unexpandLine(CharSequence self, int tabStop) {
-        return StringGroovyMethods.unexpandLine(self, tabStop);
-    }
-
-    @Deprecated
-    public static String unexpandLine(String self, int tabStop) {
-        return StringGroovyMethods.unexpandLine(self, tabStop);
-    }
-
-    @Deprecated
-    public static Process execute(final String self) throws IOException {
-        return ProcessGroovyMethods.execute(self);
-    }
-
-    @Deprecated
-    public static Process execute(final String self, final String[] envp, final File dir) throws IOException {
-        return ProcessGroovyMethods.execute(self, envp, dir);
-    }
-
-    @Deprecated
-    public static Process execute(final String self, final List envp, final File dir) throws IOException {
-        return ProcessGroovyMethods.execute(self, envp, dir);
-    }
-
-    @Deprecated
-    public static Process execute(final String[] commandArray) throws IOException {
-        return ProcessGroovyMethods.execute(commandArray);
-    }
-
-    @Deprecated
-    public static Process execute(final String[] commandArray, final String[] envp, final File dir) throws IOException {
-        return ProcessGroovyMethods.execute(commandArray, envp, dir);
-    }
-
-    @Deprecated
-    public static Process execute(final String[] commandArray, final List envp, final File dir) throws IOException {
-        return ProcessGroovyMethods.execute(commandArray, envp, dir);
-    }
-
-    @Deprecated
-    public static Process execute(final List commands) throws IOException {
-        return ProcessGroovyMethods.execute(commands);
-    }
-
-    @Deprecated
-    public static Process execute(final List commands, final String[] envp, final File dir) throws IOException {
-        return ProcessGroovyMethods.execute(commands, envp, dir);
-    }
-
-    @Deprecated
-    public static Process execute(final List commands, final List envp, final File dir) throws IOException {
-        return ProcessGroovyMethods.execute(commands, envp, dir);
-    }
-
-    @Deprecated
-    public static <T> T withStreams(Socket socket, Closure<T> closure) throws IOException {
-        return SocketGroovyMethods.withStreams(socket, closure);
-    }
-
-    @Deprecated
-    public static <T> T withObjectStreams(Socket socket, Closure<T> closure) throws IOException {
-        return SocketGroovyMethods.withObjectStreams(socket, closure);
-    }
-
-    @Deprecated
-    public static Writer leftShift(Socket self, Object value) throws IOException {
-        return SocketGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static OutputStream leftShift(Socket self, byte[] value) throws IOException {
-        return SocketGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static Socket accept(ServerSocket serverSocket, final Closure closure) throws IOException {
-        return SocketGroovyMethods.accept(serverSocket, closure);
-    }
-
-    @Deprecated
-    public static Socket accept(ServerSocket serverSocket, final boolean runInANewThread,
-                                final Closure closure) throws IOException {
-        return SocketGroovyMethods.accept(serverSocket, runInANewThread, closure);
-    }
-
-    @Deprecated
-    public static long size(File self) {
-        return ResourceGroovyMethods.size(self);
-    }
-
-    @Deprecated
-    public static Writer leftShift(Writer self, Object value) throws IOException {
-        return IOGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static void write(Writer self, Writable writable) throws IOException {
-        IOGroovyMethods.write(self, writable);
-    }
-
-    @Deprecated
-    public static Writer leftShift(OutputStream self, Object value) throws IOException {
-        return IOGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static void leftShift(ObjectOutputStream self, Object value) throws IOException {
-        IOGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static OutputStream leftShift(OutputStream self, InputStream in) throws IOException {
-        return IOGroovyMethods.leftShift(self, in);
-    }
-
-    @Deprecated
-    public static OutputStream leftShift(OutputStream self, byte[] value) throws IOException {
-        return IOGroovyMethods.leftShift(self, value);
-    }
-
-    @Deprecated
-    public static ObjectOutputStream newObjectOutputStream(File file) throws IOException {
-        return ResourceGroovyMethods.newObjectOutputStream(file);
-    }
-
-    @Deprecated
-    public static ObjectOutputStream newObjectOutputStream(OutputStream outputStream) throws IOException {
-        return IOGroovyMethods.newObjectOutputStream(outputStream);
-    }
-
-    @Deprecated
-    public static <T> T withObjectOutputStream(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withObjectOutputStream(file, closure);
-    }
-
-    @Deprecated
-    public static <T> T withObjectOutputStream(OutputStream outputStream, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withObjectOutputStream(outputStream, closure);
-    }
-
-    @Deprecated
-    public static ObjectInputStream newObjectInputStream(File file) throws IOException {
-        return ResourceGroovyMethods.newObjectInputStream(file);
-    }
-
-    @Deprecated
-    public static ObjectInputStream newObjectInputStream(InputStream inputStream) throws IOException {
-        return IOGroovyMethods.newObjectInputStream(inputStream);
-    }
-
-    @Deprecated
-    public static ObjectInputStream newObjectInputStream(InputStream inputStream, final ClassLoader classLoader) throws IOException {
-        return IOGroovyMethods.newObjectInputStream(inputStream, classLoader);
-    }
-
-    @Deprecated
-    public static ObjectInputStream newObjectInputStream(File file, final ClassLoader classLoader) throws IOException {
-        return ResourceGroovyMethods.newObjectInputStream(file, classLoader);
-    }
-
-    @Deprecated
-    public static void eachObject(File self, Closure closure) throws IOException, ClassNotFoundException {
-        ResourceGroovyMethods.eachObject(self, closure);
-    }
-
-    @Deprecated
-    public static void eachObject(ObjectInputStream ois, Closure closure) throws IOException, ClassNotFoundException {
-        IOGroovyMethods.eachObject(ois, closure);
-    }
-
-    @Deprecated
-    public static <T> T withObjectInputStream(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withObjectInputStream(file, closure);
-    }
-
-    @Deprecated
-    public static <T> T withObjectInputStream(File file, ClassLoader classLoader, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withObjectInputStream(file, classLoader, closure);
-    }
-
-    @Deprecated
-    public static <T> T withObjectInputStream(InputStream inputStream, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withObjectInputStream(inputStream, closure);
-    }
-
-    @Deprecated
-    public static <T> T withObjectInputStream(InputStream inputStream, ClassLoader classLoader, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withObjectInputStream(inputStream, classLoader, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(File self, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(self, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(File self, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(self, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(File self, int firstLine, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(self, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(File self, String charset, int firstLine, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(self, charset, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(InputStream stream, String charset, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.eachLine(stream, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(InputStream stream, String charset, int firstLine, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.eachLine(stream, charset, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(InputStream stream, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.eachLine(stream, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(InputStream stream, int firstLine, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.eachLine(stream, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(URL url, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(url, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(URL url, int firstLine, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(url, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(URL url, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(url, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(URL url, String charset, int firstLine, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.eachLine(url, charset, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(Reader self, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.eachLine(self, closure);
-    }
-
-    @Deprecated
-    public static <T> T eachLine(Reader self, int firstLine, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.eachLine(self, firstLine, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(File self, String regex, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, regex, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(File self, Pattern pattern, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(File self, String regex, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, regex, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(File self, Pattern pattern, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, pattern, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(URL self, String regex, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, regex, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(URL self, Pattern pattern, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(URL self, String regex, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, regex, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(URL self, Pattern pattern, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.splitEachLine(self, pattern, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(Reader self, String regex, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.splitEachLine(self, regex, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(Reader self, Pattern pattern, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.splitEachLine(self, pattern, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(InputStream stream, String regex, String charset, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.splitEachLine(stream, charset, regex, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(InputStream stream, Pattern pattern, String charset, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.splitEachLine(stream, pattern, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(InputStream stream, String regex, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.splitEachLine(stream, regex, closure);
-    }
-
-    @Deprecated
-    public static <T> T splitEachLine(InputStream stream, Pattern pattern, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.splitEachLine(stream, pattern, closure);
-    }
-
-    @Deprecated
-    public static String readLine(Reader self) throws IOException {
-        return  IOGroovyMethods.readLine(self);
-    }
-
-    @Deprecated
-    public static List<String> readLines(File file) throws IOException {
-        return ResourceGroovyMethods.readLines(file);
-    }
-
-    @Deprecated
-    public static List<String> readLines(File file, String charset) throws IOException {
-        return ResourceGroovyMethods.readLines(file, charset);
-    }
-
-    @Deprecated
-    public static List<String> readLines(InputStream stream) throws IOException {
-        return IOGroovyMethods.readLines(stream);
-    }
-
-    @Deprecated
-    public static List<String> readLines(InputStream stream, String charset) throws IOException {
-        return IOGroovyMethods.readLines(stream, charset);
-    }
-
-    @Deprecated
-    public static List<String> readLines(URL self) throws IOException {
-        return ResourceGroovyMethods.readLines(self);
-    }
-
-    @Deprecated
-    public static List<String> readLines(URL self, String charset) throws IOException {
-        return ResourceGroovyMethods.readLines(self, charset);
-    }
-
-    @Deprecated
-    public static List<String> readLines(Reader reader) throws IOException {
-        return IOGroovyMethods.readLines(reader);
-    }
-
-    @Deprecated
-    public static String getText(File file, String charset) throws IOException {
-        return ResourceGroovyMethods.getText(file, charset);
-    }
-
-    @Deprecated
-    public static String getText(File file) throws IOException {
-        return ResourceGroovyMethods.getText(file);
-    }
-
-    @Deprecated
-    public static String getText(URL url) throws IOException {
-        return ResourceGroovyMethods.getText(url);
-    }
-
-    @Deprecated
-    public static String getText(URL url, Map parameters) throws IOException {
-        return ResourceGroovyMethods.getText(url, parameters);
-    }
-
-    @Deprecated
-    public static String getText(URL url, String charset) throws IOException {
-        return ResourceGroovyMethods.getText(url, charset);
-    }
-
-    @Deprecated
-    public static String getText(URL url, Map parameters, String charset) throws IOException {
-        return ResourceGroovyMethods.getText(url, parameters, charset);
-    }
-
-    @Deprecated
-    public static String getText(InputStream is) throws IOException {
-        return IOGroovyMethods.getText(is);
-    }
-
-    @Deprecated
-    public static String getText(InputStream is, String charset) throws IOException {
-        return IOGroovyMethods.getText(is, charset);
-    }
-
-    @Deprecated
-    public static String getText(Reader reader) throws IOException {
-        return IOGroovyMethods.getText(reader);
-    }
-
-    @Deprecated
-    public static String getText(BufferedReader reader) throws IOException {
-        return IOGroovyMethods.getText(reader);
-    }
-
-    @Deprecated
-    public static byte[] getBytes(File file) throws IOException {
-        return ResourceGroovyMethods.getBytes(file);
-    }
-
-    @Deprecated
-    public static byte[] getBytes(URL url) throws IOException {
-        return ResourceGroovyMethods.getBytes(url);
-    }
-
-    @Deprecated
-    public static byte[] getBytes(InputStream is) throws IOException {
-        return IOGroovyMethods.getBytes(is);
-    }
-
-    @Deprecated
-    public static void setBytes(File file, byte[] bytes) throws IOException {
-        ResourceGroovyMethods.setBytes(file, bytes);
-    }
-
-    @Deprecated
-    public static void setBytes(OutputStream os, byte[] bytes) throws IOException {
-        IOGroovyMethods.setBytes(os, bytes);
-    }
-
-    @Deprecated
-    public static void writeLine(BufferedWriter writer, String line) throws IOException {
-        IOGroovyMethods.writeLine(writer, line);
-    }
-
-    @Deprecated
-    public static void write(File file, String text) throws IOException {
-        ResourceGroovyMethods.write(file, text);
-    }
-
-    @Deprecated
-    public static void setText(File file, String text) throws IOException {
-        ResourceGroovyMethods.setText(file, text);
-    }
-
-    @Deprecated
-    public static void setText(File file, String text, String charset) throws IOException {
-        ResourceGroovyMethods.setText(file, text, charset);
-    }
-
-    @Deprecated
-    public static File leftShift(File file, Object text) throws IOException {
-        return ResourceGroovyMethods.leftShift(file, text);
-    }
-
-    @Deprecated
-    public static File leftShift(File file, byte[] bytes) throws IOException {
-        return ResourceGroovyMethods.leftShift(file, bytes);
-    }
-
-    @Deprecated
-    public static File leftShift(File file, InputStream data) throws IOException {
-        return ResourceGroovyMethods.leftShift(file, data);
-    }
-
-    @Deprecated
-    public static void write(File file, String text, String charset) throws IOException {
-        ResourceGroovyMethods.write(file, text, charset);
-    }
-
-    @Deprecated
-    public static void append(File file, Object text) throws IOException {
-        ResourceGroovyMethods.append(file, text);
-    }
-
-    @Deprecated
-    public static void append(File file, byte[] bytes) throws IOException {
-        ResourceGroovyMethods.append(file, bytes);
-    }
-
-    @Deprecated
-    public static void append(File self, InputStream stream ) throws IOException {
-        ResourceGroovyMethods.append(self, stream);
-    }
-
-    @Deprecated
-    public static void append(File file, Object text, String charset) throws IOException {
-        ResourceGroovyMethods.append(file, text, charset);
-    }
-
-    @Deprecated
-    public static void eachFile(final File self, final FileType fileType, final Closure closure)
-            throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachFile(self, fileType, closure);
-    }
-
-    @Deprecated
-    public static void eachFile(final File self, final Closure closure) throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachFile(self, closure);
-    }
-
-    @Deprecated
-    public static void eachDir(File self, Closure closure) throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachDir(self, closure);
-    }
-
-    @Deprecated
-    public static void eachFileRecurse(final File self, final FileType fileType, final Closure closure)
-            throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachFileRecurse(self, fileType, closure);
-    }
-
-    @Deprecated
-    public static void traverse(final File self, final Map<String, Object> options, final Closure closure)
-            throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.traverse(self, options, closure);
-    }
-
-    @Deprecated
-    public static void traverse(final File self, final Closure closure) throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.traverse(self, closure);
-    }
-
-    @Deprecated
-    public static void traverse(final File self, final Map<String, Object> options)
-            throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.traverse(self, options);
-    }
-
-    @Deprecated
-    public static void eachFileRecurse(File self, Closure closure) throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachFileRecurse(self, closure);
-    }
-
-    @Deprecated
-    public static void eachDirRecurse(final File self, final Closure closure) throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachDirRecurse(self, closure);
-    }
-
-    @Deprecated
-    public static void eachFileMatch(final File self, final FileType fileType, final Object nameFilter, final Closure closure)
-            throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachFileMatch(self, fileType, nameFilter, closure);
-    }
-
-    @Deprecated
-    public static void eachFileMatch(final File self, final Object nameFilter, final Closure closure)
-            throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachFileMatch(self, nameFilter, closure);
-    }
-
-    @Deprecated
-    public static void eachDirMatch(final File self, final Object nameFilter, final Closure closure) throws FileNotFoundException, IllegalArgumentException {
-        ResourceGroovyMethods.eachDirMatch(self, nameFilter, closure);
-    }
-
-    @Deprecated
-    public static boolean deleteDir(final File self) {
-        return ResourceGroovyMethods.deleteDir(self);
-    }
-
-    @Deprecated
-    public static boolean renameTo(final File self, String newPathName) {
-        return ResourceGroovyMethods.renameTo(self, newPathName);
-    }
-
-    @Deprecated
-    public static Iterator<String> iterator(Reader self) {
-        return IOGroovyMethods.iterator(self);
-    }
-
-    @Deprecated
-    public static Iterator<Byte> iterator(InputStream self) {
-        return IOGroovyMethods.iterator(self);
-    }
-
-    @Deprecated
-    public static Iterator<Byte> iterator(final DataInputStream self) {
-        return IOGroovyMethods.iterator(self);
-    }
-
-    @Deprecated
-    public static File asWritable(File file) {
-        return ResourceGroovyMethods.asWritable(file);
-    }
-
-    @Deprecated
-    public static <T> T asType(File f, Class<T> c) {
-        return ResourceGroovyMethods.asType(f, c);
-    }
-
-    @Deprecated
-    public static File asWritable(File file, String encoding) {
-        return ResourceGroovyMethods.asWritable(file, encoding);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(File file) throws IOException {
-        return ResourceGroovyMethods.newReader(file);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(File file, String charset)
-            throws FileNotFoundException, UnsupportedEncodingException {
-        return ResourceGroovyMethods.newReader(file, charset);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(InputStream self) {
-        return IOGroovyMethods.newReader(self);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(InputStream self, String charset) throws UnsupportedEncodingException {
-        return IOGroovyMethods.newReader(self, charset);
-    }
-
-    @Deprecated
-    public static <T> T withReader(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withReader(file, closure);
-    }
-
-    @Deprecated
-    public static <T> T withReader(File file, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withReader(file, charset, closure);
-    }
-
-    @Deprecated
-    public static BufferedOutputStream newOutputStream(File file) throws IOException {
-        return ResourceGroovyMethods.newOutputStream(file);
-    }
-
-    @Deprecated
-    public static DataOutputStream newDataOutputStream(File file) throws IOException {
-        return ResourceGroovyMethods.newDataOutputStream(file);
-    }
-
-    @Deprecated
-    public static Object withOutputStream(File file, Closure closure) throws IOException {
-        return ResourceGroovyMethods.withOutputStream(file, closure);
-    }
-
-    @Deprecated
-    public static Object withInputStream(File file, Closure closure) throws IOException {
-        return ResourceGroovyMethods.withInputStream(file, closure);
-    }
-
-    @Deprecated
-    public static <T> T withInputStream(URL url, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withInputStream(url, closure);
-    }
-
-    @Deprecated
-    public static <T> T withDataOutputStream(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withDataOutputStream(file, closure);
-    }
-
-    @Deprecated
-    public static <T> T withDataInputStream(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withDataInputStream(file, closure);
-    }
-
-    @Deprecated
-    public static BufferedWriter newWriter(File file) throws IOException {
-        return ResourceGroovyMethods.newWriter(file);
-    }
-
-    @Deprecated
-    public static BufferedWriter newWriter(File file, boolean append) throws IOException {
-        return ResourceGroovyMethods.newWriter(file, append);
-    }
-
-    @Deprecated
-    public static BufferedWriter newWriter(File file, String charset, boolean append) throws IOException {
-        return ResourceGroovyMethods.newWriter(file, charset, append);
-    }
-
-    @Deprecated
-    public static BufferedWriter newWriter(File file, String charset) throws IOException {
-        return ResourceGroovyMethods.newWriter(file, charset);
-    }
-
-    @Deprecated
-    public static <T> T withWriter(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withWriter(file, closure);
-    }
-
-    @Deprecated
-    public static <T> T withWriter(File file, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withWriter(file, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T withWriterAppend(File file, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withWriterAppend(file, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T withWriterAppend(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withWriterAppend(file, closure);
-    }
-
-    @Deprecated
-    public static PrintWriter newPrintWriter(File file) throws IOException {
-        return ResourceGroovyMethods.newPrintWriter(file);
-    }
-
-    @Deprecated
-    public static PrintWriter newPrintWriter(File file, String charset) throws IOException {
-        return ResourceGroovyMethods.newPrintWriter(file, charset);
-    }
-
-    @Deprecated
-    public static PrintWriter newPrintWriter(Writer writer) {
-        return IOGroovyMethods.newPrintWriter(writer);
-    }
-
-    @Deprecated
-    public static <T> T withPrintWriter(File file, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withPrintWriter(file, closure);
-    }
-
-    @Deprecated
-    public static <T> T withPrintWriter(File file, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withPrintWriter(file, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T withPrintWriter(Writer writer, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withPrintWriter(writer, closure);
-    }
-
-    @Deprecated
-    public static <T> T withWriter(Writer writer, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withWriter(writer, closure);
-    }
-
-    @Deprecated
-    public static <T> T withReader(Reader reader, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withReader(reader, closure);
-    }
-
-    @Deprecated
-    public static <T> T withStream(InputStream stream, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withStream(stream, closure);
-    }
-
-    @Deprecated
-    public static <T> T withReader(URL url, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withReader(url, closure);
-    }
-
-    @Deprecated
-    public static <T> T withReader(URL url, String charset, Closure<T> closure) throws IOException {
-        return ResourceGroovyMethods.withReader(url, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T withReader(InputStream in, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withReader(in, closure);
-    }
-
-    @Deprecated
-    public static <T> T withReader(InputStream in, String charset, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withReader(in, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T withWriter(OutputStream stream, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withWriter(stream, closure);
-    }
-
-    @Deprecated
-    public static <T> T withWriter(OutputStream stream, String charset, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withWriter(stream, charset, closure);
-    }
-
-    @Deprecated
-    public static <T> T withStream(OutputStream os, Closure<T> closure) throws IOException {
-        return IOGroovyMethods.withStream(os, closure);
-    }
-
-    @Deprecated
-    public static BufferedInputStream newInputStream(File file) throws FileNotFoundException {
-        return ResourceGroovyMethods.newInputStream(file);
-    }
-
-    @Deprecated
-    public static BufferedInputStream newInputStream(URL url) throws MalformedURLException, IOException {
-        return ResourceGroovyMethods.newInputStream(url);
-    }
-
-    @Deprecated
-    public static BufferedInputStream newInputStream(URL url, Map parameters) throws MalformedURLException, IOException {
-        return ResourceGroovyMethods.newInputStream(url, parameters);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(URL url) throws MalformedURLException, IOException {
-        return ResourceGroovyMethods.newReader(url);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(URL url, Map parameters) throws MalformedURLException, IOException {
-        return ResourceGroovyMethods.newReader(url, parameters);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(URL url, String charset) throws MalformedURLException, IOException {
-        return ResourceGroovyMethods.newReader(url, charset);
-    }
-
-    @Deprecated
-    public static BufferedReader newReader(URL url, Map parameters, String charset) throws MalformedURLException, IOException {
-        return ResourceGroovyMethods.newReader(url, parameters, charset);
-    }
-
-    @Deprecated
-    public static DataInputStream newDataInputStream(File file) throws FileNotFoundException {
-        return ResourceGroovyMethods.newDataInputStream(file);
-    }
-
-    @Deprecated
-    public static void eachByte(File self, Closure closure) throws IOException {
-        ResourceGroovyMethods.eachByte(self, closure);
-    }
-
-    @Deprecated
-    public static void eachByte(File self, int bufferLen, Closure closure) throws IOException {
-        ResourceGroovyMethods.eachByte(self, bufferLen, closure);
-    }
-
-    @Deprecated
-    public static void eachByte(InputStream is, Closure closure) throws IOException {
-        IOGroovyMethods.eachByte(is, closure);
-    }
-
-    @Deprecated
-    public static void eachByte(InputStream is, int bufferLen, Closure closure) throws IOException {
-        IOGroovyMethods.eachByte(is, bufferLen, closure);
-    }
-
-    @Deprecated
-    public static void eachByte(URL url, Closure closure) throws IOException {
-        ResourceGroovyMethods.eachByte(url, closure);
-    }
-
-    @Deprecated
-    public static void eachByte(URL url, int bufferLen, Closure closure) throws IOException {
-        ResourceGroovyMethods.eachByte(url, bufferLen, closure);
-    }
-
-    @Deprecated
-    public static void transformChar(Reader self, Writer writer, Closure closure) throws IOException {
-        IOGroovyMethods.transformChar(self, writer, closure);
-    }
-
-    @Deprecated
-    public static void transformLine(Reader reader, Writer writer, Closure closure) throws IOException {
-        IOGroovyMethods.transformLine(reader, writer, closure);
-    }
-
-    @Deprecated
-    public static void filterLine(Reader reader, Writer writer, Closure closure) throws IOException {
-        IOGroovyMethods.filterLine(reader, writer, closure);
-    }
-
-    @Deprecated
-    public static Writable filterLine(File self, Closure closure) throws IOException {
-        return ResourceGroovyMethods.filterLine(self, closure);
-    }
-
-    @Deprecated
-    public static Writable filterLine(File self, String charset, Closure closure) throws IOException {
-        return ResourceGroovyMethods.filterLine(self, closure);
-    }
-
-    @Deprecated
-    public static void filterLine(File self, Writer writer, Closure closure) throws IOException {
-        ResourceGroovyMethods.filterLine(self, writer, closure);
-    }
-
-    @Deprecated
-    public static void filterLine(File self, Writer writer, String charset, Closure closure) throws IOException {
-        ResourceGroovyMethods.filterLine(self, writer, charset, closure);
-    }
-
-    @Deprecated
-    public static Writable filterLine(Reader reader, final Closure closure) {
-        return IOGroovyMethods.filterLine(reader, closure);
-    }
-
-    @Deprecated
-    public static Writable filterLine(InputStream self, Closure predicate) {
-        return IOGroovyMethods.filterLine(self, predicate);
-    }
-
-    @Deprecated
-    public static Writable filterLine(InputStream self, String charset, Closure predicate) throws UnsupportedEncodingException {
-        return IOGroovyMethods.filterLine(self, charset, predicate);
-    }
-
-    @Deprecated
-    public static void filterLine(InputStream self, Writer writer, Closure predicate) throws IOException {
-        IOGroovyMethods.filterLine(self, writer, predicate);
-    }
-
-    @Deprecated
-    public static void filterLine(InputStream self, Writer writer, String charset, Closure predicate) throws IOException {
-        IOGroovyMethods.filterLine(self, writer, charset, predicate);
-    }
-
-    @Deprecated
-    public static Writable filterLine(URL self, Closure predicate) throws IOException {
-        return ResourceGroovyMethods.filterLine(self, predicate);
-    }
-
-    @Deprecated
-    public static Writable filterLine(URL self, String charset, Closure predicate) throws IOException {
-        return ResourceGroovyMethods.filterLine(self, charset, predicate);
-    }
-
-    @Deprecated
-    public static void filterLine(URL self, Writer writer, Closure predicate) throws IOException {
-        ResourceGroovyMethods.filterLine(self, writer, predicate);
-    }
-
-    @Deprecated
-    public static void filterLine(URL self, Writer writer, String charset, Closure predicate) throws IOException {
-        ResourceGroovyMethods.filterLine(self, writer, charset, predicate);
-    }
-
-    @Deprecated
-    public static byte[] readBytes(File file) throws IOException {
-        return ResourceGroovyMethods.readBytes(file);
-    }
-
     /**
      * Dynamically wraps an instance into something which implements the
      * supplied trait classes. It is guaranteed that the returned object

Commit:
3bb44bfb305188f1b56a8a8b3c073d6317ec18fa
paulk
paulk@asert.com.au
2018-03-26 13:22:01 +1000
remove an unused class
diff --git a/src/main/java/org/codehaus/groovy/runtime/ClassExtender.java b/src/main/java/org/codehaus/groovy/runtime/ClassExtender.java
deleted file mode 100644
index 390cf9c010..0000000000
--- a/src/main/java/org/codehaus/groovy/runtime/ClassExtender.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.runtime;
-
-import groovy.lang.Closure;
-
-import java.util.HashMap;
-import java.util.Map;
-
-
-/**
- * A helper class used by the runtime to allow Groovy classes to be extended at runtime
- * 
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
- */
-public class ClassExtender {
-    private Map variables;
-    private Map methods;
-
-    public synchronized Object get(String name) {
-        if (variables != null) {
-            return variables.get(name);
-        }
-        return null;
-    }
-
-    public synchronized void set(String name, Object value) {
-        if (variables == null) {
-            variables = createMap();
-        }
-        variables.put(name, value);
-    }
-
-    public synchronized void remove(String name) {
-        if (variables != null) {
-            variables.remove(name);
-        }
-    }
-
-    public void call(String name, Object params) {
-        Closure closure = null;
-        synchronized (this) {
-            if (methods != null) {
-                closure = (Closure) methods.get(name);
-            }
-        }
-        if (closure != null) {
-            closure.call(params);
-        }
-        /*
-        else {
-            throw DoesNotUnderstandException();
-        }
-        */
-    }
-
-    public synchronized void addMethod(String name, Closure closure) {
-        if (methods == null) {
-            methods = createMap();
-        }
-        methods.put(name, closure);
-    }
-
-    public synchronized void removeMethod(String name) {
-        if (methods != null) {
-            methods.remove(name);
-        }
-    }
-
-    protected Map createMap() {
-        return new HashMap();
-    }
-}

Commit:
72da47385c6b489790e5cec5429ad35ead9afd07
paulk
paulk@asert.com.au
2018-03-26 13:21:11 +1000
improve doco/tests for dateutil module - test could fail for one hour around a daulight saving time change
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyStaticMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyStaticMethods.java
index 04421afa57..7d9477146f 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyStaticMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyStaticMethods.java
@@ -161,60 +161,19 @@ public class DefaultGroovyStaticMethods {
         sleepImpl(milliseconds, onInterrupt);
     }
 
-    /**
-     * Parse a String into a Date instance using the given pattern.
-     * This convenience method acts as a wrapper for {@link java.text.SimpleDateFormat}.
-     * <p>
-     * Note that a new SimpleDateFormat instance is created for every
-     * invocation of this method (for thread safety).
-     *
-     * @param self   placeholder variable used by Groovy categories; ignored for default static methods
-     * @param format pattern used to parse the input string.
-     * @param input  String to be parsed to create the date instance
-     * @return a new Date instance representing the parsed input string
-     * @throws ParseException if there is a parse error
-     * @see java.text.SimpleDateFormat#parse(java.lang.String)
-     * @since 1.5.7
-     */
+    @Deprecated
     public static Date parse(Date self, String format, String input) throws ParseException {
         return new SimpleDateFormat(format).parse(input);
     }
 
-    /**
-     * Parse a String into a Date instance using the given pattern and TimeZone.
-     * This convenience method acts as a wrapper for {@link java.text.SimpleDateFormat}.
-     * <p>
-     * Note that a new SimpleDateFormat instance is created for every
-     * invocation of this method (for thread safety).
-     *
-     * @param self   placeholder variable used by Groovy categories; ignored for default static methods
-     * @param format pattern used to parse the input string.
-     * @param input  String to be parsed to create the date instance
-     * @param zone   TimeZone to use when parsing
-     * @return a new Date instance representing the parsed input string
-     * @throws ParseException if there is a parse error
-     * @see java.text.SimpleDateFormat#parse(java.lang.String)
-     * @since 2.4.1
-     */
+    @Deprecated
     public static Date parse(Date self, String format, String input, TimeZone zone) throws ParseException {
         SimpleDateFormat sdf = new SimpleDateFormat(format);
         sdf.setTimeZone(zone);
         return sdf.parse(input);
     }
 
-    /**
-     * Parse a String matching the pattern EEE MMM dd HH:mm:ss zzz yyyy
-     * containing US-locale-constants only (e.g. Sat for Saturdays).
-     * Such a string is generated by the toString method of {@link java.util.Date}
-     * <p>
-     * Note that a new SimpleDateFormat instance is created for every
-     * invocation of this method (for thread safety).
-     *
-     * @param self          placeholder variable used by Groovy categories; ignored for default static methods
-     * @param dateToString  String to be parsed to create the date instance. Must match the pattern EEE MMM dd HH:mm:ss zzz yyyy with US-locale symbols
-     * @return a new Date instance representing the parsed input string
-     * @throws ParseException if there is a parse error
-     */
+    @Deprecated
     public static Date parseToStringDate(Date self, String dateToString) throws ParseException {
         return new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US).parse(dateToString);
     }
diff --git a/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeStaticExtensions.java b/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeStaticExtensions.java
index 9015504231..ef9e588e49 100644
--- a/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeStaticExtensions.java
+++ b/subprojects/groovy-datetime/src/main/java/org/apache/groovy/datetime/extensions/DateTimeStaticExtensions.java
@@ -46,6 +46,8 @@ public class DateTimeStaticExtensions {
     /**
      * Parse text into a {@link java.time.LocalDate} using the provided pattern.
      *
+     * Note: the order of parameters differs from versions of this method for the legacy Date class.
+     *
      * @param type    placeholder variable used by Groovy categories; ignored for default static methods
      * @param text    String to be parsed to create the date instance
      * @param pattern pattern used to parse the text
@@ -63,6 +65,8 @@ public class DateTimeStaticExtensions {
     /**
      * Parse text into a {@link java.time.LocalDateTime} using the provided pattern.
      *
+     * Note: the order of parameters differs from versions of this method for the legacy Date class.
+     *
      * @param type    placeholder variable used by Groovy categories; ignored for default static methods
      * @param text    String to be parsed to create the date instance
      * @param pattern pattern used to parse the text
diff --git a/subprojects/groovy-dateutil/build.gradle b/subprojects/groovy-dateutil/build.gradle
index 296f0fa3c4..000f26d3ac 100644
--- a/subprojects/groovy-dateutil/build.gradle
+++ b/subprojects/groovy-dateutil/build.gradle
@@ -23,6 +23,6 @@ dependencies {
 
 task moduleDescriptor(type: org.codehaus.groovy.gradle.WriteExtensionDescriptorTask) {
     extensionClasses = 'org.apache.groovy.dateutil.extensions.DateUtilExtensions'
-//    staticExtensionClasses = 'org.apache.groovy.dateutil.extensions.DateUtilStaticExtensions'
+    staticExtensionClasses = 'org.apache.groovy.dateutil.extensions.DateUtilStaticExtensions'
 }
 compileJava.dependsOn moduleDescriptor
diff --git a/subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilExtensions.java b/subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilExtensions.java
index 19cf6dd303..b2fb898906 100644
--- a/subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilExtensions.java
+++ b/subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilExtensions.java
@@ -20,7 +20,6 @@ package org.apache.groovy.dateutil.extensions;
 
 import groovy.lang.Closure;
 import groovy.lang.GroovyRuntimeException;
-import org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport;
 
 import java.sql.Timestamp;
 import java.text.DateFormat;
@@ -35,7 +34,7 @@ import java.util.TimeZone;
  * This class defines new groovy methods which appear on normal JDK
  * Date and Calendar classes inside the Groovy environment.
  */
-public class DateUtilExtensions extends DefaultGroovyMethodsSupport {
+public class DateUtilExtensions {
 
     /**
      * Support the subscript operator for a Date.
diff --git a/subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilStaticExtensions.java b/subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilStaticExtensions.java
new file mode 100644
index 0000000000..ddfb1d42fb
--- /dev/null
+++ b/subprojects/groovy-dateutil/src/main/java/org/apache/groovy/dateutil/extensions/DateUtilStaticExtensions.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.groovy.dateutil.extensions;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * This class defines new groovy static methods which appear on normal JDK
+ * Date and Calendar classes inside the Groovy environment.
+ */
+public class DateUtilStaticExtensions {
+    /**
+     * Parse a String into a Date instance using the given pattern.
+     * This convenience method acts as a wrapper for {@link java.text.SimpleDateFormat}.
+     * <p>
+     * Note that a new SimpleDateFormat instance is created for every
+     * invocation of this method (for thread safety).
+     *
+     * @param self   placeholder variable used by Groovy categories; ignored for default static methods
+     * @param format pattern used to parse the input string.
+     * @param input  String to be parsed to create the date instance
+     * @return a new Date instance representing the parsed input string
+     * @throws ParseException if there is a parse error
+     * @see java.text.SimpleDateFormat#parse(java.lang.String)
+     * @since 1.5.7
+     */
+    public static Date parse(Date self, String format, String input) throws ParseException {
+        return new SimpleDateFormat(format).parse(input);
+    }
+
+    /**
+     * Parse a String into a Date instance using the given pattern and TimeZone.
+     * This convenience method acts as a wrapper for {@link java.text.SimpleDateFormat}.
+     * <p>
+     * Note that a new SimpleDateFormat instance is created for every
+     * invocation of this method (for thread safety).
+     *
+     * @param self   placeholder variable used by Groovy categories; ignored for default static methods
+     * @param format pattern used to parse the input string.
+     * @param input  String to be parsed to create the date instance
+     * @param zone   TimeZone to use when parsing
+     * @return a new Date instance representing the parsed input string
+     * @throws ParseException if there is a parse error
+     * @see java.text.SimpleDateFormat#parse(java.lang.String)
+     * @since 2.4.1
+     */
+    public static Date parse(Date self, String format, String input, TimeZone zone) throws ParseException {
+        SimpleDateFormat sdf = new SimpleDateFormat(format);
+        sdf.setTimeZone(zone);
+        return sdf.parse(input);
+    }
+
+    /**
+     * Parse a String matching the pattern EEE MMM dd HH:mm:ss zzz yyyy
+     * containing US-locale-constants only (e.g. Sat for Saturdays).
+     * Such a string is generated by the toString method of {@link java.util.Date}
+     * <p>
+     * Note that a new SimpleDateFormat instance is created for every
+     * invocation of this method (for thread safety).
+     *
+     * @param self          placeholder variable used by Groovy categories; ignored for default static methods
+     * @param dateToString  String to be parsed to create the date instance. Must match the pattern EEE MMM dd HH:mm:ss zzz yyyy with US-locale symbols
+     * @return a new Date instance representing the parsed input string
+     * @throws ParseException if there is a parse error
+     * @since 1.8.4
+     */
+    public static Date parseToStringDate(Date self, String dateToString) throws ParseException {
+        return new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US).parse(dateToString);
+    }
+
+}
diff --git a/subprojects/groovy-dateutil/src/spec/test/gdk/WorkingWithDateUtilTypesTest.groovy b/subprojects/groovy-dateutil/src/spec/test/gdk/WorkingWithDateUtilTypesTest.groovy
index 7599867780..ec60df983a 100644
--- a/subprojects/groovy-dateutil/src/spec/test/gdk/WorkingWithDateUtilTypesTest.groovy
+++ b/subprojects/groovy-dateutil/src/spec/test/gdk/WorkingWithDateUtilTypesTest.groovy
@@ -36,14 +36,17 @@ class WorkingWithDateUtilTypesTest extends GroovyTestCase {
 
     void testDateArithmetic() {
         // tag::date_arithmetic[]
-        def yesterday = new Date() - 1
-        def tomorrow = new Date() + 1
+        def utc = TimeZone.getTimeZone('UTC')
+        Date date = Date.parse("yyyy-MM-dd HH:mm", "2010-05-23 09:01", utc)
 
-        def diffInDays = tomorrow - yesterday
+        def prev = date - 1
+        def next = date + 1
+
+        def diffInDays = next - prev
         assert diffInDays == 2
 
         int count = 0
-        yesterday.upto(tomorrow) { count++ }
+        prev.upto(next) { count++ }
         assert count == 3
         // end::date_arithmetic[]
     }

Commit:
dfefeefa6fdae3701697d95f32572b7ed3c25aec
paulk
paulk@asert.com.au
2018-03-26 10:26:33 +1000
GROOVY-8519: Groovy should provide collect DGM variants for Optional and Future
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java
index 973d8569c4..7a272934fc 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v8/PluginDefaultGroovyMethods.java
@@ -18,12 +18,21 @@
  */
 package org.codehaus.groovy.vmplugin.v8;
 
+import groovy.lang.Closure;
+import groovy.transform.stc.ClosureParams;
+import groovy.transform.stc.FirstParam;
+
 import java.util.Arrays;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.stream.BaseStream;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
@@ -52,6 +61,83 @@ public class PluginDefaultGroovyMethods {
         return optional.isPresent();
     }
 
+    /**
+     * If the optional contains a value, returns an optional containing the transformed value obtained using the <code>transform</code> closure
+     * or otherwise an empty optional.
+     * <pre class="groovyTestCase">
+     * assert Optional.of("foobar").collect{ it.size() }.get() == 6
+     * assert !Optional.empty().collect{ it.size() }.isPresent()
+     * </pre>
+     *
+     * @param self      an Optional
+     * @param transform the closure used to transform the optional value if present
+     * @return an Optional containing the transformed value or empty if the optional is empty or the transform returns null
+     */
+    public static <S,T> Optional<T> collect(Optional<S> self, @ClosureParams(FirstParam.FirstGenericType.class) Closure<T> transform) {
+        Objects.requireNonNull(self);
+        Objects.requireNonNull(transform);
+        if (!self.isPresent()) {
+            return self.empty();
+        }
+        return Optional.ofNullable(transform.call(self.get()));
+    }
+
+    /**
+     * Returns a Future asynchronously returning a transformed result.
+     * <pre class="groovyTestCase">
+     * import java.util.concurrent.*
+     * def executor = Executors.newSingleThreadExecutor()
+     * Future<String> foobar = executor.submit{ "foobar" }
+     * Future<Integer> foobarSize = foobar.collect{ it.size() }
+     * assert foobarSize.get() == 6
+     * executor.shutdown()
+     * </pre>
+     *
+     * @param self      a Future
+     * @param transform the closure used to transform the Future value
+     * @return a Future allowing the transformed value to be obtained asynchronously
+     */
+    public static <S,T> Future<T> collect(Future<S> self, @ClosureParams(FirstParam.FirstGenericType.class) Closure<T> transform) {
+        Objects.requireNonNull(self);
+        Objects.requireNonNull(transform);
+        return new TransformedFuture<T>(self, transform);
+    }
+
+    private static class TransformedFuture<E> implements Future<E> {
+        private Future delegate;
+        private Closure<E> transform;
+
+        private TransformedFuture(Future delegate, Closure<E> transform) {
+            this.delegate = delegate;
+            this.transform = transform;
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return delegate.cancel(mayInterruptIfRunning);
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return delegate.isCancelled();
+        }
+
+        @Override
+        public boolean isDone() {
+            return delegate.isDone();
+        }
+
+        @Override
+        public E get() throws InterruptedException, ExecutionException {
+            return transform.call(delegate.get());
+        }
+
+        @Override
+        public E get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+            return transform.call(delegate.get(timeout, unit));
+        }
+    }
+
     /**
      * Accumulates the elements of stream into a new List.
      * @param stream the Stream

Commit:
82e16156151a0b4e0dd6ae94b616f0aa91290570
sunlan
sunlan@apache.org
2018-03-26 08:22:48 +0800
Fix `addMethod` of `ClassExtender`
diff --git a/src/main/java/org/codehaus/groovy/runtime/ClassExtender.java b/src/main/java/org/codehaus/groovy/runtime/ClassExtender.java
index 6e5d371613..390cf9c010 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ClassExtender.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ClassExtender.java
@@ -74,7 +74,7 @@ public class ClassExtender {
         if (methods == null) {
             methods = createMap();
         }
-        methods.put(name, methods);
+        methods.put(name, closure);
     }
 
     public synchronized void removeMethod(String name) {

Commit:
3190b697f82bb3682a2688f79f3c002b16014a4d
danielsun1106
realbluesun@hotmail.com
2018-03-25 20:01:06 +0800
Fix format issues
diff --git a/gradle/test.gradle b/gradle/test.gradle
index 9870befb70..02628e2c44 100644
--- a/gradle/test.gradle
+++ b/gradle/test.gradle
@@ -19,9 +19,9 @@
 allprojects {
     tasks.withType(Test) {
         if (JavaVersion.current().isJava8Compatible()) {
-            jvmArgs '-ea', "-Xms${groovyJUnit_ms}", "-Xmx${groovyJUnit_mx}", "-XX:+UseConcMarkSweepGC"
+            jvmArgs '-ea', "-Xms${groovyJUnit_ms}", "-Xmx${groovyJUnit_mx}", "-XX:+UseConcMarkSweepGC", "-Duser.language=en"
         } else {
-            jvmArgs '-ea', "-Xms${groovyJUnit_ms}", "-Xmx${groovyJUnit_mx}", "-XX:PermSize=${groovyJUnit_permSize}", "-XX:MaxPermSize=${groovyJUnit_maxPermSize}", "-XX:+UseConcMarkSweepGC"
+            jvmArgs '-ea', "-Xms${groovyJUnit_ms}", "-Xmx${groovyJUnit_mx}", "-XX:PermSize=${groovyJUnit_permSize}", "-XX:MaxPermSize=${groovyJUnit_maxPermSize}", "-XX:+UseConcMarkSweepGC", "-Duser.language=en"
         }
         def headless = System.properties['java.awt.headless']
         if (headless == 'true') {

Commit:
ef0ac1fe50e88a012296c13909e6daf6c03c3dea
danielsun1106
realbluesun@hotmail.com
2018-03-25 19:24:53 +0800
Move java test files to "test" directory
diff --git a/src/test/java/org/apache/groovy/util/MapsTest.java b/src/test/org/apache/groovy/util/MapsTest.java
similarity index 100%
rename from src/test/java/org/apache/groovy/util/MapsTest.java
rename to src/test/org/apache/groovy/util/MapsTest.java
diff --git a/src/test/java/org/apache/groovy/util/concurrentlinkedhashmap/ConcurrentLinkedHashMapTest.java b/src/test/org/apache/groovy/util/concurrentlinkedhashmap/ConcurrentLinkedHashMapTest.java
similarity index 100%
rename from src/test/java/org/apache/groovy/util/concurrentlinkedhashmap/ConcurrentLinkedHashMapTest.java
rename to src/test/org/apache/groovy/util/concurrentlinkedhashmap/ConcurrentLinkedHashMapTest.java
diff --git a/src/test/java/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java b/src/test/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java
similarity index 100%
rename from src/test/java/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java
rename to src/test/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java

Commit:
0f0c96d5a783dee0c2ef2b26ecec440cc1e4b9d4
danielsun1106
realbluesun@hotmail.com
2018-03-25 13:45:03 +0800
Control access to wrapped cache
diff --git a/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java b/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java
index a6aa112650..ad852be772 100644
--- a/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java
+++ b/src/main/java/org/codehaus/groovy/runtime/memoize/ConcurrentCommonCache.java
@@ -216,7 +216,7 @@ public class ConcurrentCommonCache<K, V> implements EvictableCache<K, V>, ValueC
      * deal with the backed cache guarded by write lock
      * @param action the content to complete
      */
-    public <R> R doWithWriteLock(Action<K, V, R> action) {
+    private <R> R doWithWriteLock(Action<K, V, R> action) {
         writeLock.lock();
         try {
             return action.doWith(commonCache);
@@ -229,7 +229,7 @@ public class ConcurrentCommonCache<K, V> implements EvictableCache<K, V>, ValueC
      * deal with the backed cache guarded by read lock
      * @param action the content to complete
      */
-    public <R> R doWithReadLock(Action<K, V, R> action) {
+    private <R> R doWithReadLock(Action<K, V, R> action) {
         readLock.lock();
         try {
             return action.doWith(commonCache);

Commit:
fde8e7c5b719ee245a624e20627c8cc92d0b9a0c
danielsun1106
realbluesun@hotmail.com
2018-03-24 20:00:23 +0800
Rename variable name and refine javadoc
diff --git a/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java
index 1fabef1ed6..273fc41fe6 100644
--- a/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java
@@ -395,6 +395,7 @@ public class EncodingGroovyMethods {
      * @return digested value
      * @throws NoSuchAlgorithmException if the algorithm not found
      * @since 2.5.0
+     * @see MessageDigest#getInstance(java.lang.String)
      */
     public static String digest(CharSequence self, String algorithm) throws NoSuchAlgorithmException {
         final String text = self.toString();
@@ -408,11 +409,12 @@ public class EncodingGroovyMethods {
      * @return digested value
      * @throws NoSuchAlgorithmException if the algorithm not found
      * @since 2.5.0
+     * @see MessageDigest#getInstance(java.lang.String)
      */
     public static String digest(byte[] self, String algorithm) throws NoSuchAlgorithmException {
-        MessageDigest md5 = MessageDigest.getInstance(algorithm);
-        md5.update(ByteBuffer.wrap(self));
+        MessageDigest md = MessageDigest.getInstance(algorithm);
+        md.update(ByteBuffer.wrap(self));
 
-        return String.format("%032x", new BigInteger(1, md5.digest()));
+        return String.format("%032x", new BigInteger(1, md.digest()));
     }
 }

Commit:
ea4165007b1342d2f55331f571e1161962697c89
sunlan
sunlan@apache.org
2018-03-23 19:09:57 +0800
Add DGM `digest`(closes #677)
diff --git a/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java
index 8eb846c847..1fabef1ed6 100644
--- a/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/EncodingGroovyMethods.java
@@ -43,10 +43,9 @@ import static org.codehaus.groovy.runtime.EncodingGroovyMethodsSupport.TRANSLATE
 public class EncodingGroovyMethods {
 
     private static final char[] T_TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".toCharArray();
-
     private static final char[] T_TABLE_URLSAFE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=".toCharArray();
-
     private static final String CHUNK_SEPARATOR = "\r\n";
+    private static final String MD5 = "MD5";
 
     /**
      * Produce a Writable object which writes the Base64 encoding of the byte array.
@@ -373,23 +372,45 @@ public class EncodingGroovyMethods {
     /**
      * Calculate md5 of the CharSequence instance
      * @return md5 value
-     * @throws NoSuchAlgorithmException if no MD5 algorithm found
+     * @throws NoSuchAlgorithmException if MD5 algorithm not found
      * @since 2.5.0
      */
     public static String md5(CharSequence self) throws NoSuchAlgorithmException {
-        final String text = self.toString();
-
-        return md5(text.getBytes(StandardCharsets.UTF_8));
+        return digest(self, MD5);
     }
 
     /**
      * Calculate md5 of the byte array
      * @return md5 value
-     * @throws NoSuchAlgorithmException if no MD5 algorithm found
+     * @throws NoSuchAlgorithmException if MD5 algorithm not found
      * @since 2.5.0
      */
     public static String md5(byte[] self) throws NoSuchAlgorithmException {
-        MessageDigest md5 = MessageDigest.getInstance("MD5");
+        return digest(self, MD5);
+    }
+
+    /**
+     * digest the CharSequence instance
+     * @param algorithm the name of the algorithm requested, e.g. MD5, SHA-1, SHA-256, etc.
+     * @return digested value
+     * @throws NoSuchAlgorithmException if the algorithm not found
+     * @since 2.5.0
+     */
+    public static String digest(CharSequence self, String algorithm) throws NoSuchAlgorithmException {
+        final String text = self.toString();
+
+        return digest(text.getBytes(StandardCharsets.UTF_8), algorithm);
+    }
+
+    /**
+     * digest the byte array
+     * @param algorithm the name of the algorithm requested, e.g. MD5, SHA-1, SHA-256, etc.
+     * @return digested value
+     * @throws NoSuchAlgorithmException if the algorithm not found
+     * @since 2.5.0
+     */
+    public static String digest(byte[] self, String algorithm) throws NoSuchAlgorithmException {
+        MessageDigest md5 = MessageDigest.getInstance(algorithm);
         md5.update(ByteBuffer.wrap(self));
 
         return String.format("%032x", new BigInteger(1, md5.digest()));
diff --git a/src/test/java/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java b/src/test/java/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java
index 4155a4c1f7..20c08973a9 100644
--- a/src/test/java/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java
+++ b/src/test/java/org/codehaus/groovy/runtime/EncodingGroovyMethodsTest.java
@@ -27,4 +27,10 @@ public class EncodingGroovyMethodsTest {
         Assert.assertEquals("e99a18c428cb38d5f260853678922e03", EncodingGroovyMethods.md5("abc123"));
         Assert.assertEquals("e99a18c428cb38d5f260853678922e03", EncodingGroovyMethods.md5("abc123".getBytes("UTF-8")));
     }
+
+    @Test
+    public void digest() throws Exception {
+        Assert.assertEquals("e99a18c428cb38d5f260853678922e03", EncodingGroovyMethods.digest("abc123", "MD5"));
+        Assert.assertEquals("e99a18c428cb38d5f260853678922e03", EncodingGroovyMethods.digest("abc123".getBytes("UTF-8"), "MD5"));
+    }
 }
