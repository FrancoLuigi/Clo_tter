Commit:
f828a38b1a4b6300bd4ddef1d62d42f4909ead63
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2017-03-20 23:38:37 +0000
- Change the number of CNAMEs that the Lookup code will follow,   as the previous limit (6) was not enough for www.paypal.com.   (reported by George Nikolaidis <gnikolaidis@ergobyte.gr>)
diff --git a/Changelog b/Changelog
index 8055b83..ba7858a 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,8 @@
+3/20/2017:
+	- Change the number of CNAMEs that the Lookup code will follow,
+	  as the previous limit (6) was not enough for www.paypal.com.
+	  (reported by George Nikolaidis <gnikolaidis@ergobyte.gr>)
+
 1/3/2017:
 	- 2.1.8 released
 
diff --git a/org/xbill/DNS/Lookup.java b/org/xbill/DNS/Lookup.java
index 8478790..b661f1b 100644
--- a/org/xbill/DNS/Lookup.java
+++ b/org/xbill/DNS/Lookup.java
@@ -400,7 +400,7 @@ follow(Name name, Name oldname) {
 	nxdomain = false;
 	referral = false;
 	iterations++;
-	if (iterations >= 6 || name.equals(oldname)) {
+	if (iterations >= 10 || name.equals(oldname)) {
 		result = UNRECOVERABLE;
 		error = "CNAME loop";
 		done = true;

Commit:
b7f2562da1ee9067baf90334955a753e92010347
Ingo Bauersachs
ingo@jitsi.org
2017-01-07 18:39:50 +0100
Update version number in pom.xml to 2.1.8
diff --git a/pom.xml b/pom.xml
index f692d92..572bbcc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>dnsjava</groupId>
     <artifactId>dnsjava</artifactId>
-    <version>2.1.7</version>
+    <version>2.1.8</version>
     <name>dnsjava</name>
     <description>dnsjava is an implementation of DNS in Java. It supports all defined record types (including the DNSSEC types), and unknown types. It can be used for queries, zone transfers, and dynamic updates. It includes a cache which can be used by clients, and a minimal implementation of a server. It supports TSIG authenticated messages, partial DNSSEC verification, and EDNS0. </description>
     <url>http://www.dnsjava.org</url>
@@ -26,7 +26,7 @@
         <connection>scm:git:https://github.com/dnsjava/dnsjava</connection>
         <developerConnection>scm:git:git@github.com:dnsjava/dnsjava</developerConnection>
         <url>https://github.com/dnsjava/dnsjava</url>
-        <tag>v2.1.6</tag>
+        <tag>v2.1.8</tag>
     </scm>
     <developers>
         <developer>

Commit:
342ee99c50c92a7945aa143cf34f1882047158f5
Ingo Bauersachs
ingo@jitsi.org
2017-01-07 18:39:07 +0100
Add profile to ignore DocLint when building on JDK >= 8
diff --git a/pom.xml b/pom.xml
index e5f2779..f692d92 100644
--- a/pom.xml
+++ b/pom.xml
@@ -179,4 +179,24 @@
         </dependency>
     </dependencies>
 
+    <profiles>
+        <profile>
+            <id>doclint-java8-disable</id>
+            <activation>
+                <jdk>[1.8,)</jdk>
+            </activation>
+
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-javadoc-plugin</artifactId>
+                        <configuration>
+                            <additionalparam>-Xdoclint:none</additionalparam>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
 </project>

Commit:
cb9e0f60ca90edd3466e49b03c6fb3b6ea26df15
Ingo Bauersachs
ingo@jitsi.org
2017-01-07 18:32:48 +0100
Merge branch 'upstream'
Commit:
147cc172875281f3f440d1040b162d60d38ad05b
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2017-01-04 22:15:20 +0000
Update version numbers.
diff --git a/Changelog b/Changelog
index d014550..8055b83 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,6 @@
+1/3/2017:
+	- 2.1.8 released
+
 8/13/2016:
 	- Add a Message constructor taking a ByteBuffer, and convert the
 	  DNSInput class to use a ByteBuffer internally.
diff --git a/Makefile b/Makefile
index b4ee7b4..e5c9d8b 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,7 @@ JAR = jar cf
 SUNAPIDOC = http://java.sun.com/j2se/1.4/docs/api
 JAVADOC=javadoc -classpath . -d doc -windowtitle "dnsjava documentation" -link ${SUNAPIDOC}
 
-VERSION = 2.1.7
+VERSION = 2.1.8
 
 DNSSRC = org/xbill/DNS/*.java \
 	 org/xbill/DNS/utils/*.java
diff --git a/build.xml b/build.xml
index 16a20b6..098c044 100644
--- a/build.xml
+++ b/build.xml
@@ -5,7 +5,7 @@
     <property name="dist_dir" value="${basedir}"/>
     <property name="tests_dir" value="${basedir}/tests"/>
     <property name="reports_dir" value="${basedir}/reports"/>
-    <property name="version" value="2.1.7"/>
+    <property name="version" value="2.1.8"/>
     <property name="jarname" value="dnsjava-${version}.jar"/>
     <property name="zipname" value="dnsjava-${version}.zip"/>
     <property name="targzname" value="dnsjava-${version}.tar.gz"/>

Commit:
e2528668afcc4c4b773ece99773075777e453279
Ingo Bauersachs
ingo@jitsi.org
2016-09-20 20:08:04 +0200
Merge branch 'upstream'
Commit:
849bde970e2349d828147453807898ed761cc2c7
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2016-08-14 17:21:17 +0000
Fix typo.
diff --git a/org/xbill/DNS/OPENPGPKEYRecord.java b/org/xbill/DNS/OPENPGPKEYRecord.java
index 696eda7..359fb67 100644
--- a/org/xbill/DNS/OPENPGPKEYRecord.java
+++ b/org/xbill/DNS/OPENPGPKEYRecord.java
@@ -33,7 +33,7 @@ getObject() {
 public
 OPENPGPKEYRecord(Name name, int dclass, long ttl, byte [] cert)
 {
-	super(name, Type.CERT, dclass, ttl);
+	super(name, Type.OPENPGPKEY, dclass, ttl);
 	this.cert = cert;
 }
 

Commit:
afb7963bdd554628b07542004e649274faa4884d
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2016-08-13 21:12:31 +0000
- Add support for the OPENPGPKEY record.   (patch from Valentin Hauner <vh@hnr.name>) - Add support for the SMIMEA record.
diff --git a/Changelog b/Changelog
index 220af1b..d014550 100644
--- a/Changelog
+++ b/Changelog
@@ -2,6 +2,9 @@
 	- Add a Message constructor taking a ByteBuffer, and convert the
 	  DNSInput class to use a ByteBuffer internally.
 	  (patch from Marrache Mickael <mickoo95@users.sf.net>)
+	- Add support for the OPENPGPKEY record.
+	  (patch from Valentin Hauner <vh@hnr.name>)
+	- Add support for the SMIMEA record.
 
 11/25/2015:
 	- Add support for the CAA record.
diff --git a/org/xbill/DNS/OPENPGPKEYRecord.java b/org/xbill/DNS/OPENPGPKEYRecord.java
new file mode 100644
index 0000000..696eda7
--- /dev/null
+++ b/org/xbill/DNS/OPENPGPKEYRecord.java
@@ -0,0 +1,81 @@
+package org.xbill.DNS;
+
+import java.io.IOException;
+
+import org.xbill.DNS.utils.base64;
+
+/**
+ * OPENPGPKEY Record - Stores an OpenPGP certificate associated with a name.
+ * RFC 7929.
+ * 
+ * @author Brian Wellington
+ * @author Valentin Hauner
+ *
+ */
+public class OPENPGPKEYRecord extends Record {
+
+private static final long serialVersionUID = -1277262990243423062L;
+
+private byte [] cert;
+
+OPENPGPKEYRecord() {}
+
+Record
+getObject() {
+	return new OPENPGPKEYRecord();
+}
+
+/**
+ * Creates an OPENPGPKEY Record from the given data
+ * 
+ * @param cert Binary data representing the certificate
+ */
+public
+OPENPGPKEYRecord(Name name, int dclass, long ttl, byte [] cert)
+{
+	super(name, Type.CERT, dclass, ttl);
+	this.cert = cert;
+}
+
+void
+rrFromWire(DNSInput in) throws IOException {
+	cert = in.readByteArray();
+}
+
+void
+rdataFromString(Tokenizer st, Name origin) throws IOException {
+	cert = st.getBase64();
+}
+
+/**
+ * Converts rdata to a String
+ */
+String
+rrToString() {
+	StringBuffer sb = new StringBuffer();
+	if (cert != null) {
+		if (Options.check("multiline")) {
+			sb.append("(\n");
+			sb.append(base64.formatString(cert, 64, "\t", true));
+		} else {
+			sb.append(base64.toString(cert));
+		}
+	}
+	return sb.toString();
+}
+
+/**
+ * Returns the binary representation of the certificate
+ */
+public byte []
+getCert()
+{
+	return cert;
+}
+
+void
+rrToWire(DNSOutput out, Compression c, boolean canonical) {
+	out.writeByteArray(cert);
+}
+
+}
diff --git a/org/xbill/DNS/SMIMEARecord.java b/org/xbill/DNS/SMIMEARecord.java
new file mode 100644
index 0000000..09132c2
--- /dev/null
+++ b/org/xbill/DNS/SMIMEARecord.java
@@ -0,0 +1,158 @@
+// Copyright (c) 1999-2004 Brian Wellington (bwelling@xbill.org)
+
+package org.xbill.DNS;
+
+import java.io.*;
+import org.xbill.DNS.utils.*;
+
+/**
+ * S/MIME cert association, draft-ietf-dane-smime.
+ *
+ * @author Brian Wellington
+ */
+
+public class SMIMEARecord extends Record {
+
+private static final long serialVersionUID = 1640247915216425235L;
+
+// Note; these are copied from the TLSA type.
+
+public static class CertificateUsage {
+	private CertificateUsage() {}
+
+	public static final int CA_CONSTRAINT = 0;
+	public static final int SERVICE_CERTIFICATE_CONSTRAINT = 1;
+	public static final int TRUST_ANCHOR_ASSERTION = 2;
+	public static final int DOMAIN_ISSUED_CERTIFICATE = 3;
+}
+
+public static class Selector {
+	private Selector() {}
+
+	/**
+	 * Full certificate; the Certificate binary structure defined in
+	 * [RFC5280]
+	 */
+	public static final int FULL_CERTIFICATE = 0;
+
+	/**
+	 * SubjectPublicKeyInfo; DER-encoded binary structure defined in
+	 * [RFC5280]
+	 */
+	public static final int SUBJECT_PUBLIC_KEY_INFO = 1;
+}
+
+public static class MatchingType {
+	private MatchingType() {}
+
+	/** Exact match on selected content */
+	public static final int EXACT = 0;
+
+	/** SHA-256 hash of selected content [RFC6234] */
+	public static final int SHA256 = 1;
+
+	/** SHA-512 hash of selected content [RFC6234] */
+	public static final int SHA512 = 2;
+}
+
+private int certificateUsage;
+private int selector;
+private int matchingType;
+private byte [] certificateAssociationData;
+
+SMIMEARecord() {}
+
+Record
+getObject() {
+	return new SMIMEARecord();
+}
+
+/**
+ * Creates an SMIMEA Record from the given data
+ * @param certificateUsage The provided association that will be used to
+ * match the certificate presented in the S/MIME handshake. 
+ * @param selector The part of the S/MIME certificate presented by the server
+ * that will be matched against the association data. 
+ * @param matchingType How the certificate association is presented.
+ * @param certificateAssociationData The "certificate association data" to be
+ * matched.
+ */
+public
+SMIMEARecord(Name name, int dclass, long ttl, 
+	     int certificateUsage, int selector, int matchingType,
+	     byte [] certificateAssociationData)
+{
+	super(name, Type.SMIMEA, dclass, ttl);
+	this.certificateUsage = checkU8("certificateUsage", certificateUsage);
+	this.selector = checkU8("selector", selector);
+	this.matchingType = checkU8("matchingType", matchingType);
+	this.certificateAssociationData = checkByteArrayLength(
+						"certificateAssociationData",
+						certificateAssociationData,
+						0xFFFF);
+}
+
+void
+rrFromWire(DNSInput in) throws IOException {
+	certificateUsage = in.readU8();
+	selector = in.readU8();
+	matchingType = in.readU8();
+	certificateAssociationData = in.readByteArray();
+}
+
+void
+rdataFromString(Tokenizer st, Name origin) throws IOException {
+	certificateUsage = st.getUInt8();
+	selector = st.getUInt8();
+	matchingType = st.getUInt8();
+	certificateAssociationData = st.getHex();
+}
+
+/** Converts rdata to a String */
+String
+rrToString() {
+	StringBuffer sb = new StringBuffer();
+	sb.append(certificateUsage);
+	sb.append(" ");
+	sb.append(selector);
+	sb.append(" ");
+	sb.append(matchingType);
+	sb.append(" ");
+	sb.append(base16.toString(certificateAssociationData));
+
+	return sb.toString();
+}
+
+void
+rrToWire(DNSOutput out, Compression c, boolean canonical) {
+	out.writeU8(certificateUsage);
+	out.writeU8(selector);
+	out.writeU8(matchingType);
+	out.writeByteArray(certificateAssociationData);
+}
+
+/** Returns the certificate usage of the SMIMEA record */
+public int
+getCertificateUsage() {
+	return certificateUsage;
+}
+
+/** Returns the selector of the SMIMEA record */
+public int
+getSelector() {
+	return selector;
+}
+
+/** Returns the matching type of the SMIMEA record */
+public int
+getMatchingType() {
+	return matchingType;
+}
+
+/** Returns the certificate associate data of this SMIMEA record */
+public final byte []
+getCertificateAssociationData() {
+	return certificateAssociationData;
+}
+
+}
diff --git a/org/xbill/DNS/Type.java b/org/xbill/DNS/Type.java
index 4d040ba..cadf35a 100644
--- a/org/xbill/DNS/Type.java
+++ b/org/xbill/DNS/Type.java
@@ -165,6 +165,12 @@ public static final int NSEC3PARAM	= 51;
 /** Transport Layer Security Authentication, draft-ietf-dane-protocol-23 */
 public static final int TLSA		= 52;
 
+/** S/MIME cert association, draft-ietf-dane-smime */
+public static final int SMIMEA		= 53;
+
+/** OpenPGP Key, RFC 7929 */
+public static final int OPENPGPKEY	= 61;
+
 /** Sender Policy Framework (experimental) */
 public static final int SPF		= 99;
 
@@ -283,6 +289,8 @@ static {
 	types.add(NSEC3, "NSEC3", new NSEC3Record());
 	types.add(NSEC3PARAM, "NSEC3PARAM", new NSEC3PARAMRecord());
 	types.add(TLSA, "TLSA", new TLSARecord());
+	types.add(SMIMEA, "SMIMEA", new SMIMEARecord());
+	types.add(OPENPGPKEY, "OPENPGPKEY", new OPENPGPKEYRecord());
 	types.add(SPF, "SPF", new SPFRecord());
 	types.add(TKEY, "TKEY", new TKEYRecord());
 	types.add(TSIG, "TSIG", new TSIGRecord());

Commit:
3a19f808cc607e5325d12e7572de826dd582a5e5
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2016-08-13 20:57:57 +0000
- Add a Message constructor taking a ByteBuffer, and convert the   DNSInput class to use a ByteBuffer internally.   (patch from Marrache Mickael <mickoo95@users.sf.net>)
diff --git a/Changelog b/Changelog
index be734e2..220af1b 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,8 @@
+8/13/2016:
+	- Add a Message constructor taking a ByteBuffer, and convert the
+	  DNSInput class to use a ByteBuffer internally.
+	  (patch from Marrache Mickael <mickoo95@users.sf.net>)
+
 11/25/2015:
 	- Add support for the CAA record.
 
diff --git a/org/xbill/DNS/DNSInput.java b/org/xbill/DNS/DNSInput.java
index d3134ed..cd66d74 100644
--- a/org/xbill/DNS/DNSInput.java
+++ b/org/xbill/DNS/DNSInput.java
@@ -2,6 +2,8 @@
 
 package org.xbill.DNS;
 
+import java.nio.ByteBuffer;
+
 /**
  * An class for parsing DNS messages.
  *
@@ -10,9 +12,7 @@ package org.xbill.DNS;
 
 public class DNSInput {
 
-private byte [] array;
-private int pos;
-private int end;
+private ByteBuffer byteBuffer;
 private int saved_pos;
 private int saved_end;
 
@@ -22,9 +22,18 @@ private int saved_end;
  */
 public
 DNSInput(byte [] input) {
-	array = input;
-	pos = 0;
-	end = array.length;
+	byteBuffer = ByteBuffer.wrap(input);
+	saved_pos = -1;
+	saved_end = -1;
+}
+
+/**
+ * Creates a new DNSInput from the given {@link ByteBuffer}
+ * @param byteBuffer The ByteBuffer
+ */
+public
+DNSInput(ByteBuffer byteBuffer) {
+	this.byteBuffer = byteBuffer;
 	saved_pos = -1;
 	saved_end = -1;
 }
@@ -34,7 +43,7 @@ DNSInput(byte [] input) {
  */
 public int
 current() {
-	return pos;
+	return byteBuffer.position();
 }
 
 /**
@@ -43,7 +52,7 @@ current() {
  */
 public int
 remaining() {
-	return end - pos;
+	return byteBuffer.remaining();
 }
 
 private void
@@ -61,11 +70,11 @@ require(int n) throws WireParseException{
  */
 public void
 setActive(int len) {
-	if (len > array.length - pos) {
+	if (len > byteBuffer.capacity() - byteBuffer.position()) {
 		throw new IllegalArgumentException("cannot set active " +
 						   "region past end of input");
 	}
-	end = pos + len;
+	byteBuffer.limit(byteBuffer.position() + len);
 }
 
 /**
@@ -74,7 +83,7 @@ setActive(int len) {
  */
 public void
 clearActive() {
-	end = array.length;
+	byteBuffer.limit(byteBuffer.capacity());
 }
 
 /**
@@ -82,7 +91,7 @@ clearActive() {
  */
 public int
 saveActive() {
-	return end;
+	return byteBuffer.limit();
 }
 
 /**
@@ -93,11 +102,11 @@ saveActive() {
  */
 public void
 restoreActive(int pos) {
-	if (pos > array.length) {
+	if (pos > byteBuffer.capacity()) {
 		throw new IllegalArgumentException("cannot set active " +
 						   "region past end of input");
 	}
-	end = pos;
+	byteBuffer.limit(byteBuffer.position());
 }
 
 /**
@@ -108,12 +117,12 @@ restoreActive(int pos) {
  */
 public void
 jump(int index) {
-	if (index >= array.length) {
+	if (index >= byteBuffer.capacity()) {
 		throw new IllegalArgumentException("cannot jump past " +
 						   "end of input");
 	}
-	pos = index;
-	end = array.length;
+	byteBuffer.position(index);
+	byteBuffer.limit(byteBuffer.capacity());
 }
 
 /**
@@ -123,8 +132,8 @@ jump(int index) {
  */
 public void
 save() {
-	saved_pos = pos;
-	saved_end = end;
+	saved_pos = byteBuffer.position();
+	saved_end = byteBuffer.limit();
 }
 
 /**
@@ -135,8 +144,8 @@ restore() {
 	if (saved_pos < 0) {
 		throw new IllegalStateException("no previous state");
 	}
-	pos = saved_pos;
-	end = saved_end;
+	byteBuffer.position(saved_pos);
+	byteBuffer.limit(saved_end);
 	saved_pos = -1;
 	saved_end = -1;
 }
@@ -149,7 +158,7 @@ restore() {
 public int
 readU8() throws WireParseException {
 	require(1);
-	return (array[pos++] & 0xFF);
+	return (byteBuffer.get() & 0xFF);
 }
 
 /**
@@ -160,9 +169,7 @@ readU8() throws WireParseException {
 public int
 readU16() throws WireParseException {
 	require(2);
-	int b1 = array[pos++] & 0xFF;
-	int b2 = array[pos++] & 0xFF;
-	return ((b1 << 8) + b2);
+	return (byteBuffer.getShort() & 0xFFFF);
 }
 
 /**
@@ -173,11 +180,7 @@ readU16() throws WireParseException {
 public long
 readU32() throws WireParseException {
 	require(4);
-	int b1 = array[pos++] & 0xFF;
-	int b2 = array[pos++] & 0xFF;
-	int b3 = array[pos++] & 0xFF;
-	int b4 = array[pos++] & 0xFF;
-	return (((long)b1 << 24) + (b2 << 16) + (b3 << 8) + b4);
+	return (byteBuffer.getInt() & 0xFFFFFFFFL);
 }
 
 /**
@@ -191,8 +194,7 @@ readU32() throws WireParseException {
 public void
 readByteArray(byte [] b, int off, int len) throws WireParseException {
 	require(len);
-	System.arraycopy(array, pos, b, off, len);
-	pos += len;
+	byteBuffer.get(b, off, len);
 }
 
 /**
@@ -204,8 +206,7 @@ public byte []
 readByteArray(int len) throws WireParseException {
 	require(len);
 	byte [] out = new byte[len];
-	System.arraycopy(array, pos, out, 0, len);
-	pos += len;
+	byteBuffer.get(out, 0, len);
 	return out;
 }
 
@@ -218,8 +219,7 @@ public byte []
 readByteArray() {
 	int len = remaining();
 	byte [] out = new byte[len];
-	System.arraycopy(array, pos, out, 0, len);
-	pos += len;
+	byteBuffer.get(out, 0, len);
 	return out;
 }
 
@@ -231,8 +231,7 @@ readByteArray() {
  */
 public byte []
 readCountedString() throws WireParseException {
-	require(1);
-	int len = array[pos++] & 0xFF;
+	int len = readU8();
 	return readByteArray(len);
 }
 
diff --git a/org/xbill/DNS/Message.java b/org/xbill/DNS/Message.java
index 879b68f..8d1d5ae 100644
--- a/org/xbill/DNS/Message.java
+++ b/org/xbill/DNS/Message.java
@@ -4,6 +4,7 @@ package org.xbill.DNS;
 
 import java.util.*;
 import java.io.*;
+import java.nio.ByteBuffer;
 
 /**
  * A DNS Message.  A message is the basic unit of communication between
@@ -135,6 +136,15 @@ Message(byte [] b) throws IOException {
 	this(new DNSInput(b));
 }
 
+/**
+ * Creates a new Message from its DNS wire format representation
+ * @param byteBuffer A ByteBuffer containing the DNS Message.
+ */
+public
+Message(ByteBuffer byteBuffer) throws IOException {
+    this(new DNSInput(byteBuffer));
+}
+
 /**
  * Replaces the Header with a new one.
  * @see Header

Commit:
1cf07d3d440ab3a065004a6fd57956820404a175
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2016-08-13 20:55:18 +0000
Update tests to remove reference to nonexistent host.
diff --git a/tests/org/xbill/DNS/AddressTest.java b/tests/org/xbill/DNS/AddressTest.java
index 323463d..83af801 100644
--- a/tests/org/xbill/DNS/AddressTest.java
+++ b/tests/org/xbill/DNS/AddressTest.java
@@ -275,9 +275,8 @@ public class AddressTest extends TestCase
 	InetAddress out = Address.getByName("128.145.198.231");
 	assertEquals("128.145.198.231", out.getHostAddress());
 
-	out = Address.getByName("serl.cs.colorado.edu");
-	assertEquals("epic.cs.colorado.edu", out.getCanonicalHostName());
-	assertEquals("128.138.72.229", out.getHostAddress());
+	out = Address.getByName("a.root-servers.net");
+	assertEquals("198.41.0.4", out.getHostAddress());
     }
 
     public void test_getByName_invalid() throws UnknownHostException
@@ -302,10 +301,10 @@ public class AddressTest extends TestCase
 	assertEquals(1, out.length);
 	assertEquals("128.145.198.231", out[0].getHostAddress());
 
-	out = Address.getAllByName("serl.cs.colorado.edu");
-	assertEquals(1, out.length);
-	assertEquals("epic.cs.colorado.edu", out[0].getCanonicalHostName());
-	assertEquals("128.138.72.229", out[0].getHostAddress());
+	out = Address.getAllByName("a.root-servers.net");
+	assertTrue(out.length == 2);
+	assertEquals("198.41.0.4", out[0].getHostAddress());
+	assertEquals("2001:503:ba3e:0:0:0:2:30", out[1].getHostAddress());
 
 	out = Address.getAllByName("cnn.com");
 	assertTrue(out.length > 1);
@@ -344,8 +343,8 @@ public class AddressTest extends TestCase
 
     public void test_getHostName() throws UnknownHostException
     {
-	String out = Address.getHostName(InetAddress.getByName("128.138.207.163"));
-	assertEquals("www-serl.cs.colorado.edu.", out);
+	String out = Address.getHostName(InetAddress.getByName("198.41.0.4"));
+	assertEquals("a.root-servers.net.", out);
 
 	try {
 	    Address.getHostName(InetAddress.getByName("192.168.1.1"));

Commit:
d94a3db3f028d4fb00706d8d646ea48782a026b7
Ingo Bauersachs
ingo@jitsi.org
2016-05-14 15:32:46 +0200
Merge branch 'upstream'
Commit:
1cb41ff574f7d5a488a43ab13a5e41d1e3688992
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2015-11-26 01:31:54 +0000
Add support for the CAA record.
diff --git a/Changelog b/Changelog
index 0bacd43..be734e2 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,6 @@
+11/25/2015:
+	- Add support for the CAA record.
+
 8/21/2015:
 	- Convert the TSIG code from using a custom HMAC implementation to
 	  the one in javax.crypto.Mac.
diff --git a/org/xbill/DNS/CAARecord.java b/org/xbill/DNS/CAARecord.java
new file mode 100644
index 0000000..d5553ec
--- /dev/null
+++ b/org/xbill/DNS/CAARecord.java
@@ -0,0 +1,110 @@
+// Copyright (c) 2004 Brian Wellington (bwelling@xbill.org)
+
+package org.xbill.DNS;
+
+import java.io.*;
+import org.xbill.DNS.utils.*;
+
+/**
+ * Certification Authority Authorization
+ *
+ * @author Brian Wellington
+ */
+
+public class CAARecord extends Record {
+
+private static final long serialVersionUID = 8544304287274216443L;
+
+public static class Flags {
+	private Flags() {}
+
+	public static final int IssuerCritical = 128;
+}
+
+private int flags;
+private byte [] tag;
+private byte [] value;
+
+CAARecord() {} 
+
+Record
+getObject() {
+	return new CAARecord();
+}
+
+/**
+ * Creates an CAA Record from the given data.
+ * @param flags The flags.
+ * @param tag The tag.
+ * @param value The value.
+ */
+public
+CAARecord(Name name, int dclass, long ttl, int flags, String tag, String value)
+{
+	super(name, Type.CAA, dclass, ttl);
+	this.flags = checkU8("flags", flags);
+	try {
+		this.tag = byteArrayFromString(tag);
+		this.value = byteArrayFromString(value);
+	}
+	catch (TextParseException e) {
+		throw new IllegalArgumentException(e.getMessage());
+	}
+}
+
+void
+rrFromWire(DNSInput in) throws IOException {
+	flags = in.readU8();
+	tag = in.readCountedString();
+	value = in.readByteArray();
+}
+
+void
+rdataFromString(Tokenizer st, Name origin) throws IOException {
+	flags = st.getUInt8();
+	try {
+		tag = byteArrayFromString(st.getString());
+		value = byteArrayFromString(st.getString());
+	}
+	catch (TextParseException e) {
+		throw st.exception(e.getMessage());
+	}
+}
+
+String
+rrToString() {
+	StringBuffer sb = new StringBuffer();
+	sb.append(flags);
+	sb.append(" ");
+	sb.append(byteArrayToString(tag, false));
+	sb.append(" ");
+	sb.append(byteArrayToString(value, true));
+	return sb.toString();
+}
+
+/** Returns the flags. */
+public int
+getFlags() {
+	return flags;
+}
+
+/** Returns the tag. */
+public String
+getTag() {
+	return byteArrayToString(tag, false);
+}
+
+/** Returns the value */
+public String
+getValue() {
+	return byteArrayToString(value, false);
+}
+
+void
+rrToWire(DNSOutput out, Compression c, boolean canonical) {
+	out.writeU8(flags);
+	out.writeCountedString(tag);
+	out.writeByteArray(value);
+}
+
+}
diff --git a/org/xbill/DNS/Type.java b/org/xbill/DNS/Type.java
index 2184134..4d040ba 100644
--- a/org/xbill/DNS/Type.java
+++ b/org/xbill/DNS/Type.java
@@ -194,6 +194,9 @@ public static final int ANY		= 255;
  */
 public static final int URI		= 256;
 
+/** Certification Authority Authorization, RFC 6844 */
+public static final int CAA		= 257;
+
 /** DNSSEC Lookaside Validation, RFC 4431 . */
 public static final int DLV		= 32769;
 
@@ -289,6 +292,7 @@ static {
 	types.add(MAILA, "MAILA");
 	types.add(ANY, "ANY");
 	types.add(URI, "URI", new URIRecord());
+	types.add(CAA, "CAA", new CAARecord());
 	types.add(DLV, "DLV", new DLVRecord());
 }
 

Commit:
2a0d35dcd7b9a45543bdbef86895acbbeabb8b32
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2015-08-21 22:21:02 +0000
Add back some javadoc comments which were removed, and fix some style and duplicated code issues.
diff --git a/org/xbill/DNS/TSIG.java b/org/xbill/DNS/TSIG.java
index 4d88fab..5551003 100644
--- a/org/xbill/DNS/TSIG.java
+++ b/org/xbill/DNS/TSIG.java
@@ -19,13 +19,30 @@ import org.xbill.DNS.utils.base64;
 
 public class TSIG {
 
-// Backwards compatible constants for the HMAC algorithm selectors
-public static final Name HMAC_MD5 = Name.fromConstantString("HMAC-MD5.SIG-ALG.REG.INT.");
+/** The domain name representing the HMAC-MD5 algorithm. */
+public static final Name HMAC_MD5 =
+	Name.fromConstantString("HMAC-MD5.SIG-ALG.REG.INT.");
+
+/** The domain name representing the HMAC-MD5 algorithm (deprecated). */
 public static final Name HMAC = HMAC_MD5;
+
+/** The domain name representing the HMAC-SHA1 algorithm. */
 public static final Name HMAC_SHA1 = Name.fromConstantString("hmac-sha1.");
+
+/**
+ * The domain name representing the HMAC-SHA224 algorithm.
+ * Note that SHA224 is not supported by Java out-of-the-box, this requires use
+ * of a third party provider like BouncyCastle.org.
+ */
 public static final Name HMAC_SHA224 = Name.fromConstantString("hmac-sha224.");
+
+/** The domain name representing the HMAC-SHA256 algorithm. */
 public static final Name HMAC_SHA256 = Name.fromConstantString("hmac-sha256.");
+
+/** The domain name representing the HMAC-SHA384 algorithm. */
 public static final Name HMAC_SHA384 = Name.fromConstantString("hmac-sha384.");
+
+/** The domain name representing the HMAC-SHA512 algorithm. */
 public static final Name HMAC_SHA512 = Name.fromConstantString("hmac-sha512.");
 
 private static Map algMap;
@@ -100,6 +117,19 @@ verify(Mac mac, byte [] signature, boolean truncation_ok) {
         return Arrays.equals(signature, expected);
 }
 
+private void
+init_hmac(String macAlgorithm, SecretKey key) {
+	try {
+		hmac = Mac.getInstance(macAlgorithm);
+		hmac.init(key);
+	}
+	catch (GeneralSecurityException ex) {
+		throw new IllegalArgumentException("Caught security " +
+						   "exception setting up " +
+						   "HMAC.");
+	}
+}
+
 /**
  * Creates a new TSIG key, which can be used to sign or verify a message.
  * @param algorithm The algorithm of the shared key.
@@ -112,13 +142,7 @@ TSIG(Name algorithm, Name name, byte [] keyBytes) {
 	this.alg = algorithm;
 	String macAlgorithm = nameToAlgorithm(algorithm);
 	SecretKey key = new SecretKeySpec(keyBytes, macAlgorithm);
-	try {
-		this.hmac = Mac.getInstance(macAlgorithm);
-		this.hmac.init(key);
-	}
-	catch(GeneralSecurityException ex) {
-		throw new IllegalArgumentException("Caught security exception setting up HMAC.");
-	}
+	init_hmac(macAlgorithm, key);
 }
 
 /**
@@ -132,13 +156,7 @@ TSIG(Name algorithm, Name name, SecretKey key) {
 	this.name = name;
 	this.alg = algorithm;
 	String macAlgorithm = nameToAlgorithm(algorithm);
-	try {
-		this.hmac = Mac.getInstance(macAlgorithm);
-		this.hmac.init(key);
-	}
-	catch(GeneralSecurityException ex) {
-		throw new IllegalArgumentException("Caught security exception setting up HMAC.");
-	}
+	init_hmac(macAlgorithm, key);
 }
 
 /**
@@ -186,13 +204,7 @@ TSIG(Name algorithm, String name, String key) {
 	}
 	this.alg = algorithm;
 	String macAlgorithm = nameToAlgorithm(this.alg);
-	try {
-		this.hmac = Mac.getInstance(macAlgorithm);
-		this.hmac.init(new SecretKeySpec(keyBytes, macAlgorithm));
-	}
-	catch(GeneralSecurityException ex) {
-		throw new IllegalArgumentException("Caught security exception setting up HMAC.");
-	}
+	init_hmac(macAlgorithm, new SecretKeySpec(keyBytes, macAlgorithm));
 }
 
 /**
@@ -474,7 +486,11 @@ verify(Message m, byte [] b, int length, TSIGRecord old) {
 
 	byte [] signature = tsig.getSignature();
 	int digestLength = hmac.getMacLength();
-	int minDigestLength = hmac.getAlgorithm().toLowerCase().contains("md5") ? 10 : digestLength / 2;
+	int minDigestLength;
+	if (hmac.getAlgorithm().toLowerCase().contains("md5"))
+		minDigestLength = 10;
+	else
+		minDigestLength = digestLength / 2;
 
 	if (signature.length > digestLength) {
 		if (Options.check("verbose"))

Commit:
712e142cc6c8a08d115401eb6f843444e64f4100
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2015-08-21 22:10:45 +0000
- Convert the TSIG code from using a custom HMAC implementation to   the one in javax.crypto.Mac.   (patch from Nick Sayer <nsayer@silverspringnet.com>)
diff --git a/Changelog b/Changelog
index 5ac2973..0bacd43 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,8 @@
+8/21/2015:
+	- Convert the TSIG code from using a custom HMAC implementation to
+	  the one in javax.crypto.Mac.
+	  (patch from Nick Sayer <nsayer@silverspringnet.com>)
+
 4/21/2015:
 	- Update the URI record implementation to match the latest spec.
 	  (patch from Anthony Kirby <anthonykirby@users.sf.net>)
diff --git a/org/xbill/DNS/TSIG.java b/org/xbill/DNS/TSIG.java
index d9e6972..4d88fab 100644
--- a/org/xbill/DNS/TSIG.java
+++ b/org/xbill/DNS/TSIG.java
@@ -3,7 +3,11 @@
 package org.xbill.DNS;
 
 import java.util.*;
-import org.xbill.DNS.utils.*;
+import java.security.GeneralSecurityException;
+import javax.crypto.spec.SecretKeySpec;
+import javax.crypto.SecretKey;
+import javax.crypto.Mac;
+import org.xbill.DNS.utils.base64;
 
 /**
  * Transaction signature handling.  This class generates and verifies
@@ -15,37 +19,47 @@ import org.xbill.DNS.utils.*;
 
 public class TSIG {
 
-private static final String HMAC_MD5_STR = "HMAC-MD5.SIG-ALG.REG.INT.";
-private static final String HMAC_SHA1_STR = "hmac-sha1.";
-private static final String HMAC_SHA224_STR = "hmac-sha224.";
-private static final String HMAC_SHA256_STR = "hmac-sha256.";
-private static final String HMAC_SHA384_STR = "hmac-sha384.";
-private static final String HMAC_SHA512_STR = "hmac-sha512.";
-
-/** The domain name representing the HMAC-MD5 algorithm. */
-public static final Name HMAC_MD5 = Name.fromConstantString(HMAC_MD5_STR);
-
-/** The domain name representing the HMAC-MD5 algorithm (deprecated). */
+// Backwards compatible constants for the HMAC algorithm selectors
+public static final Name HMAC_MD5 = Name.fromConstantString("HMAC-MD5.SIG-ALG.REG.INT.");
 public static final Name HMAC = HMAC_MD5;
+public static final Name HMAC_SHA1 = Name.fromConstantString("hmac-sha1.");
+public static final Name HMAC_SHA224 = Name.fromConstantString("hmac-sha224.");
+public static final Name HMAC_SHA256 = Name.fromConstantString("hmac-sha256.");
+public static final Name HMAC_SHA384 = Name.fromConstantString("hmac-sha384.");
+public static final Name HMAC_SHA512 = Name.fromConstantString("hmac-sha512.");
+
+private static Map algMap;
+
+static {
+	Map out = new HashMap();
+	out.put(HMAC_MD5, "HmacMD5");
+	out.put(HMAC_SHA1, "HmacSHA1");
+	out.put(HMAC_SHA224, "HmacSHA224");
+	out.put(HMAC_SHA256, "HmacSHA256");
+	out.put(HMAC_SHA384, "HmacSHA384");
+	out.put(HMAC_SHA512, "HmacSHA512");
+	algMap = Collections.unmodifiableMap(out);
+}
 
-/** The domain name representing the HMAC-SHA1 algorithm. */
-public static final Name HMAC_SHA1 = Name.fromConstantString(HMAC_SHA1_STR);
-
-/**
- * The domain name representing the HMAC-SHA224 algorithm.
- * Note that SHA224 is not supported by Java out-of-the-box, this requires use
- * of a third party provider like BouncyCastle.org.
- */
-public static final Name HMAC_SHA224 = Name.fromConstantString(HMAC_SHA224_STR);
-
-/** The domain name representing the HMAC-SHA256 algorithm. */
-public static final Name HMAC_SHA256 = Name.fromConstantString(HMAC_SHA256_STR);
-
-/** The domain name representing the HMAC-SHA384 algorithm. */
-public static final Name HMAC_SHA384 = Name.fromConstantString(HMAC_SHA384_STR);
-
-/** The domain name representing the HMAC-SHA512 algorithm. */
-public static final Name HMAC_SHA512 = Name.fromConstantString(HMAC_SHA512_STR);
+public static Name
+algorithmToName(String alg)
+{
+	Iterator it = algMap.entrySet().iterator();
+	while (it.hasNext()) {
+		Map.Entry entry = (Map.Entry) it.next();
+		if (alg.equalsIgnoreCase((String)entry.getValue()))
+			return (Name) entry.getKey();
+	}
+	throw new IllegalArgumentException("Unknown algorithm");
+}
+public static String
+nameToAlgorithm(Name name)
+{
+	String alg = (String) algMap.get(name);
+	if (alg != null)
+		return alg;
+	throw new IllegalArgumentException("Unknown algorithm");
+}
 
 /**
  * The default fudge value for outgoing packets.  Can be overriden by the
@@ -54,32 +68,36 @@ public static final Name HMAC_SHA512 = Name.fromConstantString(HMAC_SHA512_STR);
 public static final short FUDGE		= 300;
 
 private Name name, alg;
-private String digest;
-private int digestBlockLength;
-private byte [] key;
-
-private void
-getDigest() {
-	if (alg.equals(HMAC_MD5)) {
-		digest = "md5";
-		digestBlockLength = 64;
-	} else if (alg.equals(HMAC_SHA1)) {
-		digest = "sha-1";
-		digestBlockLength = 64;
-	} else if (alg.equals(HMAC_SHA224)) {
-		digest = "sha-224";
-		digestBlockLength = 64;
-	} else if (alg.equals(HMAC_SHA256)) {
-		digest = "sha-256";
-		digestBlockLength = 64;
-	} else if (alg.equals(HMAC_SHA512)) {
-		digest = "sha-512";
-		digestBlockLength = 128;
-	} else if (alg.equals(HMAC_SHA384)) {
-		digest = "sha-384";
-		digestBlockLength = 128;
-	} else
-		throw new IllegalArgumentException("Invalid algorithm");
+private Mac hmac;
+
+/**
+ * Verifies the data (computes the secure hash and compares it to the input)
+ * @param mac The HMAC generator
+ * @param signature The signature to compare against
+ * @return true if the signature matches, false otherwise
+ */
+private static boolean
+verify(Mac mac, byte [] signature) {
+        return verify(mac, signature, false);
+}
+
+/**
+ * Verifies the data (computes the secure hash and compares it to the input)
+ * @param mac The HMAC generator
+ * @param signature The signature to compare against
+ * @param truncation_ok If true, the signature may be truncated; only the
+ * number of bytes in the provided signature are compared.
+ * @return true if the signature matches, false otherwise
+ */
+private static boolean
+verify(Mac mac, byte [] signature, boolean truncation_ok) {
+        byte [] expected = mac.doFinal();
+        if (truncation_ok && signature.length < expected.length) {
+                byte [] truncated = new byte[signature.length];
+                System.arraycopy(expected, 0, truncated, 0, truncated.length);
+                expected = truncated;
+        }
+        return Arrays.equals(signature, expected);
 }
 
 /**
@@ -89,11 +107,52 @@ getDigest() {
  * @param key The shared key's data.
  */
 public
-TSIG(Name algorithm, Name name, byte [] key) {
+TSIG(Name algorithm, Name name, byte [] keyBytes) {
 	this.name = name;
 	this.alg = algorithm;
-	this.key = key;
-	getDigest();
+	String macAlgorithm = nameToAlgorithm(algorithm);
+	SecretKey key = new SecretKeySpec(keyBytes, macAlgorithm);
+	try {
+		this.hmac = Mac.getInstance(macAlgorithm);
+		this.hmac.init(key);
+	}
+	catch(GeneralSecurityException ex) {
+		throw new IllegalArgumentException("Caught security exception setting up HMAC.");
+	}
+}
+
+/**
+ * Creates a new TSIG key, which can be used to sign or verify a message.
+ * @param algorithm The algorithm of the shared key.
+ * @param name The name of the shared key.
+ * @param key The shared key.
+ */
+public
+TSIG(Name algorithm, Name name, SecretKey key) {
+	this.name = name;
+	this.alg = algorithm;
+	String macAlgorithm = nameToAlgorithm(algorithm);
+	try {
+		this.hmac = Mac.getInstance(macAlgorithm);
+		this.hmac.init(key);
+	}
+	catch(GeneralSecurityException ex) {
+		throw new IllegalArgumentException("Caught security exception setting up HMAC.");
+	}
+}
+
+/**
+ * Creates a new TSIG key from a pre-initialized Mac instance.
+ * This assumes that init() has already been called on the mac
+ * to set up the key.
+ * @param mac The JCE HMAC object
+ * @param Name The name of the key
+ */
+public
+TSIG(Mac mac, Name name) {
+	this.name = name;
+	this.hmac = mac;
+	this.alg = algorithmToName(mac.getAlgorithm());
 }
 
 /**
@@ -116,8 +175,8 @@ TSIG(Name name, byte [] key) {
  */
 public
 TSIG(Name algorithm, String name, String key) {
-	this.key = base64.fromString(key);
-	if (this.key == null)
+	byte[] keyBytes = base64.fromString(key);
+	if (keyBytes == null)
 		throw new IllegalArgumentException("Invalid TSIG key string");
 	try {
 		this.name = Name.fromString(name, Name.root);
@@ -126,7 +185,14 @@ TSIG(Name algorithm, String name, String key) {
 		throw new IllegalArgumentException("Invalid TSIG key name");
 	}
 	this.alg = algorithm;
-	getDigest();
+	String macAlgorithm = nameToAlgorithm(this.alg);
+	try {
+		this.hmac = Mac.getInstance(macAlgorithm);
+		this.hmac.init(new SecretKeySpec(keyBytes, macAlgorithm));
+	}
+	catch(GeneralSecurityException ex) {
+		throw new IllegalArgumentException("Caught security exception setting up HMAC.");
+	}
 }
 
 /**
@@ -141,22 +207,7 @@ TSIG(Name algorithm, String name, String key) {
  */
 public
 TSIG(String algorithm, String name, String key) {
-	this(HMAC_MD5, name, key);
-	if (algorithm.equalsIgnoreCase("hmac-md5"))
-		this.alg = HMAC_MD5;
-	else if (algorithm.equalsIgnoreCase("hmac-sha1"))
-		this.alg = HMAC_SHA1;
-	else if (algorithm.equalsIgnoreCase("hmac-sha224"))
-		this.alg = HMAC_SHA224;
-	else if (algorithm.equalsIgnoreCase("hmac-sha256"))
-		this.alg = HMAC_SHA256;
-	else if (algorithm.equalsIgnoreCase("hmac-sha384"))
-		this.alg = HMAC_SHA384;
-	else if (algorithm.equalsIgnoreCase("hmac-sha512"))
-		this.alg = HMAC_SHA512;
-	else
-		throw new IllegalArgumentException("Invalid TSIG algorithm");
-	getDigest();
+	this(algorithmToName(algorithm), name, key);
 }
 
 /**
@@ -215,9 +266,11 @@ generate(Message m, byte [] b, int error, TSIGRecord old) {
 	else
 		timeSigned = old.getTimeSigned();
 	int fudge;
-	HMAC hmac = null;
-	if (error == Rcode.NOERROR || error == Rcode.BADTIME)
-		hmac = new HMAC(digest, digestBlockLength, key);
+	boolean signing = false;
+	if (error == Rcode.NOERROR || error == Rcode.BADTIME) {
+		signing = true;
+		hmac.reset();
+	}
 
 	fudge = Options.intValue("tsigfudge");
 	if (fudge < 0 || fudge > 0x7FFF)
@@ -226,14 +279,14 @@ generate(Message m, byte [] b, int error, TSIGRecord old) {
 	if (old != null) {
 		DNSOutput out = new DNSOutput();
 		out.writeU16(old.getSignature().length);
-		if (hmac != null) {
+		if (signing) {
 			hmac.update(out.toByteArray());
 			hmac.update(old.getSignature());
 		}
 	}
 
 	/* Digest the message */
-	if (hmac != null)
+	if (signing)
 		hmac.update(b);
 
 	DNSOutput out = new DNSOutput();
@@ -251,12 +304,12 @@ generate(Message m, byte [] b, int error, TSIGRecord old) {
 	out.writeU16(error);
 	out.writeU16(0); /* No other data */
 
-	if (hmac != null)
+	if (signing)
 		hmac.update(out.toByteArray());
 
 	byte [] signature;
-	if (hmac != null)
-		signature = hmac.sign();
+	if (signing)
+		signature = hmac.doFinal();
 	else
 		signature = new byte[0];
 
@@ -312,7 +365,7 @@ applyStream(Message m, TSIGRecord old, boolean first) {
 	}
 	Date timeSigned = new Date();
 	int fudge;
-	HMAC hmac = new HMAC(digest, digestBlockLength, key);
+	hmac.reset();
 
 	fudge = Options.intValue("tsigfudge");
 	if (fudge < 0 || fudge > 0x7FFF)
@@ -336,7 +389,7 @@ applyStream(Message m, TSIGRecord old, boolean first) {
 
 	hmac.update(out.toByteArray());
 
-	byte [] signature = hmac.sign();
+	byte [] signature = hmac.doFinal();
 	byte [] other = null;
 
 	Record r = new TSIGRecord(name, DClass.ANY, 0, alg, timeSigned, fudge,
@@ -364,7 +417,7 @@ public byte
 verify(Message m, byte [] b, int length, TSIGRecord old) {
 	m.tsigState = Message.TSIG_FAILED;
 	TSIGRecord tsig = m.getTSIG();
-	HMAC hmac = new HMAC(digest, digestBlockLength, key);
+	hmac.reset();
 	if (tsig == null)
 		return Rcode.FORMERR;
 
@@ -420,8 +473,8 @@ verify(Message m, byte [] b, int length, TSIGRecord old) {
 	hmac.update(out.toByteArray());
 
 	byte [] signature = tsig.getSignature();
-	int digestLength = hmac.digestLength();
-	int minDigestLength = digest.equals("md5") ? 10 : digestLength / 2;
+	int digestLength = hmac.getMacLength();
+	int minDigestLength = hmac.getAlgorithm().toLowerCase().contains("md5") ? 10 : digestLength / 2;
 
 	if (signature.length > digestLength) {
 		if (Options.check("verbose"))
@@ -431,7 +484,7 @@ verify(Message m, byte [] b, int length, TSIGRecord old) {
 		if (Options.check("verbose"))
 			System.err.println("BADSIG: signature too short");
 		return Rcode.BADSIG;
-	} else if (!hmac.verify(signature, true)) {
+	} else if (!verify(hmac, signature, true)) {
 		if (Options.check("verbose"))
 			System.err.println("BADSIG: signature verification");
 		return Rcode.BADSIG;
@@ -479,7 +532,7 @@ public static class StreamVerifier {
 	 */
 
 	private TSIG key;
-	private HMAC verifier;
+	private Mac verifier;
 	private int nresponses;
 	private int lastsigned;
 	private TSIGRecord lastTSIG;
@@ -488,7 +541,7 @@ public static class StreamVerifier {
 	public
 	StreamVerifier(TSIG tsig, TSIGRecord old) {
 		key = tsig;
-		verifier = new HMAC(key.digest, key.digestBlockLength, key.key);
+		verifier = tsig.hmac;
 		nresponses = 0;
 		lastTSIG = old;
 	}
@@ -571,14 +624,14 @@ public static class StreamVerifier {
 		out.writeU16(tsig.getFudge());
 		verifier.update(out.toByteArray());
 
-		if (verifier.verify(tsig.getSignature()) == false) {
+		if (TSIG.verify(verifier, tsig.getSignature()) == false) {
 			if (Options.check("verbose"))
 				System.err.println("BADSIG failure");
 			m.tsigState = Message.TSIG_FAILED;
 			return Rcode.BADSIG;
 		}
 
-		verifier.clear();
+		verifier.reset();
 		out = new DNSOutput();
 		out.writeU16(tsig.getSignature().length);
 		verifier.update(out.toByteArray());
diff --git a/org/xbill/DNS/utils/HMAC.java b/org/xbill/DNS/utils/HMAC.java
deleted file mode 100644
index 5eb5afd..0000000
--- a/org/xbill/DNS/utils/HMAC.java
+++ /dev/null
@@ -1,182 +0,0 @@
-// Copyright (c) 1999-2004 Brian Wellington (bwelling@xbill.org)
-
-package org.xbill.DNS.utils;
-
-import java.util.Arrays;
-import java.security.*;
-
-/**
- * An implementation of the HMAC message authentication code.
- *
- * @author Brian Wellington
- */
-
-public class HMAC {
-
-private MessageDigest digest;
-private int blockLength;
-
-private byte [] ipad, opad;
-
-private static final byte IPAD = 0x36;
-private static final byte OPAD = 0x5c;
-
-private void
-init(byte [] key) {
-	int i;
-
-	if (key.length > blockLength) {
-		key = digest.digest(key);
-		digest.reset();
-	}
-	ipad = new byte[blockLength];
-	opad = new byte[blockLength];
-	for (i = 0; i < key.length; i++) {
-		ipad[i] = (byte) (key[i] ^ IPAD);
-		opad[i] = (byte) (key[i] ^ OPAD);
-	}
-	for (; i < blockLength; i++) {
-		ipad[i] = IPAD;
-		opad[i] = OPAD;
-	}
-	digest.update(ipad);
-}
-
-/**
- * Creates a new HMAC instance
- * @param digest The message digest object.
- * @param blockLength The block length of the message digest.
- * @param key The secret key
- */
-public
-HMAC(MessageDigest digest, int blockLength, byte [] key) {
-	digest.reset();
-	this.digest = digest;
-  	this.blockLength = blockLength;
-	init(key);
-}
-
-/**
- * Creates a new HMAC instance
- * @param digestName The name of the message digest function.
- * @param blockLength The block length of the message digest.
- * @param key The secret key.
- */
-public
-HMAC(String digestName, int blockLength, byte [] key) {
-	try {
-		digest = MessageDigest.getInstance(digestName);
-	} catch (NoSuchAlgorithmException e) {
-		throw new IllegalArgumentException("unknown digest algorithm "
-						   + digestName);
-	}
-	this.blockLength = blockLength;
-	init(key);
-}
-
-/**
- * Creates a new HMAC instance
- * @param digest The message digest object.
- * @param key The secret key
- * @deprecated won't work with digests using a padding length other than 64;
- *             use {@code HMAC(MessageDigest digest, int blockLength,
- *             byte [] key)} instead.
- * @see        HMAC#HMAC(MessageDigest digest, int blockLength, byte [] key)
- */
-public
-HMAC(MessageDigest digest, byte [] key) {
-	this(digest, 64, key);
-}
-
-/**
- * Creates a new HMAC instance
- * @param digestName The name of the message digest function.
- * @param key The secret key.
- * @deprecated won't work with digests using a padding length other than 64;
- *             use {@code HMAC(String digestName, int blockLength, byte [] key)}
- *             instead
- * @see        HMAC#HMAC(String digestName, int blockLength, byte [] key)
- */
-public
-HMAC(String digestName, byte [] key) {
-	this(digestName, 64, key);
-}
-
-/**
- * Adds data to the current hash
- * @param b The data
- * @param offset The index at which to start adding to the hash
- * @param length The number of bytes to hash
- */
-public void
-update(byte [] b, int offset, int length) {
-	digest.update(b, offset, length);
-}
-
-/**
- * Adds data to the current hash
- * @param b The data
- */
-public void
-update(byte [] b) {
-	digest.update(b);
-}
-
-/**
- * Signs the data (computes the secure hash)
- * @return An array with the signature
- */
-public byte []
-sign() {
-	byte [] output = digest.digest();
-	digest.reset();
-	digest.update(opad);
-	return digest.digest(output);
-}
-
-/**
- * Verifies the data (computes the secure hash and compares it to the input)
- * @param signature The signature to compare against
- * @return true if the signature matches, false otherwise
- */
-public boolean
-verify(byte [] signature) {
-	return verify(signature, false);
-}
-
-/**
- * Verifies the data (computes the secure hash and compares it to the input)
- * @param signature The signature to compare against
- * @param truncation_ok If true, the signature may be truncated; only the
- * number of bytes in the provided signature are compared.
- * @return true if the signature matches, false otherwise
- */
-public boolean
-verify(byte [] signature, boolean truncation_ok) {
-	byte [] expected = sign();
-	if (truncation_ok && signature.length < expected.length) {
-		byte [] truncated = new byte[signature.length];
-		System.arraycopy(expected, 0, truncated, 0, truncated.length);
-		expected = truncated;
-	}
-	return Arrays.equals(signature, expected);
-}
-
-/**
- * Resets the HMAC object for further use
- */
-public void
-clear() {
-	digest.reset();
-	digest.update(ipad);
-}
-
-/**
- * Returns the length of the digest.
- */
-public int
-digestLength() {
-	return digest.getDigestLength();
-}
-
-}
diff --git a/tests/org/xbill/DNS/utils/HMACTest.java b/tests/org/xbill/DNS/utils/HMACTest.java
deleted file mode 100644
index 33afb94..0000000
--- a/tests/org/xbill/DNS/utils/HMACTest.java
+++ /dev/null
@@ -1,165 +0,0 @@
-// -*- Java -*-
-//
-// Copyright (c) 2005, Matthew J. Rutherford <rutherfo@cs.colorado.edu>
-// Copyright (c) 2005, University of Colorado at Boulder
-// All rights reserved.
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-// 
-// * Redistributions of source code must retain the above copyright
-//   notice, this list of conditions and the following disclaimer.
-// 
-// * Redistributions in binary form must reproduce the above copyright
-//   notice, this list of conditions and the following disclaimer in the
-//   documentation and/or other materials provided with the distribution.
-// 
-// * Neither the name of the University of Colorado at Boulder nor the
-//   names of its contributors may be used to endorse or promote
-//   products derived from this software without specific prior written
-//   permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-package org.xbill.DNS.utils;
-
-import	java.security.MessageDigest;
-import	java.security.NoSuchAlgorithmException;
-import	junit.framework.TestCase;
-
-public class HMACTest extends TestCase
-{
-    private static class test_data
-    {
-	public byte[] key;
-	public byte[] data;
-	public byte[] digest;
-    }
-
-    private static test_data[] tests;
-
-    static {
-	// These test cases come directly from RFC 2202 (for MD5)
-
-	tests = new test_data[7];
-
-	for( int i=0; i<tests.length; ++i){
-	    tests[i] = new test_data();
-	}
-
-	// test_case =     1
-	tests[0].key =		base16.fromString("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b");
-	tests[0].data =		"Hi There".getBytes();
-	tests[0].digest =	base16.fromString("9294727a3638bb1c13f48ef8158bfc9d");
-
-	// test_case =     2
-	tests[1].key =		"Jefe".getBytes();
-	tests[1].data =		"what do ya want for nothing?".getBytes();
-	tests[1].digest =	base16.fromString("750c783e6ab0b503eaa86e310a5db738");
-	
-	// test_case =     3
-	tests[2].key =          base16.fromString("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
-	tests[2].data =		new byte[ 50 ]; // 0xdd repeated 50 times
-	for( int i=0; i<tests[2].data.length; ++i){
-	    tests[2].data[i] = (byte)0xdd;
-	}
-	tests[2].digest =       base16.fromString("56be34521d144c88dbb8c733f0e8b3f6");
-
-	// test_case =     4
-	tests[3].key =          base16.fromString("0102030405060708090a0b0c0d0e0f10111213141516171819");
-	tests[3].data =         new byte[ 50 ]; // 0xcd repeated 50 times;
-	for( int i=0; i<tests[3].data.length; ++i){
-	    tests[3].data[i] = (byte)0xcd;
-	}
-	tests[3].digest =       base16.fromString("697eaf0aca3a3aea3a75164746ffaa79");
-	    
-	// test_case =     5
-	tests[4].key =		base16.fromString("0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c");
-	tests[4].data =         "Test With Truncation".getBytes();
-	tests[4].digest =       base16.fromString("56461ef2342edc00f9bab995690efd4c");
-
-	// test_case =     6
-	tests[5].key =		 new byte[ 80 ]; // 0xaa repeated 80 times;
-	for( int i=0; i<tests[5].key.length; ++i){
-	    tests[5].key[i] = (byte)0xaa;
-	}
-	tests[5].data =          "Test Using Larger Than Block-Size Key - Hash Key First".getBytes();
-	tests[5].digest =        base16.fromString("6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd");
-
-	// test_case =     7
-	tests[6].key =           new byte [ 80 ]; // 0xaa repeated 80 times;
-	for( int i=0; i<tests[6].key.length; ++i){
-	    tests[6].key[i] = (byte)0xaa;
-	}
-	tests[6].data =          "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data".getBytes();
-	tests[6].digest =        base16.fromString("6f630fad67cda0ee1fb1f562db3aa53e");
-    }
-
-    public HMACTest( String name )
-    {
-	super(name);
-    }
-
-
-    private void do_test(int i, HMAC h) throws CloneNotSupportedException
-    {
-	h.update(tests[i].data, 0, tests[i].data.length);
-	byte[] out = h.sign();
-	
-	assertEquals("test=" + i, tests[i].digest.length, out.length);
-	for( int j=0; j<out.length; ++j){
-	    assertEquals("test=" + i, tests[i].digest[j], out[j]);
-	}
-	
-	// clear and do it again to make sure verify() agrees
-	h.clear();
-	h.update(tests[i].data);
-	assertTrue(h.verify(tests[i].digest));
-	
-	// clear and do it again to make sure verify() 
-	h.clear();
-	h.update(tests[i].data, 0, tests[i].data.length);
-	byte[] tmp = (byte[])tests[i].digest.clone();
-	tmp[tmp.length/2] = (byte)0xAB;
-	assertFalse(h.verify(tmp));
-    }
-
-    public void test_ctor_digest_key() throws NoSuchAlgorithmException,
-					      CloneNotSupportedException
-    {
-	for( int i=0; i<tests.length; ++i){
-	    MessageDigest md = MessageDigest.getInstance("md5");
-	    HMAC h = new HMAC(md, tests[i].key);
-	    do_test(i, h);
-	}
-    }
-
-    public void test_ctor_digestName_key() throws NoSuchAlgorithmException,
-					      CloneNotSupportedException
-    {
-	for( int i=0; i<tests.length; ++i){
-	    HMAC h = new HMAC("md5", tests[i].key);
-	    do_test(i, h);
-	}
-    }
-
-    public void test_ctor_digestName_key_invalid()
-    {
-	try {
-	    new HMAC("no name", new byte[ 0 ]);
-	    fail("IllegalArgumentException not thrown");
-	}
-	catch( IllegalArgumentException e ){}
-    }
-}

Commit:
c547d4dfc324682d293fabc1d385922158be1d0d
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2015-04-22 00:58:40 +0000
Javadoc patches (from Noa Resare <noa@users.sf.net>)
diff --git a/org/xbill/DNS/RPRecord.java b/org/xbill/DNS/RPRecord.java
index 7aa066c..4c9017f 100644
--- a/org/xbill/DNS/RPRecord.java
+++ b/org/xbill/DNS/RPRecord.java
@@ -8,7 +8,7 @@ import java.io.*;
  * Responsible Person Record - lists the mail address of a responsible person
  * and a domain where TXT records are available.
  *
- * @author Tom Scola <tscola@research.att.com>
+ * @author Tom Scola (tscola@research.att.com)
  * @author Brian Wellington
  */
 
diff --git a/org/xbill/DNS/Type.java b/org/xbill/DNS/Type.java
index ac5ba8e..2184134 100644
--- a/org/xbill/DNS/Type.java
+++ b/org/xbill/DNS/Type.java
@@ -190,7 +190,7 @@ public static final int MAILA		= 254;
 public static final int ANY		= 255;
 
 /** URI
- * @see see http://tools.ietf.org/html/draft-faltstrom-uri-14
+ * @see <a href="http://tools.ietf.org/html/draft-faltstrom-uri-14">draft-faltstrom-uri-14</a>
  */
 public static final int URI		= 256;
 
diff --git a/org/xbill/DNS/ZoneTransferIn.java b/org/xbill/DNS/ZoneTransferIn.java
index 8a19992..3dbac87 100644
--- a/org/xbill/DNS/ZoneTransferIn.java
+++ b/org/xbill/DNS/ZoneTransferIn.java
@@ -196,7 +196,6 @@ ZoneTransferIn(Name zone, int xfrtype, long serial, boolean fallback,
  * @param address The host/port from which to transfer the zone.
  * @param key The TSIG key used to authenticate the transfer, or null.
  * @return The ZoneTransferIn object.
- * @throws UnknownHostException The host does not exist.
  */
 public static ZoneTransferIn
 newAXFR(Name zone, SocketAddress address, TSIG key) {
@@ -245,7 +244,6 @@ throws UnknownHostException
  * @param address The host/port from which to transfer the zone.
  * @param key The TSIG key used to authenticate the transfer, or null.
  * @return The ZoneTransferIn object.
- * @throws UnknownHostException The host does not exist.
  */
 public static ZoneTransferIn
 newIXFR(Name zone, long serial, boolean fallback, SocketAddress address,

Commit:
2bfe71fe2467ffb97685efe7fc01383a881dc3d8
bwelling
bwelling@c76caeb1-94fd-44dd-870f-0c9d92034fc1
2015-04-21 18:29:19 +0000
- Update the URI record implementation to match the latest spec.   (patch from Anthony Kirby <anthonykirby@users.sf.net>)
diff --git a/Changelog b/Changelog
index 72486c3..5ac2973 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,7 @@
+4/21/2015:
+	- Update the URI record implementation to match the latest spec.
+	  (patch from Anthony Kirby <anthonykirby@users.sf.net>)
+
 2/15/2015
 	- 2.1.7 released
 
diff --git a/org/xbill/DNS/Type.java b/org/xbill/DNS/Type.java
index d2d79af..ac5ba8e 100644
--- a/org/xbill/DNS/Type.java
+++ b/org/xbill/DNS/Type.java
@@ -190,7 +190,7 @@ public static final int MAILA		= 254;
 public static final int ANY		= 255;
 
 /** URI
- * @see see http://tools.ietf.org/html/draft-faltstrom-uri-09
+ * @see see http://tools.ietf.org/html/draft-faltstrom-uri-14
  */
 public static final int URI		= 256;
 
diff --git a/org/xbill/DNS/URIRecord.java b/org/xbill/DNS/URIRecord.java
index f7fc0fd..4859150 100644
--- a/org/xbill/DNS/URIRecord.java
+++ b/org/xbill/DNS/URIRecord.java
@@ -55,7 +55,7 @@ void
 rrFromWire(DNSInput in) throws IOException {
 	priority = in.readU16();
 	weight = in.readU16();
-	target = in.readCountedString();
+	target = in.readByteArray();
 }
 
 void
@@ -102,7 +102,7 @@ void
 rrToWire(DNSOutput out, Compression c, boolean canonical) {
 	out.writeU16(priority);
 	out.writeU16(weight);
-	out.writeCountedString(target);
+	out.writeByteArray(target);
 }
 
 }
diff --git a/tests/org/xbill/DNS/URIRecordTest.java b/tests/org/xbill/DNS/URIRecordTest.java
index 0461864..286185d 100644
--- a/tests/org/xbill/DNS/URIRecordTest.java
+++ b/tests/org/xbill/DNS/URIRecordTest.java
@@ -58,7 +58,6 @@ public class URIRecordTest extends TestCase
 	String target = ("http://foo");
 	byte[] exp = new byte[] { 
 			(byte)0xbe, (byte)0xef, (byte)0xde, (byte)0xad, 
-			(byte)0xa,
 			(byte)0x68, (byte)0x74, (byte)0x74, (byte)0x70, (byte)0x3a, 
 			(byte)0x2f, (byte)0x2f, (byte)0x66, (byte)0x6f, (byte)0x6f };
     
@@ -72,7 +71,6 @@ public class URIRecordTest extends TestCase
     {
    	byte[] raw= new byte[] { 
     			(byte)0xbe, (byte)0xef, (byte)0xde, (byte)0xad, 
-    			(byte)0xa,
     			(byte)0x68, (byte)0x74, (byte)0x74, (byte)0x70, (byte)0x3a, 
     			(byte)0x2f, (byte)0x2f, (byte)0x66, (byte)0x6f, (byte)0x6f };
 	DNSInput in = new DNSInput(raw);

Commit:
6b86c9f72a849feb35f6d646ecde45dcbd8b5d6a
Noa Resare
noa@resare.com
2015-02-17 16:22:34 +0100
Update version number in pom.xml to 2.1.7
diff --git a/pom.xml b/pom.xml
index f375225..e5f2779 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>dnsjava</groupId>
     <artifactId>dnsjava</artifactId>
-    <version>2.1.6</version>
+    <version>2.1.7</version>
     <name>dnsjava</name>
     <description>dnsjava is an implementation of DNS in Java. It supports all defined record types (including the DNSSEC types), and unknown types. It can be used for queries, zone transfers, and dynamic updates. It includes a cache which can be used by clients, and a minimal implementation of a server. It supports TSIG authenticated messages, partial DNSSEC verification, and EDNS0. </description>
     <url>http://www.dnsjava.org</url>

Commit:
e07721a35afcd6a0e5a13c51f9bac61dae34afa8
Noa Resare
noa@resare.com
2015-02-17 16:22:13 +0100
Merge v2.1.7 changes from branch upstream into master